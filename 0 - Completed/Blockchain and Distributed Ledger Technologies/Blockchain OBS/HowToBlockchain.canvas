{
	"nodes":[
		{"id":"87e0f46ba8de8691","type":"text","text":"# Cash Digitale & Blockchain (DS)\n\nL'idea di realizzare un sistema di ***cash digitale*** affonda le sue radici verso la seconda metà degli anni 80. Se le prime implementazioni si riducevano a tentativi di implementare modi sicuri per eseguire le transazioni, è con DigiCash (1989) che compaiono i primi coin.\n\nLe moderne criptovalute si basano sulle ***Blockchain*** (***BC***): ogni transazione viene inviata ad un server del sistema distribuito, il quale la inoltra agli altri. Dall'insieme delle transazioni in attesa (***mempool***) condiviso (idealmente) da tutti i server viene estratto mediante delle logiche variabili un sottoinsieme (che prende il nome di ***blocco***) da aggiungere alla BC. Un singolo server guadagna volta per volta il diritto di farsi portavoce di un blocco (e di ottenere di conseguenza un ***reward***) principalmente in due modi (ne esistono $N$, ovviamente):\n\n- Risolvendo un ***computational puzzle***, se la Blockchain stabilisce un meccanismo di consenso di tipo ***Proof-of-Work*** (***PoW***). In questo caso, i server vengono chiamati ***miner***;\n- \"Bloccando\" una certa quantità di criptovaluta, se si applica un meccanismo ***Proof-of-Stake*** (***PoS***). I server possono avere nomi (i.e. ruoli) variabili a seconda del protocollo;\n\nAltri protocolli sono possibili, e.g. ***Proof-of-Authority***, ***PoA***, in cui solo i nodi autorizzati possono proporre nuovi blocchi, ideale per BC ***private*** o ***permissioned***, i.e. basate su permessi specifici).\n\nDeve essere semplice per gli altri server verificare che colui che propone il blocco sia legittimato a farlo (i.e. raggiungere il ***consenso*** su quel server). La sequenza dei blocchi approvati costituisce il \"***libro mastro***\" (***ledger***) delle transazioni. Il concetto di ledger è indipendente da quello di BC: esistono ledger la cui implementazione non è una BC (e.g. IOTA).\n\nLe implementazioni recenti danno la possibilità di eseguire codice direttamente sulla BC. Questi pezzetti di SW vengono detti ***Chain Code*** o ***Smart Contracts*** (***SC***).","x":-9120,"y":-5207,"width":759,"height":693,"color":"6"},
		{"id":"49e6eafb2938a493","type":"text","text":"# Creare Cash Digitale (DS)\n\nPochi accetterebbero come pagamento il carbone, ma molti accetterebbero i diamanti. Eppure hanno la stessa composizione chimica. Cosa cambia? I diamanti sono rari.\n\nIn generale, se si vuole creare una moneta digitale si deve tenere presente che il suo valore è legato alla sua quantità. Deve quindi esserci in qualche modo \"difficile\" creare nuovo cash.\n\nUna soluzione a questo problema viene direttamente da una tecnica anti-spam per email che risale al 1992 (Dwok, Naor), basata su un principio molto semplice: per inviare una mail devo risolvere un ***computational puzzle*** legato in modo univoco a quella specifica mail, altrimenti questa non partirà. Se risolvere il problema per una mail `A` non dà alcun aiuto per la risoluzione del problema per la mail `B`, allora diventa computazionalmente difficile inviare grandi quantità di mail tutte insieme.\n\nQuesto stesso principio si applica in generale alle Blockchain ***PoW***: il cash viene creato ogni volta che un miner aggiunge un blocco alla blockchain, i.e. solo quando questo è stato in grado di risolvere il computational puzzle. In particolare, la prima transazione di ogni blocco assegna nuovi coin all'indirizzo del miner che sta costruendo quel blocco. \n\n\"Ma così continuo ad erogare all'infinito!\". Ni. In genere esiste un meccanismo di riduzione del reward. In ***Bitcoin***, ad esempio, il reward iniziale era di $50\\,\\BTC$ per blocco, ma il sistema stabilisce che ogni $210\\cdot10^3$ blocchi aggiunti alla Blockchain (in che si traduce in un intervallo di tempo di qualche anno) questo valore si dimezza. Questo consente di dire che in una prima \"era\" sono stati prodotti $21\\cdot10^3\\times50=10.5$ milioni di bitcoin, poi $\\times 25$ e via dicendo. Questa è ovviamente una serie convergente: se le regole restano queste, il massimo numero di Bitcoin in circolo sarà $21$ milioni. Ad oggi (2025) il reward è di $3.125\\,\\BTC$. ","x":-10129,"y":-5207,"width":759,"height":693,"color":"4"},
		{"id":"e027f44c3e948552","type":"text","text":"# ... ma cos'è il \"Cash Digitale\"? (DS)\n\nL'entità \"analogica\" più vicina ad una moneta digitale è un assegno: erogo un biglietto con la mia firma che indica che il possessore può restituirmelo per ottenere l'equivalente in dollari. Questo assume fondamentalmente due cose:\n\n- È difficile replicare la mia firma (i.e. è difficile falsificare l'assegno);\n\t- È invece molto facile copiare un file. Se a tale file è associato un \"assegno digitale\" (i.e. un coin) potrei duplicarlo e usarlo più volte. Questo problema prende il nome di ***double spending***, e la sua risoluzione ha stuzzicato la curiosità di diversi esponenti del mondo della crittografia.\n- Chi accetta l'assegno si fida del fatto che a fronte di esso qualcuno mi pagherà.\n\t- Questo è equivalente a dire che qualcuno deve garantire che la transazione avvenga. Di norma questo compito spetta alle banche, che fungono da entità garante centrale. L'obiettivo di un DS, tuttavia, è quello di evitare centralizzazioni. Deve quindi essere il DS stesso a fare da garante, obiettivo raggiungibile tramite il ***consenso*** da parte di tutti i server (***miner***) sull'approvazione delle transazioni presenti nei singoli ***blocchi*** della BC;\n\t- L'assenza di un garante è anche il motivo per cui qualcuno storce il naso sulla definizione di queste entità come \"currency\";\n\t- Dovrei anche fidarmi del fatto che, una volta effettuato, il pagamento non sia revocabile. Questo, di nuovo, porterebbe ad un double spending: dopo che mi arriva la merce ***off-chain*** (i.e. è un evento non registrato dalla BC) \"torno indietro\" e revoco la transazione (o meglio, il blocco). Questo di fatto si traduce in un cosiddetto ***attacco del 51%***. Gli eventi off-chain sono fondamentali per questo tipo di attacco, tanto che la soluzione sarebbe semplicemente quella di registrare tutto (se revochi il pagamento revochi anche l'evento di consegna della merce, e.g. un ***token***).","x":-9120,"y":-6238,"width":759,"height":796,"color":"4"},
		{"id":"ad475259f1ef5f06","type":"text","text":"# Hashing & Computational Puzzles (DS)\n\nDopo aver effettuato un pagamento (che quindi è stato approvato dal sistema) e ricevuto un bene, un singolo miner prova a modificare la transazione in modo da recuperare i coin spesi. \n\nSi può fare? In teoria sì, ma viene reso estremamente difficile dall'***hashing*** dei blocchi. Ogni blocco ha un valore di hash che dipende dalle transazioni al suo interno, ma anche dall'hash del blocco precedente. Modificare un blocco significa non solo modificare il suo hash, ma rendere inconsistenti tutti gli hash di tutti i blocchi successivi. Un attaccante dovrebbe quindi modificare una sequenza di hash, che è notoriamente un problema difficile da risolvere ma di cui è facile da verificare la soluzione (tuttavia non è formalmente un problema $\\NPH$).\n\nIn virtù della difficoltà del problema, le Blockchain ***PoW*** sfruttano l'hashing per implementare il ***computational puzzle***: solo chi riesce a trovare il giusto hash per il blocco che vuole proporre può aggiungerlo alla Blockchain.\n\nUn'idea di come funziona è il meccanismo usato da ***Bitcoin***: per essere un blocco valido, l'hash in uscita deve avere i $k$ bit meno significativi uguali a $0$.\n\nOra, la funzione di hash (e.g. ***SHA-256*** per Bitcoin) prende in input le transazioni del blocco che voglio far approvare, l'hash del blocco precedente e (oltre ad altra roba che non stiamo a specificare in quanto non utile alla trattazione) un ***nonce***. In generale non ho idea di cosa esca fuori come hash di output, posso solo cambiare il nonce e guardare il risultato.\n\nLa probabilità di trovare proprio quello che voglio (i.e. i $k$ zeri finali) richiede un numero di lanci quantomeno esponenziale per diventare di ordine $1$, da cui la difficoltà probabilistica del problema (si capisce meglio perché non è classificabile come $\\NPH$). Una volta risolto il problema (i.e. trovato il nonce), è facile per gli altri miner verificare la soluzione (basta far girare SHA-256 con i parametri indicati dal miner risolutore).","x":-8111,"y":-5207,"width":759,"height":693,"color":"4"},
		{"id":"90bd914ffad09146","type":"text","text":"# Lezioni Di Ciccio 00 - Introduction\n\nla BC non è un DB, non salva dati (tipo il saldo di un account) ma transazioni (poi ovviamente puoi farti un piccolo DB riassuntivo locale per fare rapidamente il punto della situazione senza rileggere ogni volta tutta la storia). Di per sé è una data structure, ma spesso si intende l'intero environment che la supporta.\n\nGli smart contracts sono anche detti Chain Code su BC più rigorose.\n\nweb3, t-apps? middleware\n\ndice che \"cryptocurrency\" è impreciso, perché \"currency\" richiede un'entità \"garante\" (puoi prendertela con lo stato, tipo)\n\nmattone base della BC: l'account `0xA` manda dei soldi all'account `0xB` tramite una transazione `0xT`. Cose da fare:\n\n- Assicurarsi che chi ordina la transazione sia autorizzato a farlo. Con la banca abbiamo username/password, OTP, token, ecc... Qua si fa con la firma digitale.\n\t- nota che con una banca avere quei metodi di accesso significa che ti sei prima fatto identificare come essere umano, mentre qui non serve\n\t- nota anche che questo implica che non è detto che chi è in possesso della chiave privata giusta sia anche l'owner dell'account di partenza, è solo \"quello autorizzato a fare questa transazione\". può ad esempio essere un account aziendale di cui diversi umani hanno la chiave privata\n- Externally Owned Account (EOA) - accounts owned by entities that are not on the chain (humans, bots, AI tools, dogs, ...). e l'alternativa? ovviamente gli Smart Contracts, che possono essere la sola entità a controllare un account (prima degli SC esistevano solo EOA)\n\t- anche la creazione di un account è una transazione scritta sulla BC, quindi si può vedere se un account è EOA o generato da SC\n- le private keys sono in genere tenute in un PK manager nel wallet, e a volte vengono perse o rubate (alcuni fondi sono frozen)\n- per bitcoin tutta sta roba è simile ad un assegno (ID, sender, recipient (causale tipo), amount, timestamp, signature), per ETH è un po' diverso\n\nUn ledger è una APPEND-ONLY LIST di transactions.... quasi, perché non posso avere duplicati -> ogni transaction è unica, quantomeno per l'ID. A livello tecnico è quindi un ***totally ordered*** set without complement, i.e. ogni transaction avviene sempre ***dopo*** un'altra e ***prima*** di un'altra. Ci sono eccezioni? Sì, tipo Iota implementa un ordine parziale in cui rilassa un po' questa condizione, ma al momento non ci interessa. L'altra eccezione è la mempool delle transactions non ancora scritte sulla BC, ma appunto, non sono ancora scritte sulla BC. Tutto questo per evitare il double spending.\n\naxe-infinity? permetteva ai giocatori di avere un account crypto sul gioco. tutti gli account convergevano all'account del gioco stesso, e c'era una rete  che faceva le conversioni (relay network, una dozzina di nodi). gli hanno fatto un 51% attack (rewriting history). ci stanno gli oracle che si assicurano che ciò che avviene fuori dalla chain sia registrato anche sulla chain nel giusto ordine.\n\nora, visto che siamo in un sistema distribuito ogni nodo deve avere contezza dell'intero ledger. but nodes come and go, and ledger is enorme. Che si fa? \"come in passato i contabili non avevano un solo libro, ma molteplici, anche qui dividiamo\". Nascono i blocchi, che a loro volta vanno ordinati. Come? Con gli hash. E con i merkle tree (too soon). Ma a un nuovo nodo non do solo gli hash. Inizialmente dovevo dare tutta la BC, di recente ci sono sistemi (mechanical breakpoints) che ti permettono di scaricare solo gli ultimi blocchi. e comunque il blocco è l'equivalente del tempo in una BC: per questo hanno lunghezza variabile ma bene o male rate di aggiunta alla BC costante (e.g. bitcoin \\sim 10 min, ETH \\sim 12s). Questo per quanto riguarda i nodi del DS, dopodiché i wallet sono \"light client\" che salvano solo gli hash (o meglio, solo gli header).\n\nIn prima approssimazione assumiamo che ogni partecipante alla BC abbia tutta l'info della BC (escludiamo quindi wallet & co). Un nodo poco potente in un contesto PoW rischia di non vedere mai approvato il proprio blocco. Questo porta ad un folle generale aumento di potenza computazionale che culmina sempre più spesso nel preferire la PoS.\n\n\"non importa se la transazione è valida (o giusta, o vera) o meno, l'unica cosa che importa è che la maggioranza dei nodi del DS concordi che è stata eseguita\". Solo il DS decide cosa è vero e cosa no (i.e. cosa avviene e cosa no). L'obiettivo della BC è solo quello di essere un ledger, non di garantire CIA triad e simili.\n\npoi parla delle fork e della regola dei 6 blocchi (\\sim 1h su bitcoin) e di come non ci sia nessun sistema swift di turno a fare da garante per l'approvazione della tua transazione. le fees poi funzionano (anche) perché non essendoci un perfect distributed clock non posso usare il timestamp per sapere quali transactions hanno la precedenza nella mempool per essere inserite in un blocco (e dunque \"bribery\", come dice lui). Se ho capito bene dice pure che magari io non pago, ma magari un'altra transazione che prende come input il mio output ha fee altissime e al sistema conviene ficcare dentro anche la mia.\n\nprocede a spiegare la PoW come love affair - \"per conquistarmi devi metterci il cuore, provare e fallire\". Incredibile.\n\nnon confondere mempool (set delle transazioni in attesa in un certo nodo, che quindi cambia da nodo a nodo) con la mining pool (gruppo di miner che uniscono gli sforzi computazionali per risolvere più rapidamente la PoW).\n\nGli SC sono pezzi di codice touring-complete. Questo viene poi tradotto in bytecode (una specie di assembly che però può runnare su diverse piattaforme). Più il codice è complesso, più sforzo computazionale richiede per essere eseguito più richiede ***gas***\n\n- paga chi invoca la funzione in questione! ma chi riceve? lui dice \"the publisher\", ma di cosa? non dello SC, perché sennò scriverebbero tutti codice super complesso per intascarsi fees giganti. ah ok il publisher intende il miner che ha fatto approvare quel blocco forse. o tutti? no sarebbe assurdo, è zero scalabile sta cosa).\n- Stessa differenza che c'era tra mainframe e terminal (... cioè? il mainframe offriva la cpu e il terminale era l'invoker?). Visto che tutto su una BC è una transazione, lo è anche l'invocazione di funzione (la chiamata avviene come payload della transazione). Ok, ma chi lo esegue? Preventivamente chi vuole proporre il blocco in cui è contenuta, dopodiché se non ci sono errori e quel blocco viene approvato lo SC verrà eseguito dall'intero DS (ogni nodo deve eseguirlo per vederne le conseguenze e aggiornare di conseguenza la BC, il miner non condivide il risultato, ma il codice).\n\nOvviamente anche la creazione di un nuovo account è una transaction: il sistema sceglie un target address inutilizzato e \"da ora in poi è tuo\".\nHopefully chi sviluppa SC mette il codice su GitHub (sulla blockchain c'è solo versione binary, illeggibile).\n\nOk ma quindi se sono un nuovo nodo non solo devo scaricarmi tutte le transazioni ma anche rieseguire tutte le funzioni degli SC? ...ni. Esistono dei breakpoints in cui la BC ti dice \"questo era lo stato condiviso al 100% (?) a questo punto, scarica/esegui solo da qui in poi\".\n\nTokens - li puoi pensare come bollini di fidelizzazione (\"se compri da noi ti diamo dei token che puoi utilizzare comprando ***di nuovo da noi***\").\n\nSegue distinzione public/private e permission(less). Slide 43 per lo schemino.\n\n\"law of the highest left force\", \"goals LMD?\". Creare N account non mi fa vincere il gioco: devo comunque risolvere il PoW.\n\n hashing nasce per riempire un array/lista/spazio nel modo più uniforme possibile e con meno collisioni possibili (e.g. buckets, ...), poi si riscopre utile come fingerprint dei dati. E il cryptographic hash?","x":-13440,"y":-13120,"width":1207,"height":1834},
		{"id":"ac381904b8cd5952","type":"text","text":"# ... o meglio...\n\n- per bitcoin tutta sta roba è simile ad un assegno (ID, sender, recipient (causale tipo), amount, timestamp, signature), per ETH è un po' diverso","x":-8111,"y":-6238,"width":759,"height":796},
		{"id":"fc29e282c8934010","type":"text","text":"# Cosa (non) è una Blockchain\n\nNonostante con una BC si implementi un ledger, questa ***non è un Database***: non c'è scritto da nessuna parte una roba tipo `account X possiede Y token`, ma va piuttosto dedotto dalla sequenza delle transazioni salvate. Poi ovviamente è saggio costruirsi un DB per tenere traccia dello stato del sistema senza dover rieseguire tutto, ma tale DB non ha niente a che fare con la BC.\n\nDi per sé è una ***struttura dati*** che somiglia ad una ***append-only list senza duplicati***. Per dirla in termini tecnici, è un ***totally ordered set without complement***, dove\n\n- \"totally ordered\" si riferisce al fatto che ogni transazione avviene esattamente ***dopo*** un'altra e ***prima*** di un'altra, e tale ordine è l'unico consentito;\n- \"set\" serve a non avere duplicati. Ogni transazione ha un ***ID*** univoco (esadecimale), tipicamente ottenuto come ***hash crittografico*** (e.g. `SHA-256`, `Keccak-256`) della transazione stessa;\n\t- Qui due assunzioni: l'address space è enorme e la probabilità di collisione trascurabile.\n- \"without complement\" enfatizza il fatto che non ha senso considerare il complemento di questo set (i.e. le transazioni non già presenti nella BC).\n\nOgni transazione ha un `ID mittente` e un `ID destinatario`, detti in generale `account`.\n\n- Possiamo avere ***Externally Owned Accounts*** (***EOA***, i.e. gestiti da entità esterne alla BC, come un essere umano) o `account` gestiti direttamente dagli ***Smart Contracts***;\n\t- Dal momento che la BC contiene solo transazioni, anche la creazione di un `account` è una transazione, in particolare verso un `account ID` ( il cui address space è sufficientemente astronomico da farci ignorare il timore di esaurirlo e.g. un intero a `160 bit`) non ancora utilizzato, che diventerà quello del nuovo `account`. Di norma tale `ID` è un ***hash della chiave pubblica*** associata a tale `account`.\n- Gli `account` non sono legati al concetto di \"proprietà\", ma a quello di ***autorizzazione***. Dal momento che una transazione valida necessita della ***firma digitale*** del mittente per essere valida, solo chi possiede la ***chiave privata*** (***PK***) dell'`account` è in grado di ordinarne una.\n\t- Segue che chi è in possesso della PK non è necessariamente il proprietario dell'`account`;\n\t- Quando ci si interfaccia alla BC lo si fa tramite il ***Wallet***, che altro non è che un gestore di chiavi crittografiche. Spesso include un'interfaccia che mostra il saldo dell'`account` associato alla chiave che contiene. Questo dato viene ricavato ripercorrendo lo storico di tutte le transazioni che riguardano l'account, motivo per cui deve conoscere la BC. Questo rende il Wallet un ***nodo del sistema distribuito BC***.\n\nRiassumendo: creare un account significa creare una coppia di chiavi asimmetriche, dare quella privata ad un gestore (detto Wallet) e dare in pasto quella pubblica ad una funzione di hash crittografico per ricavare l'indirizzo unico che identifica univocamente quell'account.\n","x":-9120,"y":-4280,"width":759,"height":985,"color":"4"},
		{"id":"2ecba2716d7cab9c","type":"text","text":"# Chain Code - Smart Contracts\n\nA qualcuno è venuta la geniale idea di aggiungere a tutto questo la possibilità di eseguire ***codice Touring-Complete***. Quale? Beh, dipende.\n\n- Anzitutto, il concetto di Smart Contract come \"pezzo di codice che esegue automaticamente le promesse delle parti al verificarsi di certe condizioni\" nasce nel 1994 a opera di un tizio che (ovviamente) era un po' informatico e un po' giurista. Al tempo era sostanzialmente impossibile realizzare questa roba, come spesso accade;\n- Bitcoin nel 2009 introduce un chain code non-Touring-Complete, ***Bitcoin Script***;\n\t- È volutamente limitato per motivi di sicurezza (niente loop, ricorsione, ...), viene eseguito una tantum come conferma di validità della singola transazione;\n\t- Come quasi tutti i suoi successori, è ***interpretato*** da un'apposita VM, la ***Bitcoin Virtual Machine***, che lo traduce in ***bytecode*** universale;\n- Ethereum nel 2015 introduce ***Solidity***, il primo chain code Touring-Complete. La logica è simile a Bitcoin Script ma con un livello di astrazione in più: c'è un compilatore (`solc`) che permette al linguaggio di essere più simile a `C` che ad `Assembly`. Anche qui abbiamo una Ethereum VM (***EVM***) che lo trasforma in bytecode.\n- Implementazioni successive possono implementare diversi linguaggi (anche noti, come `C` o `Rust`), ma hanno sempre lo stesso schema sottostante (i.e. la Virtual Machine e il bytecode).\n\nDetto questo, Bitcoin non voleva implementare un linguaggio Touring-Completo perché questo avrebbe (anche) voluto dire ammettere i ***loop infiniti***, con i quali chiunque potrebbe bloccare la verifica di una transazione, di fatto Dossando il nodo e potenzialmente bloccando l'intera BC. Questo problema viene risolto da Ethereum con il concetto di ***Gas Fee***: ogni operazione ha un costo in una valuta, detta `gas`. Eseguire codice, quindi, equivale ad un costo in `gas`. La `gas fee` si ottiene come quantità di `gas` utilizzata per eseguire il codice moltiplicato per il costo del `gas` (e.g. `ETH / gas_unit`). Più codice vuoi fare eseguire, più paghi valuta. Ma chi paga chi?\n\n- L'***invoker*** del codice (i.e. quello che immette la transazione contenente il codice) è ovviamente quello che paga. Quanto? Insieme al codice si inviano due parametri: `gasLimit`, i.e. la massima quantità di `gas` che sono disposto a usare (e.g. non ho visto un loop infinito nel codice, quando raggiungo `gasLimit` si blocca tutto) e il suo prezzo unitario `gasPrice`;\n- Il nodo che fa da ***publisher*** del blocco in cui vuole inserire tale transazione è quello che deve verificare preventivamente la validità del codice, e che quindi spende risorse computazionali. Viene da sé che il pagamento va a lui (e non a tutti gli altri nodi, nonostante lo eseguano anche loro dopo l'approvazione: questo perché solo solo meri verificatori previsti dal protocollo).\n\nSe si raggiunge il `gasLimit`, la transazione viene annullata (i.e. lo stato della BC viene ripristinato a prima dell'esecuzione), ma l'invoker paga lo stesso la fee (\"giocare sporco non gli conviene\").","x":-8111,"y":-4280,"width":759,"height":984,"color":"4"},
		{"id":"2a9b9c170774f579","type":"text","text":"# Blockchains as Distributed Systems\n\nIl consenso (cfr. esame di ***Distributed Systems***, ***DS***) su cosa aggiungere alla BC non avviene sulle singole transazioni, ma su ***blocchi di transazioni***. Ci sono diversi buoni motivi per fare così:\n\n- Intanto il consenso sulle singole transazioni produrrebbe un delirio di messaggi. Se un blocco contiene $O(100)$ transazioni, l'***overhead di comunicazione*** si taglia di un fattore $O(10000)$;\n\t- Strettamente collegato a questo, sarebbe troppo facile per un nodo malevolo inviare un quantitativo immenso di transazioni e DoSsare l'intero sistema. Può succedere anche con i blocchi, ma viene reso più difficile.\n- L'***atomic commit*** passa dalla singola transazione ad un gruppo di transazioni, che quindi sono consistenti in blocco. Sappiamo (cfr. ***DS***) che anche solo questa è una grande cosa;\n- Il ritmo di aggiunta dei nuovi blocchi scandisce il ***tempo*** della BC (e.g. $\\sim 10$ min per Bitcoin), utile tra le altre cose a ***regolare la velocità del mining*** e, di conseguenza, a determinare quanto velocemente viene creata nuova criptovaluta;\n\t- Ovviamente non è un tempo assoluto (cfr. ***DS***).\n- Ogni blocco e identificato da un hash derivante dal suo contenuto. Questo permette, tramite i ***merkle trees***, di cercare le transazioni all'interno della BC in maniera molto più efficiente.\n\nPer i nuovi nodi potrebbe essere pesante scaricare tutto da capo. I sistemi recenti prevedono l'uso dei ***mechanical breakpoints***, i.e. degli ***snapshot*** (cfr. ***DS***) della BC che permettono di scaricare solo il checkpoint più recente e i blocchi successivi ad esso, risparmiando `terabyte` di download. Ciò include il non essere costretti a rieseguire da capo tutti gli SC.\n\nIn ogni caso, non tutti i nodi devono avere necessariamente tutta la BC scaricata. I ***light nodes*** scaricano solo gli header dei blocchi, e se hanno bisogno di dettagli più precisi interrogano i ***full nodes***, eventualmente richiedendo ***Merkle Proofs***. Questo accade in generale per risparmiare risorse. Altra cosa sono i ***light clients***, i.e. quei pezzi di SW che tramite API chiamano (spesso e volentieri) i light nodes per avere contezza dello stato della BC. Tutti i nodi possono partecipare al protocollo P2P del DS, i light clients ovviamente no (... perché non sono nodi). Spesso il concetto di gestore delle chiavi crittografiche e di light client convergono nella parola \"***Wallet***\" (pur essendo a rigore cose separate: potrei avere le chiavi salvate offline e usare le API tramite un mio codice).\n\nOra, se sono un nodo trovo ogni informazione sulla BC guardando solo alla mia versione: la mia verità è quello che ho salvato io, non mi servono conferme altrui. Puzza di sistema centralizzato, almeno localmente. Il ledger però è replicato ovunque, e chiunque può partecipare al consenso: a livello tecnico è sicuramente un DS. In pratica però i nodi si raggruppano in pool computazionali per avere più probabilità di diventare proposer. Si passa da una \"democrazia diretta\" ad una \"indiretta\", in cui solo pochi nodi diventano proposer. Potremmo chiamarla \"decentralizzazione politica\". Il messaggio in pratica è che ***il grado di distribuzione dipende da cosa guardi***.","x":-10129,"y":-4279,"width":759,"height":985,"color":"4"},
		{"id":"39f7a7e1bec4f9ea","type":"text","text":"# Lezioni Di Ciccio 02 - Intro a Bitcoin\n\nEssendo un progetto open source, in centinaia hanno clonato la repo, fatto qualche piccola modifica e creato ognuno una propria BC. Sono cloni di BTC e derivatives of BTC (?), e.g. Namecoin: posso pickare un solo username, chi se lo aggiudica? FCFS, con possibilità di contrattare se vengo dopo e voglio acquistare un nickname che mi piace (tipo comprare domini con parole chiave trendy e aspettare che qualche azienda neofita ti offra 10 volte tanto per averlo).\n\n\"a ledger is a collation of transactions\", i.e. keeping the order while collectin them\n\nla mempool viene gossippata in giro, magari non con il giusto ordine, ma l'idea è che la stessa transazione venga affidata a diversi miner per la scrittura in un blocco. Validity by:\n\n- input account ha firmato la transazione e ha abbastanza soldi per completarla (non esiste il concetto di debito);\n- se il timestamp è coerente. Cosa? Un timestamp in un DS? Sì, ma con una sigma enorme. Al momento dell'accettazione, il timestamp del blocco in cui è inserita la transazione deve essere compreso tra la mediana del timestamp degli ultimi 11 blocchi e il network-adjusted-time del DS + 2 ore. \n\nSia transaction che blocks girano con gossiping, dopo aver controllato la validità. perché?\n\n- non devo congestionare la rete con roba potenzialmente invalida;\n- perché sennò ovviamente salvo informazioni potenzialmente false\n\nCome sappiamo in un DS non c'è un global clock, non perché non saremmo capaci (esistono gli orologi atomici) ma perché non possiamo fidarci dei nodi.\n\njj furman? CAP theorem: la BC è AP: la Consistency (i.e. every read receives either the most recent write or an error) se ne va a farsi benedire in caso di fork.\n- Qui però ho un'inconsistenza con gli appunti di DS, che dicono che la BC è CP.\n- Comunque c'è eventual consistency con alta probabilità (pseudo-guarantee, thumb rule dei 6 blocchi, su Ethereum sono $\\sim$ 12), questo perché il consenso sul singolo blocco richiede più round, e nel frattempo possono esserci altri blocchi pubblicati (cfr. fork).\n\nè quasi la stessa struttura dietro Git, che è un (blocktree?)\n\ncambiare l'algoritmo di hashing su btc porta ad una hard fork in cui devo ri-hashare tutto\n\n- sha-128 o sha-256? ovviamente 256 è più sicuro, c'è un numero esponenzialmente più alto di possibilità, ma serve anche più memoria (e  potenza computazionale?)\n\nnon può succedere che due blocchi abbiano lo stesso hash, e non deve succedere (... perché??)\n\n\"the more the nodes, the safest the network\" ovviamente\n\nSi hasha solo l'header del blocco (perché ci sta il merkle tree?)\n\nnessuno decide quando comincia il nuovo round. certo, se mi aspetto un blocco ogni 10 minuti e passa un'ora potrei dedurre che sono offline.\n\nminare dei blocchi vuoti ogni tanto è SANO per la BC. Perché? Lo è rispetto a non mettere alcun blocco, perché continua a tenere traccia del tempo e consolida i blocchi precedenti. e poi \"vuoti\" si fa per dire, c'è sempre la coinbase transaction con cui il miner si autoassegna il premio per il blocco\n\ni nodi sono invogliati a diffondere le informazioni perché ovviamente vengono premiati con la coinbase transaction. la fine di questo reward è prevista verso il 2030, dopodiché o ci saranno solo fees o ci sarà una hard fork che cambia il protocollo\n\nper mantenere un blocco ogni 10 minuti si guarda il tempo medio di risoluzione degli ultimi 2000 blocchi, e si aggiusta di conseguenza\n\nL'idea per una qualsiasi BC stabile è fare in modo che giocare pulito sia più rewarding rispetto a provare a giocare sporco. PoW è super expensive a livello di consumo elettrico.\n\nanonimity nel senso del gdpr significa non essere in grado di risalire ad un singolo individuo a partire dai dati.\n\ninkscape opensource per vedere i layer (ungroup). meglio non usare adobe appiccicando la tua firma perché qualcuno potrebbe disentanglarla e usarla al posto tuo. sarebbe davvero una pessima idea usare questo invece della crittografia a chiave pubblica-privata\n\nUn full node può rifiutarsi di condividere con gli altri una transazione nella propria mempool. perché? tralasciando il caso in cui è bizantino, ci sono diversi livelli in cui la transazione può essere sbagliata, e il nodo deve fare un pre check su ognuno:\n\n- la TX dichiara di voler pagare 100BTC, ma il sender ne ha solo 99. Chiaramente rifiutata, ma magari esiste una transazione che aumenta i fondi di A che non è stata ancora approvata, quindi potrebbe anche aver senso aspettare, in questo caso;\n\t- ma a na certa che aspetta scade??? esiste un TTL?\n\t- i.e. faccio riferimento ad una transazione che non esiste\n- la TX è firmata male, in generale, i.e. se gli input non erano rivolti a me e provo a usarli lo stesso, se provo a dare in output più della somma degli input, ...\n\nState Transition Networks???\n\n","x":-11960,"y":-13120,"width":1207,"height":1834},
		{"id":"6b1f1894ab710644","type":"text","text":"# intro al seminario\n\nBC for notorization? era tipo un seminario quell'anno\n\nSta di fatto che parla di web 3.0 (SC eseguiti in backend e ho frontend pulito)\n\nriassumendo: SC -> programmability; Transactions -> asset transfer & SC function execution; ledger on DS -> data robustness, traceability & consistency; Hash Signatures -> Authentication/non-repudiation. E tutto questo (da buon DS) in un setting in cui la fiducia tra nodi è solo parziale.\n\nperò il fatto che sia tutto tracciabile ci piace fino a un certo punto -> \"privity\" \"notorization\". \"we want BC to record everything... but not too much\". L'idea è che sì, tu registri tutto, ma devi anche offuscare un po' e/o mostrare cose diverse ad entità diverse. Non ho capito se si chiama davvero CAKE o se è un suo meme. InterPlanetary File System to implement it (na specie di torrent + tor + emule che implementa distributed hash tables DHT, i.e. prendi degli hash e fai tipo sfere del drago). Ciphertext-Policy e Attribute-Based Encryption meaning sono identificato dal mio ruolo e non dalla mia identità (tipo...). L'address è content-based, quindi cambiare pezzi di file = cambiare l'hash (in questo caso l'address, cfr. Torrent su esame DS). in pratica con IPFS non possediamo i dati ma i link ai dati.\n\nvabbè ma come si realizza? con un sistema public key critto con chiavi diverse diversi pezzi di dati. ","x":-14580,"y":-12457,"width":828,"height":508},
		{"id":"ab5bdfb7e15861eb","type":"text","text":"# Implementare una Blockchain\n \nPrendiamo un blocco (inteso come gruppo di transazioni) e la nostra funzione di hash crittografico preferita (magari la stessa che usavamo per rappresentare le singole transazioni). Per ottenere il valore di hash di tale blocco, diamo in input alla funzione\n\n- tutti i valori di hash delle singole transazioni al suo interno;\n- il valore di hash del blocco precedente;\n- altra roba, tipo l'ID del nodo che ha fatto approvare il blocco, o un `nonce` (specie se c'è sotto un meccanismo di consenso di tipo POW. Non è così importante ai fini di questo discorso, lo dico per completezza).\n\nPer via delle proprietà delle funzioni di hash, abbiamo che:\n\n- Possiamo conservare in modo leggero l'intera struttura dati (gli hash sono rappresentativi dell'intera struttura), ed effettuare ricerche veloci al suo interno (vedi ***Merkle Trees***);\n- Visto che l'hash di ogni blocco dipende dal precedente, abbiamo di fatto una catena in cui se ne cambia uno cambiano a cascata tutti i successivi. Ogni modifica a quanto era stato approvato in precedenza diventa quindi abbastanza evidente (i.e. la BC è ***tamper-evident***), nonché quasi impossibile (i.e. la BC è ***tamper-resistant***), perché a partire dalla modifica che hai fatto dovresti ricalcolare tutti gli hash successivi per fare in modo che nessuno si accorga che l'hai fatta (e convincere tutta la rete distribuita che la tua versione sia quella giusta...).\n\n\n\n\nTutte le BC hanno un'unità minima indivisibile (e.g. Satoshi per BTC, Wei per ETH, Lamport per Solana, ...). La logica è che non devo assolutamente mai usare i float: gli errori di approssimazione distruggerebbero tutta la logica del sistema.","x":-9120,"y":-1844,"width":759,"height":984,"color":"6"},
		{"id":"6d0a42604e6ee149","type":"text","text":"# Solidity\n\nNon ho tempo di entrare nel dettaglio, per un esempio vedi Task 4.","x":-6093,"y":-4277,"width":759,"height":984,"color":"3"},
		{"id":"ce361acbec560316","type":"text","text":"# Ethereum\n\nPossiamo avere\n\n- Externally Owned Account (EOA) - private keys-Public address of EAO is generated by taking the last 20 bytes of the Keccak-256 hash of the public key and adding 0x to the beginning.\n- Contract account - An account controlled by a smart contract. They are also made of 20 bytes and start with 0x the address is computed from the Keccak-256 hash of the RLP-encoded sender address and nonce. The resulting contract address is the last 20 bytes (160 bits) of that hash. \n\nQui c'è il Balance: The number of wei owned by this address\n\n- codeHash: It is an hash that refers to the code of an account on the Ethereum virtual machine (EVM). It is used as the key to retrieve the corresponding code from the database where it is stored. In EOA it is the hash of an Empty String.\n- StorageRoot or Storage Hash: A 256-bit hash of the root node of a Merkle Patricia Trie that encodes the storage contents of the account (a mapping between 256-bit integer values), encoded into the trie as a mapping from the Keccak 256-bit hash\n\nTransactions are signed messages originated by an externally owned account (EOA), transmitted by the Ethereum network, and recorded on the Ethereum blockchain. They are the only things that can trigger a change of state, or cause a contract to execute in the EVM.\n\nOn Ethereum there are a few different types of transactions:\n\n- Regular transactions: a transaction from one account to another.\n- Contract deployment transactions: a transaction without a 'to' address, where the data field is used for the contract code.\n- Execution of a contract: a transaction that interacts with a deployed smart contract. In this case, 'to' address is the smart contract address.\n\nTime in proof-of-stake Ethereum is divided into:\n• slots (12 seconds)\n• epochs (32 slots, 6.4 minutes)\nSlots are the heartbeat of the Ethereum blockchain.\nA slot is a chance for a block to be added to the Beacon Chain.\nA slot can be empty. I.E. no block is added at that slot.\nSlots and epochs progress regularly and relentlessly, whatever else may be happening on the\nnetwork.","x":-6093,"y":-1844,"width":759,"height":984},
		{"id":"778bad592f5b6d45","type":"text","text":"# Lezioni DiCiccio 03 - Bitcoin\n\n##### State Transition Network\n\n\n\n\n##### Cosa sono i (bit)coin? (BITCOIN 2)\n\nI BTC sono un po' come le banconote: esattamente come non posso avere la banconota da 15, nel mio wallet ci sono UTXO che sono singole entità da 1, 2, 10 o quanto ti pare. Se devo pagare 15 e ho solo un pezzo da 20 non divido la banconota, ma pago e aspetto il resto. Same here.\n\n... o quasi. Qui posso fondere i coin. In che senso?\n\n- Devo pagare 6.5 e nel wallet ho un pezzo da 5 e uno da 2;\n- Genero una transazione mettendo insieme questi due pezzi, ma scrivendo sopra 6.5.\n- A questo punto la rete fa due cose:\n\t- trasforma quello strano UTXO 5+2 in un 6.5 e lo consegna all'indirizzo bersaglio;\n\t- genera un UTXO da 0.5 come resto e lo dà all'account a cui va dato il resto (di norma è lo stesso del sender, per ovvi motivi)\n\nThe STATE represents to every account which UTXO they have.\n\nin tutto questo una transazione può essere fatta DA 1, ..., N account A 1, ..., N account. Posso fare quel simpatico raggruppamento di cui sopra anche prendendo UTXO da account diversi e indirizzando a diversi account diverse cifre.\n\n# Come si usano i coin?\n\nUna transazione ha tre elementi:\n\n- `input` - una serie di N sorgenti dalle quali prendo i fondi. Vengono scritte come `ID_transazione(indice_output_transazione)[valore]` (perché ogni transazione, come detto, può avere N output);\n\t- è sufficiente che chi comanda questa transazione sia in grado di firmare tutti gli input\n- `output` - una serie di M indirizzi ai quali cedo BTC nella forma `address[value]`. (Esistono nomi speciali per il campo `address`, tipo `CDC` che indica me stesso???);\n- `ID_transazione` - Autoesplicativo\n\nLa fee della transazione è automaticamente calcolata come somma input - somma output. Questo vuol dire che il sistema non ci dà il resto in automatico, ma ce lo dobbiamo auto-assegnare noi. Ciò che avanza diventa la fee.\n\n- La coinbase transaction ha come source un indirizzo speciale, target il miner e valore il reward + la tx fee (per il miner??? cioè doppio reward??)","x":-10270,"y":-13120,"width":1207,"height":1834},
		{"id":"02a3aef22819281c","type":"text","text":"Ecco una spiegazione chiara e strutturata di cos'è un'**Initial Coin Offering (ICO)**, pensata per integrarsi con il contesto del tuo report su Binance.\n\n### Cos'è una ICO?\n\nL'**Initial Coin Offering (ICO)** è un metodo di **raccolta fondi** (crowdfunding) utilizzato da aziende o progetti nel settore blockchain per finanziare lo sviluppo della loro piattaforma.\n\nIl concetto è simile a una **IPO** (Initial Public Offering) nel mercato azionario tradizionale, ma con differenze sostanziali:\n\n- **Nella IPO (Borsa):** L'investitore compra **azioni** (_shares_), diventando proprietario di una quota della società e acquisendo diritti (dividendi, voto).\n    \n- **Nella ICO (Crypto):** L'investitore compra **token**. Questi token solitamente _non_ rappresentano quote della società, ma offrono un'utilità futura (es. pagare le commissioni sulla piattaforma che verrà costruita) o sono puramente speculativi.\n    \n\n### Come funziona tecnicamente (Il ciclo di vita)\n\n1. **L'Idea e il Whitepaper:** Il team di sviluppatori pubblica un documento tecnico (il _Whitepaper_) dove spiega: \"Vogliamo costruire questo progetto, ci servono X milioni di dollari. Ecco come funzionerà la tecnologia e a cosa servirà il token\".\n    \n2. **Creazione del Token:** Il team crea uno Smart Contract (solitamente su Ethereum, standard ERC-20) che gestisce la creazione e la distribuzione dei token.\n    \n3. **La Raccolta (Crowdsale):** Viene aperta la vendita. Gli utenti inviano criptovalute \"pregiate\" e già liquide (solitamente **ETH** o **BTC**) all'indirizzo del progetto.\n    \n4. **Distribuzione:** In cambio, lo Smart Contract invia automaticamente al wallet dell'utente i nuovi token del progetto, secondo un tasso di cambio stabilito (es. 1 ETH = 10.000 NuoviToken).\n    \n5. **Listing:** Una volta finita la raccolta, il token viene listato sugli exchange (come Binance o Uniswap) e il mercato inizia a determinarne il prezzo tramite domanda e offerta.\n    \n\n### Perché è importante per il tuo report su Binance?\n\nBinance è l'esempio \"da manuale\" di una ICO di successo. È fondamentale per capire la genesi della chain.\n\n- **Luglio 2017:** Changpeng Zhao (CZ) pubblica il Whitepaper di Binance.\n    \n- **La promessa:** \"Costruiremo l'exchange di criptovalute più veloce al mondo\".\n    \n- **Il Token (BNB):** Agli investitori veniva venduto il token **Binance Coin** (allora ERC-20 su Ethereum).\n    \n- **L'Utilità:** \"Se usate BNB per pagare le commissioni di trading sul nostro exchange, avrete uno sconto del 50%\". Questa _utility_ ha creato la domanda per il token.\n    \n- **Il Risultato:** Hanno raccolto circa **15 milioni di dollari** in due settimane. Quei soldi sono stati usati per assumere sviluppatori, comprare server e marketing.\n    \n\n### Rischi e Problemi (Contesto Storico)\n\nNel tuo report hai citato l'ascesa degli Smart Contract e la congestione di Ethereum. Le ICO sono state il motore principale di quella congestione nel **2017-2018 (The ICO Mania)**.\n\nPoiché chiunque poteva creare un token ERC-20 in 10 minuti e raccogliere milioni senza controlli (a differenza delle IPO che sono super-regolamentate):\n\n1. **Truffe (Exit Scams):** Molti progetti raccoglievano ETH e sparivano senza costruire nulla.\n    \n2. **Bolle speculative:** La gente comprava qualsiasi cosa sperando in un \"x100\" al listing.\n    \n3. **Congestione:** Le chain (come Ethereum) si intasavano durante le ICO più attese perché migliaia di utenti cercavano di inviare fondi nello stesso istante.\n    \n\n### Sintesi per il Report\n\nSe dovessi definirla in una riga nel tuo lavoro:\n\n> _\"An unregulated fundraising mechanism where a project sells its underlying crypto tokens in exchange for immediate investment capital (usually ETH or BTC), often utilized to bootstrap network liquidity and development costs.\"_","x":-5713,"y":2157,"width":1035,"height":1792},
		{"id":"60294113d6fcd78e","type":"text","text":"# 03 Bitcoin 3 (2023-10-17)","x":-10060,"y":-12100,"width":1304,"height":1327,"color":"1"},
		{"id":"34c1452fcb19ba4f","type":"text","text":"# 30/09\n\nsu ethereum ci sta wrapped ether perché è più facile fare operazioni nelle LP con i token che con il coin\n\ntrovare collision hash -> calcola hash per 2^{#bit dell'hash} elementi per trovare almeno due elementi che collidono. Se #=256 servono miliardi di miliardi di anni. Ma un QC?\n","x":-3076,"y":-11436,"width":680,"height":492},
		{"id":"f7ec2b633006125f","type":"text","text":"Esame 2025/26\n\n- homeworks verso la fine del corso con deadline;\n\t- mandatory, se li faccio entro deadline punti bonus (max 3)\n- group report (pdf) and presentation (slides in class)\n\t- mandatory, se si fa bene punti bonus fino a 15 punti (10 report + 5 presentazione)\n- Scritto\n","x":-3076,"y":-13544,"width":680,"height":320},
		{"id":"9f6e59f539e508ef","type":"text","text":"# lec 23/09\n\nel salvador usa btc come currency\n\npolymarket? prediction market based on blockchain\n\n\"we're approaching the alt season\" (??)\n\ncash ti da privacy, ma se sono in un sistema credito/debito devo sapere chi contrae il debito.\n\n(non c'è più l'oro come controvalore -> fractional reserve)\n\ncarta di credito -> no privacy e serve intermediario\n\nvogliamo best of both worlds: privacy e nessun intermediario dal mondo del cash e online payments, reversibility da credit card. però un intermediario fa anche da garante. e che se fa? non solo: non posso avere un file che rappresenta cash se non so di chi è: il proprietario deve firmarlo (lack of anonimity). E poi double spending. vedi la nota a dx.\n\nperché non ci piaccono le central authorities? \n\n- censura, chi cede denaro e chi riceve devono concordare la stessa auth, transaction costs (pure BC eh...). vabbè siamo anarchici dai\n\npure quello della banca si chiama ledger, ma è centralized.\n\nora, centralized = stella, decentralized = stella di stelle, distributed = grafo \"omogeneo\" (appare come singolo sistema con molti nodi, contro la stella di stelle che appare come \"tanti responsabili\"). in questi ultimi due contesti un singolo nodo può fare poco, rispetto a tutti gli altri insieme\n\nbitcoin è così mainstream che i coin delle altre blockchain si chiamano altcoin.\n\nmarket capitalization = \\#coins \\* valore_singolo_coin\n\nvisto l'hype della struttura dati blockchain, la gente mo vuole usarla per tutto. non è sempre una buona idea.","x":-3076,"y":-13184,"width":680,"height":1020},
		{"id":"ae9a8a2e0696f060","type":"text","text":"# Lec 24/09\n\nhash function (overview)\n\npost quantum computing è un po' tosta seguirlo da metà lezione in poi","x":-3076,"y":-12064,"width":680,"height":500},
		{"id":"246a476e166d1303","type":"text","text":"# [Materiale valido (Di Ciccio)](https://drive.google.com/drive/folders/1BUlKuJIxB6_HxisGTIoDneJFWF7Ihla3)\n\n# [DeFi Course](https://defi-learning.org/f22)","x":-3076,"y":-13929,"width":680,"height":294,"color":"1"},
		{"id":"94b314070ee4465e","type":"text","text":"# idee presentazione/progetto\n\n- scrivere una roba di AI? Un'APP? non ho capito\n- creare un nostro token, magari su una test blockchain, così non paghiamo\n- creare un NFT, stessa cosa di prima","x":-4240,"y":-11017,"width":646,"height":488},
		{"id":"c4b18ebd4a0039c5","type":"text","text":"# progetti basati su BC (tokenizing things)\n\n- Steem\n- Open Music Initiative\n- Madhive\n- Votaz\n- Tradelens\n- Patientory\n- Propy\n- Algorand\n- Forestcoin","x":-4173,"y":-10330,"width":513,"height":358},
		{"id":"ac6a7ffa8b2cf17c","type":"text","text":"# Web 3.0\n\n1.0 - classico client server, ogni azione ricarica intera pagina\n\n2.0 - client più potenti, più calcoli in frontend, AJAX permette di non ricaricare tutto ma solo pezzi di pagina lasciando inalterata l'interfaccia\n\n3.0 - sembra la stessa cosa di 2.0 ma il backend ha account, BC, SC e via dicendo. ne riparla a fine corso.","x":-4240,"y":-9769,"width":646,"height":363},
		{"id":"6c3ba07e993ec188","type":"text","text":"# Bitcoin Consensus\n\nPOW\n\nnessuno decide quando comincia il nuovo round. certo, se mi aspetto un blocco ogni 10 minuti e passa un'ora potrei dedurre che sono offline.\n\nminare dei blocchi vuoti ogni tanto è SANO per la BC. Perché? Lo è rispetto a non mettere alcun blocco, perché continua a tenere traccia del tempo e consolida i blocchi precedenti. e poi \"vuoti\" si fa per dire, c'è sempre la coinbase transaction con cui il miner si autoassegna il premio per il blocco\n\ni nodi sono invogliati a diffondere le informazioni perché ovviamente vengono premiati con la coinbase transaction. la fine di questo reward è prevista verso il 2030, dopodiché o ci saranno solo fees o ci sarà una hard fork che cambia il protocollo\n\nper mantenere un blocco ogni 10 minuti si guarda il tempo medio di risoluzione degli ultimi 2000 blocchi, e si aggiusta di conseguenza\n\nL'idea per una qualsiasi BC stabile è fare in modo che giocare pulito sia più rewarding rispetto a provare a giocare sporco. PoW è super expensive a livello di consumo elettrico.\n\n- sha-128 o sha-256? ovviamente 256 è più sicuro, c'è un numero esponenzialmente più alto di possibilità, ma serve anche più memoria (e  potenza computazionale?)\nA distributed consensus protocol must satisfy two key properties:\n• All honest nodes must reach agreement on the same value.\n• The agreed-upon value must originate from an honest node.\n\nA block should be produced every 10 minutes, however new miners can join the network\nwhile other can left.\nSo the target change over time, it is updated every 2016 blocks, in such a way that the time\nto find a new block needs on average 10 minutes.\n(2016 blocks * 10 minutes)/24 hours = 14 days (2 weeks)\n\n\n### POW Consensus\n\nBlock headers contain the target in a notations called “target bits”.\nTarget bits = 0x1903a30c\nThe first two hexadecimal digits for the exponent and the next six hex digits as the coefficient\nExponent = 0x19\nCoefficient = 0x03a30c\n\n= a valid block is one that has a block header hash less than the target. In\nbinary that number must have more than 60 leading bits set to zero\n\n```\nNew Target = Old Target * (Actual Time of Last 2015 Blocks/ 20,160 minutes)\n```\n\nThe timestamps set in block headers are set by the miners.\nThere is no global clock\n\n- If a miner sets their time in the future, they can lower difficulty, allowing them to mine more blocks and claim some of the block subsidy reserved for future miners.\n- If a miner set their times in the past for some blocks, they can use the current time for some other blocks, and so make it look like there's a long time between blocks for the purpose of manipulating difficulty.\n\nSo, Rules:\n\n- no node will accept any block with a time further in the future than two hours.\n- no node will accept a block with a time less than or equal to the median time of the last 11 blocks, i.e. median time past (MTP).\n\n\nThe data structure of transactions does not have a field for fees. Instead, fees are implied as the difference between the sum of inputs and the sum of outputs. Any excess amount that remains after all outputs have been deducted from all inputs is the fee that is collected by the miners.\n- Replace by fee (RBF): creating a conflicting version of the transaction that pays a higher fee. Two or more transactions are considered to be conflicting transactions if only one of them can be included in a valid blockchain, forcing a miner to choose only one of them.\n- Child Pays for Parent (CPFP) : Anyone who receives the output of an unconfirmed transaction can incentivize miners to confirm that transaction by spending that output. The transaction you want to get confirmed is called the parent transaction. A transaction that spends an output of the parent transaction is called a child transaction\n\nAn orphan block is a legitimate block with a nonexistent or unknown parent block. It is also known as an orphan, detached block, or extinct block. They were common in the early versions of bitcoins (no more possible since 2015). Nowadays it is also used for referring to stale block, because the client denotes their block rewards as “orphaned”. I.E. SUCCEDE CON LE FORK QUANDO APPLICHI LONGEST CHAIN\n\nFinality: Finality is metric that measure the amount of time one has to wait for a reasonable guarantee that crypto transactions executed on the blockchain will not be reversed or changed.\nBitcoin finality : 6 block confirmations X 10 minutes = 60 minutes\n\n","x":-12147,"y":-3061,"width":759,"height":982,"color":"2"},
		{"id":"4ecf6e84c27eefab","type":"text","text":"# Bitcoin (2008)\n\nIl sistema Bitcoin consta di $O(10^3)$ miner sparsi per il mondo, e il gossiping avviene tra $O(10)$ primi vicini. Dal momento che non sono previsti Smart Contracts, esiste un unico coin: $\\BTC$.\n\nNasce con un primo blocco hard-coded contenente una sola transazione che ha fornito $50\\,\\BTC$ al suo fondatore, dopodiché diversi server si sono proposti come miner ed è iniziato il gioco.\nIl numero di transazioni per blocco è aumentato con il tempo, e la prima transazione di ogni blocco costituisce il reward per il miner che risolve il problema computazionale, motivo per cui la storia di ogni $\\BTC$ è tracciabile fino alla sua origine. Questa radice di ogni $\\BTC$ costituisce di fatto l'unico punto in cui vengono creati nuovi $\\BTC$, e il suo valore si dimezza ogni $210\\cdot10^3$ blocchi approvati. Non è tuttavia l'unica fonte di guadagno per il miner. \n\nQuando si esegue una transazione, è consigliato (ma non obbligatorio) pagare una ***fee*** al miner che fa approvare il blocco. Questo perché di fatto è un guadagno per il miner, il quale tenderà a dare priorità di approvazione alle transazioni in mempool con le `fee` più alte. Se ad oggi le `fee` sono solo parte del guadagno dei miner, a lungo termine la `coinbase transaction` diventerà quasi nulla e le `fee` l'unico introito. La somma di `reward` e `fee` si assegna con la ***coinbase transaction***.\n\nL'approvazione dei blocchi  segue uno schema ***PoW*** : \"l'hash del blocco da fare approvare deve avere i $k$ bit meno significativi uguali a $0$\". La funzione di hash (`SHA-256`) prende in input le transazioni del blocco che voglio far approvare, l'hash del blocco precedente, un ***nonce*** e altra roba meno interessante. In generale non ho idea di cosa esca fuori come hash di output, posso solo cambiare il nonce e guardare il risultato. La probabilità di trovare proprio quello che voglio (i.e. i $k$ zeri finali) richiede un numero di lanci quantomeno esponenziale per diventare di ordine $1$, da cui la difficoltà probabilistica del problema (a rigore non è classificabile come $\\NPH$). Una volta risolto il problema (i.e. trovato il nonce), è facile per gli altri miner verificare la soluzione (basta far girare `SHA-256` con i parametri indicati dal miner risolutore).\n\nI coin vengono gestiti come ***Unspent Transaction Outputs*** (***UTXO***), e il compito di smistarli tra i vari `account` viene delegato alle transazioni. In ogni istante, lo ***stato*** della BC è una fotografia che descrive a quale `account` $a_i$ appartiene il `coin` (UTXO) $c_j$. Le transazioni sono quindi delle funzioni che fanno \"evolvere\" lo stato della BC, motivo per cui parliamo di ***State Transition Network***.\n\nL'intero sistema è ***pseudonimo***: non compaiono informazioni personali, ma è comunque possibile provare ad inferire informazioni su chi c'è dietro al singolo `account` cercando i punti in cui i $\\BTC$ vengono convertiti in fiat currency (l'anonimity nel senso del GDPR significa non essere in grado di risalire ad un singolo individuo a partire dai dati, cosa che qui non accade).","x":-12147,"y":-1846,"width":759,"height":984,"color":"6"},
		{"id":"e2d623b8a580162c","type":"text","text":"# Soft and Hard (... forks) - Report\n\nIt might happen, with small probability, that a single round ends up with two proposers.\nIf each proposer manages to convince a different subset of the network (say, half of it, w.l.o.g.) to approve its own block, we end up in a situation in which the Distributed Ledger is no longer consistent. Such a situation is known as a ***fork***.\n\nIn most cases, the system is able to recover from such unwanted events by itself, but while these events are usually accidental (in fact, they're usually called ***Temporary Forks***), sometimes they're intentional. It is crucial to distinguish between a ***Chain Fork*** and a ***Codebase Fork***.\n\n- A ***Chain Fork*** occurs when a single Blockchain splits into two paths sharing a common history up to the split point. The most famous example is the division between Ethereum and Ethereum Classic (2016). Following a major hack (The DAO), the majority of the community decided to alter the protocol history to revert the theft. However, a subset of nodes refused this \"irregular state change\" and continued mining the original chain. This resulted in a ***Hard Fork***: two chains emerged, sharing the same history until the fork block, but diverging afterwards\n\t- While a Hard Fork is a modification to the rules such that non-updated nodes reject blocks adhering to the new standards (non-backward compatible), a ***Soft Fork*** is a retro-compatible update where non-updated nodes continue to accept the new blocks (they might ignore some new data fields they do not understand, but the block remains valid according to the old rules).\n- A ***Codebase Fork***, instead, implies copying the open-source software of an existing project to launch a completely new network with no shared history (i.e. starting from a new Genesis Block). It is the case of ***Binance Smart Chain***. Developers forked the Ethereum software client (Go-Ethereum), replaced the Proof of Work consensus with ***Proof of Staked Authority*** (***PoSA***), and launched a fresh independent ledger. While compatible with Ethereum's applications, BSC does not share its transaction history.\n\n\n###### Other\n\ncambiare l'algoritmo di hashing su btc porta ad una hard fork in cui devo ri-hashare tutto","x":-14165,"y":-3061,"width":759,"height":980,"color":"5"},
		{"id":"5ad864a1df83d423","type":"text","text":"# full node\n\n1. New transactions are broadcast to all nodes\n2. Each node collects new transactions into a block\n3. Each node works on finding a difficult proof-of-work for its block\n4. When a node finds a proof-of-work, it broadcasts the block to all nodes\n5. Nodes accept the block only if all transactions in it are valid and not\nalready spent\n6. Nodes express their acceptance of the block by working on creating the\nnext block in the chain, using the hash of the accepted block as the\nprevious hash","x":-13171,"y":-362,"width":619,"height":508},
		{"id":"c4d82ff3e837b284","type":"text","text":"# ... e suoi derivati\n\n\nEssendo un progetto Open Source, in molti hanno clonato la repository di Bitcoin, fatto qualche piccola modifica e creato ognuno una propria BC.\n\nSono cloni di BTC e derivatives of BTC (?), e.g. Namecoin: posso pickare un solo username, chi se lo aggiudica? FCFS, con possibilità di contrattare se vengo dopo e voglio acquistare un nickname che mi piace (tipo comprare domini con parole chiave trendy e aspettare che qualche azienda neofita ti offra 10 volte tanto per averlo).","x":-13156,"y":-2336,"width":759,"height":255,"color":"3"},
		{"id":"6bbb08f8cb881a51","type":"text","text":"# Validity\n\nCome e quando verificare che una TX sia valida non è un problema da sottovalutare. Ovviamente\n\n- Chi ordina la TX deve essere in grado di firmare ciascuno degli input da cui attinge;\n- Deve anche avere abbastanza soldi per completarla (non esiste il concetto di debito). Questo in parte è ovvio, se pensiamo al fatto che la TX non fa altro che fondere i coin di input per produrre quelli di output, e che è un \"gioco a somma zero\" (o meglio, un \"gioco a somma `fee`\", visto che `fee` = `INPUT` - `OUTPUT`). Il concetto di debito equivarrebbe a creare coin dal nulla;\n- Il `TIMESTAMP` deve essere coerente. Cosa? Un `timestamp` in un DS? Sì, ma con una tolleranza enorme: al momento dell'accettazione, il `TIMESTAMP` del blocco in cui è inserita la TX deve essere compreso tra la mediana del `TIMESTAMP` degli ultimi 11 blocchi e il ***network-adjusted-time*** (una sorta di stima del real clock basata sui tempi di tutti i nodi della rete) del DS + 2 ore.\n\nSia le TX che i blocchi vengono condivisi tra i vari nodi tramite gossiping, ma solo dopo averne controllato la validity. Questo perché\n\n- se non controllo prima del gossiping potrei finire per congestionare la rete con informazioni  potenzialmente non valide;\n- anche se avessi banda infinita, rischierei di salvare informazioni false.\n\nRiassumendo: prima di condividere una qualsiasi informazione devo esserne sicuro (che poi sarebbe una regola di vita abbastanza generale, vabbè).","x":-12147,"y":718,"width":759,"height":565,"color":"4"},
		{"id":"8d91611c75cc89a0","type":"file","file":"Screenshot from 2025-10-26 17-11-20.png","x":-14131,"y":-1022,"width":400,"height":248},
		{"id":"4001807b0ef5ec56","type":"text","text":"# Bitcoin Script\n\nUn input Bitcoin non dice solo “spendo questa moneta”, ma specifica _come_, _quando_ e _a quali condizioni_ quella spesa è valida. Queste verifiche vengono fatte con Bitcoin Script, un linguaggio volontariamente limitato (i.e. non Turing-Completo) che si occupa di:\n\n- Prendere uno specifico UTXO - Devo individuarlo sulla BC come specifico output (`VOUT`) di una specifica transazione (`TXID`);\n- Verificare di poterlo spendere - Questo UTXO è bloccato da una `ScriptPubKey`. Sbloccarla significa essere in possesso di una `ScriptSig` (i.e. firma + chiave pubblica);\n- Stabilire se la spesa è valida - Ci sono diverse condizioni affiché sia legittimo spendere un certo UTXO, oltre al possesso della chiave privata. `Locktime` dice una cosa tipo \"questo output non può essere usato prima di `X`\", dove `X` può essere un tempo o un'altezza di blocco. \n\t- Il \"grado di validità\" di una transazione è dato dal suo campo `Sequence`, che definisce la validità del `locktime` o attiva il meccanismo di ***Replace By Fee*** (***RBF***, i.e. se ho mandato una transazione nella mempool con una fee bassa, con questo meccanismo posso dire una cosa tipo \"se arriva una transazione identica ma con condizioni migliori per te miner, sostituiscila a questa.\"), nonché altra roba noiosa che ignoro.\n\nScript esegue tutti questi controlli (e altri che non mi va di scrivere), permettendo di creare condizioni e applicazioni come\n\n- ***P2PKH*** (***Pay To Public Key Hash***) - \"Questa moneta può essere spesa solo da chi dimostra di conoscere la chiave privata associata a questa chiave pubblica\", il classico esempio;\n- ***P2SH*** (***Pay To Script Hash***) - \"Alice paga Bob solo se c'è la firma di almeno due persone, o comunque dopo un certo tempo\". E mo? P2PKH non è in grado di implementare questa roba, serve che Script stesso verifichi queste condizioni. È per questo che in P2SH Alice paga l'***hash di una regola***, piuttosto che l'hash di un account. Ci penserà poi la regola (i.e. lo script) a fare tutte le verifiche del caso. Questo apre ad applicazioni come\n\t- **Escrow** (Deposito fiduciario condizionato) - Una sorta di Secret Sharing in cui servono (e.g.) 2 firme su 3 per sbloccare i fondi. E se Bob e il notaio spariscono? I fondi sono congelati? Ni. Si può aggiungere una regola di `locktime` che dice tipo \"`se i fondi non sono stati ancora utilizzati entro un certo tempo T, Alice può riaverli`\";\n\t- ***Micropayment Channel*** - Se volessi pagarti a rate, ognuna avrebbe una fee. Allora sfrutto `sequence`, che mi permette di inserire la transazione nella mempool con il primo importo, poi aggiornarla al cumulativo del secondo, ... senza pagare fee ogni volta. Tutto questo è determinato dallo Script in modo automatico.","x":-13156,"y":-1846,"width":759,"height":984,"color":"4"},
		{"id":"200a0a35b8171b4c","type":"text","text":"# Coin & Transazioni (TX)\n\nImmaginiamo di essere in possesso di `1 BTC` sull'`address` `0xABADCAFE`, di ricevere `1 BTC` sullo stesso indirizzo e di dover pagare `1.5 BTC` a `0xDEADBEEF`.\n\n- Anzitutto, il `BTC` che riceviamo ***non si unisce a quello precedente***. Certo, la mia disponibilità totale sarà di `2 BTC`, ma quei due oggetti da `1 BTC` restano due entità separate (un po' come avere due monete da `1€`). Queste entità prendono il nome di ***Unspent Transaction Outputs*** (***UTXO***), e vengono create come risultato di una transazione;\n- In virtù di quello che abbiamo detto, non possiamo fare una cosa tipo \"prendo il primo `BTC` e metà del secondo\", né \"dal mio portafoglio che conta `2 BTC` scalo `1.5 BTC`\". Piuttosto, nella TX darò come input entrambe le \"monete\" (UTXO) di cui sono in possesso. Quindi:\n\t- La transazione \"fonde\" tutti gli UTXO di input formando una disponibilità complessiva;\n\t- \"Devo pagare `1.5 BTC`\" viene tradotto come \"creo un nuovo UTXO del valore di `1.5 BTC` e ne certifico la proprietà di `0xDEADBEEF`\";\n\t- Avanzano `0.5 BTC`. Anche qui, viene creato un nuovo UTXO dal valore di `0.5 BTC` e viene indirizzato al mio `change address` (un indirizzo speciale dedicato a questo). O meglio, questo succede in assenza di `fees`. Verosimilmente dovrò invogliare il miner a far approvare questa TX, quindi è più probabile che di questi `0.5 BTC` ne vadano `0.3` al miner e solo `0.2` al mio `change address`.\n- Tutto questo funziona solo se sono in grado di autenticare gli input con la mia chiave privata, i.e. se sono in grado di dimostrare di essere l'entità autorizzata a spendere quegli UTXO;\n- A transazione approvata (i.e. registrata all'interno di un blocco sulla BC), `0xDEADBEEF` si ritrova con una \"moneta\" (UTXO) da `1.5 BTC`, e il mio `change address` ne avrà una da `0.2 BTC`.\n\nOgni TX può essere scritta come `[INPUT] [OUTPUT] [TX_ID]`, dove\n\n- `INPUT` è la lista delle `N` sorgenti da cui prendo i fondi. Ogni elemento di questa lista si scrive come `TX_ID(indice_output_TX)[valore]` (i.e. individuo la TX, che però ha `M` output, quindi devo specificare quale voglio e quanto vale). Perché la TX sia valida, chi la ordina deve essere in grado di firmare ogni elemento della lista di input, più le cose scritte nel riquadro ***Validity***;\n- `OUTPUT` - Simile a prima, lista di `M` indirizzi ai quali cedo BTC nella forma `address[value]`;\n- `TX_ID` - Autoesplicativo.\n\nLa `fee`  è calcolata automaticamente come $\\sum$`INPUT` $-\\sum$`OUTPUT`: ***il sistema non dà il resto in automatico***, chi ordina la TX se lo deve auto-assegnare . Ciò che avanza diventa la fee.\n\nSeguono FAQ.\n\n- \"Mi disturba avere un sacco di micro monete da `0.0000001 BTC` ciascuna, posso unificarle in una singola moneta?\" - Certo signor ossessivo compulsivo, se sei disposto a pagare una `fee` per la tua sanità mentale puoi auto-indirizzarti le transazioni, non c'è nulla che lo vieti;\n- \"Posso prendere UTXO da diversi account per formare l'input?\" - Certo, fintantoché hai le chiavi di tutti questi account per firmare la transazione;\n- \"E la `coinbase transaction`?\" - Ha come `input address 0x00000000`, come `indice_output 0xFFFFFFFF` e come output l'indirizzo del miner.","x":-12147,"y":-637,"width":759,"height":1120,"color":"4"},
		{"id":"f67f91f5e2629c41","type":"text","text":"Immagina la blockchain come un enorme manuale di istruzioni che tutti i nodi usano per interpretare blocchi e transazioni. La questione “soft vs hard fork” nasce quando qualcuno vuole cambiare quel manuale.\n\nLa differenza sta tutta nel tipo di “nuova grammatica” che introduci.\n\nParto dalla scena più semplice possibile.\n\n### Una storia concreta, senza tecnicismi iniziali\n\nHai un gruppo di persone che parla un dialetto. Un giorno qualcuno propone una nuova regola:\n\n_“Da oggi la parola **ciao** è lecita ma opzionale.”_\n\nChi non aggiorna il proprio dialetto continua a capire tutto. Chi lo aggiorna capisce sia il vecchio che il nuovo. È un tipo di cambiamento compatibile verso il passato.\n\nQuesto è un **soft fork**.\n\nOra cambia la proposta:\n\n_“Da oggi **ciao** è obbligatorio. Se non la usi, la frase è non valida.”_\n\nChi non aggiorna il dialetto all’improvviso non riesce più a interpretare certe frasi. Non solo: i due gruppi iniziano a costruire due lingue diverse, incompatibili.\n\nQuesto è un **hard fork**.\n\n### Portiamo l’analogia dentro Bitcoin/Ethereum\n\nLa blockchain è un sistema distribuito molto suscettibile a queste differenze grammaticali, perché basta un piccolo disallineamento per creare **due catene, due verità**.\n\n#### Soft fork\n\nÈ una modifica che **restringe** le regole.  \nI nodi aggiornati accettano meno cose di prima.  \nI nodi non aggiornati… non si accorgono di nulla e continuano a vedere tutto come valido.\n\nUn esempio classico è **SegWit in Bitcoin**:  \naggiunge un nuovo modo di formare le transazioni, ma non richiede ai nodi vecchi di riconoscerlo. Per loro quelle parti extra sono solo “dati di cui non capisco bene il senso”, ma il blocco resta valido.\n\nRisultato: tutta la rete resta unita.\n\n#### Hard fork\n\nÈ una modifica che **allarga** le regole.  \nI nodi aggiornati accettano più cose di prima.  \nI nodi non aggiornati… rifiutano questi blocchi.  \nE da qui nasce la scissione: due blockchain distinte.\n\nEthereum dopo il DAO hack ne è un esempio perfetto. Chi ha aggiornato ha accettato il “rollback” del furto. Chi non era d’accordo ha continuato la catena vecchia → **Ethereum Classic**.\n\n### Perché basta una “banalità” per dividere la rete?\n\nPerché ogni blocco costruisce sul precedente. Se io accetto un blocco e tu no, da lì in poi viviamo in universi tecnicamente separati. Nessuno dei due ha modo di “tornare indietro” senza rompere il proprio stato interno.\n\nLa blockchain non perdona nemmeno una virgola di incompatibilità.\n\n### Il punto chiave, riassunto in una frase\n\nUn **soft fork** introduce regole più restrittive: i vecchi nodi considerano tutto ancora valido, quindi la rete resta unita.  \nUn **hard fork** introduce regole più permissive: i vecchi nodi rifiutano i nuovi blocchi, quindi la rete si divide.\n\nSe ti interessa, posso anche mostrarti come formalizzare la differenza pensando alla blockchain come un **State Transition System**, dove i soft fork restringono l’insieme delle transizioni valide mentre gli hard fork lo ampliano.","x":-16273,"y":-3181,"width":822,"height":1619},
		{"id":"abf6c2ebe99219a6","type":"text","text":"# Simultaneità e Fork\n\nNonostante sia probabilisticamente raro, cosa succede se due miners risolvono insieme?\n\nEscludiamo il caso in cui uno dei due è più veloce a comunicarlo e a farlo approvare, e diciamo che il server `A` convince alcuni miner ad allungare la blockchain con il proprio blocco e che `B` convince i restanti con il suo. D'altronde \"randomized consensus\" significa proprio questo: \"`è talmente improbabile che qualcuno risolva che quando succede mi convinco che sia un caso isolato e accetto, assumendo implicitamente che tutti quanti accetteranno questo mio stesso blocco`\". Questa situazione rompe esattamente questa assunzione.\n\nQuesto porta in pratica alla creazione di una ***fork*** (i.e. ci sono due diversi ***branch***). Diciamo che tutti concordano inizialmente su `XYZ`. Sia `A` che `B` usano come hash del blocco precedente quello di `Z`. Se però ho approvato `XYZA`, il mio \"blocco precedente\" diventa `A`. Quando mi arriva `B` vedo subito l'incongruenza, e mi pongo il problema: gli altri stanno lavorando su una Blockchain diversa dalla mia? Chiedo allora agli altri gli hash dei loro ultimi blocchi, arrivando a ricostruire la presenza dei branch divergenti: `XYZA` ed `XYZB`. Come si ***riconcilia***?\n\nL'idea è che una delle due catene si estenderà prima dell'altra, i.e. uno dei due gruppi di miner troverà il blocco successivo prima degli altri (se i branch hanno la stessa lunghezza, continuo nel dubbio a lavorare sul primo che ho approvato: fino a prova contraria, quella è la \"vera\" Blockchain). Se quelli che lavorano su `XYZA` trovano per primi `XYZAC`, con un processo simile a quello descritto in precedenza tutti quanti saranno in grado di ricostruire i branch divergenti, ma stavolta una delle due catene (sia essa la principale o l'\"alternativa\") risulterà più lunga. A questo punto, chi aveva quella più corta farà marcia indietro e si adeguerà all'altro gruppo, ripristinando la consistenza globale. Ciò si chiama ***regola della catena più lunga***.\n\nPotrebbe ovviamente succedere di nuovo che due miner nei due blocchi risolvano insieme e che quindi generino nello stesso sottogruppo due chain `XXXAD` e `XXXBC`, ma l'idea è che a livello probabilistico prima o poi uno dei due si renda conto dell'errore.\n\nLa *rule of thumb* è che prima di approvare in via definitiva le transazioni si aspetta di impilare altri 6 blocchi. Questo riduce quasi del tutto (ma non annulla!) la possibilità di sbagliare (e.g. come caso isolato, nel 2013 a causa di un errore SW c'è stata una fork di 24 blocchi).\n\nConsiderando che si aggiunge circa un blocco ogni circa $10$ minuti, prima di essere certi di un pagamento in Bitcoin bisogna aspettare all'incirca un'ora.","x":-15174,"y":-4279,"width":759,"height":984,"color":"4"},
		{"id":"7b9a2f1c22d3ed92","type":"text","text":"# ... cioè quindi come GitHub!\n\nSì!! ... ni. Cioè, le strutture dati sono simili ma non uguali.\n\n\nè quasi la stessa struttura dietro Git, che è un (blocktree?)","x":-15174,"y":-3061,"width":759,"height":980},
		{"id":"6174a42308c05ee3","type":"text","text":"# Byzantine Nodes ed Attacco del 51%\n\nIn un sistema del genere, è ovviamente un problema se ci stanno dei ***byzantine nodes***.\n\nTuttavia, Bitcoin ha una discreta tolleranza. Ad esempio, non è possibile per un miner inserire transazioni false ed indirizzare a se stessi i coin altrui. Questo perché per realizzare una transazione serve sempre la chiave privata del vecchio proprietario del coin. Non è neanche possibile fare double spending, dato che ogni coin è unico. Né è possibile modificare una transazione approvata, perché romperebbe tutti gli incastri successivi degli hash.\n\n... o meglio, se sono un singolo miner o un piccolo gruppo di miner che collabora posso fare poco. Se però raggruppo una discreta potenza computazionale (***hashrate***) posso iniziare a vincere spesso. A seconda di quanto ne ho possono succedere diversi scenari simpatici.\n\n- Se ne ho tanto (e.g. sono un governo o una banca) posso provare a ***DDOSsare*** il sistema.\n\t- ***Come?*** - Inserendo blocchi vuoti nella BC per aumentare il carico computazionale, *DDOSsando* direttamente i miner.\n\t- ***Perché?*** - Una banca potrebbe avere interesse a destabilizzare le criptovalute.\n\t- ***È un problema?*** - $\\BTC$ è abbastanza resistente, e non sembra sia mai successo.\n- Se ne ho ***più della metà*** posso fare un pagamento, ricevere quello che mi viene dato e poi ritirare il pagamento invalidando la vecchia chain con una fork (***Attacco del*** $51\\%$).\n\t- ***Come?*** - Avere più della metà dell'hashrate significa essere in grado di costruire un branch alternativo più velocemente rispetto al restante $49\\%$ del sistema. Posso così prima o poi (potenzialmente mi servono tanti blocchi) sovrascrivere il branch del resto del sistema (in cui ho speso $100\\BTC$) con il mio (in cui non l'ho fatto).\n\t- ***Perché?*** - Posso fare double spending: mando agli altri una transazione in cui spendo $100\\BTC$ nel blocco `A` che forma la catena `XXXA` per poi sovrascrivere con `XXXBC`. Particolarmente problematico se supero la catena dopo oltre $6$ blocchi (i.e. dopo che il sistema ha già \"ratificato\" la transazione): posso di nuovo spendere i coin che qualcuno aveva già accettato come pagamento (inviandomi magari la cocaina).\n\t- ***È un problema?*** - Difficile ottenere il $51\\%$ dell'hashrate in Bitcoin. Forse è più fattibile con blockchain più piccole.","x":-15174,"y":-6240,"width":780,"height":796,"color":"4"},
		{"id":"1de20a395d19c219","type":"text","text":"# Problemi con il Consenso\n\nFork, Merge, Attacco del 51%\n\n","x":-14165,"y":-4040,"width":759,"height":503,"color":"6"},
		{"id":"8969a303981934a3","type":"text","text":"# Consensus\n\nOra che abbiamo i nostri nodi funzionanti e con la giusta struttura dati, possiamo specificare che nella stragrande maggioranza dei casi parliamo di ***Randomized Consensus***, quantomeno per le BC pubbliche. Questo significa che mi aspetto di avere un solo ***proposer*** alla volta, e che quando questa condizione non si verifica (e.g. in Bitcoin due miner risolvono la PoW in simultanea) può crearsi una ***fork*** (i.e. entrambi convincono un proprio sottoinsieme del DS ad allungare la catena con il proprio blocco). Le fork normalmente si risolvono da sole tramite la ***longest chain rule***.\n\n\n###### Report\n\nFor transactions to be accepted by the entire distributed system, a ***consensus*** protocol must be executed - i.e. all nodes must agree on what to append next on the Ledger.\n\n- At the end of each round (in a sense, a \"time division\" inside a distributed system, even though \"time\" itself is a subtle notion in such an environment) of the consensus protocol, each node should see the same snapshot of the Distributed Ledger.\n- In each round, one proposer suggests some content to agree on, while all the others may either commit (if everything is correct) or abort (otherwise).\n- For new contents to be added to the distributed ledger, it is necessary that a sufficient majority of nodes choose to commit\n\t- The exact number depends on the protocol. Typically, for instance, it is $51\\%$ in PoW and $2/3$ in BFT protocols.\n\nTypically, Blockchains take advantage of ***randomized consensus***.\nWhile deterministic consensus protocols (e.g. Paxos, PBFT) generally favor consistency (i.e. all nodes see the same state instantly, but the system halts if too many nodes differ), Randomized ones (like PoW) prioritize liveness (i.e. the effective progression of the protocol) providing only probabilistic finality.\n","x":-12147,"y":-4279,"width":759,"height":985,"color":"5"},
		{"id":"40e8d3d5bf4aedc3","type":"file","file":"BlockchainConsensusTypes.png","x":-12147,"y":-5023,"width":759,"height":325},
		{"id":"16618beda3da0513","type":"file","file":"(De)Centralization.png","x":-11002,"y":-4280,"width":487,"height":340},
		{"id":"71ab0ea4434a54bc","type":"text","text":"### BCs are often politically decentralized and architecturally distributed.","x":-11138,"y":-4426,"width":759,"height":60,"color":"4"},
		{"id":"d100b02353e9602a","type":"text","text":"# (CONSENSUS) HASH RATE ATTACKS\n\n\n- Temporary block‐withholding attacks (𝜶 > 𝟐𝟓 − 𝟑𝟑%): : When a new block is mined, instead of follow the default behavior and immediately announce it to the network, you don’t announce it right away. Instead you try to get ahead by doing some more mining on top of this block (selfish mining) in hopes of finding two blocks in a row before the rest of network finds even one, keeping your blocks secret the whole time. IL RISCHIO È CHE QUALCUNO APPROVA PRIMA DI TE, DICIAMO CHE PUOI FARLO SOLO SE FINISCI INASPETTATAMENTE PRIMA, COSÌ SFRUTTI IL VANTAGGIO\n- Blacklisting and punitive forking (𝜶 > 𝟓𝟎%) : In punitive forking, miners agree to reject any chain that includes transactions from a blacklisted address. By refusing to mine on such chains, and if they control a majority of the hash power, they can effectively prevent those transactions from ever being confirmed. Other miners eventually stop including the blacklisted transactions, since their blocks would be repeatedly orphaned and yield no rewards.\n\t- Blacklisting and punitive forking : Instead of announcing that you're going to fork forever as soon as you see a transaction originating from address X , you announce that you’ll attempt to fork if you see a block that has a transaction from address X , but you will give up after a while. For example, you might announced that after k blocks confirm the transaction from address X, you'll go back to the longest chain.","x":-14165,"y":-5150,"width":759,"height":579},
		{"id":"da2c17bafb6ed3d4","type":"text","text":"# Axe-Infinity & 51%\n\naxe-infinity? permetteva ai giocatori di avere un account crypto sul gioco. tutti gli account convergevano all'account del gioco stesso, e c'era una rete  che faceva le conversioni (relay network, una dozzina di nodi). gli hanno fatto un 51% attack (rewriting history). ci stanno gli oracle che si assicurano che ciò che avviene fuori dalla chain sia registrato anche sulla chain nel giusto ordine.","x":-14165,"y":-6240,"width":759,"height":796},
		{"id":"c1c53488a2e8bc86","type":"file","file":"MerkleTree.png","x":-11002,"y":-3549,"width":487,"height":255},
		{"id":"20d719242a16b6d6","type":"file","file":"MerkleTree_Verification.png","x":-11054,"y":-1846,"width":591,"height":374},
		{"id":"0e4d8fe89b554b49","type":"text","text":"# Hashing\n\nQuando ci sono un sacco di dati che non vanno modificati, le ***funzioni di hash*** entrano in scena. In breve, sono ***algoritmi deterministici di compressione dati tali che l'output sembra casuale***, i.e. tali che ad input molto \"vicini\" corrispondano output arbitrariamente \"lontani\". Non esiste alcuna logica semplice che dato un valore di output desiderato ti faccia risalire al giusto input da dare.\n\nOvviamente, essendo algoritmi di compressione (e.g. si passa da `1024` a `256 bit`) esistono di sicuro delle collisioni. Per trovarne una, basta testare $2^{256}$ input. Facile, no? Il problema è che $$2^{256}=115792089237316195423570985008687907853269984665640564039457584007913129639936$$\nAnche avendo una potenza computazionale di $234 \\text{ TH/s}$ (i.e. $234\\times10^{12}$ hash al secondo, che ad oggi ottieni solo con un ASIC fatto apposta), ci metti circa $O(10^{12})$ anni.\n\nQuesto chiaramente apre a tutta una serie di applicazioni note in crittografia. Qui in particolare ce ne interessano due:\n\n- ***Hashpointers*** - Per garantirne l'integrità, ogni transazione è salvata come hash. I blocchi seguono di conseguenza. Gli ***hashpointers*** (i.e. un oggetto che restituisce l'hash del contenuto della memoria di un puntatore) consentono di trasformare la sequenza di blocchi approvati in una vera e propria catena, dal momento che l'hash del blocco `N+1` prende come input ***anche*** l'hash del blocco `N`: modificare il blocco `N` modifica non solo il suo stesso hash (in modo pseudo-casuale), ma anche quello del blocco `N + 1` (e di conseguenza di tutti i successivi). Questo meccanismo rende la BC sia ***tamper-evident*** che ***tamper-resistant***;\n- ***Merkle Trees*** - Invece di salvare solo l'hash finale del blocco, possiamo creare un albero binario di hashpointers le cui foglie sono gli hash delle transazioni. Questo consente di verificare che una transazione sia presente o meno in un blocco senza fornire informazioni sulle altre, ed effettuando un numero esponenzialmente minore di operazioni.\n\nBitcoin usa principalmente la funzione di hashing `SHA-256`. Di suo, questa funzione sarebbe una mappatura da `768 bit` a `256 bit`, ma esistono trucchi (i.e. la costruzione di Merkle‐Damgard) per accettare qualsiasi lunghezza di input.\n\n","x":-11138,"y":-3061,"width":759,"height":982,"color":"6"},
		{"id":"ad8208c1fc1416c4","type":"file","file":"PublicKey_to_BitcoinAddress.png","x":-10129,"y":-1846,"width":320,"height":374},
		{"id":"304a91e6af8a93cc","type":"file","file":"PublicKey_to_BitcoinAddress_Example.png","x":-9680,"y":-1763,"width":309,"height":208},
		{"id":"2c61b33f3ab14279","type":"file","file":"MerkleTree_Verification.png","x":-23876,"y":12669,"width":591,"height":374},
		{"id":"e16b00a2c72cfc6a","type":"file","file":"Valid_Blocks.png","x":-23876,"y":14489,"width":591,"height":354},
		{"id":"0066984aa8ee3f98","type":"text","text":"# MLM Bitcoin Dump\n\n\nA distributed consensus protocol must satisfy two key properties:\n• All honest nodes must reach agreement on the same value.\n• The agreed-upon value must originate from an honest node.\n\nA block should be produced every 10 minutes, however new miners can join the network\nwhile other can left.\nSo the target change over time, it is updated every 2016 blocks, in such a way that the time\nto find a new block needs on average 10 minutes.\n(2016 blocks * 10 minutes)/24 hours = 14 days (2 weeks)\n\n\n### hash\n\n1.Consider an hash function with 256-bit output size.\n2.Now pick 2256 + 1 input.\n3.Computes the hash of each of them.\n4.For sure you have found a collision.\n\n$2^{256}=115792089237316195423570985008687907853269984665640564039457584007913129639936$\n\nif a computer calculates 10,000 hashes per second (H/s), it would take more than 1027\nyears (octillion) to calculate 2128 hashes!\nA modern computer (ASIC) calculates 234 TH/s.\nSo it needs 46077254411749 years.\n\nHiding: A hash function H is hiding if: when a secret value r is chosen from a probability\ndistribution that has high min‐entropy , then given H(r ‖ x) it is infeasible to find x . In other words: If we’re given the output of the hash function H(r||x) = y , there’s no feasible way\nto figure out what the input, x , was.\n\nSha-256 is the hash function primary used in Bitcoin.\nAs underlying hash function sha-256 uses an hash function called compression function.\nInput size 768 bit\nOutput size 256 bit\n\nSHA‐256 uses the Merkle‐Damgard transform to turn a fixed‐length collision‐resistant\ncompression function into a hash function that accepts arbitrary‐length inputs. (TRADOTTO, È UNA COSTRUZIONE PER ACCETTRE QUALSIASI LUNGHEZZA DI INPUT)\n\n***I nodi del merkle tree sono hashpointers***, per questo è facile mandarne meno per verificare una TX\n\n#### Signature\n\nBitcoin uses a particular digital signature scheme that’s called the Elliptic Curve Digital Signature\nAlgorithm (ECDSA).\nElliptic curve used “secp256k1“\nIt produces:\nPrivate key: 256 bits\nPublic key, uncompressed: 512 bits\nPublic key, compressed: 257 bits\nMessage to be signed: 256 bits\nSignature: 512 bits\n\nHow can the public key be shortened?\nHash and the commitment properties is the solution.\nBitcoin uses a concatenation of SHA-256 (256 bit 32 byte) and RIPEMD-160 (160-bit 20Byte) to\ncreate address. In this way the final Bitcoin address is of 20 Byte. This operation is also called\nHASH-160. Then, to make the address more human friendly it is encoded with Base58Check\n\nBase58 alphabet ” 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz”\nit is a set of lowercase and capital letters and numbers without the four (0, O, l, I)\nTo add extra security against typos or transcription errors, base58check includes a checksum\nencoded in the base58 alphabet. The checksum is an additional 4 bytes added to the end of the data\nthat is being encoded.\nThe checksum, namely Hash-256, is computed by applying 2 times Sha-256 on the data and taking\nthe first 4 bytes.\n\n### POW Consensus\n\nBlock headers contain the target in a notations called “target bits”.\nTarget bits = 0x1903a30c\nThe first two hexadecimal digits for the exponent and the next six hex digits as the coefficient\nExponent = 0x19\nCoefficient = 0x03a30c\n\n= a valid block is one that has a block header hash less than the target. In\nbinary that number must have more than 60 leading bits set to zero\n\n```\nNew Target = Old Target * (Actual Time of Last 2015 Blocks/ 20,160 minutes)\n```\n\nThe timestamps set in block headers are set by the miners.\nThere is no global clock\n\n- If a miner sets their time in the future, they can lower difficulty, allowing them to mine more blocks and claim some of the block subsidy reserved for future miners.\n- If a miner set their times in the past for some blocks, they can use the current time for some other blocks, and so make it look like there's a long time between blocks for the purpose of manipulating difficulty.\n\nSo, Rules:\n\n- no node will accept any block with a time further in the future than two hours.\n- no node will accept a block with a time less than or equal to the median time of the last 11 blocks, i.e. median time past (MTP).\n\n\nThe data structure of transactions does not have a field for fees. Instead, fees are implied as the difference between the sum of inputs and the sum of outputs. Any excess amount that remains after all outputs have been deducted from all inputs is the fee that is collected by the miners.\n- Replace by fee (RBF): creating a conflicting version of the transaction that pays a higher fee. Two or more transactions are considered to be conflicting transactions if only one of them can be included in a valid blockchain, forcing a miner to choose only one of them.\n- Child Pays for Parent (CPFP) : Anyone who receives the output of an unconfirmed transaction can incentivize miners to confirm that transaction by spending that output. The transaction you want to get confirmed is called the parent transaction. A transaction that spends an output of the parent transaction is called a child transaction\n\nAn orphan block is a legitimate block with a nonexistent or unknown parent block. It is also known as an orphan, detached block, or extinct block. They were common in the early versions of bitcoins (no more possible since 2015). Nowadays it is also used for referring to stale block, because the client denotes their block rewards as “orphaned”. I.E. SUCCEDE CON LE FORK QUANDO APPLICHI LONGEST CHAIN\n\nFinality: Finality is metric that measure the amount of time one has to wait for a reasonable guarantee that crypto transactions executed on the blockchain will not be reversed or changed.\nBitcoin finality : 6 block confirmations X 10 minutes = 60 minutes\n\n","x":-24960,"y":11840,"width":904,"height":3003},
		{"id":"31aa3a29d696664a","type":"text","text":"# (CONSENSUS) HASH RATE ATTACKS\n\n\n- Temporary block‐withholding attacks (𝜶 > 𝟐𝟓 − 𝟑𝟑%): : When a new block is mined, instead of follow the default behavior and immediately announce it to the network, you don’t announce it right away. Instead you try to get ahead by doing some more mining on top of this block (selfish mining) in hopes of finding two blocks in a row before the rest of network finds even one, keeping your blocks secret the whole time. IL RISCHIO È CHE QUALCUNO APPROVA PRIMA DI TE, DICIAMO CHE PUOI FARLO SOLO SE FINISCI INASPETTATAMENTE PRIMA, COSÌ SFRUTTI IL VANTAGGIO\n- Blacklisting and punitive forking (𝜶 > 𝟓𝟎%) : In punitive forking, miners agree to reject any chain that includes transactions from a blacklisted address. By refusing to mine on such chains, and if they control a majority of the hash power, they can effectively prevent those transactions from ever being confirmed. Other miners eventually stop including the blacklisted transactions, since their blocks would be repeatedly orphaned and yield no rewards.\n\t- Blacklisting and punitive forking : Instead of announcing that you're going to fork forever as soon as you see a transaction originating from address X , you announce that you’ll attempt to fork if you see a block that has a transaction from address X , but you will give up after a while. For example, you might announced that after k blocks confirm the transaction from address X, you'll go back to the longest chain.","x":-24960,"y":14929,"width":904,"height":579},
		{"id":"f222fd26f496c2da","type":"file","file":"PublicKey_to_BitcoinAddress.png","x":-23876,"y":13222,"width":591,"height":692},
		{"id":"68389474995d597c","type":"file","file":"PublicKey_to_BitcoinAddress_Example.png","x":-23876,"y":13989,"width":591,"height":397},
		{"id":"02b6ff0927f1d7e6","type":"file","file":"MerkleTree.png","x":-23876,"y":11840,"width":591,"height":309},
		{"id":"1f5a326896274b8f","type":"file","file":"MerkleTree_2.png","x":-23876,"y":12209,"width":590,"height":355},
		{"id":"177ff5d536f7a0f8","type":"text","text":"# Firme, Chiavi Pubbliche e Indirizzi\n\nPer capire come Bitcoin deriva le chiavi e gli indirizzi dobbiamo fare una piccola digressione matematica. Prendiamo la ***curva ellittica*** `secp256k1`, definita come$$y^2=x^3+7 \\mod p$$\ndove $p$ è un numero primo a `256 bit`. I punti $(x,y)$ che soddisfano questa equazione formano un ***gruppo abeliano*** su cui sono definite cose come la somma di due punti, gli inversi, ... Dati i parametri della curva, possiamo ricavare un \"punto speciale\" $G$ , detto ***generatore***, tale che (e qui iniziamo ad andare a braccio) sommando iterativamente $G$ a se stesso si ottengono \"quasi tutti gli elementi del gruppo, senza troppe ripetizioni o pattern prevedibili\". A questo punto definisco:\n\n- Una chiave privata $d$, banalmente un numero casuale a `256 bit`;\n- Una chiave pubblica $Q$ ottenuta come $d\\cdot G$ (i.e. la somma di $G$ con se stesso eseguita $d$ volte).\n\nLa chiave pubblica è quindi un punto sulla curva ellittica, ed è difficile risalire alla privata: la domanda da farsi sarebbe \"quante volte hai sommato $G$ con se stesso per ottenere questa chiave $Q$?\", ma a meno di provare letteralmente tutte e $2^{256}$ le possibilità non esistono modi efficienti di accorciare il lavoro (che è infatti noto come ***Elliptic Curve Discrete Logarithm Problem***, ***ECDLP***).\n\nQuindi, siamo arrivati ad avere una chiave privata a `256 bit` e una pubblica a `512 bit`. Ma per le proprietà della funzione sopra, sappiamo già che fissato $x$ esistono solo due soluzioni per $y$, una pari e una dispari. Possiamo quindi comprimere la coppia `(256, 256) bit` in `(256, 1) bit`, dove il valore di `y` diventa banalmente una flag per distinguere pari o dispari.\n\n`257 bit` sono ancora troppi per renderli un address. E poi, meglio non esporla direttamente. Ad oggi non si conoscono attacchi efficienti per risalire alla privata, ma non si sa mai. Per ovviare a questa cosa, la pubblica passa attraverso un doppio hashing: `SHA-256` e `RIPEMD-160` (che insieme prendono il nome di ***HASH-160***). In pratica, la pubblica è nascosta dietro ad un suo hash. \n\nQuesti `160 bit` sono quelli che si includono nelle transazioni, ma non quelli che legge l'utente. L'ultimo step è un encoding, e viene fatto in ***Base58*** (i.e. numeri e lettere maiuscole/minuscole escludendo `0`, `o`, `O`, `l` e `I`, per evitare confusione). L'input non sono i `20 byte` di output di `HASH-160`, ma gli si aggiunge un checksum (perché non si è mai abbastanza cauti: questo protegge da errori di battitura o di copia e incolla, perché un indirizzo valido deve avere il checksum corretto).\n\nLa ***firma*** si ottiene come coppia `(r, s)` a partire dalla chiave privata, ma non entriamo in dettaglio sul come, perché è un delirio matematico di poco interesse qui ed ora.\n","x":-10129,"y":-3061,"width":759,"height":980,"color":"4"},
		{"id":"ca2750dfcadcc2cb","type":"text","text":"# How to Rug Pull\n\n- Creo il token e la LP associata, usando come coin comparativo una roba forte (e.g. $\\ETH$);\n- Aspetto l'allocco che compra. Questa fase in linea di principio è ***zero-effort***: di norma, è facile che arrivi qualcuno a comprare, un po' perché la gente c'ha la ***FOMO*** (\"e se questo coso diventa una roba che vale tantissimo?! Che fai, non compri?!\". Sì, davvero), un po' perché in ogni caso ci stanno gli ***sniper bot***;\n\t- Al più puoi fare ***advertising***, i.e. pubblicizzare questo nuovo incredibile token su Telegram, Discord o X (notoriamente dei bei posti). E la gente? Eh, la gente piazza scommesse sulle corse clandestine di cani, vuoi che non faccia un po' di sano ***gambling*** in criptovalute? Qualcuno magari pensa anche di riuscire a comprare subito ad un prezzo basso per poi rivendere quando l'hype generale avrà fatto salire il prezzo. Probabilmente non sanno che uno sniper bot fa esattamente questo, ma ad una velocità di svariati ordini di grandezza superiore.\n- Quando il valore è cresciuto e mi ritrovo con abbastanza $\\ETH$ nella Poll, disinvesto. Il guadagno sarà dato dagli investimenti dei vari allocchi meno le fees per fare tutte queste transazioni (che su Ethereum sono comunque un po' di soldi, motivo per cui non è proprio immediato fregare soldi al sistema);\n- In ogni caso, chi ha comprato ha buttato i soldi.\n\nEthereum ha circa $300\\text{k}$ token attivi, BSC essendo più economica ne ha molti di più.","x":-23545,"y":-1106,"width":780,"height":563,"color":"4"},
		{"id":"32adeffc3526776e","type":"text","text":"# Sniper Bots\n\nMa chi è abbastanza matto da comprare un token sconosciuto?\n\nPur vero che alla gente piace fare gambling, un bot può farlo in maniera molto più efficiente. Se l'obiettivo è comprare più velocemente possibile per poi rivendere a prezzo maggiorato, un bot può ad esempio analizzare la ***mempool*** e scoprire in anticipo quale token sta per essere creato sulla BC. In questo modo ha maggiori probabilità di essere il primo acquirente, per poi ovviamente rivendere dopo quello che arriva secondo.\n\nQuesti ***Sniper Bot*** sono tipicamente a pagamento, perché hanno un'ottima probabilità di portare guadagni. Maggiori di quello che costano? È da capire, ma intanto l'idea funziona. Ci sono anche quelli gratuiti, ma hanno un altissimo tasso di fallimento (magari vengono messi in circolo proprio da quelli che usano gli sniper bot potenti, in modo da avere dei concorrenti dichiaratamente deboli il cui unico scopo è perdere).\n\nOra, esistono casi di gente che ha implementato meccanismi in grado di fregare persino i bot. Ad esempio, un tizio una volta ha creato un token senza la primitiva di vendita. Cioè, la gente poteva letteralmente solo acquistare. Visto che nessuno poteva rivendergli i suoi Truffa Coin, questo ha banalmente aspettato e dopo un po' ha disinvestito, guadagnando diversi milioni.\n\nA seguito di questo, i bot hanno implementato una fase preventiva: intanto provo ad acquistare la minima quantità possibile di token. Poi, se riesco a rivendere, faccio un acquisto serio.","x":-23545,"y":-191,"width":780,"height":575,"color":"4"},
		{"id":"4f0a66cffc04f4b7","type":"text","text":"# Protocolli per Liquidity Pool\n\nEsistono diversi modi di implementare una LP, in particolare\n\n- Il primo, nato intorno al 2017 ad opera di ","x":-23531,"y":-3070,"width":780,"height":705},
		{"id":"bc8aed2be00fab71","type":"text","text":"Perfetto, qui c'è una storia affascinante che rivela come le idee buone spesso precedano l'implementazione di successo.\n\n**Il problema originale: gli exchange tradizionali**\n\nPrima di spiegare le liquidity pool, devi capire cosa c'era prima. Gli exchange tradizionali (come Binance, Coinbase, ma anche exchange decentralizzati primitivi come EtherDelta) usavano **order book** - libri degli ordini.\n\nFunziona così: tu vuoi vendere 10 ETH. Piazzi un ordine \"vendo 10 ETH a 2.000 dollari l'uno\". Questo ordine va nel libro e aspetta che qualcuno arrivi con un ordine di acquisto corrispondente. Se qualcuno vuole comprare 10 ETH a 2.000 dollari (o più), l'ordine viene eseguito. Altrimenti aspetti.\n\nIl problema? Per coppie di token poco popolari (tipo TokenX/TokenY dove TokenX è un progetto obscuro), non c'è abbastanza gente che piazza ordini. Il libro è \"thin\" - vuoto. Se provi a vendere, non trovi compratori. Se provi a comprare, non trovi venditori. Questo è il problema della **liquidità scarsa**.\n\nInoltre, mantenere un order book on-chain su Ethereum è costosissimo: ogni ordine piazzato, modificato, o cancellato è una transazione che costa gas. Per progetti piccoli, nessuno vuole pagare 5-10 dollari solo per piazzare un ordine che magari non verrà mai eseguito.\n\n**L'intuizione: e se non servisse un order book?**\n\nL'idea di automated market maker viene discussa per la prima volta in un blog post di Vitalik Buterin nel 2017. L'intuizione è: invece di matchare compratori e venditori, creiamo un **pool di token** e usiamo una formula matematica per determinare il prezzo.\n\nBancor lancia il 12 giugno 2017 con la più grande ICO dell'epoca, raccogliendo 153 milioni di dollari. Bancor è il primo a deployare automated market maker su Ethereum nel 2017, prima ancora che \"DeFi\" fosse un termine usato.\n\n**Come funziona una liquidity pool: l'esempio concreto**\n\nImmagina di voler creare un mercato per scambiare ETH con un token chiamato DAI (stablecoin). Invece di aspettare ordini, fai così:\n\n1. **Crei un pool** - uno smart contract - e ci depositi, diciamo, 100 ETH e 200.000 DAI. Questo stabilisce il rapporto iniziale: 1 ETH = 2.000 DAI.\n    \n2. **La formula magica: x * y = k** - Il prodotto delle quantità dei due token deve rimanere costante. Nel nostro caso: 100 ETH * 200.000 DAI = 20.000.000 = k (la costante).\n    \n3. **Qualcuno vuole comprare ETH** - Bob arriva e vuole comprare 10 ETH. Deposita DAI nel pool. Quanti DAI deve dare? La formula lo decide automaticamente:\n    \n    - Prima: 100 ETH, 200.000 DAI\n    - Bob prende 10 ETH, quindi ora ci sono 90 ETH nel pool\n    - Per mantenere k = 20.000.000, serve: 90 * y = 20.000.000, quindi y = 222.222 DAI\n    - Bob deve aggiungere 222.222 - 200.000 = 22.222 DAI (pagando quindi ~2.222 DAI per ETH, più del prezzo iniziale)\n4. **Il prezzo si aggiusta automaticamente** - Più ETH compri, più costoso diventa (perché svuoti il pool di ETH). Più ne vendi, più economico diventa. Non serve nessuno dall'altra parte - il pool è sempre lì.\n    \n\n**Perché le liquidity pool non esistevano prima degli smart contracts?**\n\nEsistevano in forma _centralizzata_. Gli exchange come Binance sono essenzialmente pool di liquidità giganti gestiti dall'exchange stesso. Ma erano centralizzati - dovevi fidarti dell'exchange.\n\nIl punto cruciale è che gli smart contracts permettono di creare pool **trustless** (senza fiducia). Il contratto è immutabile, il codice è pubblico, nessuno può rubare i fondi o manipolare i prezzi arbitrariamente. La formula x*y=k è garantita matematicamente.\n\nPrima di Ethereum e smart contracts sufficientemente potenti, non potevi avere questa garanzia in modo decentralizzato. Qualcuno doveva gestire il pool, e dovevi fidarti di loro.\n\n**Perché Bancor non ha avuto successo (all'inizio)?**\n\nBancor ha visto solo modesta adozione perché ogni token era accoppiato con il token nativo di Bancor (BNT). Quindi se volevi scambiare TokenA con TokenB, dovevi passare per BNT: TokenA → BNT → TokenB. Due swap, due fee, complicato.\n\nInoltre, nel luglio 2018, un attacker ha rubato 25.000 ETH, 2,5 milioni di BNT, e 230 milioni di token NPXS da Bancor. Peggio ancora, il team è stato in grado di recuperare, congelare o distruggere il BNT rubato - ma questo ha scatenato controversie perché significava che Bancor era troppo centralizzato. Se il team può \"congelare\" token, allora non è veramente decentralizzato.\n\n**Uniswap: la versione che funziona**\n\nHayden Adams lancia Uniswap nel novembre 2018, dopo essere stato ispirato da un blog post di Vitalik Buterin. Adams era un ex ingegnere meccanico alla Siemens che si era insegnato da solo blockchain senza esperienza precedente.\n\nLa genialità di Uniswap è la **semplicità**:\n\n- Ogni pool accoppia un token con ETH direttamente (ETH/DAI, ETH/UNI, ecc.). Vuoi scambiare DAI con UNI? Vai DAI → ETH → UNI, ma è trasparente.\n- Chiunque può creare un pool per qualsiasi coppia di token\n- Chiunque può diventare **liquidity provider** (LP) - depositi i tuoi token nel pool e guadagni una percentuale delle fee di trading (0.3% per swap)\n- Zero permessi, zero KYC, completamente on-chain\n\nI volumi DEX sono esplosi da 1 miliardo di dollari mensili nel maggio 2020 (quando Uniswap V2 lancia) a 186 miliardi nel dicembre 2021.\n\n**Perché non esistevano prima?**\n\nLe liquidity pool richiedono diverse cose che sono arrivate solo nel 2017-2018:\n\n1. **Smart contracts sufficientemente espressivi** - Ethereum nel 2015-2016 era ancora primitivo. Serve capacità di gestire pool complessi, calcoli matematici, e interazioni sicure.\n    \n2. **Gas fees gestibili** - Nel 2015, fare operazioni complesse costava troppo. Solo verso il 2017, con ottimizzazioni, diventa fattibile.\n    \n3. **Token standardizzati (ERC-20)** - Serve uno standard comune perché i pool possano gestire qualsiasi token. ERC-20 viene finalizzato nel 2015, ma l'ecosistema di token matura solo verso il 2017.\n    \n4. **Massa critica di utenti** - Serve gente che depositi liquidità nei pool. Nel 2015-2016, Ethereum aveva pochi utenti. Nel 2017-2018, con l'esplosione delle ICO, c'erano migliaia di token e milioni di utenti.\n    \n5. **Comprensione del concetto** - L'idea di AMM è controintuitiva. Il mercato doveva \"imparare\" che funzionava. Bancor è stato il pioniere, Uniswap ha perfezionato il modello.\n    \n\n**La timeline precisa**\n\n- **2017**: Bancor lancia la prima AMM on-chain. Innovazione massiva, ma design difettoso (BNT come intermediario, troppa centralizzazione).\n- **2018**: Uniswap lancia il 2 novembre 2018, semplificando il modello e rendendolo veramente decentralizzato.\n- **2019**: Uniswap cresce lentamente ma costantemente. Altri progetti (MakerDAO per stablecoin, Compound per lending) iniziano a usare Uniswap per liquidità.\n- **2020**: DeFi Summer. Il volume medio giornaliero di Uniswap raggiunge 220 milioni di dollari in ottobre 2020.\n\n**In sintesi**\n\nLe liquidity pool sono possibili tecnicamente solo dal 2015 con Ethereum, ma diventano pratiche solo nel 2017-2018 quando l'ecosistema matura. Bancor è il pioniere che dimostra il concetto, Uniswap è l'implementazione che raggiunge massa critica. E tutto questo prepara il terreno per BSC: quando Binance lancia BSC a settembre 2020, può semplicemente _copiare_ Uniswap (essendo EVM-compatible) creando PancakeSwap - un clone quasi identico ma con fee bassissime e velocità maggiore. L'infrastruttura software era già pronta, serviva solo una blockchain più scalabile.","x":-22539,"y":-3070,"width":1048,"height":705},
		{"id":"85fc8a05c99ff340","type":"text","text":"# NFT Wash Trading - Uno Studio\n\nL'idea alla base del Wash Trading è molto semplice. Metto in vendita un NFT a $10$, il mio complice lo acquista e lo rivende a $100$, poi a $1000$. Il primo genio esterno al mio circolo chiuso di complici che pensa \"hey ma questo è stato venduto a $1000$ e ora costa solo $100$, è un affare!\" diventa il pollo spennato di turno.\n\nDopo aver raccolto i dati (i.e. eventi di tipo `transferFrom`), per ogni NFT costruisco un grafo in cui i nodi rappresentano gli account e gli archi i trasferimenti, etichettati con `timestamp` e `valore` della transazione. L'idea è che ***strong connected components*** e ***loops*** siano dei buoni indicatori per la presenza di Wash Trading. Quindi cerco\n\n- ***Loop*** - Se trovo `A → B → A` è possibile che `A` e `B` siano la stessa persona, o complici;\n- ***Common Founder*** - Un terzo account (esterno) fornisce l’NFT ad `A` e `B`, i quali procedono a scambiarselo secondo le modalità descritte sopra;\n- ***Common Exit*** - Stessa cosa ma al contrario. Dopo il wash trading, i soldi finiti a `B` vengono inviati a un terzo account `C` (probabilmente il vero destinatario della truffa);\n- ***Self-loops*** - `A` può vendere un NFT a sé stesso (sì, si può fare, paghi solo le fee).\n\nSe in questi cicli compaiono piattaforme CEX o LP allora vengono ignorati. Si assume che i CEX non siano coinvolti nel WT (sono loro richieste politiche di trasparenza che li metterebbero rapidamente nei guai), e le Pool usano NFT per rappresentare posizioni di liquidità.\n\nQuesto però non esclude la presenza degli ***NFC Marketplaces***, perché prima o poi questi NFT vanno rivenduti a qualcuno. Chi più chi meno, ci finiscono tutti in mezzo (e.g. ***LooksRare*** presenta un $80\\%$ del volume di traffico legato al WT, mentre su OpenSea è $<0.5\\%$).\n\nLooksRare era infestato di wash trader perché aveva un forte ***Token Reward System***: Se il marketplace aveva un volume di trading totale di $1000\\,\\ETH$ e tu ne generavi $100$, ottenevi il $10\\%$ dei reward. Quindi, gli scammer si scambiavano NFT tra loro per accumulare reward, facendo milioni, finché il sistema di incentivi non è stato abbassato.\n\nIl modo migliore per gonfiare i volumi di trading era usare i ***flash loans***, i.e. prestiti che devi ripagare nello stesso blocco in cui vengono richiesti. Questo porta enormi vantaggi: le fees sono praticamente ***zero***, e se non ripaghi la transazione viene semplicemente annullata. \n\nQuindi? Prendevi diversi milioni in flash loan, ti scambiavi NFT tra amichetti per gonfiare il prezzo, incassavi i reward di LooksRare, e ripagavi il prestito senza perdere un centesimo.\nOvviamente questo aveva senso finché i reward erano alti, ora il gioco non vale la candela.","x":-25855,"y":-1930,"width":780,"height":944,"color":"4"},
		{"id":"340205e6a9b86c6e","type":"text","text":"# Altre Considerazioni\n\n- Il paper stima che il wash trading abbia generato **$3.4 miliardi di volume artificiale**, pari a circa il **10% del volume totale degli NFT su Ethereum**.\n- Viene fatta una distinzione chiara tra due strategie di wash trading:\n    - **Sfruttare il sistema di reward dei marketplace** (più efficace, 80% delle operazioni in profitto e un guadagno medio di **$1.055M per operazione su LooksRare**).\n    - **Gonfiare artificialmente il prezzo di un NFT e rivenderlo** (rischioso, con un successo del **50% e guadagni molto più incerti**).\n    - Il paper evidenzia che la maggior parte delle operazioni dura **meno di 10 giorni** (**26% durano solo un giorno**, **52% durano meno di 10 giorni**). Questo conferma che è una strategia a breve termine per massimizzare i guadagni velocemente.\n- Il **27% degli account coinvolti** nel wash trading è responsabile di **quasi il 73% delle attività**, indicando che si tratta di un gruppo ristretto di attori che eseguono queste operazioni ripetutamente.\n- Il wash trading sugli NFT avviene soprattutto con\n\t- **Round-trip trading (60%)** - Due account si scambiano lo stesso NFT più volte.\n\t- **Schemi circolari (20%)** - Tre o più account fanno girare l’NFT tra loro.\n\t- **Self-trading (7.6%)** - Un singolo account vende NFT a se stesso.\n- Un'operazione specifica su LooksRare ha visto due account scambiarsi lo stesso NFT **otto volte in meno di un’ora**, generando un volume di **5.733 ETH** e incassando **$1.1M in reward LOOKS** con un meccanismo di riduzione progressiva del prezzo.\n- Alcuni wash trader hanno sfruttato il sistema di \"evoluzione\" di alcune collezioni NFT (es. OG:Crystals), dove ogni vendita cambiava alcune proprietà visibili dell’NFT, rendendolo più raro e aumentando il valore percepito.\n- Foundation **non ha casi di wash trading** perché ha **fee troppo alte (15%)**, rendendo la pratica economicamente sconveniente.\n- LooksRare è il marketplace più coinvolto nel wash trading, con **oltre l’84% del volume generato artificialmente**, mentre OpenSea ha un impatto molto minore (0.49%).","x":-25855,"y":-837,"width":780,"height":784,"color":"5"},
		{"id":"40d21f642132b8a5","type":"text","text":"# Liquidity Pool (LP)\n\nIn un CEX è chiaro dove devo andare per la compravendita di asset. In un DEX la piattaforma centralizzata viene sostituita dai singoli utenti, che all'interno di una stessa BC possono mettere sul tavolo, ad esempio, $1000\\,\\ETH$ e $1000$ USDT (***Tether***) e proporsi come Exchange.\n\nUna ***Liquidity Pool*** (***LP***) è un particolare tipo di Smart Contract che permette di fare proprio questo. Un utente che aggiunge fondi (i.e. coppie di token in modo proporzionale rispetto al loro valore attuale) alla LP è detto ***Liquidity Provider***. Ciò include ovviamente il creatore, ma anche tutti gli investitori che contribuiscono. Tutti ricevono una piccola percentuale sugli scambi che avvengono all'interno della LP, proporzionalmente alla quantità di ***LP Tokens*** in loro possesso (i.e. fanno le veci delle quote azionarie per la LP). Tutto ciò è regolato da un modello matematico chiamato ***Automated Market Maker*** (***AMM***).\n\nQuando creo la LP con un rapporto $1:1$ (e.g. metto $1000\\,\\ETH$ e $1000$ USDT) e qualcuno compra $100$ USDT, nella LP restano $1100\\,\\ETH$ e $900$ USDT. Questo però significa che il rapporto non è più $1:1$: USDT è diventato più forte di $\\ETH$. Il prossimo utente che vuole comprare $100$ USDT dovrà pagarli $122\\,\\ETH$.\n\nOra, uno potrebbe chiedersi: ma se USDT è l'equivalente del dollaro, come fa ad acquisire valore così rapidamente? Ecco, se qualcuno vuole venderti $100$ USDT a $122\\,\\ETH$ è sicuramente una truffa. Perché? L'USDT autentico è un token ERC-20 associato ad una ed una sola LP originale (gestita da Tether Limited). Siccome però chiunque può creare una LP ed un ERC-20 con un nome qualsiasi (anche duplicato), è facile restare fregati. Poi magari questo fa un bel ***rug pull*** e gli finanziamo la vacanza ai Caraibi.\n\nOvviamente il modo di controllare se lo scambio è uno scam esiste: confrontare l'indirizzo ufficiale di USDT (e.g. su piattaforme come Etherscan) con quello della LP.","x":-24625,"y":-3070,"width":780,"height":705,"color":"4"},
		{"id":"bd58e931f55c72e9","type":"text","text":"# Rug Pull\n\nCreare una mia moneta alternativa in un DEX come Ethereum è relativamente semplice.\n\n- Creo uno Smart Contract che rispetta lo standard ERC-20 che chiamo ***Truffa Coin*** (***TC***);\n- Creo uno Smart Contract che definisce una ***Liquidity Pool*** per scambiarlo con gli $\\ETH$. Imposto quindi un valore iniziale, i.e. metto nella Pool $1000\\, \\ETH$ e $1000$ TC. Questo significa dire \"un mio coin vale esattamente quanto un $\\ETH$\".\n\t- Nota che se qualcun altro crea in modo indipendente un altro token chiamato TC, non potrà semplicemente venderlo alla LP in cambio di ETH. Gli scambi nella LP sono vincolati ai soli token originali.\n\nOra, se qualcuno compra $100$ TC al costo di $100\\,\\ETH$, nella LP restano $900$ TC e $1100\\,\\ETH$. Ma il rapporto è sempre $1:1$, quindi ora $1\\, TC={1100\\over900}\\,\\ETH\\sim 1.22\\,\\ETH$. Il fatto che qualcuno abbia dato ***fiducia*** al mio TC acquistandolo lo ha fatto salire di valore, come atteso. Il prossimo che vuole $100$ TC dovrà darmi $122\\,\\ETH$, e così via. L'idea, ovviamente, è che poi possano rivendermi quegli stessi TC ad un prezzo di mercato maggiore, guadagnando con la speculazione.\n\nPiù fiducia darà la gente al TC più $\\ETH$ mi ritroverò sulla mia LP, finché ad un certo punto... la chiudo e sparisco con tutti i soldi. Diciamo che avevo investito $1000$, la gente aveva comprato un po', quindi incasso $4000$, e al netto di $100\\,\\ETH$ di fees ho guadagnato un sacco di $\\ETH$ in barba a chi mi ha ritenuto affidabile. Questa simpatica azione prende il nome di ***Rug Pull*** (i.e. tu metti i soldi sul tappeto e io te lo sfilo da sotto al naso).","x":-24625,"y":-1930,"width":780,"height":590,"color":"4"},
		{"id":"8a6b328ab8c2b7cf","type":"text","text":"# Rug Pull - Uno Studio Comparativo\n\nIl paper analizza le manipolazioni di mercato di tipo Rug Pull confrontando due diverse BC:\n\n- ***Ethereum*** - Muove somme di denaro maggiori. Le gas fee tendono ad essere un po' più alte per via della decentralizzazione: avendo migliaia di ***nodi validatori***, la latenza di rete fa sì che venga aggiunto un nuovo blocco ogni $\\sim 13\\,s$, e il ***sync time*** (i.e. quanto bisogna aspettare perché tutti i nodi della rete concordino su una transazione) può arrivare fino ad una settimana. Creare un token ERC-20 costa quindi $O(100\\$)$, arrivando quasi a $O(1000\\$)$ in periodi di congestione, sfavorendo di fatto gli scam a basso prezzo;\n- ***Binance Smart Chain*** (***BSC***) - Ha un'architettura più snella, in cui vengono scelti solo $21$ nodi validatori alla volta, riducendo l'overhead computazionale complessivo. Ne deriva un minore tempo di blocco rispetto ad Ethereum ($\\sim3\\,s$), ma un maggiore sync time ($\\sim 3$ settimane). Da questo derivano costi di creazione molto minori, tipicamente $O(1\\$)$.\n\nPosto che puoi voler creare ERC-20 per svariati motivi, dai dati dello studio emerge che\n\n- Il $60\\%$ dei token ha una vita media inferiore alle $24$ ore. Chiamiamoli ***1-day tokens***;\n- Di questi, su Ethereum il $30\\%$ ha una ***LP associata***, mentre su BSC saliamo al $95\\%$. Questo è facilmente spiegabile in virtù di quanto detto prima: Ethereum costa di più;\n- L'$1\\%$ degli account crea il $20\\%$ dei token. Chiamiamoli ***Token Spammers***.\n\t- La maggior parte di questi sono 1-day tokens;\n\t- Quello più attivo su BSC ha creato $20\\text{k}$ token in un anno, il che significa che ha speso almeno $20\\text{k }\\$$. Perché abbia senso fare questa cosa, è logico pensare ad un guadagno effettivo maggiore, il che ci porta a dedurre che c'è un giro di soldi ancora maggiore.\n\nDa tutto questo si arriva a concludere che ***circa l'$80\\%$ delle LP contenenti 1-day tokens sono rug pulls***. Il success rate si aggira intorno al $62\\%$ su Ethereum e al $40\\%$ su BSC (forse per un meccanismo di tipo \"mi fido di più se ci sono investimenti di grosse somme, chissà), con un average gain di $2500\\$$ su Ethereum e $33\\$$ su BSC (le fees complessive sono in media $380\\$$ e $9\\$$). ","x":-24625,"y":-1204,"width":780,"height":759,"color":"4"},
		{"id":"313585cc249c3349","type":"text","text":"# Altre Considerazioni\n\n - Il paper stima che i rug pull abbiano generato circa **240 milioni di dollari di profitti** totali, con Ethereum che ha generato **150 milioni** e BSC **91 milioni**. Inoltre, il volume totale delle operazioni di rug pull è stato di **772 milioni di dollari su Ethereum** e **243 milioni su BSC**.\n - Il paper identifica tre fasi principali:\n\t - **DeFi Summer 2020** – Crescita iniziale dei rug pull su Ethereum.\n    - **Altcoin Season 2021** – Rug pull esplodono su entrambe le blockchain a causa dell’hype sulle altcoin.\n    - **Superamento di Ethereum da parte di BSC** – Da ottobre 2021, i rug pull su BSC diventano più numerosi e più redditizi di quelli su Ethereum.\n- Il paper distingue tra diversi tipi di sniper bot e quantifica il loro impatto:\n     - Su **BSC**, 130 indirizzi sospetti hanno scambiato in **235.777 liquidity pool**, rappresentando il **68,7% di tutti i rug pull**.\n    - Su **Ethereum**, gli sniper bot sono meno presenti, ma il **60% degli swap avviene nello stesso blocco in cui viene creata la LP**, segno che stanno leggendo la mempool.\n- Alcuni rug pull usano strategie di **wash trading** per gonfiare artificialmente il volume della LP e attirare investitori.\n- Il paper suggerisce alcune metriche per identificare i rug pull, come:\n    - Se il token dura meno di 24 ore, è sospetto.\n    - Se un singolo wallet controlla tutta la liquidità, è un rischio.\n    - Identificare chi ha già eseguito rug pull in passato.\n    - Molti truffatori usano nomi di aziende famose o meme coin per attirare investitori.","x":-24625,"y":-224,"width":780,"height":640,"color":"5"},
		{"id":"d006bd8a921bcf16","type":"text","text":"# **Perché mi compaiono token strani nel wallet?**\n\nSe hai mai aperto il tuo wallet e trovato un token che non hai mai comprato – tipo `SuperMegaApeCoin69420` – sappi che **non hai vinto nulla** e **nessuno ti sta regalando soldi**. Benvenuto nel mondo degli **airdrop scam**.\n\n---\n\n### **Come funziona la truffa?**\n\n1. **Gli scammer creano un token ERC-20**\n    \n    - Nome accattivante, magari simile a un token famoso (`SHIBA INU 2.0`, `NEW USDT`, `BONK v2`).\n    - Simbolo simile a uno vero (`USDTX`, `WBTCV`).\n    - Magari un supply assurdo (tipo 1 quadrilione di token).\n2. **Distribuiscono il token a migliaia di indirizzi**\n    \n    - I wallet su Ethereum sono pubblici, quindi possono mandare token a chiunque.\n    - Usano bot per distribuire il token a centinaia di migliaia di indirizzi casuali.\n    - Tu lo trovi nel wallet e pensi: _\"Wow, ho ricevuto un airdrop gratuito!\"_\n3. **Ti fanno cascare nella trappola**\n    \n    - Se provi a venderlo o trasferirlo, BAM! Scatta il vero scam.\n    - Alcuni di questi token sono progettati per **bloccare i tuoi fondi**: quando interagisci con il loro smart contract, dai il permesso di spendere tutto il tuo ETH.\n    - Altri ti mandano su un sito fake tipo `SuperMegaApeSwap.com` dove ti chiedono di connettere il wallet e autorizzare transazioni fasulle.\n\n---\n\n### **Come proteggersi?**\n\n✅ **Non interagire mai con token che non hai comprato.**  \n✅ **Non andare su siti a caso suggeriti da questi progetti.**  \n✅ **Non approvare transazioni se non sai esattamente cosa stai facendo.**  \n✅ **Se proprio vuoi liberartene, nascondili nel wallet o bruciali con un tool sicuro.**\n\nSe trovi un token sconosciuto nel wallet, **ignoralo e vai avanti con la tua vita**. Perché se qualcosa sembra troppo bello per essere vero… beh, sai già come finisce. 🚀","x":-24625,"y":-7204,"width":780,"height":946,"color":"#4545ff"},
		{"id":"4e3449fd770ccfb1","type":"text","text":"### **Le truffe più famose nel mondo cripto (oltre ai Rug Pull e agli Airdrop Scam)**\n\nNel mondo delle criptovalute, la fantasia degli scammer è infinita. Se pensavi che i rug pull e gli airdrop scam fossero le uniche fregature in circolazione, sappi che siamo solo all’inizio. Vediamo alcune delle truffe più note e geniali (nel senso malvagio del termine).\n\n---\n\n### **1️⃣ Exit Scam – La fuga col bottino**\n\n**Schema:** Crei un progetto, attiri investitori, raccogli fondi… e sparisci.\n\n✅ **Esempio famoso: PlusToken ($3 miliardi rubati)**\n\n- Prometteva rendimenti assurdi a chi depositava BTC ed ETH.\n- Milioni di persone hanno abboccato.\n- Gli sviluppatori hanno incassato e si sono volatilizzati, lasciando gli utenti con il nulla.\n\n📌 **Come evitarlo?**\n\n- Diffida da progetti che **promettono rendimenti fissi e sicuri** (in cripto, niente è sicuro).\n- Se non c'è un team pubblico e verificabile, scappa.\n\n---\n\n### **2️⃣ Ponzi e Schemi Piramidali**\n\n**Schema:** Ti promettono un guadagno “garantito” se porti dentro altre persone. I nuovi soldi pagano i vecchi investitori. Finché dura.\n\n✅ **Esempio famoso: Bitconnect ($2 miliardi bruciati)**\n\n- \"Investi in Bitconnect, guadagni il 40% al mese!\"\n- Milioni di utenti dentro, il valore del token sale alle stelle.\n- Il sistema crolla quando non entrano più nuovi soldi.\n- Il prezzo di BCC passa da 400$ a quasi **zero** in poche ore.\n\n📌 **Come evitarlo?**\n\n- Se il guadagno dipende più dal reclutare gente che dall’effettivo investimento, **è una piramide**.\n- Se sembra troppo bello per essere vero… lo è.\n\n---\n\n### **3️⃣ Honeypot – Il finto banchetto**\n\n**Schema:** Crei un token con un prezzo in crescita, la gente compra… ma non può vendere.\n\n✅ **Come funziona?**\n\n- Uno smart contract modificato per impedire agli utenti di vendere.\n- Gli unici che possono incassare sono gli sviluppatori.\n- La gente compra pensando di fare il colpo della vita, ma il bottone \"Sell\" è solo decorativo.\n\n📌 **Come evitarlo?**\n\n- Controlla se il contratto del token è verificato e open-source.\n- Usa tool come Token Sniffer per vedere se il token ha limitazioni nelle vendite.\n\n---\n\n### **4️⃣ Pump & Dump – Il gioco dello squalo**\n\n**Schema:** Un gruppo di persone si organizza per comprare un token, farne salire il prezzo e poi rivenderlo a chi arriva tardi.\n\n✅ **Esempio famoso: Dogecoin (sì, anche DOGE)**\n\n- Ogni volta che Elon Musk twitta su DOGE, il prezzo esplode.\n- Chi sa prima compra a basso prezzo.\n- I ritardatari comprano in FOMO.\n- I primi vendono in cima al pump e il prezzo crolla.\n\n📌 **Come evitarlo?**\n\n- Se un token sale del **500% in poche ore**, probabilmente qualcuno sta facendo il dump.\n- Non inseguire il prezzo, fai ricerche prima di comprare.\n\n---\n\n### **5️⃣ Flash Loan Attack – Il colpo al sistema**\n\n**Schema:** Prendi in prestito una cifra enorme senza collaterale, manipoli il prezzo di un token, incassi e ripaghi il prestito in un'unica transazione.\n\n✅ **Esempio famoso: Il caso dYdX e bZx ($55 milioni persi)**\n\n- Un hacker ha preso un prestito flash di milioni di dollari.\n- Ha manipolato il prezzo di un asset su un DEX.\n- Ha scambiato il token manipolato per cripto reali.\n- Ha ripagato il prestito e ha incassato la differenza.\n\n📌 **Come evitarlo?**\n\n- Se usi piattaforme DeFi, assicurati che abbiano misure anti-flash loan.\n- Segui i progetti con audit di sicurezza solido.\n\n---\n\n### **6️⃣ Wallet Drainer – Il furto in un click**\n\n**Schema:** Ti fanno firmare una transazione che, in realtà, gli dà accesso al tuo wallet.\n\n✅ **Come funziona?**\n\n- Ti mandano un link a un sito fake che sembra un wallet reale.\n- Ti chiedono di collegare il wallet e approvare una transazione.\n- Se lo fai, gli dai accesso ai tuoi fondi e… addio.\n\n📌 **Come evitarlo?**\n\n- Non cliccare su link sospetti o pubblicizzati a caso.\n- Usa wallet hardware per operazioni importanti.\n\n---\n\n### **Conclusione**\n\nIl mondo cripto è una giungla piena di opportunità, ma anche di trappole. La regola d’oro? **Se non capisci come funziona qualcosa, non investirci un centesimo.**","x":-22505,"y":-7204,"width":878,"height":2875,"color":"#4545ff"},
		{"id":"ef073ac9df95dbd1","type":"text","text":"# Ethereum Request for Comments - ERC\n\nGli Smart Contracts permettono di creare asset secondari scambiabili entro la blockchain stessa, detti ***Token***. Ora, questo significa che chiunque può creare qualsiasi cosa in qualunque formato, ed è proprio per mettere un freno a questa potenziale follia che a qualcuno è venuto in mente di ***standardizzare*** i formati di questi Token.\n\nGli ***standard ERC*** garantiscono che i token siano compatibili con i vari strumenti di DeFi (e.g. wallet, exchange). Ci sono grossomodo due tipologie di Token su Ethereum:\n\n- ***ERC-20*** (***Fungible Tokens***) - Sono token che si comportano come una moneta secondaria rispetto ad $\\ETH$. Sono intercambiabili e divisibili come le valute fiat, e si possono creare particolari token (detti ***stablecoins***) ancorati ad esse (e.g. ***Tether*** (***USDT***) con il ***dollaro***);\n- ***ERC-721*** (***Non-Fungible Tokens***) - Ognuno di questi token è unico e non divisibile. Li si può associare ad un'opera d'arte o ad un oggetto da collezione.\n\nEsistono poi standard come ***ERC-1155***, che unifica i concetti di FT ed NFT per situazioni in cui servono asset diversi (e.g. un gioco ha sia una valuta sia una collezione di oggetti, skin, ...).\n\nNota che, esattamente come gli RFC su internet, non è che questi devono per forza definire il protocollo del secolo. Anche piccole definizioni di funzioni possono costituire un ERC.\n\nAd esempio, ***ERC-165*** definisce delle funzioni di `interfaceID()` che permettono di verificare rapidamente il tipo di compatibilità del contratto senza doverlo analizzare per intero. Per verificare che uno SC sia compatibile con ERC-721, un altro SC può chiamare la sua funzione `supportsInterface(0x80ac58cd)`, ricevendo come risposta `True` in caso affermativo.","x":-24625,"y":-5016,"width":780,"height":687,"color":"4"},
		{"id":"c0bc01d1e65c717d","type":"text","text":"# Smart Contracts (SC)\n\nQuando si fa una transazione, il problema è sempre lo stesso: io vorrei ricevere il pagamento prima di cedere il bene e l'acquirente vorrebbe essere sicuro di ricevere il bene dopo aver pagato. Questo problema si traduce spesso nella presenza di un intermediario (e.g. un notaio) al quale entrambi i membri dell'accordo delegano la propria fiducia.\n\nGli ***Smart Contracts*** (***SC***) servono ad eliminare l'intermediario e ad automatizzare i contratti, e.g. `Se Andrea versa 100 ETH a Mario, la proprietà del token di Mario passa ad Andrea`. Questa roba è garantita dal fatto che gli SC sono ***codici*** eseguiti direttamente sulla blockchain. Sono ***pubblici***, ***immutabili*** ed ***auto-eseguenti*** al verificarsi delle condizioni.\n\nQuesto rende la blockchain una sorta di *trusted worldwide virtual computer*, in cui posso\n\n- Creare ***asset*** secondari rispetto al ***coin*** principale, detti comunemente ***Token***;\n- Creare dei ***marketplace*** (detti ***Liquidity Pool***) per scambiare gli asset direttamente all'interno della blockchain, senza dover passare per intermediari esterni come Binance.\n\t- Da questi ***Decentralized Exchanges*** (***DEX***) nasce la ***Decentralized Finance*** (***DeFi***).\n\nIl costo computazionale di un'operazione su ***Ethereum*** (e.g. trasferimento di $\\ETH$, creazione di Token) viene quantificato in unità chiamate ***gas***. Esiste quindi un ***prezzo del gas*** legato al valore di $\\ETH$ rispetto al dollaro. Il prodotto tra il prezzo del gas e la quantità di gas richiesta dall'operazione che si vuole effettuare risulta nella ***gas fee*** (i.e. la fee) da pagare alla BC.","x":-24625,"y":-3960,"width":780,"height":595,"color":"6"},
		{"id":"8689b6a4e7e83f20","type":"text","text":"# ERC-721 - NFT\n\nERC-721 introduce il concetto di ***unicità***. Gli NFT rappresentano arte digitale, oggetti interni ai videogiochi (e.g. armi, skin), biglietti, collezionabili e via dicendo. Proprio come con l'arte, il suo valore è dato da quanto è bramato dalla ggente. Le sue funzioni principali definiscono\n\n- La creazione dell'NFT, i.e. `mint(token)`;\n- La sua identità, i.e. `name()`, `symbol()` e `tokenURI(token)`. Quest'ultima in particolare contiene immagine, descrizione e metadati, solitamente salvati su un server esterno;\n\t- Questo rappresenta anche un importante ***point of failure*** per gli NFT: non vengono salvati davvero sulla blockchain. Qualsiasi problema al server esterno che custodisce l'asset e *puff*, hai perso tutto.\n- Il suo proprietario, i.e. `ownerOf(token)`;\n- Il suo trasferimento, con `transferFrom(from, to, token)`;\n- La sua distruzione, i.e. `burn(token)`.\n\nUn singolo ERC-721 può in realtà creare diverse copie dell'NFT, che nel complesso prendono il nome di ***collezione***. Un NFT è dunque completamente identificato da due elementi:\n\n- L'indirizzo dello SC che lo ha creato (ed il nome, e.g. ***Bored Ape***);\n- Il suo numero seriale all'interno della collezione (***Token ID***, e.g. $152$).\n\nLa stragrande maggioranza degli NFT non è legata ad alcun valore reale, è piuttosto uno ***strumento speculativo*** fortemente volatile ed utilizzato per manipolazioni di mercato quali ***Rug Pull*** e ***Wash Trading***.","x":-23545,"y":-5016,"width":780,"height":687,"color":"4"},
		{"id":"54b251eb5f580875","type":"text","text":"# Gas Fee\n\nSe in Bitcoin e BC simili il costo della fee è semplicemente proporzionale alla lunghezza in byte della transazione, ***Ethereum*** e BC simili usano un meccanismo per le ***fee*** che dipende dalla ***potenza computazionale*** che verrà utilizzata e dal livello di ***congestione*** della rete.\n\nLa fee è quindi divisa in due parti:\n\n- ***Gas limit*** - Quante unità di gas servono per eseguire la transazione. Dipende dalla complessità computazionale dello SC, solitamente si aggira tra i $20\\text{k}$ e i $300\\text{k}$;\n- ***Gas price*** - Il prezzo della singola unità di gas, tipicamente espresso in Gwei. Esiste un prezzo minimo, ma può essere scelto dall'utente per alzare la fee (i.e. acquisire priorità).\n\nLa ***gas fee*** è quindi data dal prodotto di queste due grandezze. È poi possibile aggiungere una ulteriore ed esplicita ***priority fee*** (anche detta ***tip***) per acquisire ancora più priorità.\n\nLa ***base fee*** (i.e. il gas price minimo sotto al quale l'utente non può scendere) è determinata in automatico dal protocollo in base alla congestione della rete.\n\nIn sostanza, l'idea è \"comprare\" la potenza computazionale dei nodi che eseguono lo SC.","x":-25855,"y":-5016,"width":780,"height":687,"color":"4"},
		{"id":"68b193c5004cfe21","type":"text","text":"# ERC-20 - Fungible Tokens (i.e. Coin Secondari)\n\nLo standard ERC-20 prevede nello SC delle funzioni per definire\n\n- L'identità del token, e.g. `name()`, `symbol()`;\n- La sua distribuzione, e.g. `totalSupply()` restituisce la quantità massima possibile di token sulla BC), `balanceOf()` restituisce il saldo di un certo indirizzo;\n- I suoi trasferimenti, e.g. `transfer()` che banalmente invia dei token ad un indirizzo, `transferFrom()` che specifica mittente e destinatario, previa approvazione data dalla funzione `approve()`;\n\nVersioni più elaborate che estendono le funzionalità di ERC-20 possono includere operazioni di ***minting*** (i.e. creazione di nuovi token) e ***burning*** (i.e. distruzione), o di `pause`/`unpause` (i.e. blocco o sblocco tutte le transazioni relative ai token, potenzialmente per evitare il propagarsi di errori o per motivi di sicurezza). Tutto questo non rientra strettamente in questo standard, ma è compatibile con esso.\n\nCi sono diversi motivi per cui potrei voler creare un ERC-20, ad esempio:\n\n- Implementare un sistema di pagamento interno ad un'***applicazione***;\n- Usarlo per gestire la ***governance***, un po' come avviene con le azioni in borsa: più coin di governance di un determinato tipo possiedo, più ho potere decisionale in quell'ambito;\n\t- Più in generale si parla di ***rappresentanza di asset***. Questo tipo di token può rappresentare il grado di possesso di un'immobile, di una società o anche di un NFT!\n- Implementare uno ***stablecoin***, i.e. un coin il cui valore è legato ad una ***moneta fiat***;\n- Per puro ***fine speculativo***, i.e. spero che la gente per qualche motivo riponga fiducia nel mio token facendolo crescere di valore...\n\t- ... per poi eventualmente disinvestire tutto e scappare con i soldi alle Maldive. Questo chiaramente sarebbe illegale in una finanza controllata, ma (guess what) la DeFi non è affatto regolamentata. Vedi ***Rug Pull***.","x":-24625,"y":-6075,"width":780,"height":836,"color":"4"},
		{"id":"dcba45b3aa4e8ffc","type":"text","text":"# Sottomultipli\n\nTutte le BC hanno un livello di granularità oltre il quale il coin non è ulteriormente divisibile (... in prima approssimazione, vbb).\n\nPer ***Bitcoin*** è il ***satoshi*** ($10^{-8}\\,\\BTC$), in Ethereum è il ***wei*** ($10^{-18}\\,\\ETH$), spesso usato come ***Gwei*** ($10^9\\text{wei}=10^{-9}\\,\\ETH$, il wei è troppo piccolo).","x":-25765,"y":-5439,"width":600,"height":200,"color":"4"},
		{"id":"e23ed681df359267","type":"text","text":"# Introduzione - Cash Digitale e Blockchain\n\nL'idea di realizzare un sistema di ***cash digitale*** affonda le sue radici verso la seconda metà degli anni 80. Se le prime implementazioni si riducevano a tentativi di implementare modi sicuri per eseguire le transazioni, è con DigiCash (1989) che compaiono i primi coin.\n\nLe moderne criptovalute si basano sulle ***blockchain***: ogni transazione viene inviata ad un server del sistema distribuito, il quale la inoltra agli altri. Dall'insieme delle transazioni in attesa (***mempool***) condiviso (idealmente) da tutti i server viene estratto mediante delle logiche variabili un sottoinsieme (che prende il nome di ***blocco***) da aggiungere alla blockchain. Un singolo server guadagna volta per volta il diritto di farsi portavoce di un blocco (e di ottenere di conseguenza un ***reward***) principalmente in due modi (ne esistono $N$, ovviamente):\n\n- Risolvendo un ***computational puzzle***, se la Blockchain stabilisce un meccanismo di consenso di tipo ***Proof-of-Work*** (***PoW***). In questo caso, i server vengono chiamati ***miner***;\n- \"Bloccando\" una certa quantità di criptovaluta, se si applica un meccanismo ***Proof-of-Stake*** (***PoS***). I server possono avere nomi (i.e. ruoli) variabili a seconda del protocollo.\n\nDeve essere semplice per gli altri server verificare che colui che propone il blocco sia legittimato a farlo (i.e. raggiungere il ***consenso*** su quel server). \n\nLa sequenza dei blocchi approvati costituisce il \"libro mastro\" (***ledger***) delle transazioni.\n\nEsistono ledger la cui implementazione non è una Blockchain (e.g. IOTA).","x":-28710,"y":-3960,"width":759,"height":595,"color":"6"},
		{"id":"b55611606993630d","type":"text","text":"\n\"Cos'è emptygocks? O qualcosa di simile, credo sia correlato alle blockchain\"\n\n\"Probabilmente ti riferisci a **Mt. Gox**, uno dei primi e più noti exchange di Bitcoin. Fondato nel 2010 e con sede a Tokyo, Mt. Gox gestiva oltre il 70% delle transazioni globali di Bitcoin al suo apice. Nel 2014, l'exchange ha dichiarato bancarotta dopo aver perso centinaia di migliaia di Bitcoin, presumibilmente a causa di un hack. Questo evento ha avuto un impatto significativo sulla fiducia nel mercato delle criptovalute.\"","x":-26635,"y":-3464,"width":780,"height":198,"color":"#b48383"},
		{"id":"bc974bfebe38a31d","type":"text","text":"# Creare Cash Digitale\n\nPochi accetterebbero come pagamento il carbone, ma molti accetterebbero i diamanti. Eppure hanno la stessa composizione chimica. Cosa cambia? I diamanti sono rari.\n\nIn generale, se si vuole creare una moneta digitale si deve tenere presente che il suo valore è legato alla sua quantità. Deve quindi esserci in qualche modo \"difficile\" creare nuovo cash.\n\nUna soluzione a questo problema viene direttamente da una tecnica anti-spam per email che risale al 1992 (Dwok, Naor), basata su un principio molto semplice: per inviare una mail devo risolvere un ***computational puzzle*** legato in modo univoco a quella specifica mail, altrimenti questa non partirà. Se risolvere il problema per una mail `A` non dà alcun aiuto per la risoluzione del problema per la mail `B`, allora diventa computazionalmente difficile inviare grandi quantità di mail tutte insieme.\n\nQuesto stesso principio si applica in generale alle Blockchain ***PoW***: il cash viene creato ogni volta che un miner aggiunge un blocco alla blockchain, i.e. solo quando questo è stato in grado di risolvere il computational puzzle. In particolare, la prima transazione di ogni blocco assegna nuovi coin all'indirizzo del miner che sta costruendo quel blocco. \n\n\"Ma così continuo ad erogare all'infinito!\". Ni. In genere esiste un meccanismo di riduzione del reward. In ***Bitcoin***, ad esempio, il reward iniziale era di $50\\,\\BTC$ per blocco, ma il sistema stabilisce che ogni $210\\cdot10^3$ blocchi aggiunti alla Blockchain (in che si traduce in un intervallo di tempo di qualche anno) questo valore si dimezza. Questo consente di dire che in una prima \"era\" sono stati prodotti $21\\cdot10^3\\times50=10.5$ milioni di bitcoin, poi $\\times 25$ e via dicendo. Questa è ovviamente una serie convergente: se le regole restano queste, il massimo numero di Bitcoin in circolo sarà $21$ milioni. Ad oggi il reward è di $3.125\\,\\BTC$. ","x":-29225,"y":-3070,"width":780,"height":711,"color":"4"},
		{"id":"420c6a87906609da","type":"text","text":"# Marketplaces\n\nCon le blockchain è possibile quindi implementare degli ***asset*** digitali. Come in finanza, anche qui il valore di un asset è proporzionale alla fiducia del mercato in esso. Ma come li scambio?\n\n- ***Centralized Exchange*** (***CEX***) - Funzionano come le tradizionali borse. Quando vuoi comprare o vendere parte un ordine (e.g. \"`Vendo 0.1 BTC a chi è disposto a pagarlo 1000$`\") e aspetti che qualcuno dall'altra parte lo accetti;\n\t- L'insieme degli ordini costituisce l'***order book***;\n\t- I wallet sono di proprietà del CEX (i.e. investire $1\\,\\BTC$ su ***Binance*** equivale a darlo alla piattaforma), il che costituisce un importante point of failure (i.e. se il CEX fallisce o viene hackerato perdi i soldi);\n\t- Spesso sono soggetti a regolamentazioni come ***Know Your Customer*** (***KYC***), i.e. sono costretto a fornire i miei dati reali alla piattaforma per investire;\n\t- Si portano dietro tutti i problemi dell'entità centralizzata (e.g. potere di ban di utenti);\n\t- Ne sono esempi ***Binance***, Coinbase e Kraken.\n- ***Decentralized Exchange*** (***DEX***) - All'interno di una BC che supporta gli SC, ogni utente in possesso di una coppia di token (e.g. $\\ETH$ e ***USDT***, affermatosi come l'equivalente digitale su Ethereum del ***dollaro***) può depositarli in una LP diventando un ***Liquidity Provider***.\n\t- Anonimo, in quanto non c'è alcuna politica KYC;\n\t- Il wallet è tuo, nessuno può bloccare i tuoi soldi o bloccare le transazioni;\n\t- Il rischio di ***scam*** è discretamente alto (e.g. ***Front Running*** - Un bot vede che voglio fare una transazione, compra prima di me e rivende subito dopo, alzandomi il prezzo);\n\t- Ne sono esempi ***Uniswap*** su Ethereum e PancakeSwap su Binance Smart Chain.\n\nNe esistono poi altre tipologie, come ***NFT Marketplace*** (e.g. ***Open Sea***, che opera su Ethereum, Polygon e Solana) e Hybrid Exchange (una sorta di mix tra CEX e DEX).\n","x":-26635,"y":-3070,"width":780,"height":705,"color":"4"},
		{"id":"af09c1c6572f2db1","type":"text","text":"# HowToCEX\n\nEsattamente come una ***borsa***. Ogni criptovaluta ivi quotata ha due elementi di interesse:\n\n- ***Candlesticks*** - Le candele rappresentano la differenza tra il prezzo di apertura e di chiusura. Sono rosse se il prezzo è sceso, verdi se è salito. Si possono poi aggiungere delle \"stanghette\" che rappresentano eventuali massimi o minimi nel corso del periodo intercorso tra apertura e chiusura (tipicamente un giorno, ma può variare);\n- ***Order Book*** - Raccoglie tutti gli ordini del tipo \"`Voglio comprare 1 BTC a 1000$`\". Se però non c'è nessuno disposto a vendere a quel prezzo (e.g. il più basso è `Voglio vendere 1 BTC a 2000$`), l'ordine resta in sospeso. ***Il punto di incontro tra domanda e offerta è il prezzo***. Quando due ordini si incontrano, viene effettuata la transazione.\n\t- Un ordine in cui stabilisco io il prezzo è detto ***limit order***. Se nessuno compra/vende a quella cifra, l'affare non si conclude e resta in sospeso a tempo indeterminato;\n\t- Un ordine in cui dico `Voglio comprare 1 BTC al miglior prezzo disponibile` è detto ***market order***, e prenderà il `Voglio vendere 1 BTC a XXXX$` con `XXXX` più basso possibile. Questo definirà di conseguenza il prezzo di mercato di $\\BTC$.\n- \"Semplificare\" due ordini di tipo `Vendo 1 BTC a 1000$` e `Compro 1 BTC a 1000$` significa che i prossimi ordini più vicini saranno ad esempio `Vendo 1 BTC a 1100$` e `Compro 1 BTC a 900$`. E quindi qual è il nuovo prezzo di mercato?\n\t- Finché nessuno fa nulla, vale l'ultima \"semplificazione\": il prezzo resta `1000$`. Si nota però che l'order book ha un \"buco\". E quindi? I limit order restano in sospeso, a meno che qualcuno non faccia un market order: `Compro 1 BTC al miglior prezzo` significa pagarlo `1100$`, il che porta il prezzo di mercato a `1100$`.","x":-27415,"y":-1930,"width":780,"height":637,"color":"4"},
		{"id":"37be4a9f1c9a0573","type":"text","text":"# Hashing e Computational Puzzles\n\nDopo aver effettuato un pagamento (che quindi è stato approvato dal sistema) e ricevuto un bene, un singolo miner prova a modificare la transazione in modo da recuperare i coin spesi. \n\nSi può fare? In teoria sì, ma viene reso estremamente difficile dall'***hashing*** dei blocchi. Ogni blocco ha un valore di hash che dipende dalle transazioni al suo interno, ma anche dall'hash del blocco precedente. Modificare un blocco significa non solo modificare il suo hash, ma rendere inconsistenti tutti gli hash di tutti i blocchi successivi. Un attaccante dovrebbe quindi modificare una sequenza di hash, che è notoriamente un problema difficile da risolvere ma di cui è facile da verificare la soluzione (tuttavia non è formalmente un problema $\\NPH$).\n\nIn virtù della difficoltà del problema, le Blockchain ***PoW*** sfruttano l'hashing per implementare il ***computational puzzle***: solo chi riesce a trovare il giusto hash per il blocco che vuole proporre può aggiungerlo alla Blockchain.\n\nUn'idea di come funziona è il meccanismo usato da ***Bitcoin***: per essere un blocco valido, l'hash in uscita deve avere i $k$ bit meno significativi uguali a $0$.\n\nOra, la funzione di hash (e.g. ***SHA-256*** per Bitcoin) prende in input le transazioni del blocco che voglio far approvare, l'hash del blocco precedente e (oltre ad altra roba che non stiamo a specificare in quanto non utile alla trattazione) un ***nonce***. In generale non ho idea di cosa esca fuori come hash di output, posso solo cambiare il nonce e guardare il risultato.\n\nLa probabilità di trovare proprio quello che voglio (i.e. i $k$ zeri finali) richiede un numero di lanci quantomeno esponenziale per diventare di ordine $1$, da cui la difficoltà probabilistica del problema (si capisce meglio perché non è classificabile come $\\NPH$). Una volta risolto il problema (i.e. trovato il nonce), è facile per gli altri miner verificare la soluzione (basta far girare SHA-256 con i parametri indicati dal miner risolutore).","x":-28195,"y":-3070,"width":780,"height":711,"color":"4"},
		{"id":"9a26a8530886011a","type":"text","text":"# HowToBlockchain - An Overview\n\nSe ho un file che rappresenta del cash digitale, potrei in linea di principio darlo a più utenti (i.e. ***double spending***). Per ovviare a questo problema, si costruisce un sistema distribuito di server che in ogni istante posseggono una copia aggiornata del libro mastro (***ledger***) di tutte le transazioni, tipicamente implementato tramite una ***blockchain***. Concordare in ogni istante sull'intero storico di tutte le transazioni significa risolvere un problema di ***randomized consensus*** in un ***asynchronous system***.\n\nOgni ***coin*** è in ogni istante di proprietà di una singola persona (i.e. un singolo ***wallet***). A certificare questa cosa c'era inizialmente una Central Authority (e.g. una banca), dopodiché si è passati al seguente sistema decentralizzato (detto ***UTXO***, ***Unspent Transaction Output***):\n\n- La creazione di un coin avviene come output di una ***transazione*** sulla blockchain. Questa è l'unica entità che salva le informazioni relative a \"chi possiede cosa\", dove il \"chi\" consta di un ***hash*** derivato dalla ***public key*** di un wallet, il cosa è un ***amount***;\n\t- Segue che il wallet di per sé non contiene nulla. Piuttosto, la sua ***private key*** serve a certificare che questo ha **potere di cedere i coin associati alla sua public key** sulla blockchain.\n- Quando viene ceduto, l'operazione prende in input il vecchio hash, la private key del vecchio proprietario e la public key del nuovo (oltre a cose tecniche tipo l'hash del blocco in cui rientra tale operazione, un nonce, ...) generando una transazione che certifica il nuovo proprietario;\n\t- L'amount in output in genere è minore dell'input: la differenza costituisce la ***fee*** per il ***miner*** che fa approvare il proprio blocco con il randomized consensus della blockchain (e.g. PoW, PoS, ...).\n- Quando un server riceve una richiesta di transazione, questa viene inserita nella ***mempool*** (i.e. il set di tutte le transazioni in attesa) e divulgata in ***broadcast*** (o più comunemente facendo ***gossiping***) a tutti gli altri server. I server inseriscono le transazioni della mempool in un ***blocco*** che cercano di far approvare tramite il randomized consensus all'intero sistema distribuito.\n\nQuesto sistema, adottato ad esempio in ***Bitcoin***, consente di tracciare l'intera storia di ogni singolo coin.\n\nEsistono sistemi alternativi, come ***Account-Based*** (e.g. ***Ethereum***). Qui i wallet hanno un saldo effettivo (che sostituisce il concetto di \"coin\" di per sé), ed è questo valore che viene aggiornato nelle transazioni. \n\nPiù in generale, ogni blockchain ha un funzionamento unico. La grande differenza in questo senso è data dalla presenza o meno degli ***Smart Contracts*** (i.e. la possibilità di eseguire codice direttamente sulla blockchain stessa), introdotti da Ethereum ed oggi largamente utilizzati.","x":-31365,"y":-3180,"width":860,"height":932,"color":"4"},
		{"id":"8ae9d77db5d92e7f","type":"text","text":"# From Distributed Systems","x":-31179,"y":-3732,"width":489,"height":140,"color":"6"},
		{"id":"0187f418b12b8a18","type":"text","text":"# Tracciabilità\n\nSe è vero che ogni $\\BTC$ è unico, cosa succede se ho $3\\BTC$ e ma voglio spenderne solo uno?\n\nIl punto è che i coin non sono veramente dei coin. Il sistema ***UTXO*** (***Unspent Transaction Output***) intende l'output di una transazione come \"somma non ancora spesa\", piuttosto che come \"moneta\" aggiunta al tuo wallet.\n\nQuesto significa che il saldo del tuo wallet altro non è che la somma degli output di una collezione di transazioni sparse in giro per la blockchain di Bitcoin che hanno in comune il fatto di poter essere cedute a qualcuno usando la private key associata al tuo wallet stesso.\n\nIn tutto questo, ogni output di ogni transazione è detto \"UTXO\", e se (tornando all'esempio di prima) vuoi spendere un $\\BTC$ avendo nel wallet $3\\BTC$ ci sono tre scenari principali:\n\n- Il tuo wallet consta di diversi UTXO, tra cui uno da $1\\BTC$. Ho risolto (sto ignorando le fee);\n- Nel tuo wallet c'è una miriade di UTXO di valore infimo. Il sistema ne \"aggrega\" fino a raggiungere la somma che serve e tramite la transazione li distrugge tutti, creando un nuovo UTXO da $1\\BTC$ utilizzabile dal destinatario;\n- Il tuo wallet consta di un solo UTXO da $3\\BTC$. Il sistema distrugge tale UTXO e ne crea due: uno da $1\\BTC$ per il destinatario ed uno da $1.99\\BTC$ per te (... ci stanno le fee). \n\nOra, manteniamoci nel caso facile in cui la gente si scambia sempre $1\\BTC$. È chiaro che in questo caso è immediato risalire la catena di transazioni che distruggono/creano i vari UTXO fino alla transazione che ha generato quel particolare $\\BTC$.\n\nUn po' meno ovvio è se nel frattempo sono avvenute diverse operazioni di aggregazione e divisione. Resta comunque possibile (anche se più difficile) risalire alla storia di ogni pezzo che compone quel particolare UTXO. Diciamo che un conto sono io che sono curioso di sapere la storia dei miei $\\BTC$ ed un altro conto è l'FBI che cerca di ricostruire i giri di soldi di Silkroad.\n\nIl punto è che per quanto possa essere oscurata da pratiche di ***coin mixing*** o frammentazione, la storia di un UTXO è comunque scritta nella blockchain. Esistono SW come ***Chainalysis*** o ***CipherTrace*** in grado di semplificare molto le cose per gli addetti ai lavori.","x":-29225,"y":-6134,"width":780,"height":895,"color":"4"},
		{"id":"f73c6a4e69389480","type":"text","text":"# What Cash Digitale?\n\nL'entità \"analogica\" più vicina ad una moneta digitale è un assegno: erogo un biglietto con la mia firma che indica che il possessore può restituirmelo per ottenere l'equivalente in dollari. Questo assume fondamentalmente due cose:\n\n- È difficile replicare la mia firma (i.e. è difficile falsificare l'assegno);\n\t- È invece molto facile copiare un file. Se a tale file è associato un \"assegno digitale\" (i.e. un coin) potrei duplicarlo e usarlo più volte. Questo problema prende il nome di ***double spending***, e la sua risoluzione ha stuzzicato la curiosità di diversi esponenti del mondo della crittografia;\n- Chi accetta l'assegno si fida del fatto che a fronte di esso qualcuno mi pagherà.\n\t- Questo è equivalente a dire che qualcuno deve garantire che la transazione avvenga. Di norma questo compito spetta alle banche, che fungono da entità garante centrale. L'obiettivo di un DS, tuttavia, è quello di evitare centralizzazioni. Deve quindi essere il DS stesso a fare da garante, obiettivo raggiungibile tramite il ***consenso*** da parte di tutti i server (***miner***) sull'approvazione delle transazioni presenti nei singoli ***blocchi*** della ***blockchain***, i.e. il \"libro mastro\" (***ledger***) di tutte le transazioni.","x":-29225,"y":-4917,"width":780,"height":489,"color":"4"},
		{"id":"b0e15795235728f2","type":"text","text":"# Simultaneità e Fork\n\nNonostante sia probabilisticamente raro, cosa succede se due miners risolvono insieme?\n\nEscludiamo il caso in cui uno dei due è più veloce a comunicarlo e a farlo approvare, e diciamo che il server `A` convince alcuni miner ad allungare la blockchain con il proprio blocco e che `B` convince i restanti con il suo. D'altronde \"randomized consensus\" significa proprio questo: \"`è talmente improbabile che qualcuno risolva che quando succede mi convinco che sia un caso isolato e accetto, assumendo implicitamente che tutti quanti accetteranno questo mio stesso blocco`\". Questa situazione rompe esattamente questa assunzione.\n\nQuesto porta in pratica alla creazione di una ***fork*** (i.e. ci sono due diversi ***branch***). Diciamo che tutti concordano inizialmente su `XYZ`. Sia `A` che `B` usano come hash del blocco precedente quello di `Z`. Se però ho approvato `XYZA`, il mio \"blocco precedente\" diventa `A`. Quando mi arriva `B` vedo subito l'incongruenza, e mi pongo il problema: gli altri stanno lavorando su una Blockchain diversa dalla mia? Chiedo allora agli altri gli hash dei loro ultimi blocchi, arrivando a ricostruire la presenza dei branch divergenti: `XYZA` ed `XYZB`. Come si ***riconcilia***?\n\nL'idea è che una delle due catene si estenderà prima dell'altra, i.e. uno dei due gruppi di miner troverà il blocco successivo prima degli altri (se i branch hanno la stessa lunghezza, continuo nel dubbio a lavorare sul primo che ho approvato: fino a prova contraria, quella è la \"vera\" Blockchain). Se quelli che lavorano su `XYZA` trovano per primi `XYZAC`, con un processo simile a quello descritto in precedenza tutti quanti saranno in grado di ricostruire i branch divergenti, ma stavolta una delle due catene (sia essa la principale o l'\"alternativa\") risulterà più lunga. A questo punto, chi aveva quella più corta farà marcia indietro e si adeguerà all'altro gruppo, ripristinando la consistenza globale. Ciò si chiama ***regola della catena più lunga***.\n\nPotrebbe ovviamente succedere di nuovo che due miner nei due blocchi risolvano insieme e che quindi generino nello stesso sottogruppo due chain `XXXAD` e `XXXBC`, ma l'idea è che a livello probabilistico prima o poi uno dei due si renda conto dell'errore.\n\nLa *rule of thumb* è che prima di approvare in via definitiva le transazioni si aspetta di impilare altri 6 blocchi. Questo riduce quasi del tutto (ma non annulla!) la possibilità di sbagliare (e.g. come caso isolato, nel 2013 a causa di un errore SW c'è stata una fork di 24 blocchi).\n\nConsiderando che si aggiunge circa un blocco ogni circa $10$ minuti, prima di essere certi di un pagamento in Bitcoin bisogna aspettare all'incirca un'ora.","x":-28195,"y":-6134,"width":780,"height":895,"color":"4"},
		{"id":"2825d21211592300","type":"text","text":"# Byzantine Nodes ed Attacco del 51%\n\nIn un sistema del genere, è ovviamente un problema se ci stanno dei ***byzantine nodes***.\n\nTuttavia, Bitcoin ha una discreta tolleranza. Ad esempio, non è possibile per un miner inserire transazioni false ed indirizzare a se stessi i coin altrui. Questo perché per realizzare una transazione serve sempre la chiave privata del vecchio proprietario del coin. Non è neanche possibile fare double spending, dato che ogni coin è unico. Né è possibile modificare una transazione approvata, perché romperebbe tutti gli incastri successivi degli hash.\n\n... o meglio, se sono un singolo miner o un piccolo gruppo di miner che collabora posso fare poco. Se però raggruppo una discreta potenza computazionale (***hashrate***) posso iniziare a vincere spesso. A seconda di quanto ne ho possono succedere diversi scenari simpatici.\n\n- Se ne ho tanto (e.g. sono un governo o una banca) posso provare a ***DDOSsare*** il sistema.\n\t- ***Come?*** - Inserendo blocchi vuoti nella BC per aumentare il carico computazionale, *DDOSsando* direttamente i miner.\n\t- ***Perché?*** - Una banca potrebbe avere interesse a destabilizzare le criptovalute.\n\t- ***È un problema?*** - $\\BTC$ è abbastanza resistente, e non sembra sia mai successo.\n- Se ne ho ***più della metà*** posso fare un pagamento, ricevere quello che mi viene dato e poi ritirare il pagamento invalidando la vecchia chain con una fork (***Attacco del*** $51\\%$).\n\t- ***Come?*** - Avere più della metà dell'hashrate significa essere in grado di costruire un branch alternativo più velocemente rispetto al restante $49\\%$ del sistema. Posso così prima o poi (potenzialmente mi servono tanti blocchi) sovrascrivere il branch del resto del sistema (in cui ho speso $100\\BTC$) con il mio (in cui non l'ho fatto).\n\t- ***Perché?*** - Posso fare double spending: mando agli altri una transazione in cui spendo $100\\BTC$ nel blocco `A` che forma la catena `XXXA` per poi sovrascrivere con `XXXBC`. Particolarmente problematico se supero la catena dopo oltre $6$ blocchi (i.e. dopo che il sistema ha già \"ratificato\" la transazione): posso di nuovo spendere i coin che qualcuno aveva già accettato come pagamento (inviandomi magari la cocaina).\n\t- ***È un problema?*** - Difficile ottenere il $51\\%$ dell'hashrate in Bitcoin. Forse è più fattibile con blockchain più piccole.","x":-27105,"y":-6134,"width":780,"height":895,"color":"4"},
		{"id":"b6a85d26a6d762d8","type":"text","text":"# Mai fidarsi dei Nodi (Merkle Trees)\n\nLa blockchain è un oggetto pesante (ad oggi $\\sim 1\\text{ Tb}$ di dati). I ***nodi completi*** la tengono tutta in memoria, ma un utente tiene il proprio wallet su smartphone si chiaramente non può. Allora si limita a salvarne una versione compatta, costruita nel seguente modo.\n\nUn blocco è una sequenza di transazioni, ad ognuna delle quali è associato un ***hash***. Prendo allora coppie contigue di hash e ne faccio un unico hash (i.e. ogni hash rappresenta due transazioni). Continuo così fino a costruire un ***albero binario completo*** che prende il nome di ***merkle tree***. La sua radice rappresenta quindi tutte transazioni del blocco, e viene salvata nell'header di quest'ultimo. Un ***light client*** (nodo leggero) conserva solo l'header del blocco.\n\nUn light client potrebbe avere interesse a verificare se un suo pagamento è stato o meno accettato dalla rete, i.e. se si trova in uno dei blocchi. Questo si traduce nel problema \"data una transazione, controlla che questa sia all'interno di un certo blocco\".\n\nOra, ci vorrebbe poco a chiedere ad un nodo completo \"scusa, questa transazione è davvero nella blockchain?\". Non è così facile. Perché? Il punto è che ***il light client in genere non si fida al 100% del nodo completo***, quindi preferisce verificare da sé. Come? Con una ***Merkle Proof***!\n\nInvece di rispondere semplicemente \"sì\", il nodo completo deve dimostrarmelo. Quindi mi manda tutte le informazioni per permettermi di ricostruire la ***Merkle Root*** (... la radice del Merkle Tree salvata nell'header del blocco). Questo però viene fatto in modo intelligente: invece di mandarmi tutte le $O(N)$ transazioni del blocco, mi manda solo gli $O(\\log N)$ hash dei fratelli con i quali devo via via accoppiare il mio hash per arrivare alla radice.\n\nIn pratica, il Merkle Tree è utile ogni volta che voglio ***verificare che un pezzetto di informazione sia parte di una \"big picture\"***, senza però scaricare interi Terabyte di file!","x":-27105,"y":-5016,"width":780,"height":687,"color":"4"},
		{"id":"7e38a9731b069017","type":"text","text":"# Bitcoin (2008)\n\nIl sistema Bitcoin consta di $O(10^3)$ miner sparsi per il mondo, e il gossiping avviene tra $O(10)$ primi vicini. Dal momento che non sono previsti Smart Contracts, esiste un unico coin: $\\BTC$.\n\nNasce con un primo blocco hard-coded contenente una sola transazione che ha fornito $50\\,\\BTC$ al suo fondatore, dopodiché diversi server si sono proposti come miner ed è iniziato il gioco. Il numero di transazioni per blocco è aumentato con il tempo, e al prima transazione di ogni blocco costituisce il reward per il miner che risolve il problema computazionale, motivo per cui la storia di ogni $\\BTC$ è tracciabile fino alla sua origine.\n\nQuando si esegue una transazione, è consigliato (ma non obbligatorio) pagare una ***fee*** al miner che fa approvare il blocco. Questo perché di fatto è un guadagno per il miner, il quale tenderà a dare priorità di approvazione alle transazioni in mempool con le fee più alte.\n\nIl computational puzzle è \"l'hash in uscita deve avere i $k$ bit meno significativi uguali a $0$\".  la funzione di hash (e.g. ***SHA-256*** per Bitcoin) prende in input le transazioni del blocco che voglio far approvare, l'hash del blocco precedente e (oltre ad altra roba che non stiamo a specificare in quanto non utile alla trattazione) un ***nonce***. In generale non ho idea di cosa esca fuori come hash di output, posso solo cambiare il nonce e guardare il risultato.\n\nLa probabilità di trovare proprio quello che voglio (i.e. i $k$ zeri finali) richiede un numero di lanci quantomeno esponenziale per diventare di ordine $1$, da cui la difficoltà probabilistica del problema (si capisce meglio perché non è classificabile come $\\NPH$). Una volta risolto il problema (i.e. trovato il nonce), è facile per gli altri miner verificare la soluzione (basta far girare SHA-256 con i parametri indicati dal miner risolutore).","x":-28195,"y":-5004,"width":780,"height":663,"color":"6"},
		{"id":"66e789f3b5a0ec37","type":"text","text":"# Privacy\n\nBitcoin è un sistema trasparente, i.e. le public key coinvolte nelle transazioni sono sempre in bella mostra sulla blockchain. Tuttavia, l'associazione tra le public key e l'identità della persona fisica dietro quel wallet non è ovvia.\n\nQuindi Bitcoin è anonimo? ... non proprio. Quando uso un ***Exchange*** per convertire i Bitcoin in ***moneta fiat*** (i.e. dollaro, euro, ...) la piattaforma tipicamente richiede una verifica dell'identità nota come ***Know Your Customer*** (***KYC***) nel rispetto delle normative anti-riciclaggio. Questo significa che nel momento in cui converto viene fatta l'associazione tra il nome e il wallet.\n\nQuesto può innescare un processo in cui via via che la gente converte si crea un puzzle in cui diventa sempre più chiaro a chi si estende il giro di soldi, e diventa più facile riempire i vuoti.\n\nIn pratica, Bitcoin non è molto anonimo (piuttosto è ***pseudonimo***, nel senso che finché il gioco regge io sono mascherato dalla mia public key). Ovviamente ci sono tecniche per aumentare il livello di sicurezza di tutto questo.\n\n- Creo tanti wallet per diversificare le attività che svolgo;\n- Al costo di una fee faccio fare le montagne russe ai miei $\\BTC$, dividendoli in milioni di parti e creando flussi di decine di milioni di transazioni (***coin mixing***). In mezzo a questa enorme quantità di flussi è difficile risalire a chi ha fatto cosa. In pratica, è ***Money Laundering***.\n\nQuesto meccanismo di pseudo-anonimato non proprio chiarissimo ha portato nel corso del tempo diverse persone ad essere scoperta con le mani nella marmellata (cfr. ***Silkroad***). \n\nIn generale, se non vuoi farti scoprire mentre traffichi cocaina ci sono blockchain create con in mente la privacy come focus principale (e.g. ***Monero***, ***Zcash***).","x":-30255,"y":-6134,"width":780,"height":895,"color":"4"},
		{"id":"704b2682f6ccaf20","type":"text","text":"# Listone delle Blockchain\n\n- Algorand - fa transactions ogni pochi secondi, fee prederterminate e basse\n- Arbitrum - Gas fee\n- Avalanche - Gas fee\n- ***Bitcoin*** - Fee proporzionali alla dimensione in byte della transazione, posso scegliere fee più alte per ottenere priorità entro la mempool\n\t- Litecoin, Dogecoin\n- ***Binance Smart Chain*** (***BSC***) - Vedi report BCDLT\n- Cardano - \n- C-Chain - Gas fee\n- Cosmos - \n- ***Ethereum*** - Inizialmente nata PoW (2015) tramite un investimento iniziale di circa 18 milioni di dollari, introduce il concetto di ***Smart Contract***. Per risolvere problemi legati ad efficienza energetica ed eccessivo volume di transazioni crea nel 2020 una Blockchain PoS parallela (Beacon Chain). A seguito dell'evidente successo di quest'ultima, nel 2022 le due chain vengono unificate in un evento cosmico che prende il nome di \"***The Merge***\". Abbandonare il mining riduce i consumi energetici del sistema del 99.5%;\n- Hedera Hashgraph - In realtà non è una Blockchain. È basata invece su una struttura dati a **grafo aciclico diretto (DAG)**, ed usa un algoritmo di consenso simile al PoS;\n- Monero - \n- Optimism\n- Polkadot - \n- Solana - \n- Tezos - \n- Tron - ","x":-31365,"y":-5082,"width":860,"height":819},
		{"id":"d1bdc75d4a561ac5","type":"text","text":"# Difendersi dai Pump and Dump\n\nSe creo una blockchain e il mio coin viene preso di mira da un Pump and Dump, non sono proprio felicissimo, perché mina la mia credibilità. Da cui la domanda: come mi difendo?\n\nEcco... diciamo che non ti difendi. Per quanto sia una pratica immorale (non diciamo illegale perché banalmente non è regolamentata), il problema è che ***i CEX ci guadagnano***, perché implica la presenza di grossi volumi scambiati su di essi. Possono anche pubblicizzare delle policies moralmente impeccabili, ma all'atto pratico non faranno niente per evitarlo.\n\nSe crei un token su DEX, è anzitutto la struttura stessa delle LP a proteggerti da questo tipo di cose: non essendoci un order book, acquistare significa istantaneamente far esplodere il prezzo, quindi dovresti trovare gente convinta a comprare a prezzi già alti. Inoltre, gli SC ti permettono di avere un po' più di gioco sulle funzioni di compravendita, tipo\n\n- Aumenti le fee sulle transazioni di account che comprano e vendono in pochi secondi;\n- Metti limiti di volume di acquisto per indirizzo;\n- Metti un cooldown al di sotto del quale non puoi rivendere.\n\nTutto questo però è un disincentivo per i trader \"legittimi\". Troppe regole.","x":-28585,"y":-1204,"width":780,"height":647,"color":"4"},
		{"id":"cf185f8837214b5e","type":"text","text":"# Pump and Dump\n\nUna volta compreso come funziona un CEX, diventa chiaro il meccanismo di ***pump and dump***.\n\n- Compro qualcosa che non vale niente, e.g. una criptovaluta sconosciuta;\n- Convinco gli altri a comprare, facendo crescere il valore (***pump***). Questa è una fase fortemente attiva, e include pubblicità su canali Telegram dedicati;\n\t- Gli admin del canale solitamente preannunciano un \"grande affare\" imminente, ma non dicono subito quale. L'idea è che la crescita sia un'impennata di pochi secondi, al più pochi minuti. Questo ha due motivazioni psicologiche principali:\n\t\t- Sfruttare al massimo la ***FOMO*** degli investitori, che avendo pochissimo tempo a disposizione agiranno prima ancora di pensare;\n\t\t- Minimizzare i comportamenti ***FUD*** (Fear, Uncertainty and Doubt), ripensamenti e commenti scettici (che in ogni caso vengono moderati in modo feroce).\n\t- Poi, visto che non c'è limite alla speculazione: vuoi ricevere il nome della criptovaluta `1` secondo prima? Compra per la modica somma di `10$` una `Membership Premium`! Come dici? `3` secondi prima? A `50$` abbiamo il `Piano VIP`!\n\t\t- Ovviamente tutte queste cose sono scam, ci perderai comunque i soldi al $99\\%$.\n\t- Va anche molto di moda diffondere notizie false come `Truffa Coin comprato dal governo italiano!!` o messaggi motivazionali come `Oggi facciamo la storia.`;\n\t- Manco a dirlo, tutto questo è chiaro conflitto di interesse (cfr. The Wolf of Wall Street), ma ovviamente non c'è alcuna regolamentazione a riguardo.\n- A un certo punto vendo e ci guadagno un botto. Il prezzo inizia a scendere (***dump***), meno vertiginosamente rispetto alla salita. Gli altri si ritrovano il cerino in mano.","x":-27415,"y":-1204,"width":780,"height":647,"color":"4"},
		{"id":"962f6c4b3c0be25d","type":"text","text":"# Pump and Dump Detection - [Uno studio](https://github.com/SystemsLab-Sapienza/pump-and-dump-dataset)\n\nÈ facile individuare un pump quando è già esploso: basta guardare un grafico con una candela verde enorme ed un crollo altrettanto rapido subito dopo. L'obiettivo del paper è quindi un altro: possiamo accorgerci di un pump mentre sta accadendo?\n\nL'idea è sviluppare un modello di Machine Learning che monitora il mercato ed è in grado di dire entro pochi secondi se c'è o meno una pump in azione. Per fare ciò, il parametro principale è il numero di ordini, ed in particolare la presenza di ***rush orders***, i.e. una raffica di ordini di acquisto in pochi secondi. Questi dati sono forniti direttamente dalle API del CEX.\n\nQuali? Un CEX come Binance quota tipicamente coin abbastanza stabili, ed è più controllato. Sono invece ideali CEX minori come ***Cryptopia*** e ***YoBit*** (il quale arrivò perfino a pubblicare un pump su Twitter, nel 2018).\n\nSono stati quindi forniti gli stessi dati in pasto a diversi modelli:\n\n- ***Thresholds statiche*** - Pessimi risultati, ma c'era da aspettarselo, non è neanche ML;\n- ***Random Forest*** - Il migliore, presenta un F1-Score del $94.5\\%$ ed è in grado di rilevare un pump entro i primi $25$ secondi dal suo inizio;\n- ***AdaBoost*** - Meno efficace, restituisce molti falsi positivi (che tendono in ogni caso ad aumentare nei periodi di maggiore attività sul mercato).\n\n","x":-27415,"y":-462,"width":780,"height":558,"color":"4"},
		{"id":"45a986eb7349c98a","type":"text","text":"ethereum\nlayer 20\noracle tool\ndecentralized finance\n\n\nrepresentative money è quando hai 10 oro e stampi cartamoneta per 10 oro, fiat money è quando fai un po' il cazzo che ti pare e stampi roba sulla base della fiducia che ti danno e altre magnificenze.\n","x":-31840,"y":267,"width":289,"height":549},
		{"id":"f25620bcdd9ec501","type":"text","text":"# Altre Considerazioni\n\n- **Distinzione tra Pump and Dump classico e Crowd Pump**\n    \n    - Il **Crowd Pump** (es. GameStop o Dogecoin su Reddit) non mira a truffare, ma nasce dalla massa che si coordina spontaneamente per alzare un prezzo.\n    - Nel **Crowd Pump** manca una leadership chiara, il pump è più graduale e spesso viene spinto da motivazioni ideologiche o meme virali.\n- **Tecniche di manipolazione avanzata**\n    \n    - Uso di immagini obfuscate per evitare che i bot leggano il nome della cripto in anticipo.\n    - Sistemi di affiliazione per incentivare la crescita dei canali Telegram.\n- **Dinamica temporale degli eventi**\n    \n    - I pump si organizzano spesso nel pomeriggio europeo, segno che i manipolatori potrebbero risiedere in questa area geografica.\n- **Caso studio di YoBit**\n    \n    - YoBit ha pubblicamente annunciato un pump su Twitter, scatenando reazioni negative nella community.\n- **Analisi sentimentale e crowd behavior**\n    \n    - Hanno analizzato Reddit per capire come Dogecoin è esploso grazie a un semplice post: _\"Let’s make Dogecoin a thing. That’s it, that’s the post\"_.","x":-27415,"y":216,"width":780,"height":600,"color":"5"},
		{"id":"5e2bc06553931b5b","type":"text","text":"# SPACING","x":-11127,"y":-6238,"width":250,"height":235,"color":"5"},
		{"id":"3ad40ef17e537893","type":"text","text":"# Merkle Patricia Tries\n\nNo, non è un errore di battitura: un ***trie*** (che con molta fantasia viene da \"re**trie**val\") è un albero usato per rendere più efficienti i dizionari: se ho più chiavi che iniziano con la stessa lettera, non ha senso ripeterla ogni volta: avranno una radice comune. E così via.\n\nDall'esempio di trie a destra ci rendiamo conto che il ramo `B`$\\to$`O`$\\to$`O`$\\to$`K` è alquanto sprecato. Basterebbe comprimere l'informazione. Fortuna che ci ha pensato una signora chiamata Patricia, grazie alla quale abbiamo i ***Patricia Tries*** (... no, la signora non esiste, purtroppo la realtà è noiosa e quello è un acronimo per \"Practical Algorithm To Retrieve Information Coded In Alphanumeric\").\n\nPerché stiamo dicendo tutto questo? Bitcoin era statico, e faceva fede alle transazioni piuttosto che allo stato dinamico del sistema. Gli bastava usare il Merkle Tree per ottimizzare la ricerca sui blocchi, e via. Ethereum è dinamico, deve salvare i saldi e poterli modificare. Il Patricia Tree è quasi perfetto, l'unico problema è che così i dati sono in chiaro. La soluzione? Ovviamente hasharli! Alla fine della fiera, ci ritroviamo in mano con un ***Merkle*** (hash) ***Patricia*** (compressione) ***Trie*** (ricerca).\n\nBene, e che ci facciamo? Ethereum ne definisce 4:\n\n- ***State Trie*** - Contiene lo stato globale di tutti gli account. Gli `address` sono le chiavi di ricerca, mentre i valori sono `balance`, `StorageRoot`, ...;\n- ***Storage Trie*** - Ogni account ne ha uno: il valore `StorageRoot` citato nello State Trie punta qui. Di default è vuoto, a meno che l'account non sia gestito da uno SC, nel qual caso dentro ci sono i metadati del codice (e.g. variabili di stato);\n- ***Transaction Trie*** - Questo è statico, fa le veci del classico Merkle Trie di Bitcoin;\n- ***Receipts Trie*** - Anche questo specifico del blocco, contiene i log delle esecuzioni degli SC.\n\nA livello implementativo, viene realizzato sfruttando 4 tipi di nodi:\n\n- ***NULL Node*** - Segna la terminazione di un branch;\n- ***Branch Node*** - Serve a smistare. In altri termini, \"implementa le frecce\" (posso averne massimo 16, quanti sono i caratteri esadecimali);\n- ***Extension Node*** - Lui implementa la componente \"Patricia\", comprimendo i dati comuni;\n\t- Non è mai una terminazione: deve sempre puntare a un Branch o a un Leaf.\n- ***Leaf Node*** - Intuitivamente, contiene il valore.\n\nOgni nodo viene identificato da prefissi speciali (***flag***).","x":-5084,"y":-3059,"width":759,"height":980,"color":"4"},
		{"id":"dd78a3138a20b865","type":"file","file":"Accounts.png","x":-6740,"y":-1880,"width":400,"height":144},
		{"id":"582e278871552f6e","type":"text","text":"# Chain Code - Smart Contracts II\n\nThe smart contract ABI tells us how to interact with this bunch of nonsense hex on the chain\nbecause, remember, the human-readable code is not stored on chain; the hex does!\nThe ABI (Application Binary Interface) in Ethereum is a standardized format that defines how\nto interact with smart contracts. It describes the contract’s functions, inputs, outputs, and data\ntypes in a machine-readable way.\nIt is useful because:\n•It allows applications (like wallets, DApps, and scripts) to correctly encode function calls\nand decode responses.\n•Without the ABI, you could see the contract on-chain, but you wouldn’t know how to call its\nfunctions or interpret the returned data.\n\n","x":-5084,"y":-4277,"width":759,"height":984},
		{"id":"8f4367b6265dd303","type":"text","text":"\nnon può succedere che due blocchi abbiano lo stesso hash, e non deve succedere (... perché??)\n\n\"the more the nodes, the safer the network\" ovviamente\n\nSi hasha solo l'header del blocco (perché ci sta il merkle tree?)","x":-14165,"y":-1846,"width":759,"height":500},
		{"id":"1eb5d065b22c8566","type":"text","text":"# BTC PoW (Report)\n\nThe most famous randomized consensus protocol is probably Bitcoin's \\textbf{Proof of Work (PoW)} \\cite{nakamoto_bitcoin}.\nIn order to better explain it, we must specify a detail: transactions are proposed in groups (called blocks), and each of them is associated with a hash value.\nThis happens for multiple reasons, the most important ones being integrity (no one should change the contents at will) and order of the blocks (each hash is computed having previous block's one as an input, creating a tamper-evident chain).\nBeing the hash functions' output pseudo-random\\footnote{Hash functions, like \\code{SHA-256}, are in fact deterministic. Practical cryptography usually assumes them to be a good approximation for implementing one-way functions (i.e. it is computationally infeasible to reconstruct the input from the output).}, it is indeed very difficult to modify the content of a message and get precisely some desired hash as a result.\nIn Bitcoin, the proposer must solve the following problem: \"find a nonce such that the hash output of the new block has the \\code{k} most significant bits equal to \\code{0}\"\\footnote{i.e. the hash is numerically lower than a specific \\code{Target Value}. This Target is automatically adjusted by the protocol (which includes a Difficulty Adjustment Algorithm - DAA) at regular intervals (e.g. every 2016 blocks in Bitcoin) to ensure that the average time required to find a block remains constant as the network's computing power fluctuates.}.\nStatistically, it is very likely to have only one proposer per round, making Consensus work with high probability.","x":-13156,"y":-3061,"width":759,"height":255},
		{"id":"1099ca7c37f012c1","type":"text","text":"# Lezioni Di Ciccio - 00 Introduction\n\n\nweb3, t-apps? middleware\n\n\nTokens - li puoi pensare come bollini di fidelizzazione (\"se compri da noi ti diamo dei token che puoi utilizzare comprando ***di nuovo da noi***\").\n\nSegue distinzione public/private e permission(less). Slide 43 per lo schemino.\n\n\"law of the highest left force\", \"goals LMD?\". \n\n hashing nasce per riempire un array/lista/spazio nel modo più uniforme possibile e con meno collisioni possibili (e.g. buckets, ...), poi si riscopre utile come fingerprint dei dati. E il cryptographic hash?\n\nhyperparameters authorization?\nPoW tecnicamente non è il meccanismo di consenso in sé, dà solo l'autorizzazione ad essere proposer.\n\n","x":-14451,"y":-13224,"width":640,"height":640},
		{"id":"258deaa8c6cd5b2c","type":"text","text":"# Custodire le Private Keys\n\nVisto che il tuo account di fatto ***è*** la tua chiave privata, faresti meglio a non fartela rubare. Al contempo, devi anche poterla usare: chiuderla in un caveau svizzero duecento metri sotto terra è molto sicuro, ma molto poco pratico. Serve un compromesso tra queste due cose.\n\n- ***Cold storage*** - Se prediligi la sicurezza, conservi le chiavi completamente offline. All'interno di questa macro-categoria rientrano diversi livelli di paranoia e di scomodità, tipo\n\t- ***Paper/Steel*** - Te lo scrivi su carta, o sul metallo se pensi che la carta si rovina. O meglio, in genere ti scrivi il ***seed*** per generare le chiavi (tipo un tot di parole random);\n\t- ***Tamper Proof*** - Sono tipo chiavette anti-manomissione fisica;\n\t- ***Air-Gapped*** - Simpatici dispositivi che oltre a custodire le chiavi possono generarle, e ai quali puoi direttamente passare le cose da firmare e te le restituiscono firmate senza che le chiavi escano mai da questo ambiente blindato;\n\t- ***Brain*** - Qualche pazzo prova anche a memorizzarle.\n- ***Hot Storage*** - Custodisci le chiavi in posti connessi ad internet. Qui facciamo una distinzione tra\n\t- ***Custodial*** - Il SW del tuo Wallet fa gestire le tue chiavi ad un Exchange di fiducia. Di fatto è come essere clienti di una banca, con tutte le controindicazioni della centralizzazione, i.e. attacchi, frodi o banalmente bank run (i.e. un sacco di gente va a ritirare tutta insieme, ma l'Exchange non ha davvero tutti i tuoi soldi: li investe. Se tutti insieme chiedono indietro i soldi, non ce li ha). Per ovviare a questa cosa, gli Exchange forniscono alcune \"garanzie\":\n\t\t- ***Proof of Reserve*** - \"Caro Exchange, hai davvero i soldi che dici di avere?\", a cui in genere si risponde firmando transazioni valide. Tradotto, l'Exchange dimostra (crittograficamente) di possedere certi asset. Il trucco qui è che magari dimostri di possedere `100`, ma ai clienti devi `10000` (oppure prendi in prestito temporaneo solo per dimostrare di avere `10000`, ma non li hai per davvero). Il singolo cliente non lo sa (perché magari il suo credito è `5`) e tutti vissero illusi e contenti;\n\t\t- ***Proof of Liabilities*** - \"Caro Exchange, quanto devi ai clienti?\", si risponde pubblicando il debito totale e costruendo un ***Merkle Tree*** le cui foglie sono hash delle coppie `(user saldo)` di tutti i clienti. La radice è l'hash complessivo. E che ci faccio? La uso per fare Proof of Inclusion!\n\t\t- ***Proof of Inclusion*** - \"Caro Exchange, ma io sono incluso in questo Merkle Tree?\", basta dare al cliente il saldo e la Merkle Proof della sua foglia. In questo modo chiunque può controllare di far correttamente parte di questo conto.\n\t- ***Non-Custodial*** - Ti gestisci da solo le tue chiavi (e.g. MetaMask o anche Electrum). Nota che per costruzione un Non-Custodial può essere gestito come Cold Storage!\n\nLe chiavi possono essere generate in N modi (deterministici e non). Posso anche generarle con un ***Secret Sharing***, nel caso di diversi utenti che collaborano per firmare (***Multi-Signature Wallet***).","x":-8111,"y":-3059,"width":759,"height":980,"color":"4"},
		{"id":"5e23ef52130cf167","type":"text","text":"# SPACING","x":-6060,"y":-2640,"width":250,"height":235,"color":"5"},
		{"id":"62496e888409827e","type":"text","text":"# Task 3 - Exploring the Blockchain\n\nMe lo sono perso ed è scaduto il tempo limite.\n\nEdit: è obbligatorio. Basta prendere l'indirizzo `tb1qzjce5zw7j3ugd0hvcfkm4j4y5ly7sqcjjzql2u` e cercare le transactions con\n\n- Maggiori `tBTC` ricevuti;\n- Maggiore `fee` per vbyte.","x":-9120,"y":5688,"width":759,"height":813,"color":"1"},
		{"id":"428ab633c035249f","type":"text","text":"task 2\n\n\nattento a scrivere il numero di blocco e non il (come l'ha chiamato? tipo timestamp?) che serve a tracciare la transazione.\n se vai tipo su blockstream.info/testnet/ (credo) e premi su un blocco trovi le singole transazioni che di norma sono da un address verso due (uno è il vero destinatario, l'altro è il \"resto\". come sappiamo qual è il resto? non lo sappiamo (??????)). La fee si calcola come cifra del sender meno somma delle cifre dei destinatari. quel sito da un botto di info, tipo expected value della current fee da pagare per vedere la tua TX accettata.\n***deadline: 2 weeks.*** (november 10)","x":-8978,"y":6736,"width":513,"height":437},
		{"id":"85df093a330bf129","type":"text","text":"# `MyStudentToken.sol`\n\n```c\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20; // Da questa versione in poi il codice fa revert automatico su over/underflow\n\ncontract SimpleERC20 {\n\t// === METADATI ===\n\tstring public name;\n\tstring public symbol;\n\tuint8 public decimals = 18;\n\tuint256 public totalSupply; // Fa da check sulla validità logica del token (i.e. se sbaglio ad aggiornarlo diventa \"falso\")\n\n\t// === STATO === (Tabelle hash che servono a definire stato economico e stato di delega\n\tmapping(address => uint256) private balances;\n\tmapping(address => mapping(address => uint256)) private allowances;\n\taddress public owner;\n  \n\t// === EVENTI STANDARD ERC-20 === (log delle transazioni)\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n\t// === EVENTI EXTRA ===\n\tevent Mint(address indexed to, uint256 value);\n\tevent Burn(address indexed from, uint256 value);\n\n\t// === MODIFIER ===\n\tmodifier onlyOwner() {\n\trequire(msg.sender == owner, \"Not owner\");\n\t_;}\n\n\t// === COSTRUTTORE === (invocato solo al deploy)\n\tconstructor(\n\tstring memory _name,\n\tstring memory _symbol,\n\tuint256 initialSupply)\n\t{\n\tname = _name;\n\tsymbol = _symbol;\n\towner = msg.sender; // \"chi deploya è il proprietario\"\n\t_mint(owner, initialSupply);} \n\t\n\t// === FUNZIONI ERC-20 ===\n\t// Legge il saldo dall'esterno\n\tfunction balanceOf(address account) external view returns (uint256) {\n\treturn balances[account];}\n\n\t// Versione pubblica di _transfer (privata)\n\tfunction transfer(address to, uint256 value) external returns (bool) {\n\t_transfer(msg.sender, to, value);\n\treturn true;}\n\n\t// Espone la disponibilità di token\n\tfunction allowance(address _owner, address spender) external view returns (uint256) {return allowances[_owner][spender];}\n\n\t// Anche se è presente una disponibilità di token, l'owner può imporre un limite di transfer più basso per spender\n\tfunction approve(address spender, uint256 value) external returns (bool) {\n\tallowances[msg.sender][spender] = value;\n\temit Approval(msg.sender, spender, value);\n\treturn true;}\n\n\t// Controlla che allowance sia sufficiente, quindi esegue il transfer\n\n\tfunction transferFrom( address from, address to, uint256 value) external returns (bool) {\n\t\tuint256 allowed = allowances[from][msg.sender];\n\t\trequire(allowed >= value, \"Allowance exceeded\");\n\t\tallowances[from][msg.sender] = allowed - value;\n\t\t_transfer(from, to, value);\n\treturn true;}\n\n\n\t// === FUNZIONI EXTRA ===\n\n\t// Consente mint solo all'owner\n\tfunction mint(address to, uint256 value) external onlyOwner {\n\t\t_mint(to, value);}\n\t// Chiunque può distruggere i propri token\n\tfunction burn(uint256 value) external {\n\t\trequire(balances[msg.sender] >= value, \"Not enough balance\");\n\t\tbalances[msg.sender] -= value;\n\t\ttotalSupply -= value;\n\t\n\t\temit Burn(msg.sender, value);\n\t\temit Transfer(msg.sender, address(0), value);}\n\n// === INTERNAL ===\n\n// La funzione che implementa davvero la logica di transfer\n\tfunction _transfer(address from, address to, uint256 value) internal {\n\t\trequire(to != address(0), \"Zero address\");\n\t\trequire(balances[from] >= value, \"Insufficient balance\");\n\t\t\n\t\tbalances[from] -= value;\n\t\tbalances[to] += value;\n\t\n\t\temit Transfer(from, to, value);}\n\n\t// La funzione che implementa davvero la logica di minting\n\tfunction _mint(address to, uint256 value) internal {\n\t\trequire(to != address(0), \"Zero address\");\n\t\t\n\t\tbalances[to] += value;\n\t\ttotalSupply += value;\n\t\t\n\t\temit Mint(to, value);\n\t\temit Transfer(address(0), to, value);}\n}\n```","x":-8111,"y":4640,"width":759,"height":813,"color":"4"},
		{"id":"43287bf6239e8a06","type":"text","text":"# Task 4 - Create your ERC-20 Token\n\nScarico MetaMask come estensione del browser, creo un account, mi crea wallet sulle principali BC, compresa Sepolia, che è la testnet di Ethereum. Visito un faucet (tipo [questo](https://cloud.google.com/application/web3/faucet/ethereum/sepolia)) per iniziare con qualche `ETH` (l'address di Sepolia è lo stesso del wallet su Ethereum).\n\nA questo punto tocca scrivere lo Smart Contract. Usiamo Foundry. Non serve essere autenticati per scrivere codice Solidity: finché qualche wallet non lo inserisce nella BC con una transazione, resta solo codice a caso. `forge init AndreaToken` ti crea la cartella con tutto ciò che serve.\n\nSe volessimo fare tutto da soli, vedi codice sopra. Per affidarsi a librerie come `OpenZeppelin` per implementare le funzioni di base `ERC-20`, vedi codice sotto. Percorriamo quest'ultima via: dentro la cartella `AndreaToken` eseguo `forge install OpenZeppelin/openzeppelin-contracts`.\n\nA questo punto in `src` cancello il `.sol` di esempio e creo `AndreaToken.sol` con il codice sotto. Poi `forge build` per compilarlo e per creare l'ABI (i.e. il manuale di istruzioni che dice a roba tipo MetaMask quali funzioni espone il contratto). A questo punto creiamo davvero il token con\n\n```bash\nforge create src/<NomeTuoToken.sol>:<NomeTuoToken> --rpc-url https://ethereum-sepolia-rpc.publicnode.com --private-key <LA_TUA_CHIAVE_PRIVATA> --constructor-args 2000000000000000000000000 --broadcast\n```\n\n- Sto creando $2\\cdot10^{6+18}$ token perché per la BC il \"token\" è la sua unità indivisibile. `18` sono i decimali massimi, e `6` è dato dal fatto che devo trasferirne almeno `1808606`;\n- Per testare la buona riuscita della `create` in locale, basta omettere `--broadcast`.\n\nVisto che la gente non si fida degli SC, vorrebbe qualcuno che certifichi che il `bytecode` che si trova sulla BC sia non-malevolo, o comunque identico al codice sorgente. Per soddisfare ciò facciamo un account su [Etherscan](https://etherscan.io), creiamo una `API KEY` e la diamo in pasto al comando `forge verify` per farci certificare. Sì, esistono alternative ad Etherscan, ma non le cito.\n\nInfine importi i token su MetaMask e li mandi a `0x99377fcf21e5d028bfede46721b6203b7a440f9c`.","x":-8111,"y":5688,"width":759,"height":813,"color":"4"},
		{"id":"46fd9ae947b2e8bc","type":"text","text":"# `AndreaToken.sol` (Codice semplificato)\n\n```c\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\n\ncontract AndreaToken is ERC20 {\n\t\n\tfunction decimals() public view virtual override returns (uint8) {\n\t\treturn 18;\n\t}\n\n  constructor(uint256 initialSupply) ERC20(\"AndreaToken\", \"1808606\") {\n\t\t_mint(msg.sender, initialSupply);\n\t}\n\n}\n```","x":-8111,"y":6736,"width":759,"height":813,"color":"4"},
		{"id":"70a291915134a31e","type":"text","text":"# Deployment\n\n```sh\nforge create src/AndreaToken.sol:AndreaToken --broadcast --rpc-url https://ethereum-sepolia-rpc.publicnode.com --private-key e5487320d2bd314c55dba7bddac233de09ebbaadd5d67d150edc9870d281d85d --constructor-args 2000000000000000000000000\n```\n\nproduce\n\n```sh\nDeployer: 0xB811217519d6bD706Ef6d70D5E02230BaEDe4569\nDeployed to: 0xDB194e06806B7B63a23195e6A0eacF91F0b9732E\nTransaction hash: 0x20fa3e1b47430c6e6117ebfc3ea9827bcdbc824d6f25478c60bbb1b64cf6c4de\n```\n\nSegue la verifica:\n\n```sh\nforge verify-contract --rpc-url https://ethereum-sepolia-rpc.publicnode.com --etherscan-api-key DYN3JXST4UH5DR4P6BATG22SYEGSDF78WC 0xDB194e06806B7B63a23195e6A0eacF91F0b9732E src/AndreaToken.sol:AndreaToken\n```\n\nOutput\n\n```\nSubmitting verification for [src/AndreaToken.sol:AndreaToken] 0xDB194e06806B7B63a23195e6A0eacF91F0b9732E.\nSubmitted contract for verification:\n        Response: `OK`\n        GUID: `t3b8jiyg9ymyduwd2xe9dqmcvdsxgfeq6rrsafvs6tpsm2rijh`\n        URL: https://sepolia.etherscan.io/address/0xdb194e06806b7b63a23195e6a0eacf91f0b9732e\n```","x":-7102,"y":5688,"width":759,"height":813,"color":"4"},
		{"id":"0b69dbe40a28e3ed","type":"text","text":"# Parametri per creare un wallet\n\nElectrum propone diverse tipologie di wallet:\n\n- ***Standard*** - Singola chiave privata generata da una seed phrase di 12 parole. Firmi ed invii transazioni dal tuo computer senza bisogno di altri dispositivi o approvazioni;\n- ***Two-Factor Authentication*** - Un servizio esterno (e.g. TrustedCoin) deve confermare la transazione affinché questa parta. Per realizzare questa cosa si generano tre chiavi:\n\t- Due sono in mio possesso, sul computer. Da qui immetto la transazione firmando con una;\n\t- Con un altro mezzo (e.g. mail o app) chiedo al servizio esterno di firmare con un'altra;\n\t- Quando firmo con due chiavi, la transazione è valida.\n- ***Multi-Signature*** - Ci sono $N$ chiavi e serve firmare con $n\\le N$ per validare una transazione (un po' come in un Secret Sharing).\n\nPoi passiamo alla gestione della chiave privata.\n\n- `Create new seed` - Il programma genera una frase di 12 o 24 parole dalla quale verranno estratte le chiavi. Da salvare preferibilmente su carta, per evitare di esporla a potenziali leak;\n- `I already have a seed` - \"`Ho già creato il wallet, questo è il mio seed`\". Di norma non salvi quasi mai le chiavi, perché dal `seed` posso ricavarne $N$  secondo uno schema iterativo del tipo $\\text{childkey}_i=f(\\text{parentkey}, i)$. Essendo $f$ una funzione di hash, è quasi impossibile risalire alla $\\text{parentkey}$ a partire dalla $\\text{childkey}$ (quindi neanche alla ***master key*** radice dell'albero);\n- `Use a master key` - Come prima, ma saltando il passaggio del `seed` e dando direttamente la $\\text{masterkey}$ radice dell'albero di derivazione. Visto che ci sono due alberi diversi per le chiavi pubbliche e quelle private, posso dare solo la prima (e usare il wallet in sola lettura) o solo la seconda (avendo le chiavi private posso anche firmare nuove transazioni);\n- `Use a hardware device` - Posso dedicare un dispositivo *ad hoc*  per contenere il `seed`. Quando Electrum deve firmare una transazione, cerca di comunicare con esso (e.g. Bluetooth, USB) per generare la chiave. Puoi anche fartelo in casa con una chiavetta o un Raspberry, ma è consigliabile comprarne uno (tipo [questo](https://www.amazon.it/dp/B0FBWTQ8T1/ref=sspa_dk_detail_2?pd_rd_i=B0FBWTQ8T1&pd_rd_w=9f80E&content-id=amzn1.sym.27357f71-bd5d-4a5b-ba8c-4ad04b414c62&pf_rd_p=27357f71-bd5d-4a5b-ba8c-4ad04b414c62&pf_rd_r=HH7NWR4AX4T0CF5W5V3C&pd_rd_wg=J5WSi&pd_rd_r=dcb10739-6cf6-4fd0-a5a3-a4b8e89bf130&sp_csd=d2lkZ2V0TmFtZT1zcF9kZXRhaWw&th=1)) perché sono molto più sicuri. Poi ovviamente dipende da cosa devi farci, ma se usi soldi veri non è una cattiva idea.","x":-10129,"y":4640,"width":759,"height":813,"color":"4"},
		{"id":"968292c8e83a3c50","type":"text","text":"# Task 2 - Bitcoin Transaction\n\nCome da titolo, fai una transazione Bitcoin. Visto che non è carino usare i soldi veri, esiste una rete di test, che con molta fantasia si chiama ***testnet***. Installiamo [Electrum](https://electrum.org/#download) (gestore di wallet) e lo runniamo con `electrum --testnet`. Scegliamo `Standard Wallet`, e generiamo un nuovo `seed`.\n\nUn paio di cose sulla schermata iniziale:\n\n- Come da schema descritto sopra, ha creato `20 public addresses` e `10 change addresses`. I primi posso usarli per ricevere e inviare, i secondi per auto-darmi il resto dei pagamenti;\n- I `Channels` sono canali privilegiati tra due indirizzi in modalità `Lightning`: blocchi una certa quantità di `coin` sulla BC e scambi con fee ridotte tra questi due `address`. Non ci interessa.\n\nA questo punto dobbiamo ricevere i `test coin` dagli appositi ***faucet*** per la `testnet`, tipo [1](https://bitcoinfaucet.uo1.net/), [2](https://faucet-btc-testnet.metawire.cloud/), [3](https://testnet.help/en/btcfaucet/testnet), [4](https://coinfaucet.eu/en/btc-testnet/), [5](https://faucet.triangleplatform.com/bitcoin/testnet), ricordando che poi sarebbe anche buona pratica restituirglieli. Ovviamente questa cosa esiste per le `testnet` ma difficilmente per le `mainnet`. Agli inizio ce l'aveva anche `BTC mainnet`, ma con quello che vale ora e con le `fee` altissime non conviene più a nessuno.\n\nDopo aver faticosamente accumulato, procediamo a mandare tutto il ricavato all'indirizzo\n\n- `tb1qzjce5zw7j3ugd0hvcfkm4j4y5ly7sqcjjzql2u`\n\nMando letteralmente tutto, quindi non uso alcun indirizzo di change. ","x":-10129,"y":5688,"width":759,"height":813,"color":"4"},
		{"id":"ba82fe844a79a380","type":"text","text":"# Le `fee` altissime\n\nVisto che i `tBTC` non hanno valore le persone (e i bot) li usano fin troppo, congestionando la rete, che già di suo ha pochi miner. Segue logicamente che le `fee` crescono.\n\nTipo, andando su [blockstream.info](https://blockstream.info/testnet/address/tb1qtpz87jveelhwwj6ft4j8u5twjcgdj5p5rjkv5y) e cercando la prima transazione che mi ha fornito `0.1 mBTC` ci sono `0.16298514 tBTC` di input e due output: il mio indirizzo (con `0.0001 tBTC`) e il resto che il `faucet` si è ripreso (`0.15713513 tBTC`). Somma degli input meno somma degli output fa la `fee`, che quindi ricaviamo essere `0.00575001`: è $\\sim 57.5$ volte il denaro che ho ricevuto.\n\nPer dare un esempio pratico, se `1 BTC = 100 000 $`, per mandarmi `0.1 mBTC = 10 $` il `faucet` ha speso `575 $` di `fee`. Visto che le `fee` seguono una tariffa \"`per virtual byte`\" (dove il `vbyte` è una media di byte pesata sul loro significato, nella quale non ci addentriamo) e che nel wallet c'è la `size` della transazione (`219 vbytes`) possiamo ricavare che il `faucet` ha pagato $\\sim$`0.00002626 tBTC/vbyte`. In genere si esprime in `satoshi` (`sat = 10^-8 BTC`), e qui sarebbe `2626 tsat/vbyte`. È tanto? ChatGPT dice che di norma si usano sulle decine di `tsat/vbyte`, quindi andiamo su [questo sito](https://mempool.space/it/) per verificare di non aver fatto idiozie.\n\nDa [qui](https://mempool.space/testnet/tx/a09b26b11026a9c28177d751c5640dd3395168051952da58e944607efa8507d9) vediamo che i conti sono giusti, e da [qui](https://mempool.space/testnet/block/0000000000000e6fe0112cdf48b4952815d89303d47b3c9382f8101e38527972) che rispetto a tutte le altre transazioni è il `faucet` a scegliere di pagare `fee` altissime. Per assicurarsi di darti subito i `coin`? Forse.","x":-10129,"y":6736,"width":759,"height":813,"color":"4"},
		{"id":"c6f920823ae37dad","type":"text","text":"tb1qerzrlxcfu24davlur5sqmgzzgsal6wusda40er","x":-9698,"y":6589,"width":250,"height":60},
		{"id":"b1af0172cb6c2dd5","type":"text","text":"# Task 1 - Vanity Address Generation\n\nGeneri coppie pubblica-privata a caso finché l'hash della pubblica (Bitcoin address) non inizia con quello che vuoi tu. SW per fare questa roba: [Vanitygen++](https://github.com/10gic/vanitygen-plusplus). `git clone`, `make all` e invocazione come `./vanitygen++ -v PREFISSO`. Seguono risultati.\n\n- `1A` - `1Aubjp5CamZprJrV7S4qYWDqj5LgrgKAcz` con chiave pubblica `043e37db8bf3d0fa6f69bb36ce8a168b0d89905552ac64555e30e612ee79d2e975a291330978ca96440f7d8b1298bf72726f462dc2183b6a5d5cecdaaf88b0e93b`;\n- `1An` - `1AnEQ6esPwghtCYwRdJ1SieMozk7kbYYxs` con chiave pubblica `04c3fcfa45379098501646f69f5a4e658e4879dc4a1e39aa835d0f9e85e025032662cfac9d2e2c98f0c182b99bdb55c6855e096505bafbcb83dcb8bcaa90de3534`;\n- `1And` - `1AndMm6QCCyCVtvMpqJvh7z1f47Q8AGM8S` con chiave pubblica `04c0aeaef2820ddda5dce77bbe4d8aa0a3ee40ee8b3c789b5012732d93864b8ffd06f2834afe01ab21e55e5820758fc8fefea86e2f9cf719346d8914f48efae838`;\n- `1Andr` - `1AndrBfvqP67gyLzyGgrCMn3Wn5q1619E2` con chiave pubblica `04a3416d390421f720c4973aaa3f1cf01de64716bee6169e6400747d14e83addedeb5a6238d15b2b27723da4de86e6c5acf8372d5bde3e067e7c31c2ad73a3d38b`;\n- `1Andre` - `1AndreDku5wRE184YtiHDUZesdrYdnXxJW` con chiave pubblica `0496b23db8920dbec7588193f3e0302ceae174fa0a3b6359a7c95b47f51760551d194ccad7d65419cdc234d4e00bf7a7e01f766681801d55c6954fa8da3a96392c`.\n\nDa qui in poi il 12600K ci mette un'ora, quindi usiamo la 3080.\n\n- `1Andrea` - `1AndreahknZtqg4VQNKGtmMiTZEdevQJxT` con chiave pubblica `04597416f0050f9c8214170f71a9254ec363f9ab6f42b1171dcabc98727c03558b6652ae08810fcc2585552ff3584e7e3b8c6c72f4b73053ed3a55cd9739eb0fba`;\n- `1AndreaD` - `1AndreaDtr5xwCcmg7LdCATBT9NsYZvM4N` con chiave pubblica `046b60fa39b7e1f159871757ce7658f31c1b3cb6bafd6572b009289925fced9a494e5ca8396c1d728ec2b97ce74abfc4f2c98d764b171f5f715b4621bb9b14f29a`.\n\nDa qui in poi la 3080 ci mette un giorno. Evito. Lui ovviamente ha messo questo come target per avere un altro punto bonus, ma non credo che sforzerò la mia GPU per questa cosa.","x":-11138,"y":5688,"width":759,"height":813,"color":"4"},
		{"id":"8dbd71848e564c60","type":"text","text":"# Ethereum's Fees\n\nGas refers to the unit that measures the amount of computational effort required to execute\nspecific operations on the Ethereum network.\nThe gas fee is the amount of gas used to do some operation, multiplied by the cost per unit\ngas. The fee is paid regardless of whether a transaction succeeds or fails.\nGas fees have to be paid in Ether (ETH) and are usually quoted in Gwei.\nA gwei is equal to one-billionth of an ETH (0.000000001 ETH or 10-9 ETH).\nTotal Gas = unit of gas ( base fee + priority fee)\nThe base fee is set by the protocol and it is the minimum amount that you have to pay for your\ntransaction to be considered valid.\nThe priority fee is a tip added to the base fee to make your transaction attractive by validators.\nThe ‘correct’ value of the priority fee is determined by the the network usage, in a kind of\nvirtual auction.\nThus, a transaction without priority fee is valid, but it is unlikely that it will be included because\nit offers no incentive to validators.\n\nEvery block has its own base fee.\nThe base fee of the block X is determined by the block before (X-1).\nWhen a block is created the base fee is burned.\nBlock size: Each block has a target size of half the current block gas limit, but the size of\nblocks will increase or decrease in accordance with network demand, up until the block limit is\nreached (2x the target block size).The block gas limit can be adjusted upwards or downwards\nby a factor of 1/1024 from the previous block's gas limit.\nBlock Gas limit: actual block gas limit: 45 million gas.\nThe block gas limit can be adjusted upwards or downwards by a factor of 1/1024 from the\nprevious block's gas limit.\nBase fee adjustment: The amount by which the base fee is adjusted is proportional to how far\nthe current block size is from the target. This is a linear calculation from -12.5% for an empty\nblock, 0% at the target size, up to +12.5% for a block reaching the gas limit.","x":-7102,"y":-3059,"width":759,"height":980},
		{"id":"994843ccad7ad32e","type":"text","text":"# Binance Smart Chain (Report)","x":-9119,"y":1377,"width":759,"height":200,"color":"6"},
		{"id":"c5e0570766b0419b","type":"text","text":"# SPACING","x":-4325,"y":-1844,"width":250,"height":235,"color":"5"},
		{"id":"329c39789159c25f","type":"text","text":"# Consensus\n\nPer partecipare al processo di consenso di Ethereum devo depositare `32 ETH` ad uno speciale SC chiamato ***Deposit Contract***, il quale certifica che il mio SW (i.e. la mia chiave privata) è autorizzata ad essere eventualmente scelta come Proposer per i blocchi. Se ho più soldi (e.g. `64 ETH`) non \"peso\" di più, ma attivo semplicemente **più validatori** (più chiavi) gestiti dallo stesso client.\n\nDalla lista dei candidati attivi viene scelto a caso uno che propone il blocco. Se dovessero ogni volta validarlo tutti i nodi autorizzati a farlo (i.e. quelli che hanno pagato i `32 ETH`) sarebbe un delirio, quindi li dividiamo in ***committees***  di almeno 128 validatori. Per ogni blocco proposto viene estratto un singolo committee, i cui i membri sono a questo punto obbligati a validare.\n\nPuò comunque succedere che si creino delle ***fork*** (perché magari il messaggio con cui propongo il mio blocco fa ritardo sulla rete e nel frattempo ne appare un altro alternativo), nel qual caso i validators sono tenuti a votare la catena più pesante (non nel senso che sposta più soldi nelle transazioni, ma semplicemente che ha ricevuto più voti). Solo l'ultimo voto conta, e pertanto nel complesso chiamiamo questo algoritmo di risoluzione delle fork \"***Last-Message-Driven Greedy-Heaviest-Observed-Sub-Tree***\", per gli amici ***LMD GHOST***.\n\nDetto questo, la ***finalization*** passa da ***Casper*** (nome fancy, perché sì). Ethereum divide il tempo in ***epochs*** da 32 slot ($\\sim6$ minuti), e il primo blocco approvato all'interno di un'epoca viene detto ***checkpoint***. Casper interroga ***l'intera rete dei validator*** chiedendo loro \"`Qual è l'ultimo checkpoint valido?`\". Se in risposta (***Attestation***) vede una maggioranza di almeno $2/3$ dei validators, il checkpoint viene ***approvato***.\n\nL'ultimo checkpoint approvato è detto ***giustificato*** (una sorta di stato semi-provvisorio), mentre il penultimo è considerato ***finalizzato***.\n\nLa finalizzazione è un cosiddetto \"***Hard Commitment***\": di fatto, almeno $2/3$ dei nodi sta dicendo \"`non cambieremo mai più idea su A`\". Un attaccante che volesse modificare la storia della BC dovrebbe convincerli a farlo, ma da protocollo questo significherebbe andare incontro ad un pesante ***Slashing*** (i.e. \"punizione\" secondo la quale viene bruciata una parte dei `32 ETH` depositati come cauzione a seguito di violazioni del protocollo).\n","x":-4075,"y":-1844,"width":759,"height":984,"color":"4"},
		{"id":"22fde4c3c84b5341","type":"text","text":"# Proof of Stake\n\nL'idea è la seguente: per far parte del meccanismo di consenso, devo consegnare una \"cauzione\" a riprova delle mie buone intenzioni. *Vediamo per esempio un esempio*.\n\n- Da proprietario del nodo `A`, consegno ad un indirizzo speciale (controllato dal protocollo stesso) `100 Coin`. Questa \"cauzione\" prende il nome di ***stake*** ;\n- Il protocollo si ritroverà diversi nodi che fanno questa cosa. Diciamo che `A` ha messo `100`, `B 200` e `C 50`. Sulla base di questo, il ***proposer*** (i.e. colui che firmerà il blocco) viene scelto in modo probabilistico. `A` avrà una probabilità di essere estratto pari a `100/250 = 2/5`, e via dicendo. Più stake metto, più probabilità ho di essere scelto. Puoi pensarla come una sorta di \"high risk, high reward\": nodi con stake alto hanno più da perdere;\n- In tutto questo, distinguiamo costi e benefici. Perché dovrei volere essere un proposer?\n\t- ***Benefici*** - Mi prendo le fee delle transazioni che faccio approvare, nonché una sorta di \"`coinbase transaction`\" in stile `Bitcoin` (... non funziona proprio così, chiamiamola più in generale ***inflazione***);\n\t- ***Costi*** - Se mi comporto male (e.g. double spending, attacchi), il protocollo può decidere di trattenere tutta o parte della stake. Questo disincentivo a comportamenti bizantini viene detto ***slashing***.\n- Lo stake resta nell'indirizzo speciale fintantoché voglio restare all'interno del protocollo di consenso.\n\t- \"Quindi ritirarlo significa uscirne, giusto?\"... non proprio. Piuttosto, ***uscire dalla lista dei potenziali validator significa che ad un certo punto potrai ritirare il tuo stake***. Se ci pensi, ha senso: prima rinunci al potere, e poi il protocollo ti permette di riprendere la cauzione. Fare al contrario porterebbe a problemi;\n\t- \"Però posso incrementare e decrementare a piacimento lo stake quando voglio, no?\"... ni. Puoi incrementarlo, ma tipicamente non puoi decrementarlo, sempre per motivi di sicurezza: vieni scelto, e nello stesso blocco fai un grosso decremento e ti comporti in modo bizantino. Il protocollo fa slashing su pochissimo capitale, tu ti sei comportato male e la punizione è quasi nulla. Se vuoi decrementarlo, prima rinunci al ruolo di validator e poi ti ri-iscrivi con meno stake.\n","x":-4075,"y":-298,"width":759,"height":980,"color":"4"},
		{"id":"292e05f4eedbd7df","type":"text","text":"# Proof of Authority (Gemini)\n\nSe nella PoW \"comando perché fatico\" (energia) e nella PoS \"comando perché sono ricco\" (stake), nella PoA **\"comando perché sono io\"** (identità).\n\nL'idea è la seguente:\n\n- **Identità al posto dei soldi:** Non devo bloccare 100 Coin come cauzione. Devo rivelare pubblicamente la mia identità reale (es. \"Sono l'azienda X\", \"Sono l'Università Y\"). La mia \"stake\" è la mia **reputazione nel mondo reale**.\n- **Numero chiuso:** Non chiunque può svegliarsi e fare il miner. I validatori sono un \"club ristretto\" (una lista approvata).\n- **Come funziona il consenso:**\n    - I nodi validatori sono pochi (es. 20-50).\n    - A turno (spesso in modo deterministico, tipo Round Robin: \"Tocca a te, poi a te, poi a me\"), un validatore propone il blocco e gli altri lo firmano.\n    - Essendo pochi e conosciuti, non servono calcoli complessi. Il consenso è istantaneo.\n- **Incentivi (Perché comportarsi bene?):**\n     - **Benefici:** Mantengo la rete veloce e usabile (spesso la PoA si usa in chain private o aziendali dove l'interesse è che il sistema funzioni).\n    - **Costi (Slashing Sociale):** Se provo a truffare la rete, la prova crittografica della mia truffa è legata alla mia identità pubblica. Tutti sanno che l'azienda X ha truffato. Il danno d'immagine (e legale) è infinitamente superiore al guadagno del furto. Perdo la faccia e vengo cacciato dal consorzio.\n\n","x":-3066,"y":-298,"width":759,"height":980,"color":"5"},
		{"id":"cf79141c401ed7a2","type":"text","text":"# PoSA\n\n\n\nTra le varianti più note troviamo\n\n- ***Proof of Stacked Authority***  (***PoSA***) - Se nella Proof of Authority ci sono semplicemente dei nodi \"d'élite\" che approvano i blocchi, in PoSA c'è una pool di nodi \"d'élite\" dalla quale si pescano un `tot` di validatori secondo le sopracitate regole del PoS;\n\n\n### Risposta ai tuoi dubbi: Da dove viene la \"Reputazione\"?\n\n1. Il concetto di reputazione viene dalla PoA?\n\nSì, assolutamente. È il cuore della PoA.\n\nNella PoA pura, la reputazione è l'unica cosa che garantisce la sicurezza. Se i validatori fossero anonimi, ruberebbero tutto in un secondo. Devono essere \"Authority\" proprio perché hanno una reputazione da difendere.\n\n2. È un'idea originale di PoSA?\n\nNo, la PoSA (Proof of Staked Authority) ha preso l'idea della reputazione dalla PoA e l'ha \"democratizzata\" (o monetizzata) unendola alla PoS.\n\nEcco la differenza sottile ma fondamentale che devi capire:\n\n- **In PoA Pura (Reputazione Statica):**\n    - _Chi decide?_ Un amministratore centrale o una votazione degli altri validatori.\n    - _Come entro?_ \"Ciao, sono Amazon, mi fate entrare?\" -> \"Sì, ci fidiamo\".\n    - _Reputazione =_ Brand.\n- **In PoSA di Binance (Reputazione Dinamica/Mercatistica):**\n    - _Chi decide?_ Il mercato (gli utenti che hanno i BNB).\n    - _Come entro?_ \"Ciao, sono il Nodo X. Guardate, sono stato online il 100% del tempo e non ho mai truffato. Votate per me coi vostri soldi!\".\n    - _Reputazione =_ **Performance Storica**.\n\nQuindi:\n\n1. La **PoA** è velocissima perché ha pochi nodi fidati, ma è troppo centralizzata (chi decide chi entra nel club?).\n2. La **PoS** è decentralizzata (chiunque paghi entra), ma può diventare lenta se i nodi sono troppi.\n3. La **PoSA (Binance)** unisce i due mondi:\n    - Mantiene il **numero chiuso** della PoA (solo 21 nodi) per avere blocchi da 3 secondi.\n    - Usa il meccanismo di **selezione della PoS** (Stake/Deleghe) per decidere chi sono questi 21, evitando che sia Binance stessa a sceglierli a mano.","x":-3557,"y":917,"width":759,"height":1120,"color":"5"},
		{"id":"13020eedc31b0375","type":"text","text":"# Clienti e Nodi\n\nIn Ethereum a node is made of two clients:\n- The execution client (also known as the Execution Engine, EL client or formerly the Eth1 client) listens to new transactions broadcasted in the network, executes them in EVM, and holds the latest state and database of all current Ethereum data.\n- The consensus client (also known as the Beacon Node, CL client or formerly the Eth2 client) They are responsible for all consensus-related logic including the fork-choice algorithm, processing attestations and managing proof-of-stake rewards and penalties.\n\t- There is also a third piece of software, known as a 'validator' that can be added to the consensus client, allowing a node to actively participate to the proof of stake, staking 32 ETH and becoming a validator.\n\n... and three nodes\n\n- Full nodes do a block-by-block validation of the blockchain, including downloading and verifying the block body and state data for each block. full nodes only keep a local  copy of relatively recent data (typically the most recent 128 blocks), allowing older data to be deleted to save disk space. It stores full blockchain data, but not all state data (typically only those related to the most recent 128 blocks).\n\t- Participates in block validation, verifies all blocks and states.\n\t- All states can be either retrieved from local storage or regenerated from 'snapshots' by a full node.\n\t- Serves the network and provides data on request.\n- Archive nodes are full nodes that verify every block from genesis and never delete any of the downloaded data. It is needed if you want to query something like an account balance at block #4,000,000. This kind of node requires a lot of storage.\n- Light nodes only download block headers. These headers contain summary information about the contents of the blocks. Any other information the light node requires gets requested from a full node. The light node can then independently verify the data they receive against the state roots in the block headers. Light nodes enable users to participate in the Ethereum network without the powerful hardware or high bandwidth required to run full nodes. Eventually, light nodes might run on mobile phones or embedded devices. The light nodes cannot be validators, but they can access the Ethereum blockchain with the same functionality and security guarantees as a full node.\n\nTo participate as a validator, a user must deposit 32 ETH into the deposit contract and run\nthree separate pieces of software:\n• the execution client\n• the consensus client\n• the validator client.\nValidators are the nodes that form the consensus. Differently from the meaning of their name,\nthey don't really validate anything. (Validation is done by standard nodes).\nEach validator has a maximum balance of 32 ETH, but stakers can stake all their ETH. For\nevery 32 ETH staked, one validator is activated.","x":-6093,"y":-298,"width":759,"height":980},
		{"id":"ac7f55dd43e0d390","type":"text","text":"# Slides 8 (ETH CONSENSUS) n 13","x":-7978,"y":-662,"width":558,"height":322,"color":"1"},
		{"id":"028059dbeb50636d","type":"text","text":"# Commitment Scheme (Schema di Impegno)\n\nPensa al Commitment come ad una **busta sigillata**.\n\n1. Scrivi la tua previsione su un foglio (es. \"La Juve vince 2-0\").\n2. Metti il foglio in una busta e la sigilli con la ceralacca.\n3. Dai la busta al tuo amico **prima** della partita.\n\nCosa succede qui?\n\n- Il tuo amico ha la busta, ma non può leggerla (**Hiding** - Nascosto).\n- Tu sai cosa c'è scritto, ma non puoi più cambiarlo: la busta ce l'ha lui (**Binding** - Vincolante).\n- Dopo la partita, lui apre la busta e verifica che avevi indovinato.\n\nNel mondo digitale, non abbiamo buste fisiche, quindi usiamo la **matematica (crittografia)**.\n\n1. **Il Messaggio (`msg`):** La tua previsione (es. \"Vince Juve\").\n2. **Il Nonce:** Un numero casuale segreto (es. \"849204\").\n    \nNella ***fase di Impegno (commit),*** tu prendi il tuo messaggio e il numero casuale e li \"mescoli\" insieme usando una funzione matematica (solitamente un Hash).\n\n$$com = \\text{commit}(\\text{\"Vince Juve\"}, \\text{\"849204\"})$$\n\nIl risultato (com) è una stringa incomprensibile, tipo `a1b2c3d4`, che invii al tuo amico.\n\nNella fase di Verifica (verify), dopo la partita, devi \"aprire la busta\". Per farlo, riveli al tuo amico:\n\n- Il messaggio originale: \"Vince Juve\".\n- Il numero segreto (Nonce): \"849204\".\n\nLui prende questi due dati e rifà il calcolo sul suo computer. Se trova che\n\n```\ncommit(\"Vince Juve\", \"849204\") = a1b2c3d4\n```\n\nallora è matematicamente certo (o meglio, quasi, diciamo al 99.99%) che non hai cambiato idea e non hai barato.\n\nAffinché questo sistema sia sicuro, devono valere due regole:\n\n- **1. Hiding (Segretezza)**: Guardando solo il codice `a1b2c3d4`, deve essere impossibile capire cosa c'è scritto dentro.\n\t- Perché serve il Nonce? Immagina se non ci fosse il numero casuale e tu volessi scommettere solo su \"Testa\" o \"Croce\". Il tuo amico potrebbe calcolare da solo commit(\"Testa\") e commit(\"Croce\") e confrontarli con quello che gli hai mandato. Scoprirebbe subito cosa hai giocato! Aggiungendo il numero casuale (\"Testa\" + \"993812\"), rendi infinite le possibilità e lui non può indovinare provando tutte le combinazioni.\n- **2. Binding (Vincolatività)**: Una volta che hai creato il codice `a1b2c3d4` legato a \"Vince Juve\", deve essere impossibile (o meglio, altamente improbabile) trovare un altro messaggio (es. \"Vince Milan\") e un altro numero casuale che generino lo stesso identico codice `a1b2c3d4`.\n\n_In pratica:_ Sei incatenato alla tua scelta iniziale. Non puoi dire \"Ah, ma io in realtà intendevo un'altra cosa\" perché la matematica non tornerebbe.","x":-11138,"y":-1240,"width":759,"height":380,"color":"5"},
		{"id":"74b578ea8abd98a3","type":"text","text":"# Transactions \n\nA submitted transaction includes the following information:\n- From: the address of the sender, that will be signing the transaction. This will be an externally-owned account as contract accounts cannot send transactions\n- To: the receiving address (if an externally-owned account, the transaction will transfer value. If a contract account, the transaction will execute the contract code)\n- Signature: the identifier of the sender. This is generated when the sender's private key signs the transaction and confirms the sender has authorized this transaction\n- Nonce: a sequentially incrementing counter which indicates the transaction number from the account (lo usi per assicurarti che le tue transazioni siano uniche e vengano approvate nel giusto ordine). A counter that indicates the number of transactions sent from an externally-owned account or the number of contracts created by a contract account. Only one transaction with a given nonce can be executed for each account.\n- Value: amount of ETH to transfer from sender to recipient (denominated in WEI, where 1ETH equals 1e+18wei)\n- input data: optional field to include arbitrary data. If this field is empty, the transaction is a transfer between users and doesn’t involve a smart contract. The first four bytes specify which function to call, using the hash of the function's name and arguments. The rest of the call data is the arguments.\n- gasLimit: the maximum amount of gas units that can be consumed by the transaction. The EVM specifies the units of gas required by each computational step\n- maxPriorityFeePerGas: the maximum price of the consumed gas to be included as a tip to the validator\n- maxFeePerGas: the maximum fee per unit of gas willing to be paid for the transaction (inclusive of baseFeePerGas and maxPriorityFeePerGas)","x":-5084,"y":-298,"width":759,"height":984},
		{"id":"1a4f1db63437aa7f","type":"file","file":"Merkle_Patricia_Trie.png","x":-4075,"y":-2364,"width":399,"height":285},
		{"id":"110ba0ffd13f693d","type":"file","file":"Trie.png","x":-4075,"y":-3059,"width":400,"height":370},
		{"id":"29793c1823f5c66e","type":"file","file":"Patricia_Trie.png","x":-4075,"y":-2660,"width":400,"height":255},
		{"id":"cf830ccb97bbf2b1","type":"text","text":"\nA block proposer is a validator selected to build a block.\nProposers are selected pseudo-randomly by RANDAO with a weighting on the validator’s balance.\nEvery slot, exactly one validator is selected to propose a block.\nThe proposer shares its block with the whole network via a gossip protocol.\nA slot can be empty: a block proposer might be offline, or propose an invalid block, or have its block subsequently reorged out of the chain.\n\nEvery epoch, every validator gets to share its view of the world exactly once, in the form of an\nattestation.\nAn attestation is a validator’s vote, weighted by the validator’s balance.\nAttestations are broadcasted by validators in addition to blocks.\nAn attestation contains votes for the head of the chain that will be used by the LMD GHOST protocol,\nand votes for checkpoints that will be used by the Casper FFG protocol.\nLike blocks, attestations can be missing for all sorts of reasons, and the protocol can tolerate this\nto various extents\n\nIn every slot, a committee of validators is randomly chosen, whose votes are used to\ndetermine the validity of the block being proposed. A committee is a group of validators.\nEach slot has committees of at least 128 validators.\nDividing the validator set up into committees is important for keeping the network load\nmanageable.\nCommittees divide up the validator set so that every active validator attests in every epoch,\nbut not in every slot.\nThere are 1 committee per slot, If the the network is made of less than 8’192 validators.\nOtherwise there would be at least two committees per slot.","x":-2760,"y":-560,"width":303,"height":118},
		{"id":"6932e83741fba37b","type":"text","text":"# Incentivi e Punizioni\n\nOgni validator possiede due saldi distinti:\n\n- ***Actual Balance*** - Sono i `gwei` esatti che possiedi, contando deposito, premi e penalità;\n- ***Effective Balance*** - Sono i `gwei` che contano ai fini del PoS (i.e. c'è un massimo a `32 ETH`).\n\nA meno di superamento del massimale, l'`Effective Balance` dovrebbe seguire l'andamento dell' `Actual Balance`. Visto che però l'`Actual` può oscillare di piccolissime (quasi insignificanti, ai fini del PoS) quantità, definiamo un'inerzia (***Hysteresis***) tale per cui l'`Effective` cambia solo a seguito di variazioni di almeno un certo peso dell'`Actual`.\n\nCome accennato, l'`Actual` raccoglie premi e penalità. Cosa sono?\n\n- ***Premi*** - I reward per un validator vengono da tre macro-attività:\n\t- ***Attestations*** - Votare correttamente per l'aggiunta (LMD GHOST) e finalizzazione (Casper) dei blocchi. Più sei reattivo nella risposta (corretta), maggiore è il premio;\n\t- ***Proposing*** - Includere Attestations nel proprio blocco significa contribuire a consolidare la storia della BC, e porta ad un guadagno in percentuale (e.g. $1/8$ delle Attestations);\n\t- ***Sync Committee*** - I light clients non possono fare verifiche sui blocchi, devono fidarsi di qualcuno che garantisce per loro. Ethereum estrae una committee di 512 nodi ogni 256 epoche ($\\sim 27$ ore), se sei parte di essa vieni pagato per firmare gli header dei blocchi (che di per sé è una roba semplicissima, di base stai facendo da notaio).\n- ***Penalità*** - Scattano sia se sei lento a rispondere sia se sei bizantino.\n\t- ***Penalties*** - Formalmente, si chiamano così le \"multe minori\" se sei lento;\n\t- ***Slashing*** - La vera punizione brutta. Ti bruciano $1/32$ dell'`Effective Balance` e ti sbattono fuori dal set di validatori, ma resti in un limbo per 36 giorni. Nel corso di questi, pagherai multe perché non partecipi alle votazioni (non puoi farlo, ovviamente), e a metà di questo limbo il protocollo controlla quanti altri nodi sono \"in prigione\" insieme a te. Più siete, più la multa è alta. Nel complesso, è un girone dell'inferno.\n\t\t- Se il tuo `Effective Balance` scende sotto i `16 ETH` vieni automaticamente espulso dal set dei validatori.\n\t\t- Chi scopre e segnala un nodo bizantino riceve un ***Whistleblower reward***.\n\nIn ogni caso, non puoi semplicemente decidere di uscire dal protocollo di consenso e ritirare i tuoi `ETH` quando vuoi: devi aspettare un ***withdrawal delay*** nel quale il protocollo si accerta che prima di uscire tu non abbia fatto danni.","x":-3066,"y":-1844,"width":759,"height":984,"color":"4"},
		{"id":"1e4796adb210de61","type":"text","text":"# Inactivity Leak\n\nCosa succede se cade un meteorite e il 40% dei validatori va offline? La rete non può più finalizzare (manca il 2/3 dei voti).\n\nDopo 4 epoche senza finalità, scatta l'Inactivity Leak.\n\n- **Cosa fa:** Invece di darti premi, il protocollo inizia a **prosciugare** quadraticamente lo stake di chi è offline.\n- **L'obiettivo:** Abbassare il loro stake finché i nodi rimasti online non rappresentano di nuovo i 2/3 della torta totale, permettendo alla rete di ripartire.\n\n","x":-3066,"y":-2300,"width":759,"height":286,"color":"5"}
	],
	"edges":[
		{"id":"9c09d891967b6e1f","fromNode":"e23ed681df359267","fromSide":"bottom","toNode":"37be4a9f1c9a0573","toSide":"top"},
		{"id":"03edbc01e8f7e44e","fromNode":"e23ed681df359267","fromSide":"bottom","toNode":"bc974bfebe38a31d","toSide":"top"},
		{"id":"a29e41074f09eec2","fromNode":"7e38a9731b069017","fromSide":"top","toNode":"0187f418b12b8a18","toSide":"bottom"},
		{"id":"8e5e3e7086c629c2","fromNode":"7e38a9731b069017","fromSide":"top","toNode":"b0e15795235728f2","toSide":"bottom"},
		{"id":"ec109a77a5c909b8","fromNode":"7e38a9731b069017","fromSide":"top","toNode":"2825d21211592300","toSide":"bottom"},
		{"id":"28a83161ee8a1420","fromNode":"7e38a9731b069017","fromSide":"right","toNode":"b6a85d26a6d762d8","toSide":"left"},
		{"id":"e21de116395bea6a","fromNode":"e23ed681df359267","fromSide":"top","toNode":"7e38a9731b069017","toSide":"bottom"},
		{"id":"e3cc9ca3cfb7f488","fromNode":"0187f418b12b8a18","fromSide":"left","toNode":"66e789f3b5a0ec37","toSide":"right"},
		{"id":"7f018e44677a92cc","fromNode":"e23ed681df359267","fromSide":"top","toNode":"f73c6a4e69389480","toSide":"bottom"},
		{"id":"51420e3b1c786b37","fromNode":"e23ed681df359267","fromSide":"right","toNode":"c0bc01d1e65c717d","toSide":"left"},
		{"id":"379d92bceab89f78","fromNode":"e23ed681df359267","fromSide":"right","toNode":"420c6a87906609da","toSide":"left"},
		{"id":"e5a88b36d318a4b4","fromNode":"c0bc01d1e65c717d","fromSide":"bottom","toNode":"40d21f642132b8a5","toSide":"top"},
		{"id":"9cf4143d05f00343","fromNode":"c0bc01d1e65c717d","fromSide":"top","toNode":"ef073ac9df95dbd1","toSide":"bottom"},
		{"id":"0547737486b5b74d","fromNode":"c0bc01d1e65c717d","fromSide":"left","toNode":"54b251eb5f580875","toSide":"bottom"},
		{"id":"86a655b4dc5c1214","fromNode":"420c6a87906609da","fromSide":"right","toNode":"c0bc01d1e65c717d","toSide":"left","label":"DEX"},
		{"id":"d6b93699d47a0cdb","fromNode":"40d21f642132b8a5","fromSide":"bottom","toNode":"bd58e931f55c72e9","toSide":"top"},
		{"id":"f6b73b9dea669080","fromNode":"40d21f642132b8a5","fromSide":"bottom","toNode":"85fc8a05c99ff340","toSide":"top"},
		{"id":"1a99c65484401585","fromNode":"420c6a87906609da","fromSide":"right","toNode":"40d21f642132b8a5","toSide":"left","label":"DEX"},
		{"id":"af9f49327bdeb417","fromNode":"420c6a87906609da","fromSide":"bottom","toNode":"af09c1c6572f2db1","toSide":"top","label":"CEX"},
		{"id":"d1a719a7b987a4f1","fromNode":"420c6a87906609da","fromSide":"bottom","toNode":"85fc8a05c99ff340","toSide":"top","label":"DEX"},
		{"id":"f823ea86f8eeb34d","fromNode":"b0e15795235728f2","fromSide":"right","toNode":"2825d21211592300","toSide":"left"},
		{"id":"c941baa6d7992c76","fromNode":"ef073ac9df95dbd1","fromSide":"top","toNode":"68b193c5004cfe21","toSide":"bottom"},
		{"id":"d23bba83377ce2f7","fromNode":"ef073ac9df95dbd1","fromSide":"right","toNode":"8689b6a4e7e83f20","toSide":"left"},
		{"id":"f0125982149f4144","fromNode":"bd58e931f55c72e9","fromSide":"bottom","toNode":"8a6b328ab8c2b7cf","toSide":"top"},
		{"id":"4f448f229c1d1805","fromNode":"bd58e931f55c72e9","fromSide":"right","toNode":"ca2750dfcadcc2cb","toSide":"top"},
		{"id":"f4b1a8c5eac4412d","fromNode":"8a6b328ab8c2b7cf","fromSide":"right","toNode":"ca2750dfcadcc2cb","toSide":"left"},
		{"id":"a8736eb024c54f3b","fromNode":"8a6b328ab8c2b7cf","fromSide":"bottom","toNode":"32adeffc3526776e","toSide":"top"},
		{"id":"82e5a1821f53de66","fromNode":"8a6b328ab8c2b7cf","fromSide":"bottom","toNode":"313585cc249c3349","toSide":"top"},
		{"id":"1c91256870aeb260","fromNode":"ca2750dfcadcc2cb","fromSide":"bottom","toNode":"32adeffc3526776e","toSide":"top"},
		{"id":"750a76cc4b46fbed","fromNode":"d006bd8a921bcf16","fromSide":"top","toNode":"4e3449fd770ccfb1","toSide":"top"},
		{"id":"fe7b783df9081f79","fromNode":"68b193c5004cfe21","fromSide":"top","toNode":"d006bd8a921bcf16","toSide":"bottom"},
		{"id":"130059f9f4e8ec9c","fromNode":"85fc8a05c99ff340","fromSide":"bottom","toNode":"340205e6a9b86c6e","toSide":"top"},
		{"id":"7a787f3c67ed24ee","fromNode":"54b251eb5f580875","fromSide":"top","toNode":"dcba45b3aa4e8ffc","toSide":"bottom"},
		{"id":"dcd65893ed152d71","fromNode":"af09c1c6572f2db1","fromSide":"bottom","toNode":"cf185f8837214b5e","toSide":"top"},
		{"id":"2872607ec72e4e53","fromNode":"cf185f8837214b5e","fromSide":"bottom","toNode":"962f6c4b3c0be25d","toSide":"top"},
		{"id":"e12e4f9a9101eaad","fromNode":"cf185f8837214b5e","fromSide":"left","toNode":"d1bdc75d4a561ac5","toSide":"right"},
		{"id":"e68438bc3b441bbe","fromNode":"962f6c4b3c0be25d","fromSide":"bottom","toNode":"f25620bcdd9ec501","toSide":"top"},
		{"id":"21322b864022341d","fromNode":"8ae9d77db5d92e7f","fromSide":"right","toNode":"e23ed681df359267","toSide":"left"},
		{"id":"ae3a136b01dcdfd5","fromNode":"87e0f46ba8de8691","fromSide":"top","toNode":"e027f44c3e948552","toSide":"bottom"},
		{"id":"69fe1845b698790d","fromNode":"87e0f46ba8de8691","fromSide":"right","toNode":"ad475259f1ef5f06","toSide":"left"},
		{"id":"6908ece6712d57f7","fromNode":"87e0f46ba8de8691","fromSide":"left","toNode":"49e6eafb2938a493","toSide":"right"},
		{"id":"1d5a6926cee55f5b","fromNode":"87e0f46ba8de8691","fromSide":"bottom","toNode":"fc29e282c8934010","toSide":"top"},
		{"id":"d7f9063a7008b324","fromNode":"e027f44c3e948552","fromSide":"right","toNode":"ac381904b8cd5952","toSide":"left"},
		{"id":"462c2e75d26a7c8d","fromNode":"fc29e282c8934010","fromSide":"bottom","toNode":"ab5bdfb7e15861eb","toSide":"top"},
		{"id":"45f5ef3f4f725c2e","fromNode":"fc29e282c8934010","fromSide":"left","toNode":"2a9b9c170774f579","toSide":"right"},
		{"id":"04f73156ecef5bf3","fromNode":"fc29e282c8934010","fromSide":"right","toNode":"2ecba2716d7cab9c","toSide":"left"},
		{"id":"4260a3a4f6a234a4","fromNode":"2a9b9c170774f579","fromSide":"left","toNode":"8969a303981934a3","toSide":"right"},
		{"id":"d815ddba012fe4f7","fromNode":"ab5bdfb7e15861eb","fromSide":"left","toNode":"4ecf6e84c27eefab","toSide":"right"},
		{"id":"823107dd8cf963cb","fromNode":"ab5bdfb7e15861eb","fromSide":"right","toNode":"ce361acbec560316","toSide":"left"},
		{"id":"d9bc71e27d083270","fromNode":"b1af0172cb6c2dd5","fromSide":"right","toNode":"968292c8e83a3c50","toSide":"left"},
		{"id":"44cd20113d56af6d","fromNode":"4ecf6e84c27eefab","fromSide":"top","toNode":"6c3ba07e993ec188","toSide":"bottom"},
		{"id":"847772f6fe44bd29","fromNode":"8969a303981934a3","fromSide":"left","toNode":"1de20a395d19c219","toSide":"right"},
		{"id":"30584efad5427980","fromNode":"1de20a395d19c219","fromSide":"left","toNode":"abf6c2ebe99219a6","toSide":"right"},
		{"id":"a70546374832272d","fromNode":"6174a42308c05ee3","fromSide":"right","toNode":"da2c17bafb6ed3d4","toSide":"left"},
		{"id":"037733ff9d22139e","fromNode":"abf6c2ebe99219a6","fromSide":"top","toNode":"6174a42308c05ee3","toSide":"bottom"},
		{"id":"905d74e7a8f0cee6","fromNode":"1de20a395d19c219","fromSide":"bottom","toNode":"e2d623b8a580162c","toSide":"top"},
		{"id":"3dbd350fd67379dc","fromNode":"6c3ba07e993ec188","fromSide":"left","toNode":"e2d623b8a580162c","toSide":"right","fromEnd":"arrow"},
		{"id":"b1c12fc1d812b09e","fromNode":"e2d623b8a580162c","fromSide":"left","toNode":"7b9a2f1c22d3ed92","toSide":"right"},
		{"id":"5b0da00f10dead6a","fromNode":"2ecba2716d7cab9c","fromSide":"right","toNode":"6d0a42604e6ee149","toSide":"left"},
		{"id":"22a345804196ec0d","fromNode":"8969a303981934a3","fromSide":"top","toNode":"40e8d3d5bf4aedc3","toSide":"bottom"},
		{"id":"7cdbd0fb25da79bf","fromNode":"968292c8e83a3c50","fromSide":"top","toNode":"0b69dbe40a28e3ed","toSide":"bottom"},
		{"id":"6d73ecf9d19df6f8","fromNode":"968292c8e83a3c50","fromSide":"bottom","toNode":"ba82fe844a79a380","toSide":"top"},
		{"id":"857dd06a1acf436f","fromNode":"4ecf6e84c27eefab","fromSide":"bottom","toNode":"200a0a35b8171b4c","toSide":"top"},
		{"id":"438996466982afb9","fromNode":"ce361acbec560316","fromSide":"top","toNode":"6d0a42604e6ee149","toSide":"bottom"},
		{"id":"972bc357ae7336b9","fromNode":"8969a303981934a3","fromSide":"bottom","toNode":"6c3ba07e993ec188","toSide":"top"},
		{"id":"f97f1494ba65777c","fromNode":"4ecf6e84c27eefab","fromSide":"top","toNode":"c4d82ff3e837b284","toSide":"bottom"},
		{"id":"42b8efb7168d171a","fromNode":"c4d82ff3e837b284","fromSide":"left","toNode":"e2d623b8a580162c","toSide":"right"},
		{"id":"5e982d0928b2e9e9","fromNode":"200a0a35b8171b4c","fromSide":"bottom","toNode":"6bbb08f8cb881a51","toSide":"top"},
		{"id":"4cc1b7c4862aafd9","fromNode":"40d21f642132b8a5","fromSide":"right","toNode":"4f0a66cffc04f4b7","toSide":"left"},
		{"id":"00512290dc8b1ec4","fromNode":"4f0a66cffc04f4b7","fromSide":"right","toNode":"bc8aed2be00fab71","toSide":"left"},
		{"id":"eeafae71810e122b","fromNode":"22fde4c3c84b5341","fromSide":"right","toNode":"292e05f4eedbd7df","toSide":"left"},
		{"id":"cfc540ad07c6ac4e","fromNode":"22fde4c3c84b5341","fromSide":"bottom","toNode":"cf79141c401ed7a2","toSide":"top"},
		{"id":"7455ed3165d4d73a","fromNode":"292e05f4eedbd7df","fromSide":"bottom","toNode":"cf79141c401ed7a2","toSide":"top"},
		{"id":"5ff07159944809dd","fromNode":"968292c8e83a3c50","fromSide":"right","toNode":"62496e888409827e","toSide":"left"},
		{"id":"4dbacf2254796aa3","fromNode":"62496e888409827e","fromSide":"right","toNode":"43287bf6239e8a06","toSide":"left"},
		{"id":"aa1bcaf95022b1b0","fromNode":"43287bf6239e8a06","fromSide":"top","toNode":"85df093a330bf129","toSide":"bottom"},
		{"id":"30788e3da3b5174a","fromNode":"43287bf6239e8a06","fromSide":"bottom","toNode":"46fd9ae947b2e8bc","toSide":"top"},
		{"id":"30c69aab5e35b8b3","fromNode":"43287bf6239e8a06","fromSide":"right","toNode":"70a291915134a31e","toSide":"left"},
		{"id":"446f8ac99dd47071","fromNode":"329c39789159c25f","fromSide":"bottom","toNode":"22fde4c3c84b5341","toSide":"top","fromEnd":"arrow"},
		{"id":"2e74fb117ef4fef8","fromNode":"fc29e282c8934010","fromSide":"bottom","toNode":"258deaa8c6cd5b2c","toSide":"left"},
		{"id":"9a7b06819284b0fa","fromNode":"4ecf6e84c27eefab","fromSide":"left","toNode":"4001807b0ef5ec56","toSide":"right"},
		{"id":"f0f6c9b150469bd1","fromNode":"0e4d8fe89b554b49","fromSide":"left","toNode":"6c3ba07e993ec188","toSide":"right"},
		{"id":"1f1481380d06822e","fromNode":"2a9b9c170774f579","fromSide":"left","toNode":"16618beda3da0513","toSide":"right"},
		{"id":"89d52e9b938a2f8b","fromNode":"16618beda3da0513","fromSide":"top","toNode":"71ab0ea4434a54bc","toSide":"bottom"},
		{"id":"991e0d420ca51ed6","fromNode":"1de20a395d19c219","fromSide":"top","toNode":"d100b02353e9602a","toSide":"bottom"},
		{"id":"ac617c28677b63c7","fromNode":"0e4d8fe89b554b49","fromSide":"top","toNode":"c1c53488a2e8bc86","toSide":"bottom"},
		{"id":"0cb2026074e7aaf1","fromNode":"0e4d8fe89b554b49","fromSide":"bottom","toNode":"20d719242a16b6d6","toSide":"top"},
		{"id":"2a59ad20d67cc9ee","fromNode":"0e4d8fe89b554b49","fromSide":"right","toNode":"177ff5d536f7a0f8","toSide":"left"},
		{"id":"3bfe049de2dfeb9a","fromNode":"fc29e282c8934010","fromSide":"bottom","toNode":"177ff5d536f7a0f8","toSide":"right"},
		{"id":"963510f85edceffd","fromNode":"177ff5d536f7a0f8","fromSide":"bottom","toNode":"ad8208c1fc1416c4","toSide":"top"},
		{"id":"b79829695736269d","fromNode":"177ff5d536f7a0f8","fromSide":"bottom","toNode":"304a91e6af8a93cc","toSide":"top"},
		{"id":"623002e5ab18e398","fromNode":"ad8208c1fc1416c4","fromSide":"right","toNode":"304a91e6af8a93cc","toSide":"left"},
		{"id":"0b4c3d33d414c55f","fromNode":"cf79141c401ed7a2","fromSide":"left","toNode":"994843ccad7ad32e","toSide":"right"},
		{"id":"13a256c8ca2a7f13","fromNode":"ab5bdfb7e15861eb","fromSide":"bottom","toNode":"994843ccad7ad32e","toSide":"top"},
		{"id":"5bca6ac3cc358862","fromNode":"200a0a35b8171b4c","fromSide":"left","toNode":"4001807b0ef5ec56","toSide":"bottom","fromEnd":"arrow"},
		{"id":"44a261c2d5b30732","fromNode":"ce361acbec560316","fromSide":"top","toNode":"3ad40ef17e537893","toSide":"bottom"},
		{"id":"51f710f0bec184ac","fromNode":"6d0a42604e6ee149","fromSide":"right","toNode":"582e278871552f6e","toSide":"left"},
		{"id":"e2560885616e9f38","fromNode":"6c3ba07e993ec188","fromSide":"left","toNode":"1eb5d065b22c8566","toSide":"right"},
		{"id":"01ee85003d88398a","fromNode":"ce361acbec560316","fromSide":"top","toNode":"8dbd71848e564c60","toSide":"bottom"},
		{"id":"184a15abf211c880","fromNode":"2ecba2716d7cab9c","fromSide":"right","toNode":"8dbd71848e564c60","toSide":"top"},
		{"id":"03c75528b84852a2","fromNode":"6d0a42604e6ee149","fromSide":"left","toNode":"8dbd71848e564c60","toSide":"top"},
		{"id":"17a49403207b0be7","fromNode":"ce361acbec560316","fromSide":"bottom","toNode":"13020eedc31b0375","toSide":"top"},
		{"id":"f5b1bcc22c087437","fromNode":"ce361acbec560316","fromSide":"right","toNode":"329c39789159c25f","toSide":"left"},
		{"id":"3b0bb5358ac03ad2","fromNode":"ce361acbec560316","fromSide":"bottom","toNode":"74b578ea8abd98a3","toSide":"top"},
		{"id":"2516e5b5c87f96fe","fromNode":"110ba0ffd13f693d","fromSide":"bottom","toNode":"29793c1823f5c66e","toSide":"top"},
		{"id":"2616f212836ea49b","fromNode":"3ad40ef17e537893","fromSide":"right","toNode":"110ba0ffd13f693d","toSide":"left"},
		{"id":"bbf62d574cdcc26b","fromNode":"29793c1823f5c66e","fromSide":"bottom","toNode":"1a4f1db63437aa7f","toSide":"top"},
		{"id":"b941ac90cb36d06a","fromNode":"3ad40ef17e537893","fromSide":"right","toNode":"1a4f1db63437aa7f","toSide":"left"},
		{"id":"4511ce3c39918e7b","fromNode":"329c39789159c25f","fromSide":"right","toNode":"6932e83741fba37b","toSide":"left"},
		{"id":"f1d618bc562cfb18","fromNode":"6932e83741fba37b","fromSide":"top","toNode":"1e4796adb210de61","toSide":"bottom"}
	]
}