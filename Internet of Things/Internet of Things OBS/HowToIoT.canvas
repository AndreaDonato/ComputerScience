{
	"nodes":[
		{"id":"1e3fd2b7a4b6a7cc","type":"text","text":"# HowTo Build IoT Networks\n\nPur essendo molto diversi fra loro, tutti i sistemi IoT poggiano sulla stessa architettura:\n\n- ***Cloud*** - Il cervellone che ha il quadro completo della situazione e sa cosa fare si trova su Internet. Per raggiungere i dispositivi deve passare attraverso il loro Gateway;\n\t- Se il sistema è complesso, può distribuirsi sul territorio tramite i ***fog nodes***.\n- ***Gateway*** - Comunica con il Cloud tramite protocolli Internet (TCP/IP), e con i dispositivi tramite protocolli locali (e.g. BLE, ZigBee, WiFi, 6LoWPAN);\n\t- Nota che il Gateway tendenzialmente non è il router domestico, piuttosto un hub che accede ad Internet tramite esso e poi si interfaccia con i dispositivi con BLE.\n- ***Embedded Devices*** - I dispositivi veri e propri (***Things***).\n\nNel complesso, possiamo individuare una ***stack protocollare*** propria delle reti IoT.","x":-1760,"y":-1000,"width":759,"height":387,"color":"6"},
		{"id":"ff3b9035a56b4e9e","type":"text","text":"# Things\n\nUna Thing ha bisogno di fare essenzialmente tre cose:\n\n1. ***Percepire l’ambiente*** - Un ***sensore*** sfrutta un fenomeno fisico (e.g. una resistenza che varia in funzione del calore) per convertire la misura da prendere in un segnale EM. Successivamente, un ADC converte il segnale da analogico a digitale, e tramite un *protocollo/architettura* ad-hoc i dati vengono inviati al processore;\n\t- Li chiamo *protocolli/architetture* perché non definiscono solo cose tipo \"`prima di mandare il segnale successivo aspetta il colpo di clock`\", ma anche il numero e lo scopo dei fili utilizzati per farlo. Questo significa che per parlare la lingua di un certo protocollo, il microcontrollore deve avere l'HW adatto!\n\t\t- ... o quasi. Esistono modi per emulare il comportamento di un protocollo via SW, motivo per cui si chiamano \"protocolli\" e non \"*protocolli/architetture*\".\n\t- Tra i più noti citiamo ***SPI*** (**Serial Peripheral Interface**, velocissimo ma richiede tanti fili), ***I2C*** (**Inter-Integrated Circuit**, lento ma ne richiede meno) e ***UART*** (**Universal Asynchronous Receiver-Transmitter**, come dice il nome si usa per la compatibilità).\n2. ***Interagire fisicamente*** - Un ***attuatore*** funziona intuitivamente al contrario: riceve un segnale dal processore (per come descritto sopra), eventualmente converte in segnale analogico con un DAC e passa il risultato al motore, che si muove di conseguenza;\n\t- Dico \"eventualmente\" perché non tutti i motori funzionano con segnali analogici. È un attuatore anche uno switch che modifica un circuito elettrico;\n\t- I requisiti vanno dalla reattività real-time alla robustezza a condizioni atmosferiche.\n3. ***Elaborare dati e prendere decisioni locali*** - Il cuore di un sistema informatico è sempre il processore. Qui distinguiamo tra due tipi di architetture:\n    - ***MCU*** (***Microcontroller Unit***) - Un singolo chip che contiene CPU, memorie e periferiche (e.g. SPI, I2C). Consuma poco ed è ottimizzato per task specifici (i.e. esegue un singolo programma, senza SO). Ne è un esempio ***ESP32***, utilizzato per le lampadine smart, ma anche ***Arduino***;\n    - ***MPU*** (***Microprocessor Unit***) - Letteralmente la CPU che metti nel tuo computer, che deve appoggiarsi ad una MoBo e che quindi è in grado di reggere roba complessa come un SO Linux. Ovvio che in IoT la MoBo deve essere piccolissima: meglio parlare di ***System-on-Chip*** (***SoC***), che differisce da una classica MoBo perché non è affatto scalabile o espandibile (... è letteralmente un chip già saldato). Ovviamente si usa RISC, e un esempio tipico è il ***Raspberry Pi***.","x":-1760,"y":120,"width":759,"height":911,"color":"4"},
		{"id":"54d0a7ecb87b5c26","type":"text","text":"# Internet of Things (IoT)\n\nCon la ***miniaturizzazione dei processori*** che permette di inserire intelligenza praticamente ovunque e ***IPv6*** che permette di assegnare un indirizzo univoco a $O(10^{38})$ dispositivi, è facile immaginare un mondo in cui qualsiasi oggetto può collegarsi ad Internet.\n\n***Internet of Things*** (***IoT***) è il successore di quello che oggi conosciamo come Internet: se ai nodi aggiungiamo ***sensori*** per monitorare l'ambiente e ***attuatori*** per modificarlo, di fatto estendiamo il concetto di ***servizio*** (e.g. mail, video) a un qualcosa che viene materialmente fatto (in modo automatico e ottimizzato) nel mondo materiale di tutti i giorni (e.g. domotica).\n\nEssendo tanti, l'intelligenza e l'autonomia media di un singolo nodo IoT è abbastanza bassa. Questo apre a tutta una serie di problemi sulla sicurezza della comunicazione hop-to-hop e sulla necessità di protocolli energy-efficient ad hoc (e.g. da ***BLE*** a ***6LoWPAN***).","x":1320,"y":-1000,"width":759,"height":387,"color":"6"},
		{"id":"032d9aeb665be7c1","type":"text","text":"\n## **4. Problemi Aperti e Considerazioni Finali**\n\n### **4.1. Sicurezza e Privacy**\n\n- **Causa:** L’IoT spesso lavora con dati sensibili (sanità, sorveglianza, automobili connesse).\n    \n- **Effetto:** Servono protocolli di sicurezza **leggeri ma efficaci** (es. DTLS, crittografia elliptic curve per dispositivi a bassa potenza).\n    \n\n\n**Approfondimenti consigliati:**\n\n- Ricerca su **Bin Packing Problem** e tecniche di risoluzione (branch-and-cut, metaeuristiche).\n    \n- Studio di protocolli MQTT e CoAP per comprendere le differenze pratiche.\n    \n- Analisi di casi studio reali di fog computing per applicazioni industriali.","x":2520,"y":-459,"width":1055,"height":332},
		{"id":"a8dcb3193cec51a3","type":"text","text":"# L7 & L8\n\nInformation Theory, vedi quaderno","x":2160,"y":897,"width":720,"height":320},
		{"id":"bb5a7945372dc391","type":"text","text":"# L5 & L6\n\nSaltate, vedi slides","x":2160,"y":540,"width":720,"height":320},
		{"id":"442ecb8952c528e2","type":"text","text":"## cortex (il malvagio)\n\ntutti ARM. Memory Protection Unit fa switch tra  user e kernel mode.\nDMA (vedi sistemi operativi immagino)\nvbb è tutto un ripassone di cose (+ specifiche processori cortex) fino a slide 27, poi entra in dettaglio sugli interrupt (e.g. int. request (IRQ) - viene dal sensore, è il più comune) con tutta la parte tecnica (yeee).\nirrisorie differenze in costi diventano gargantuesche se moltiplicate per il numero di things. segue esempio. ma non su questo! sul fatto che tra sleep ed active consumption passa un universo mondo di potenza. poi aggiunge lo stato di transizione tra sleep  ed active (non ditelo a Donald).","x":1320,"y":70,"width":759,"height":315},
		{"id":"2ce83f8e9814f3bc","type":"file","file":"IoT_Architecture.png","x":-776,"y":-1260,"width":632,"height":387},
		{"id":"d51f893becdde7b8","type":"text","text":"# Teoria dell'Informazione","x":1320,"y":-1871,"width":759,"height":340},
		{"id":"617bc5508509a069","type":"text","text":"# Microcontrollori CortexM\n\nQuesta famiglia di microcontrollori ha dato una bella spinta allo sviluppo di IoT dal 2004.\n\nSono tutti basati su architettura `ARM` a `32 bit`, dal più semplice e meno energivoro `M0` ai più avanzati `M7`, che contengono supporto per **Digital Signal Processing** (**DSP**, che serve per l'elaborazione *real time* di immagini, audio e controlli di attuatori robotici) e `float`.\n\nTutti hanno in comune la gestione dei registri (`r0`$\\to$`r15`, di cui gli ultimi tre sono `Stack Pointer`, `Link Register`, che sarebbe `Return Address`, e `Program Counter`), e della memoria (in sequenza, `Flash`, `SRAM`, `Periferiche` e `Registri`). Alcuni implementano `User/Kernel Mode` e conseguente `Memory Protection Unit` (`MPU`) per impedire l'accesso all'area riservata al `Kernel`.\n\ncioè un microcontroller può avere RAM, ROM, Flash, EEPROM, NVRAM (RAM per operazioni temporanee. Flash ROM o EEPROM per firmware e dati persistenti)\n\nci stanno anche le porte I/O...\n\nse hai voglia, slides 3_2 n 23+\n\nUn’interruzione è un evento (es. un sensore che invia un segnale) che forza la CPU a:\n\n1. **Sospendere l’esecuzione attuale**\n2. **Passare in Kernel Mode**\n3. **Eseguire un Interrupt Service Routine (ISR)**\n4. **Riprendere il programma precedente**\nLe interruzioni hanno 3 stati:\n- **Inattivo:** Nessun evento\n- **Pending:** L’interruzione è avvenuta, ma la CPU non l’ha ancora gestita\n- **Attivo:** Il codice ISR sta risolvendo l’interruzione\nEsempi di sorgenti di interrupt:\n- **Hardware:** ADC, Timer, GPIO\n- **Software:** divisioni per zero, errori di memoria\n\nTutte le interruzioni sono associate a un indirizzo specifico memorizzato in una **IVT (Interrupt Vector Table)**, che mappa le interruzioni ai loro handler.\n\n**Gestione della priorità:** Se due interrupt arrivano contemporaneamente, quello con priorità più alta viene gestito per primo.","x":-751,"y":120,"width":759,"height":911,"color":"3"},
		{"id":"03e26affba62b324","type":"text","text":"# Esempi di MCU Cortex-Based\n\n\nNonostante siano un po' datati, restano ad oggi un punto di riferimento per applicazioni che richiedono basso consumo energetico. Esempi di configurazioni sono\n\n- ***Atmel SAM4L (Cortex-M4)*** - Consuma $4.3 \\text{ mA @ }48 \\text{ MHz}$ (i.e. alla velocità massima di $48\\times10^3$ colpi al secondo assorbe $4.3\\text{ mA}$) e supporta USB, SPI, I2C, UART e 15 canali di DMA (i.e. mette una CPU potente e ne ottimizza l'uso permettendo alle periferiche di bypassarla con un accesso diretto a memoria, se il suo intervento non è necessario);\n\t- Possiamo risalire all'assorbimento di corrente per ciclo di clock:$$I_C={4.3 \\cdot 10^{-3}\\text{ A/s}\\over48 \\cdot 10^6\\text{ Cycle/s}}\\simeq0.09\\,\\mu\\text{A/Cycle}$$\n\t- Sì, la gente in Computer Science non sa usare le dimensioni.\n- ***Nordic nRF51 (Cortex-M0 + BLE)*** - CPU meno potente ($\\sim 2.6 \\text{ mA/s @ }16 \\text{ MHz}$) che però va usata più spesso. Inoltre, abbiamo un sistema di trasmissione BLE che usa fino a $16 \\text{ mA @ TX}$ (i.e. $16 \\text{ mA}$ per trasmissione).\n\t- Questa CPU ha un costo più alto per ciclo di clock, ma va più lenta:$$I_C={2.6\\cdot 10^{-3}\\text{ A/s}\\over16 \\cdot 10^6\\text{ Cycle/s}}\\simeq0.16\\,\\mu\\text{A/Cycle}$$\n\t- Perché mai realizzare un processore che consuma più corrente per ciclo e poi mettergli un clock più lento? L'`M0` è realizzato usando meno transistor rispetto all'`M4`. Se da un lato questo lo rende meno ottimizzato (è costretto a fare le stesse operazioni in più cicli), dall'altro questo riduce le ***leakage currents*** (i.e. quelle micro-correnti che determinano il consumo quando il processore è in ***sleep mode***, che sono proporzionali al numero di transistor). In pratica, l'`M0` è ottimale se va usato poco, cosa che accade se il focus è su BLE;\n\t\t- Nota che questo effetto di leak in sleep mode è tanto più presente quanto più riduciamo le dimensioni dei transistor, per effetto del tunneling quantistico.\n\t- Piccolo ***focus su BLE***: trasmette pacchetti di dimensione fissa, e tipicamente non lo fa in modo continuativo. Ogni trasmissione dura di norma $\\sim 1\\text{ ms}$, e se ad esempio trasmettesse una volta al secondo (i.e. ***duty cycle*** di ${1\\text{ ms}/1\\text{ s}}=0.001$) avremmo qui (e sottolineo qui, perché quel $16 \\text{ mA @ TX}$ dipende dall'HW e dalla configurazione) un consumo di $16 \\text{ mA}\\times0.001 = 16\\,\\mu\\text{A}$.","x":258,"y":120,"width":759,"height":911,"color":"4"},
		{"id":"c39cda918518baad","type":"text","text":"# Sleep Mode\n\nIn ***Sleep Mode*** il processore attua una serie di comportamenti per ridurre i consumi:\n\n- ***Clock Gating*** - Disattiva il clock su alcune unità, che smettono quindi di assorbire corrente (e.g. se non serve il DAC, evito di farlo girare a vuoto);\n- ***Power Gating*** - Stacca l'alimentazione da alcune unità (e.g. in una CPU multi-core, può non essere sempre necessaria tutta la potenza computazionale parallela);\n- ***Dynamic Voltage and Frequency Scaling*** (***DVFS***) - Se non devo effettuare calcoli complessi, posso ridurre la tensione e la frequenza di clock (e.g. smartphones).\n\nTutto questo viene implementato in modo massiccio su ***MPU***, mentre su MCU il discorso è più complesso. Intanto tocca complicare l'HW (e non è scontato poterlo fare). Inoltre, un MCU ha bisogno di reagire in tempo reale agli interrupt dei sensori, evitando latenze dovute a lenti processi di risveglio (***wakeup latency***). Spesso gli MCU implementano direttamente il ***Deep Sleep*** (riduce le attività sia della CPU che della RAM) o l'***Ibernazione*** (salva lo stato su memoria non volatile e spegne tutto).\n\nIl fatto che su MCU ci sia meno margine per entrare in Sleep Mode non deve ingannare: essendo dispositivi ottimizzati, sono comunque loro che consumano di meno!\n\nOvviamente il consumo energetico non si azzera in Sleep Mode, per diversi motivi:\n\n- Anche se faccio Clock Gating, gli elementi circuitali esclusi sono comunque alimentati da una tensione (posso staccarla facendo Power Gating, ma in quel caso cancello tutti i bit!), che per effetti quantistici sulle giunzioni dei transistor continua a far scorrere una piccola ***leakage current*** (la quale aumenta esponenzialmente con la temperatura);\n- Anche il Power Gating può avere perdite minime sul transistor \"ponte\", che serve a staccare/riattaccare la corrente alla zona in sleep;\n- In ogni caso, non potrei mai spegnere completamente tutto il processore: ho sempre bisogno di qualcosa di attivo che riattivi gli elementi in sleep.","x":-751,"y":1280,"width":759,"height":773,"color":"4"},
		{"id":"4c794fe5a6070164","type":"file","file":"SAM4L_Modes.png","x":258,"y":1266,"width":759,"height":304},
		{"id":"a94d060ea349fc00","type":"text","text":"# Efficienza Energetica\n\nMolti dispositivi IoT sono alimentati a batteria, ed ogni milliwatt risparmiato prolunga la durata operativa. Questo costituisce sempre un trade-off tra il consumo e la precisione dei sensori (se devo spegnerli ogni `tot` per ridurne il consumo rischio di perdere dati utili, ma per risparmiare posso anche ridurre i bit di precisione o la frequenza di campionamento).\n\nSi rende efficiente un sistema embedded implementando la Sleep Mode e ottimizzando il codice, l'uso dei sensori e delle strategie di comunicazione.","x":-1760,"y":1536,"width":759,"height":261,"color":"6"},
		{"id":"d11ebd7b1efd8ff7","type":"text","text":"# Ottimizzazione del Codice e Riferimenti\n\nChiaro che è il codice a decidere quando andare in Sleep Mode e quando trasmettere. Questo si traduce nell'ottimizzare i periodi di ***idle*** (i.e. quando conviene disattivare cosa) e quelli di ***tempo attivo*** (i.e. se sono sveglio, allora devo fare più cose possibile).\n\n- ***Parallelismo*** - Riduce il tempo attivo eseguendo operazioni in parallelo;\n- ***Batching*** - Aspetto di avere tante cose da fare prima di attivarmi. Questo ottimizza i costi di accensione/spegnimento, riducendo la frequenza delle transizioni di stato (i.e. `ON`, `IDLE` e `HIGH DUTY`, e.g. un protocollo come BLE preferisce inviare 10 pacchetti ogni secondo piuttosto che 1 ogni decimo di secondo). Questo di fatto ottimizza il ***Duty Cycle***: il dispositivo non misura/attua/invia/riceve costantemente, ma a intervalli regolari diluiti nel tempo;\n- ***Event-Driven Sampling*** - I sensori si attivano o comunicano dati solo in risposta ad un cambiamento significativo (e.g. uno smartphone accende il giroscopio solo se l'accelerometro rileva una forte accelerazione, o un termostato comunica con il gateway solo se ci sono variazioni di temperatura).\n\nAbbiamo poi due branche che si occupano di ridurre l'overhead di comunicazione:\n\n- ***Compressione dati*** - Trasmettere meno dati per trasmissione significa meno energia spesa per la comunicazione (cfr. ***Teoria dell'Informazione***);\n- ***Edge Computing*** - Ottimizza il numero di trasmissioni sulla rete (cfr. ***Fog Computing***).","x":-2769,"y":1280,"width":759,"height":773,"color":"4"},
		{"id":"43767a936de8e8b1","type":"text","text":"# Da dove prendo l'Energia?\n\nPotrei farlo da diverse fonti. Partiamo con l'escludere il caso in cui riesco a connettermi direttamente alla rete elettrica, perché è banale: posso permettermi alti consumi, quindi verosimilmente uso un MPU. Restano due scenari principali, in cui si usano gli MCU:\n\n- ***Batterie*** - Soluzione alla quale si cerca con sempre più forza di trovare un'alternativa. Hanno capacità limitata, e il loro sviluppo in termini di potenza erogata su dimensioni non sta dietro all'esponenziale evoluzione dei dispositivi embedded. Si cerca quindi di ridurre i consumi energetici a tutti i costi, ma questo si traduce in minore potenza di calcolo e velocità di trasmissione;\n- ***Energy Harvesting*** - Idea in via di sviluppo che prevede di raccogliere l'energia dall'ambiente in cui il dispositivo è immerso.\n\t- Questo può, a seconda dell'architettura,\n\t\t- eliminare l'uso delle batterie. Parliamo di uno schema ***Harvest-Use***, i.e. uso in diretta l'energia che raccolgo, se non ce n'è abbastanza mi spengo;\n\t\t- limitare l'uso delle batterie. Schema ***Harvest-Store-Use***, i.e. accumulo energia anche quando non sono attivo per usarla successivamente (in pratica è una batteria ricaricabile).\n\t- Il concetto di fonte di energia va dal fotovoltaico/termoelettrico/eolico al calore e al movimento corporeo.","x":-1760,"y":2288,"width":759,"height":565,"color":"4"},
		{"id":"cc865f4cd6000ab4","type":"text","text":"# ARM (Architettura degli Elaboratori)\n\nArchitettura poco energivora, quindi particolarmente adatta a smartphone e tablet (è infatti utilizzata da praticamente tutti i produttori, da Apple a **Samsung** e **Huawei**), come pure a smartwatch, dispositivi *embedded* e di tipo *Internet of Things* (come *Raspberry Pi*).\n\nARM ha sviluppato nel tempo diverse ISA, volte principalmente a migliorare l'efficienza del codice e il consumo di memoria, ma soprattutto nel 2011 ha rilasciato la propria estensione a 64 bit, **ARMv8**, dando un forte impulso all'industria dei dispositivi portatili.","x":-751,"y":-376,"width":759,"height":261,"color":"4"},
		{"id":"c7e2f44140b2cd8e","type":"text","text":"   ### **2.2. Network Layer (Comunicazione e Trasporto Dati)**\n   \n- **Particolarità:** A differenza di TCP/IP classico, qui il livello di rete può **conservare dati** (data storage).\n\n### **2.4. Application Layer (Analisi e Automazione)**\n\n- **Causa:** I dati aggregati devono essere interpretati e usati per prendere decisioni.\n- **Effetto:** Si utilizzano protocolli di comunicazione applicativa come MQTT (publish-subscribe) o CoAP (REST).\n\n**CAUSA:** Un singolo dispositivo è inutile senza un’infrastruttura di comunicazione.\n**EFFETTO:** Servono protocolli di rete e standard per la trasmissione dati.\n\n- **Connettività**: BLE consuma meno energia di WiFi, ma ha un range più corto.\n    \n\n## 5. Protocolli di comunicazione\n\nI dispositivi IoT devono scambiarsi dati in modo efficiente. I protocolli sono scelti in base a **consumo energetico, latenza, scalabilità e sicurezza**.\n\n### Principali protocolli\n\n- **MQTT**: Leggero, basato su publish/subscribe, perfetto per connessioni instabili.\n- **CoAP**: Simile a HTTP ma ottimizzato per dispositivi a basso consumo.    \n- **Zigbee e LoRa**: Utilizzati per reti mesh e lungo raggio.\n    \n\n### Causa-effetto nella scelta del protocollo\n\n- **MQTT vs. HTTP**: HTTP è pesante e non adatto a IoT, mentre MQTT è ottimizzato per reti intermittenti.    \n- **Zigbee vs. WiFi**: Zigbee è ottimo per dispositivi a basso consumo ma con throughput ridotto.\n\n\n1. **CAUSA:** L’IoT richiede comunicazioni leggere ed efficienti, spesso su reti con poca banda.\n2. **EFFETTO:** MQTT (Message Queuing Telemetry Transport) usa un modello publisher/subscriber per trasmettere dati in modo efficiente.\n\n- Un \"publisher\" (es. un sensore) invia dati a un \"broker\".\n- I \"subscriber\" (es. altri dispositivi o server) ricevono solo i dati di loro interesse\n- Questo riduce il traffico di rete e il consumo energetico.\n\n### **4. Comunicazione e consumo energetico**\n\nQuando un dispositivo trasmette dati (WiFi, Bluetooth, LoRa, ZigBee...), consuma energia. La trasmissione RF è spesso uno dei principali colli di bottiglia energetici.\n\n- **WiFi:** Alta potenza, ma alta velocità\n    \n- **BLE (Bluetooth Low Energy):** Ottimizzato per consumi ridotti, ma a corto raggio\n    \n- **LoRa:** Ideale per lunghe distanze e consumi bassissimi, ma bassa velocità\n    \n\nStrategie per ridurre il consumo:\n\n- Trasmettere meno spesso\n- Usare protocolli a basso consumo (MQTT, CoAP)\n- Ridurre la potenza del segnale se non serve lungo raggio\n\n","x":-4540,"y":-1560,"width":930,"height":1358},
		{"id":"2d43e95958d0e621","type":"text","text":"# Stack Protocollare IoT\n\nL'Internet serve alle Things per comunicare comandi e dati raccolti. Come?\n\nLa stack protocollare TCP/IP è un po' un'overkill per questo tipo di applicazione. Ne usiamo una semplificata che specchia l'architettura di base, che consta di\n\n- ***Sensor/Perception Layer*** (***Edge***) - Il layer delle Things vere e proprie. Qui di norma vengono impacchettati un botto di dati da inviare al gateway;\n\t- Per via della limitata potenza delle Things, è difficile fare preprocessing a livello di Edge Computing. Al più, i sensori provano a mandare i dati solo quando servono (i.e. provano a fare ***Batching***, cfr. ***Efficienza Energetica***).\n- ***Gateway/Network Layer*** (***Fog***) - Qua si fondono il DLL e il Network Layer di TCP/IP, perché ***IPv6*** unifica MAC e IPv4. La logica resta quella di un ***gateway*** che media l'accesso ad Internet per conto delle Things, ma solo perché queste non sono abbastanza potenti da gestire una connessione completa;\n\t- Qui si alleggerisce il carico del Cloud tramite ***Fog Computing*** (i.e. preprocessing in vista dell'arrivo al Cloud). Questa architettura mira a garantire la scalabilità del sistema. Tipicamente un gateway è anche un ***fog node***;\n\t- I protocolli includono roba come ***Wi-Fi*** e ***BLE***, su IPv6. Cito questi perché essendo standard garantiscono compatibilità, ma in generale posso costruirne a piacimento: la scelta del protocollo di Network è dettata dalla specifica applicazione, perché è sempre un ***trade-off tra potenza e portata*** (stando ovviamente attenti alla complessità di comunicazione).\n- ***Application Layer*** (***Cloud***) - Come l'omonimo TCP/IP, qui troviamo i protocolli di alto livello. L'idea cardine di questo layer in versione IoT è che un protocollo come `HTTP` è troppo pesante e non tollera disconnessioni frequenti (cosa che invece qui accade). Abbiamo quindi un paio di sue varianti:\n\t- ***MQTT*** (**Message Queuing Telemetry Transport**)\n\t- ***CoAP*** (**Constrained Application Protocol**)\n\n<span style=\"color:rgb(236, 155, 14)\">Queste ultime sembrano basarsi su TCP/UDP, ma qui non ci sta il transport layer!! Che succede?</span>\n","x":-3278,"y":-1227,"width":759,"height":842,"color":"4"},
		{"id":"1f0970b33a4cb76f","type":"file","file":"NetworkProtocols.png","x":-3278,"y":-1937,"width":759,"height":408},
		{"id":"469a1094f676e542","type":"text","text":"# Sicurezza\n\nI dispositivi IoT, in quanto dispositivi connessi alla rete, sono vulnerabili a cyber-attacchi e manipolazioni fisiche. Questo rende necessario implementate misure di sicurezza HW e SW.\n\nChiaro, ma cosa c'è di nuovo? Il fatto è che questi dispositivi sono poco potenti, quindi devo limitarmi a protocolli leggeri ed efficienti.\n\n#### TPM (Trusted Platform Module) (HW)\n1. **CAUSA:** Un attaccante può tentare di modificare il software di un dispositivo per prenderne il controllo.\n2. **EFFETTO:** TPM immagazzina chiavi crittografiche in hardware per proteggere l’integrità del dispositivo.\n\n- TPM genera e protegge chiavi di crittografia.\n- Può autenticare l’hardware impedendo modifiche non autorizzate.\n   \n##### Secure Boot (HW/SW)\n1. **CAUSA:** Un firmware modificato può compromettere l’intero sistema.\n2. **EFFETTO:** Secure Boot verifica la firma digitale del firmware prima di avviarlo.\n   \n**Motivi per aggiornare il firmware:**\n\n- Correggere vulnerabilità di sicurezza.\n- Aggiungere nuove funzionalità senza sostituire l’hardware.\n\n#### Autenticazione e controllo accessi\n1. **CAUSA:** Senza autenticazione, chiunque potrebbe accedere ai dispositivi IoT.\n2. **EFFETTO:** Si usano metodi come password, certificati digitali e autenticazione a due fattori.\n   \n- Un termostato smart richiede autenticazione prima di essere controllato da remoto.\n- Un sistema di videosorveglianza cifra i dati per impedire accessi non autorizzati.\n\n\n\n## 6. Sicurezza nei dispositivi IoT\n\nLa sicurezza è un problema critico: un dispositivo IoT vulnerabile può compromettere un’intera rete.\n\n### Strategie di sicurezza\n\n- **Secure Boot**: Impedisce che firmware malevoli vengano eseguiti → fondamentale perché molti dispositivi IoT devono aggiornarsi da remoto (OTA updates).\n    \n- **Trusted Platform Module (TPM)**: Hardware dedicato alla crittografia e protezione delle chiavi → essenziale per autenticazione sicura.\n    \n- **Autenticazione e controllo accessi**: Limitare chi può accedere ai dispositivi per prevenire attacchi.\n    \n\n### Causa-effetto nella sicurezza\n\n- **Un firmware non autenticato può compromettere l’intera rete** → Secure Boot impedisce esecuzione di codice non verificato.\n    \n- **Un dispositivo compromesso può diffondere malware** → TPM protegge chiavi crittografiche.\n    \n- **L’uso di password deboli facilita attacchi** → Autenticazione forte e aggiornamenti regolari.\n    ","x":-3449,"y":-202,"width":1360,"height":1287},
		{"id":"24e729d51fa94980","type":"text","text":"\nil NL è un po' diverso da quello di TCP/IP, può fare addirittura data storage. BLE e WiFi sono considerati protocolli di questo layer\n\n\n### **4.2. Standardizzazione e Interoperabilità**\n\n- **Causa:** Ogni produttore usa formati di dati e protocolli diversi.\n    \n- **Effetto:** Si cerca di definire standard unificati (es. Open Connectivity Foundation, MQTT, CoAP).\n    \n\n### **4.3. Adattabilità ai Cambiamenti Ambientali**\n\n- **Causa:** I nodi fog possono spegnersi, cambiare posizione o avere variazioni di capacità.\n    \n- **Effetto:** I sistemi devono essere **dinamici** e adattarsi ai cambiamenti in tempo reale.\n    ","x":-4200,"y":-2340,"width":643,"height":540},
		{"id":"d700a52cca1cdc2a","type":"text","text":"# Fog Computing\n\nUna rete IoT può essere usata per gli obiettivi più disparati, e che per questo sia HW che SW sono fortemente specifici dell'applicazione.\n\nViene quindi naturale capire che in una rete IoT complessa in cui vanno elaborati i dati di dispositivi ***eterogenei*** (i.e. diversi sensori producono diversi formati di output, il che in pratica porta a dire che nel complesso i ***dati*** sono ***non-strutturati***) è scomodo far gravare tutto il peso di un'analisi dati fortemente diversificati su un unico server centrale. Questo problema viene risolto con i ***fog nodes***, i.e. distribuisco il server di analisi dati. Il ***Fog Computing*** è in pratica una via di mezzo tra l'Edge Computing e il Cloud Computing, in cui sono i ***gateway*** stessi a pre-processare i dati prima di inviarli al Cloud.\n\nTutto molto bello, ma c'è un problema: ogni sensore genera un carico di lavoro variabile, e i fog nodes hanno capacità limitate. Tradotto, bisogna assegnare dinamicamente le richieste dei sensori al fog node ottimale per evitare colli di bottiglia.\n\nQuesto è un ***Bin Packing Problem*** (o `0-1 Knapsack Problem`), pertanto $\\NPC$.\n\n","x":-1760,"y":-2220,"width":759,"height":580,"color":"3"},
		{"id":"ea6c2db0218bf20e","x":-1760,"y":-3260,"width":759,"height":805,"type":"text","text":"# Fog Node Assignment come ILP"},
		{"id":"ad40467c90bb74c9","type":"text","text":"# ILP\n\n\n- N sensori $s_i$ cui corrispondono risorse richieste $r_i$\n- un dispatcher D raccoglie i dati e li manda ad un fog node.\n- F fog nodes $f_j$ che richiedono risorse $g_j$ e che di conseguenza a $g_j$ hanno costi $c_j$\n\t- Tipicamente $N<<F$\n- D conosce i costi di ciascun fog node, e cerca di ottimizzare la data distribution.\n\n Definiamo $y_j$ come 1 sse usiamo il fog $f_j$, ed $x_{ij}$ se una task di $s_i$ è offloaded su $f_j$. Il compito di D è trovare la soluzione di$$\\min_y\\sum_jy_j\\,c_j$$il che ovviamente minimizza il costo complessivo. Mancano i constraints, perché così com'è la soluzione migliore è scegliere $y$ identicamente nullo. Allora mettiamo$$\\sum_jx_{ij}=1$$i.e. voglio che tutti i task siano eseguiti, inoltre non posso eccedere la capacità totale di ciascun fog node, i.e.$$\\sum_ix_{ij}\\,r_i\\le g_j\\,y_j$$Abbiamo ufficialmente formulato il problema come ILP. Si chiama Bin Packing problem se metti tutti i $c_i=1$ (cercalo, fog nodes con c=1 sono i bin, tasks sono gli item da mettere dentro e resources=capacities), ed è $\\NPC$ (si risolvono con algoritmi branch-and-cut? cerca). Allora cerco heuristics e approssimazioni, tendenzialmente greedy. Esistono robe $\\a$-approssimanti, vedi gurobi (codice caricato su colab)! (non so se è $\\a$-approssimante, check please). c'è un errore, aspetta versione patchata","x":-860,"y":-3560,"width":584,"height":948},
		{"id":"1d4c9d197fab6065","x":-751,"y":-2220,"width":759,"height":582,"type":"text","text":"# Gurobi"},
		{"id":"efa33c7c0a47d3b4","type":"text","text":"# SPACING","x":-2290,"y":-2172,"width":250,"height":235,"color":"5"},
		{"id":"d1d9dd6861616577","type":"text","text":"- $x_{ij} = 1$ se il task del sensore $s_i$ è assegnato al nodo fog $f_j$, altrimenti 0.\n- $y_j = 1$ se il nodo $f_j$ è attivato, altrimenti 0.\n        \n**Funzione Obiettivo:** Minimizzare il costo totale di attivazione dei nodi: $$\\min_y\\sum_j y_j c_j$$\n- **Vincoli:**\n    - Ogni task deve essere eseguito: $\\sum_j x_{ij} = 1 \\quad \\forall i$\n    - Nessun nodo può superare la sua capacità massima: $\\sum_i x_{ij} r_i \\leq g_j y_j \\quad \\forall j$\n\nIl problema rientra nella classe **NP-Complete** (Bin Packing Problem), quindi non è risolvibile esattamente in tempi brevi per sistemi di grandi dimensioni.\n\nSi usano soluzioni approssimate:\n   - Algoritmi **greedy** per una prima distribuzione.\n   - **Metaeuristiche** come Simulated Annealing e Algoritmi Genetici per migliorare la soluzione.\n   - **Gurobi** per soluzioni esatte di problemi di dimensione media.","x":-40,"y":-2810,"width":759,"height":517},
		{"id":"9b1a993fbf97aa5e","x":-1760,"y":3040,"width":759,"height":540,"color":"1","type":"text","text":"# Energy Harvesting come MDP\n\nSe hai voglia, pacco di slides 3_3_1\n\nRiferimenti:\n\n- CdM in generale: cfr. Computer Network Performance;\n- MDP e Q-Learning: cfr. Autonomous Networking"},
		{"id":"db1024436256a3a8","type":"text","text":"# Lec 3\nSi può formulare come ILP e risolvere con dynamic programming (cfr. Gurobi).\n\nrisolve il problema messo su classroom. pare sia un 0-1 knapsack problem ($\\NPC$). usa gurobi.\n\nN sensors, $r_i  \\forall sensor s_i$ , \n\n- greedy - sort sensors by priority. non ho alcuna garanzia costante entro cui trovo sol.\n- dynamic programming (wikipedia).\n\n# copia tablet\n\n\nottimizzazione lineare in N dimensioni: $\\min_x c^Tx = \\min_x \\sum_i c_ix_i$ con constraints$$Ax\\le b\\quad A_ex=b_e\\quad x\\in D$$\nnel problema di prima questi constraints (credo siano restrizioni di dominio e condizioni al contorno) diventano$$\\sum_ix_ir_i\\le g\\quad \\sum_{i\\ne j}x_{ij}=1\\quad x\\in\\Z$$\n","x":-2650,"y":-3416,"width":720,"height":660}
	],
	"edges":[
		{"id":"6883460e8c227a3c","fromNode":"1e3fd2b7a4b6a7cc","fromSide":"top","toNode":"d700a52cca1cdc2a","toSide":"bottom","label":"Distributed Cloud"},
		{"id":"e03e1fee77478baf","fromNode":"54d0a7ecb87b5c26","fromSide":"top","toNode":"d51f893becdde7b8","toSide":"bottom"},
		{"id":"fcc82691ef115619","fromNode":"54d0a7ecb87b5c26","fromSide":"left","toNode":"1e3fd2b7a4b6a7cc","toSide":"right"},
		{"id":"b6bb6d947657dd64","fromNode":"1e3fd2b7a4b6a7cc","fromSide":"left","toNode":"2d43e95958d0e621","toSide":"right","label":"Communication"},
		{"id":"1d3252b9a19eabde","fromNode":"1e3fd2b7a4b6a7cc","fromSide":"bottom","toNode":"ff3b9035a56b4e9e","toSide":"top","label":"Embedded Devices"},
		{"id":"a4ca303b3a8531b2","fromNode":"ff3b9035a56b4e9e","fromSide":"right","toNode":"617bc5508509a069","toSide":"left"},
		{"id":"d2311340c023a06e","fromNode":"617bc5508509a069","fromSide":"top","toNode":"cc865f4cd6000ab4","toSide":"bottom"},
		{"id":"1fe790485df6f8ed","fromNode":"ff3b9035a56b4e9e","fromSide":"bottom","toNode":"a94d060ea349fc00","toSide":"top"},
		{"id":"32f7122c19c5f94f","fromNode":"03e26affba62b324","fromSide":"bottom","toNode":"4c794fe5a6070164","toSide":"top"},
		{"id":"b57a4afc37693e7a","fromNode":"a94d060ea349fc00","fromSide":"right","toNode":"c39cda918518baad","toSide":"left"},
		{"id":"dbe6aedd063a9a05","fromNode":"617bc5508509a069","fromSide":"right","toNode":"03e26affba62b324","toSide":"left"},
		{"id":"ebbbf8f78d15509c","fromNode":"03e26affba62b324","fromSide":"bottom","toNode":"c39cda918518baad","toSide":"top"},
		{"id":"8ed146d7664a9824","fromNode":"c39cda918518baad","fromSide":"top","toNode":"03e26affba62b324","toSide":"bottom"},
		{"id":"1288a997ee3a73a0","fromNode":"a94d060ea349fc00","fromSide":"bottom","toNode":"43767a936de8e8b1","toSide":"top"},
		{"id":"8f0fe63c00069c47","fromNode":"a94d060ea349fc00","fromSide":"left","toNode":"d11ebd7b1efd8ff7","toSide":"right"},
		{"id":"5d6efd6cc943b5ac","fromNode":"2d43e95958d0e621","fromSide":"top","toNode":"1f0970b33a4cb76f","toSide":"bottom"},
		{"id":"4470f02e3cd1c2e6","fromNode":"d700a52cca1cdc2a","fromSide":"top","toNode":"ea6c2db0218bf20e","toSide":"bottom"},
		{"id":"89f9ea7cc3594bcc","fromNode":"d700a52cca1cdc2a","fromSide":"right","toNode":"1d4c9d197fab6065","toSide":"left"},
		{"id":"19b438e2e9d61208","fromNode":"43767a936de8e8b1","fromSide":"bottom","toNode":"9b1a993fbf97aa5e","toSide":"top"}
	]
}