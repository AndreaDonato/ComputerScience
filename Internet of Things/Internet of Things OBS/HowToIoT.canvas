{
	"nodes":[
		{"id":"d6502f7b02f95013","type":"text","text":"# Lec 1 & 2\n\nslide 41 paper non ancora presentato, video yt alla fine delle references\n\nSlides 2\n\nproblemi e relative soluzioni in IoT\n\n- Scale - IPv4 non basta ad addressare tutti i dispositivi. Si usa IPv6.\n- Security - la maggior parte dei dispositivi non regge schemi di crittografia, in più molti stanno all'esterno.\n- Unstructured data, ogni sensore ne produce di diversi. Non metto un unico software centrale di analisi ma distribuisco l'algoritmo.\n- i device vanno in posti molto diversi, super caldi fino a super freddi, umidi, movimentati, ... quindi ogni architettura è specifica dell'applicazione.\n\nLayers - come TCP/IP ma i layer centrali sono tutti fusi: non devo fare trasporto in giro, ma mi serve IPv6 al posto di MAC per indirizzare i messaggi. Quindi Applicazione, Gateway/network (che sarebbe fusione di trasporto, rete e DLL) e Fisico.\n\n- Sensor Layer - impacchetta un botto di dati  per il livello di rete. poi se fa tutta na serie de problemi tipo \"se move? non se move? ce sta la batteria?\" di cui non capisco bene il senso. hai detto che è application-specific, no?\n- Network Layer - un po' diverso, può fare addirittura data storage. BLE e WiFi sono considerati protocolli di questo layer\n\nAltre cose\n\ncodice (credo)\n\n- N sensori $s_i$ cui corrispondono risorse richieste $r_i$\n- un dispatcher D raccoglie i dati e li manda ad un fog node.\n- F fog nodes $f_j$ che richiedono risorse $g_j$ e che di conseguenza a $g_j$ hanno costi $c_j$\n\t- Tipicamente $N<<F$\n- D conosce i costi di ciascun fog node, e cerca di ottimizzare la data distribution.\n\n Definiamo $y_j$ come 1 sse usiamo il fog $f_j$, ed $x_{ij}$ se una task di $s_i$ è offloaded su $f_j$. Il compito di D è trovare la soluzione di$$\\min_y\\sum_jy_j\\,c_j$$il che ovviamente minimizza il costo complessivo. Mancano i constraints, perché così com'è la soluzione migliore è scegliere $y$ identicamente nullo. Allora mettiamo$$\\sum_jx_{ij}=1$$i.e. voglio che tutti i task siano eseguiti, inoltre non posso eccedere la capacità totale di ciascun fog node, i.e.$$\\sum_ix_{ij}\\,r_i\\le g_j\\,y_j$$Abbiamo ufficialmente formulato il problema come ILP. Si chiama Bin Packing problem se metti tutti i $c_i=1$ (cercalo, fog nodes con c=1 sono i bin, tasks sono gli item da mettere dentro e resources=capacities), ed è $\\NPC$ (si risolvono con algoritmi branch-and-cut? cerca). Allora cerco heuristics e approssimazioni, tendenzialmente greedy. Esistono robe $\\a$-approssimanti, vedi gurobi (codice caricato su colab)! (non so se è $\\a$-approssimante, check please). c'è un errore, aspetta versione patchata","x":-340,"y":-240,"width":720,"height":1364},
		{"id":"db1024436256a3a8","type":"text","text":"# Lec 3\n\nrisolve il problema messo su classroom. pare sia un 0-1 knapsack problem ($\\NPC$). usa gurobi.\n\nN sensors, $r_i  \\forall sensor s_i$ , \n\n- greedy - sort sensors by priority. non ho alcuna garanzia costante entro cui trovo sol.\n- dynamic programming (wikipedia).\n\n# copia tablet","x":-340,"y":1320,"width":720,"height":358},
		{"id":"442ecb8952c528e2","type":"text","text":"# L4\n\nottimizzazione lineare in N dimensioni: $\\min_x c^Tx = \\min_x \\sum_i c_ix_i$ con constraints$$Ax\\le b\\quad A_ex=b_e\\quad x\\in D$$\nnel problema di prima questi constraints (credo siano restrizioni di dominio e condizioni al contorno) diventano$$\\sum_ix_ir_i\\le g\\quad \\sum_{i\\ne j}x_{ij}=1\\quad x\\in\\Z$$\n\n___\n\n## cortex (il malvagio)\n\ntutti ARM. Memory Protection Unit fa switch tra  user e kernel mode.\nDMA (vedi sistemi operativi immagino)\nvbb è tutto un ripassone di cose (+ specifiche processori cortex) fino a slide 27, poi entra in dettaglio sugli interrupt (e.g. int. request (IRQ) - viene dal sensore, è il più comune) con tutta la parte tecnica (yeee).\nirrisorie differenze in costi diventano gargantuesche se moltiplicate per il numero di things. segue esempio. ma non su questo! sul fatto che tra sleep ed active consumption passa un universo mondo di potenza. poi aggiunge lo stato di transizione tra sleep  ed active (non ditelo a Donald).","x":-340,"y":1780,"width":720,"height":680},
		{"id":"bb5a7945372dc391","x":-340,"y":2620,"width":720,"height":320,"type":"text","text":"# L5 & L6\n\nSaltate, vedi slides"},
		{"id":"a8dcb3193cec51a3","x":-340,"y":3080,"width":720,"height":320,"type":"text","text":"# L7\n\nInformation Theory, vedi quaderno"}
	],
	"edges":[]
}