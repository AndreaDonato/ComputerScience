{
	"nodes":[
		{"id":"183cc241a018e501","type":"text","text":"# Alfabeti, Simboli, Linguaggi, Furfanti, Licantropi, ...\n\nBoh io ho trovato sta roba un po' confusionaria, quindi facciamo ordine.\n\nNei DMC siamo partiti da un esempio semplice, in cui $\\calX=\\calY=\\{0,1\\}$. Questa scelta di fatto costituisce la quasi totalità delle applicazioni reali. Perché? Ma perché tutto l'HW del mondo è basato sulla codifica binaria, è la codifica che trovi se intercetti una qualsiasi onda EM che trasmette dati. È chiaro che in genere vorrei trasmettere informazioni più complesse (tipo lettere, l'alfabeto inglese è in base 26), ma l'HW parla in binario, quindi sono costretto a codificare in binario. Sia $\\calX$ che $\\calY$, quindi, nel quotidiano parlano binario.\n\n... ma quindi la trattazione generica con $\\calX\\ne \\calY$ serve solo al risultato formale? ***No***. Il fatto che la ***quasi*** totalità delle codifiche sia binaria non significa che lo siano tutte.\n\nQuello che può però trarre in inganno è l'abitudine ad usare i `bit`, che come abbiamo capito vengono molto facilmente confusi con i $\\bit$. Facciamo quindi un esempio più generale per capire che diavolo sta succedendo.\n\n$\\calX=\\{A, B, C\\}$, $\\calY=\\{\\a,\\b,\\g, \\d\\}$. Il canale potrebbe conoscere più simboli di quelli che l'input gli comunica, o viceversa. In entrambi i casi esce una matrice $W$ non quadrata, tipo\n$$W(Y|X)=\\begin{bmatrix}\nP(\\a \\mid A) & P(\\b \\mid A) & P(\\g\\mid A) & P(\\d\\mid A) \\\\\nP(\\a \\mid B) & P(\\b \\mid B) & P(\\g\\mid B) & P(\\d\\mid B) \\\\\nP(\\a \\mid C) & P(\\b \\mid C) & P(\\g\\mid C) & P(\\d\\mid C) \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0.7 & 0.2 & 0.1 & 0.0 \\\\\n0.1 & 0.6 & 0.2 & 0.1 \\\\\n0.0 & 0.1 & 0.3 & 0.6 \\\\\n\\end{bmatrix}$$\nTutto questo ci sta dicendo che se viene inviato il simbolo $A$ è più probabile che in output venga ricevuto il simbolo $\\a$, e via dicendo. Visto che questa roba è suscettibile agli errori non è troppo conveniente inviare un simbolo alla volta. Scegliamo un codice $\\calC^2$, i.e. decidiamo che `AA` significa `A`, `BB` è `B` e `CC` è `C`. Questo ha due effetti:\n\n- Visto che $P(\\a\\mid A)=0.7$, diventa meno probabile che `AA` venga trasformato in due simboli di output che non sono $\\a$ $\\so$ ***ottengo robustezza rispetto all'errore***;\n- Al contempo per inviare un singolo simbolo $A$ ho dovuto inviarne due (`AA`) $\\so$ ***riduco l'efficienza della comunicazione***. Di quanto? Posso quantificarlo con il ***transmission rate***, che però malauguratamente è definito assumendo che $n$ sia la lunghezza della codeword in `bit`. Ma lasciamolo spiegare meglio al riquadro sul Transmission Rate.","x":5292,"y":-5934,"width":759,"height":856,"color":"4"},
		{"id":"20f0389aed3f57c6","type":"text","text":"# Transmission Rate\n\nCos'è il Transmission Rate, e perché è un disastro che si chiami così? (spoiler: perché ci ho messo tre ore a capire che cazzo di trasmissione fosse).\n\nPariamo con il dire che, come al solito, l'esempio fatto con i `bit` può essere fuorviante. Prima ho detto che sceglievo come codeword `1010` e `0101`, dando per scontato che ogni simbolo fosse binario. Potrei benissimo scegliere `ABBA` e `BACA` avendo come alfabeto `A B C`. Non cambierà nulla per quello che segue. O quasi. Ci arriviamo.\n\nIl ***transmission rate*** non è una qualche forma di throughput. O meglio, un po' lo è, ma la definirei piuttosto un'***efficienza***. De che? Della comunicazione, ovviamente.$$R = {\\bit \\text{ informativi}\\over \\text{bit fisici trasmessi}}\\le1$$\nIn pratica, quanti ***bit informativi*** riesco a trasmettere per ogni bit fisico. Ora, nel caso in cui utilizziamo ***sequenze binarie*** di $n$ `bit` possiamo scrivere $R$ come$$R={1\\over n}\\log_2|\\calC^n|\\in[0,1]$$\nHai presente quella legge che ti impone di usare solo sequenze binarie? No, vero? Infatti non esiste. Questa scrittura è infatti un caso particolare di$$R={1\\over n\\log_2|\\calX|}\\log_2|\\calC^n|\\in[0,1]$$\nOk, cambia solo la normalizzazione, ma è importante. Poniamo $n=4$ e $|\\calC^n|=16$.\n\n- Se usiamo l'alfabeto binario, $\\log_2|\\calX|=1$. Questo significa che con $16$ parole binarie ho un'efficienza $R=1$, i.e. sto sfruttando tutte le potenzialità del mio alfabeto. Questo però significa anche che ogni pezzetto di informazione è esattamente dove deve essere, il che la rende una situazione molto fragile e poco robusta rispetto al rumore;\n- Se usiamo l'alfabeto inglese, $\\log_2|\\calX|\\simeq4.7$, quindi con $16$ parole inglesi di lunghezza $4$ ho un'efficienza $R\\simeq0.21$. Non sto sfruttando appieno l'alfabeto, è vero, ma di contro sarà molto più facile distinguere tra `xykz` e `abcd`.\n\nIn pratica, se $R$ è alto significa che sto trasmettendo messaggi molto compressi (codeword vicine tra loro, rischio di fare più errori), viceversa la trasmissione è lenta rispetto al potenziale dell'alfabeto utilizzato, ma è robusta rispetto agli errori.","x":4285,"y":-4843,"width":759,"height":922,"color":"4"},
		{"id":"eadc00ddd47569d3","type":"text","text":"# Discrete Memoryless Channel (DMC)\n\nPartiamo da uno schema semplice: invio `0` o `1` e il `bit` può essere flippato con probabilità $\\e$. Possiamo descrivere i possibili scenari dovuti al rumore con una ***matrice stocastica***\n$$\n\\calW(Y|X)=\\begin{bmatrix}\nP(0 \\mid 0) & P(1 \\mid 0) \\\\\nP(0 \\mid 1) & P(1 \\mid 1)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 - \\varepsilon & \\varepsilon \\\\\n\\varepsilon & 1 - \\varepsilon\n\\end{bmatrix}\n$$\n\nNessuno però trasmette un `bit` alla volta: in questo modo posso comunicare solo risultati di eventi $X Y$ binari, e il rumore potenzialmente ribalta quello che voglio comunicare.\n\nGeneralizziamo a situazioni in cui l'input consta di ***simboli*** $x\\in\\calX$ e l'output di altri simboli $y\\in\\calY$ (i.e. metti che il tuo alfabeto di partenza è `A B C` ma il rumore ti fa ricevere una `D`). Questo si traduce in una matrice $|\\calY|\\times|\\calX|$ $$\\calW(\\calY|\\calX)=\\P(y_i|x_j)$$Se ricevo una sequenza di $n$ simboli, posso risalire alla probabilità che questi siano esattamente quelli che erano stati inviati in input:$$W^n(Y=\\vec{y}\\mid X=\\vec x)=\\prod_{k=1}^n\\calW(y_k\\mid x_k)$$dove la produttoria indica la proprietà di ***assenza di memoria*** del canale.\n\nDefiniamo un ***encoder*** $\\calC^n$ come un subset $\\sse \\calX^n$ di tutte le possibili sequenze di `n bit` realizzabili sull'alfabeto $\\calX$: $c\\in\\calC^n\\in\\calX^n$ sono le ***codeword***, e vengono inviate sul DMC. In output, un ***decoder*** $\\varphi^n$ prova a ricondurre la sequenza $s\\in\\calY^n$ che osserva ad una $c\\in\\calC^n$. Un ***errore*** si verifica quando il decoder ricostruisce una codeword diversa da quella che era stata inviata dall'encoder.\n\nSbagliare è tanto più facile quanto più le codeword sono vicine. Se le uniche due codeword sono `1010` e `0101` ho scelto solo `2` messaggi su `16` stringhe disponibili (in particolare queste due sono ***ortogonali***), quindi sarà più difficile sbagliarsi. Viceversa, se ne uso `14` su `16` disponibili anche un solo `bit flip` cambierà il significato della parola. Né posso avere un $n$ stratosferico, perché significa spendere troppe risorse per ogni parola.\n\nBisogna quindi trovare un compromesso tra $n$ e $|\\calC^n|$, tramite il malauguratamente detto ***Transmission Rate*** (davvero eh Claude... un nome peggiore non potevi trovarlo).","x":5292,"y":-4843,"width":759,"height":922,"color":"4"},
		{"id":"bc00b250b7b24ec0","type":"text","text":"# Informazione, Sorpresa ed Entropia\n\nL'idea fondamentale alla base di questo modello è che gli eventi rari ci sorprendono più di quelli frequenti. Prendiamo ad esempio un evento binario i cui outcome hanno probabilità $\\P[A]=t$ e $\\P[B]=1-t=q$ e fissiamo $t=0.99$. Non saremo affatto sorpresi se si verifica l'evento $A$. In altri termini, il verificarsi di $A$ non costituisce un'***informazione*** significativa. Se però viceversa si verifica $B$ (che ha probabilità $q=0.01$) le cose cambiano: saremo sorpresi, e in un mare di eventi $A$ il verificarsi di $B$ sarà un'informazione significativa.\n\nIn particolare, più $q$ si avvicina a $0$ più il verificarsi di $B$ sarà un evento sorprendente. Viceversa, quando $q\\to1$ la sorpresa va ad annullarsi. Un buon modo per modellizzare a livello matematico questo comportamento è definire il ***contenuto informativo*** (o ***sorpresa***) di un evento $E$ che si verifica con probabilità $\\P[E]$ come$$\\I[E]=-\\log_2\\bigg(\\P[E]\\bigg)=\\log_2\\bigg({1\\over\\P[E]}\\bigg)$$\nIl logaritmo ha senso, quella base $2$ sembra un po' arbitraria ma sarà chiara a breve. Il punto è che adesso abbiamo la sorpresa per un evento, vediamo che succede se sommiamo su tutte le possibilità. Limitiamoci un attimo ad eventi binari e scriviamo l'***entropia binaria***$$h(t)=t\\log_2\\bigg({1\\over t}\\bigg)+(1-t)\\log_2\\bigg({1\\over 1-t}\\bigg)\\in[0,1]$$dove $t\\in(0,1)$ è la probabilità di uno dei due eventi. Possiamo facilmente estendere per continuità a $t\\in[0,1]$ definendo $h(0)=h(1)=0$, e per com'è scritta ha un massimo in $t=0.5$. Tale massimo vale $1$: la logica della base $2$ del logaritmo è quindi normalizzare la binary entropy. Essendo un oggetto del tipo \"somma di (sorpresa $\\times$ probabilità della sorpresa)\", l'entropia costituisce un ***valore atteso di sorpresa***. Di chi? Della ***sorgente di informazioni***!\n\nQuesto significa che possiamo caratterizzare il grado di imprevedibilità (o caos, se ci piace il parallelismo con la fisica) di una sorgente di eventi probabilistici tramite questa funzione: una sorgente è \"poco sorprendente\" se $t\\sim 0$ o $t\\sim1$ (non ha senso lanciare una moneta se esce sempre testa!), e \"molto sorprendente\" per $t\\sim 0.5$ (massima casualità).\n\nNota che in realtà posso estendere tutto questo anche a sorgenti non binarie. Sia $X$ una random variable (RV) che può assumere valori $\\{x_1, ..., x_n\\}$ con probabilità $p_i = \\P[X=x_i]$ (i.e. $X$ è una sorgente di informazioni). L'***entropia di Shannon*** di $X$ è data da$$H(X)=-\\sum_ip_i\\log_2(p_i)=\\sum_ip_i\\log_2\\bigg({1\\over p_i}\\bigg)\\in[0, \\log_2n]$$che è massima se la pdf è piatta (i.e. una moneta truccata ha meno entropia di una \"pulita\").\n\nRiassumendo: la ***sorpresa*** è legata all'***evento***, l'***entropia*** alla ***distribuzione***.","x":4285,"y":-3693,"width":759,"height":1030,"color":"4"},
		{"id":"03bb0206eb695483","type":"text","text":"# \"Contenuto di Informazione per Simbolo\"\n\nQuando diciamo che un alto valore di $R$ implica un alta velocità di trasmissione, si intende che ogni singolo simbolo della codeword porta molta informazione.\n\nPrendiamo l'esempio delle `16` codeword con `4 bit`, i.e. il massimo possibile: ogni singolo `bit` è fondamentale per distinguere tra due codeword. Se ricevo `100` e manca l'ultimo bit, questo sta ancora decidendo al $50\\%$ tra `1000` e `1001`, da cui $R=1$ (perché posso fare questo stesso discorso per ogni `bit`.\n\nSe invece abbiamo l'alfabeto inglese e riceviamo `ABB`, l'ultimo `simbolo` magari porta $0$ informazione, perché esiste una sola codeword che inizia per `ABB` (e.g. `ABBA`). Chiaro, non tutti i simboli hanno un contenuto informativo pari a $0$, ma se su $26^4=456976$ codeword ne scelgo solo `16` verosimilmente queste saranno molto distanti, quindi basterà poco per discriminare tra esse. Magari il primo `simbolo` riduce le possibilità da `16` a `2`, mentre nel caso binario ogni `simbolo` (`bit`) prende una scelta al $50\\%$ su un albero binario.\n\nInsomma, nel primo caso ogni `bit` è una scelta con $\\P=0.5$ (massima entropia, da cui nel complesso uscirà $R=1$), mentre nel secondo caso il primo simbolo potrebbe avere $\\P=0.1$ e il  secondo $\\P=0.99$. Da qui otteniamo un'informazione media di $R\\simeq0.21 \\bit/$`simbolo`.","x":4285,"y":-5761,"width":759,"height":511,"color":"4"},
		{"id":"886eeef68d17e333","type":"text","text":"# Correlazione, Rumore e Comunicazione\n\nPer come l'abbiamo definita, quella di Shannon è un'entropia ***marginale*** (i.e. riguarda solo una sorgente, e.g. $X$). Poniamo di averne un'altra, e.g. $Y$. Se vogliamo caratterizzare un evento il cui outcome consta di un pezzo che discende da $X$ ed uno che deriva invece da $Y$, ci sono altre grandezze che dobbiamo introdurre.\n\n- ***Conditional Entropy*** - Se $X$ è l'incertezza tra il lanciare un dado o una moneta e $Y$ un outcome da $1$ a $6$, è chiaro che conoscere il risultato di $X$ influenza la distribuzione di probabilità su $Y$. Quindi la domanda della conditional entropy è: se conosco $X$, qual è la sorpresa residua su $Y$? Matematicamente, questa roba si scrive$$H(Y|X)=\\sum_{x\\in \\calX}\\P(x)\\,H(Y|X=x)=-\\sum_{x,y}\\P(x,y)\\log_2\\P(y|x)$$\n- ***Mutual Information*** - Ma quanto esattamente conoscere $X$ riduce la sorpresa su $Y$?$$I(X;Y)=H(Y)-H(Y|X)=H(X)-H(X|Y)=I(Y;X)$$\n\t- Nota che è sempre $\\ge 0$, l'uguaglianza vale per variabili indipendenti.\n- ***Joint Entropy*** - Quantifica l'informazione media necessaria a descrivere nel complesso l'evento che consta delle due parti $X$ ed $Y$. L'informazione necessaria a descrivere $(X,Y)$ è pari a quella per conoscere $X$ più quella residua (nel senso di conditional entropy) per conoscere $Y$ (e viceversa, perché è chiaramente simmetrica):$$H(X,Y)=H(X)+H(Y|X)= H(Y)+H(X|Y)=-\\sum_{x,y}\\P(x,y)\\log_2\\P(x,y)$$\n\nTutto questo mi serve a correlare due sorgenti in particolare: l'input e l'output di un ***Canale di Comunicazione***. Dato un input $x$, il ***rumore*** produrrà in generale un output $y\\ne x$. Segue che il mio compito di ascoltatore sarà di risalire a $x$ dato $y$.\n\nIn pratica, non possiamo a cuor leggero comprimere il messaggio da inviare fino al limite dato dall'entropia: ogni piccolo errore produrrebbe grandi incomprensioni. Per ottenere robustezza rispetto al rumore siamo costretti ad introdurre ***ridondanza*** rispetto alla compressione ottimale.","x":5292,"y":-3693,"width":759,"height":1030,"color":"4"},
		{"id":"51edfc0fd55ad3f4","type":"text","text":"# Capacità di Canale\n\nUn ***Discrete Memoryless Channel*** (***DMC***) è definito da una tripla $(\\calX, \\calY, W)$, dove $W$ è la matrice stocastica del ***rumore***. Segue quindi che è $W$ che caratterizza il canale. Possiamo definire un ***rate di trasmissione*** $R$ che ci dà due indicazioni complementari:\n\n- Quanto \"velocemente\" stiamo trasmettendo, i.e. data la lunghezza $n$ della codeword qual è il contenuto informativo (sorpresa) medio per ognuno degli $n$ `simboli`;\n- Quanto stiamo rischiando di non farci capire a destinazione (i.e. più il singolo `simbolo` è informativo, più una sua modifica dovuta al rumore modifica il senso del messaggio).\n\nOgni valore di $R$ rappresenta quindi un compromesso tra velocità e rischio di errori. Ci si potrebbe aspettare quindi che l'unico modo per far sì che l'errore tenda a $0$ è che $R\\to0$. \n\n... e invece no!\n\nAnzitutto $e\\to0$ lo puoi ottenere anche per $n\\to\\infty$. Al crescere di $n$, è più facile creare codeword distanti tra loro (in ogni caso $|\\calC^n|$ deve crescere esponenzialmente con $n$).\n\nA questo punto facciamo una piccola costruzione matematica e diciamo che un certo rate $R_0$ è ***achievable*** su un DMC $(\\calC^n,\\calY^n,\\calW^n)$ se esiste una sequenza di encoder-decoder $\\{\\calC^n,\\varphi^n\\}_{n\\in\\N}$ tali che per $n\\to\\infty$ abbiamo$$e(\\calC^n,\\calY^n,\\calW^n)\\to0\\qquad\\limsup_{n\\to\\infty}{1\\over n}\\log|\\calC^n|\\ge R_0$$i.e. se possiamo trovare un codice tale che l'errore tende a zero pur mantenendo $R\\ge R_0$.\n\nOra, tutto questo sarebbe solo una bella costruzione matematica se non fosse che esiste lo ***Shannon Capacity Theorem for DMCs*** che ci dice che il massimo rate achievable$$C(\\calW)=\\max\\{R\\mid R\\text{ è un achievable rate}\\}$$sul canale rumoroso caratterizzato da $\\calW$ è pari alla ***massima mutual information*** tra il segnale di input $X$ e quello di output $Y$, i.e.$$C^*(\\calW)=\\max_{\\P(Y|X)\\sim\\calW(Y|X)}I(Y|X)\\quad\\so\\quad C(\\calW)=C^*(\\calW)$$dove $\\P(Y|X)\\sim\\calW(Y|X)$ significa che la pdf di $Y$ dato $X$ è data dalla matrice di rumore (ma in pratica l'unica cosa che posso variare è $\\P(X)$, perché il rumore è caratteristico del canale!).\n\nNota che questo è un limite teorico. Data una matrice di rumore, esiste un massimo rate per il quale è safe comunicare senza rischio di errore. Non sta dicendo ***come*** scrivere encoder e decoder. La sfida \"ingegneristica\" qui è appunto trovare codici quanto più possibile vicini al limite teorico per ottimizzare la comunicazione.","x":6301,"y":-3693,"width":759,"height":1030,"color":"4"},
		{"id":"887e35db37687bdc","type":"text","text":"# Codici Continui e Rumore Gaussiano\n\nQuando comunico con un'onda EM lo schema concettuale non è \"`simbolo` che diventa un altro `simbolo` a causa del rumore\", piuttosto è un ***segnale continuo*** che viene ***distorto***.\n\nVista la proprietà additiva dell'ampiezza delle onde, il modello sul segnale diventa$$Y=X+Z$$dove $Z\\sim\\calN(0,\\s^2)$ è il ***rumore gaussiano***. i.e. mi aspetto che la distorsione media sia $0$ ma con un certo allargamento $\\s^2$. $X$ e $Z$ sono anche qui indipendenti.\n\nA questo punto dovremmo traslare tutto il discorso dell'entropia al caso continuo.$$h(Z)=-\\int f_Z(z)\\log\\big[f_Z(z)\\big]dz$$è detta ***entropia differenziale***, e guarda caso è massima per $Z\\sim\\calN(0,\\s^2)$. Il massimo vale$$h(Z\\sim\\calN(0,\\s^2))={1\\over2}\\log(2\\pi e\\s^2)$$Ora, per ***massimizzare la mutual information*** nel caso continuo$$I(X;Y)=h(Y)-h(Y|X)$$ho bisogno di massimizzare $h(Y)$. Quindi anche $Y$ deve essere gaussiana. Ma se $Y=X+Z$ e $Z$ è gaussiana allora ***devo scegliere $X$ gaussiana***. Così facendo abbiamo che$$h(Y|X)=h(X+Z\\mid X)=h(Z)$$(la sorpresa di $X$ dato $X$ è zero, dopodiché $X$ e $Z$ sono indipendenti), e facendo i conti$$I(X;Y)=h(Y)-h(Z)={1\\over2}\\log(2\\pi e\\s^2_Y)-{1\\over2}\\log(2\\pi e\\s^2_Y)=[...]={1\\over2}\\log\\bigg(1+{\\s^2_X\\over\\s^2_Z}\\bigg)$$\nDefiniamo quindi il ***Signal to Noise Ratio*** (***SNR***) e usando il ***teorema di Nyquist-Shannon*** sul campionamento senza perdita di informazione su canale con bandwidth $B$ (i.e. devi campionare almeno al doppio della frequenza dell'onda che trasporta l'informazione) arriviamo a formulare il ***teorema di Shannon-Hartley***$$\\SNR={\\s^2_X\\over\\s^2_Z}\\quad\\so\\quad C(\\calW)=B\\log_2(1+\\SNR)$$\nQuesto risultato fornisce la capacità massima del canale in $\\bit/s$.\n\nL'informazione di questo teorema è \"Più banda hai, più segnali puoi inviare. Più forte è il tuo segnale rispetto al rumore, più informazione puoi comprimere in ciascun segnale\".","x":7310,"y":-3693,"width":759,"height":1030,"color":"4"},
		{"id":"d51f893becdde7b8","type":"text","text":"# Teoria dell'Informazione\n\nLa Teoria dell'Informazione si occupa dello studio della quantificazione, dell'archiviazione e del trasferimento dell'informazione. Nasce da tre osservazioni sulla comunicazione:\n\n1. Il ***contenuto informativo*** di un messaggio equivale alla ***sorpresa*** che genera;\n2. In ogni ***linguaggio***, le parole di ***uso comune*** sono più corte di quelle non-comuni;\n3. Se ti perdi qualche pezzetto di frase, sei ancora in grado di ***ricostruire il messaggio***.\n\nDa questi tre principi, la modellizzazione matematica tira fuori tre risultati principali:\n\n1. Data una ***sorgente d'informazioni***, l'***Entropia di Shannon*** quantifica il valore atteso della ***sorpresa*** (i.e. del ***contenuto informativo***) del generico ***messaggio*** che essa può produrre, definendo il concetto di $\\bit$ informativo come unità di misura dell'informazione. Costituisce inoltre il limite inferiore alla ***compressione*** di un messaggio;\n- Dato un ***alfabeto*** di ***simboli*** (i.e. ***eventi*** o ***messaggi***), una ***codifica*** mira a trasformare tali simboli in sequenze di simboli (dette ***codeword***) di un altro alfabeto, detto ***codice***;\n\t- Se sembra non avere senso, considera che ***ASCII*** è una ***codifica binaria*** che trasforma simboli dell'alfabeto in sequenze di `bit`;\n\t2. Se utilizzo una ***codifica a lunghezza variabile*** posso applicare una ***compressione***, i.e. sfrutto la pdf della sorgente di simboli per assegnare ai messaggi più frequenti una rappresentazione più breve, e di conseguenza ottimizzare la lunghezza media della codeword. Si capisce anche meglio perché il suo limite inferiore è l'entropia: la compressione mira a ***minimizzare il numero di `bit` per ***$\\bit$;\n\t3. Se utilizzo una ***codifica a lunghezza fissa*** posso costruire codici appositamente per essere robusti rispetto al ***rumore***, utile se devo ***trasferire l'informazione***.","x":4285,"y":-2428,"width":759,"height":695,"color":"6"},
		{"id":"2df7743f9594ebe8","type":"text","text":"# `Bit` Fisico vs $\\bit$ Informativo\n\n***Questa è una cosa molto importante.***\n\nLa Teoria dell'Informazione riconosce l'entità logica fondamentale $0/1$ come \"quanto\" di informazione, in quanto costituisce la risposta più semplice che si possa dare (i.e. scelta binaria). Tale quanto di informazione viene chiamato ***$\\bit$ informativo***.\n\n***Il $\\bit$ NON È il `bit`.*** \n\nIl `bit` inteso come entità che può assumere solo valori `0` e `1` si riferisce a questi due oggetti in quanto ***simboli*** di un ***alfabeto binario***. Potrebbero tranquillamente essere `A` e `B`. Insomma, ***i simboli non quantificano niente***.\n\nIpotizziamo che io faccia una domanda ad una macchina che risponde sempre `sì`.\n\n- Per recapitarmi la risposta, la macchina deve mandare un `bit` fisico;\n- Quando la risposta arriva, la mia sorpresa è esattamente $0$. So che rispondi sempre `sì`, questo `bit` che mi hai inviato non mi fornisce alcun $\\bit$ di informazione.\n\nOvviamente e malauguratamente ***questi due concetti a volte coincidono***. Se faccio la stessa domanda ad una macchina che risponde `sì` o `no` al $50\\%$, ogni `bit` che mi arriva in risposta coinciderà con esattamente un $\\bit$ di informazione.\n\nAltre volte è evidente che c'è qualcosa di strano. Se la macchina risponde `sì` il $75\\%$ delle volte e `no` il restante $25\\%$, ogni `bit` porta mediamente $0.81\\bit$ di informazione. Questa strana magia si chiama ***Entropia di Shannon***.\n\nMorale della favola: non tutti i `bit` che invii servono a comunicare qualcosa.","x":5292,"y":-2428,"width":759,"height":695,"color":"4"},
		{"id":"344ee0d6725a4b78","type":"text","text":"# Esempi e Metafore per Convincersi\n\nIl `bit` fisico ha un ***costo reale*** (e.g. tempo, energia, banda). È ciò che _trasporti_.\n\nIl $\\bit$ informativo è un \"quanto siamo sorpresi\" da un simbolo. È un'entità **astratta** che si misura in base 2. È ciò che *comunichi davvero*.\n\n- $1 \\bit$ = `1` evento binario con probabilità $0.5$.   \n- Il rapporto tra `bit` e $\\bit$ la quantifica il ***transmission rate***:$$R = {\\bit \\text{ informativi}\\over \\text{bit fisici trasmessi}}\\le1$$\n- Nota che un ***simbolo*** in generale può portare più di un $\\bit$ di informazione. Se ad esempio uso l'alfabeto inglese con pdf piatta, ricevere una `K` mi genera una sorpresa pari a $\\log_2(26)\\sim4.7$.\n### **Metafora cinematografica** (By AI)\n\n- I bit **fisici** sono le **pellicole** che usi per registrare un film.\n- I bit **informativi** sono la **storia** che stai raccontando.\n    - Se filmi due ore di schermo nero, stai usando tantissima pellicola (bit fisici) ma non stai dicendo nulla (bit informativi ≈ 0).\n    - Se filmi un thriller dove ogni minuto succede qualcosa di imprevedibile, ogni metro di pellicola è carico di informazione.","x":6301,"y":-2428,"width":759,"height":695,"color":"4"},
		{"id":"19dbf5244a8bbdc1","type":"text","text":"# Abuso di Notazione\n\nNonostante \"encoder\" e \"decoder\" suggeriscano entità omologhe, $\\calC^n$ è un ***codice*** (quindi un subset di tutte le possibili stringhe realizzabili con $n$ simboli, i.e. $\\calC^n \\sse \\calX^n$) mentre $\\varphi^n$ è una ***funzione*** $\\varphi^n:\\calY^n\\to \\calC^n\\sse \\calX^n$.\n\nUn ***encoder*** in senso stretto dovrebbe essere una funzione $\\calE^n:\\calM\\to\\calC^n\\sse\\calX^n$ che mappa messaggi $m\\in\\calM$ in codeword $c\\in\\calC^n$.\n\nDa quello che leggo questo passaggio logico viene comunemente saltato per alleggerire la notazione, io non sono d'accordo. Chiamalo codice, no? Che ti costa?","x":6301,"y":-4533,"width":759,"height":303,"color":"4"},
		{"id":"953ba1b6df1d2cf5","type":"text","text":"# Compressione (lossless) dell'Informazione\n\nPoniamo di dover comunicare in binario codificando ogni lettera dell'alfabeto (`a, ..., z`). Posto che potrei usare `5 bit` (devo contare fino a più di `16` ma a meno di `32`) scegliendo `a = 00000`, `b = 00001`, `...`, esiste un modo più ottimizzato per scegliere la codifica?\n\nAnzitutto, c'è un'importante scelta da fare:\n\n- Se non accetto di perdere informazione nel processo (***compressione lossless***) devo trovare una corrispondenza biunivoca tra il messaggio codificato e la sua decodifica. Per fare ciò mi serve una ***binary encoding*** di tipo ***prefix-free***;\n- Se accetto di perdere informazione nel processo (***compressione lossy***) posso permettermi di ridurre le dimensioni oltre i limiti della versione lossless.\n\nLimitiamoci alla compressione lossless e troviamo il limite di compressione.\n\nPosto di aver trovato un prefix-free encoding e di avere un set di probabilità $\\P$ associate alle parole di $\\calM$ (i.e. sappiamo qual è la frequenza attesa delle varie parole), definiamo$$l(f)=\\sum_{m\\in\\calM}\\P[m]\\,\\bigg|f(m)\\bigg|=\\sum_{m\\in\\calM}\\P[m]\\,l_m$$lunghezza media di $f$ (i.e. della stringa prodotta da $f$ su $m\\in\\calM$ secondo $\\P$). Capiamo bene che il problema originale coincide con il minimizzare $l(f)$. Ma andiamo con ordine. La ***disuguaglianza di Kraft*** stabilisce una relazione per il codici prefix-free:$$\\sum_{m\\in\\calM}2^{-l_m}\\le1$$\nChe significa? Se interpretiamo la codifica PF come un albero binario (ogni nodo è un prefisso, ogni ramo `0/1` porta ad un nuovo prefisso), ogni $f(m)$ è il cammino dalla radice ad una foglia. Kraft dice che se quella somma fa più di $1$, allora stai cercando di usare più foglie di quante ne esistono. Di conseguenza, almeno una $f(m)$ non sarà una foglia, i.e. sarà il prefisso di una qualche $f(m')$.\n\nQuesto lemma si usa per dimostrare il ***Teorema di Codifica della Sorgente***: l'***entropia*** è il ***limite inferiore della compressione lossless***, i.e.$$l(f)\\ge H(\\P)$$dove l'uguaglianza vale solo per distribuzione $\\P$ uniforme.\n\nOra, uno potrebbe pensare che questo limite sia più stringente del dovuto, perché abbiamo preso un encoding prefix-free invece di uno univocamente decodificabile. Invece no: il limite resta questo anche se rilasso quella condizione.\n","x":3280,"y":-3693,"width":759,"height":1030,"color":"4"},
		{"id":"796fa6183e62d341","type":"text","text":"# Breve Storia della Teoria dell'Informazione\n\nGià durante gli anni '20 ***Nyquist*** e ***Hartley*** avevano pubblicato studi circa la trasmissione di informazioni, giungendo a forme funzionali del tipo $A = \\log B$. L'informazione veniva definita come la ***capacità del ricevitore di distinguere una sequenza di simboli da qualsiasi altra***.\n\n Durante il suo lavoro come crittografo nel corso della WWII, ***Shannon*** comprende che la codifica di messaggi segreti implica di fatto l'aggiunta di rumore ingannevole ai messaggi originali, e che la decodifica consiste nella rimozione di tale rumore. È forse ripensando a questo che quando gli viene chiesto di ottimizzare la comunicazione su canali rumorosi inizia a pensare ad un'astrazione teorica per modellizzare il problema.\n\nNel ***1948*** compare un suo articolo in cui definisce così il processo della comunicazione:\n\n- Dato un insieme di possibili messaggi, una ***sorgente di informazione*** ne seleziona uno; \n- Un ***trasmettitore*** codifica questo messaggio in un ***segnale***;\n- Il segnale viene inviato attraverso un ***canale***, dove può essere corrotto dal ***rumore***;\n- Un ***ricevitore*** decodifica quindi il segnale ricevuto per ricostruire il messaggio originale.\n\nLa rivoluzione di questo modello è l'uso della ***probabilità*** per modellare sorgente e rumore. Di conseguenza, le grandezze qui definite (e.g. l'***entropia dell'informazione***) trovano facili paralleli con la ***meccanica statistica***, e le applicazioni della teoria nel suo complesso spaziano oggi dalla codifica del DNA umano alle grandi teorie di unificazione in fisica.\n\nL'articolo del 1948 segna convenzionalmente l'inizio dell'***Era dell'Informazione***.","x":3280,"y":-2428,"width":759,"height":695,"color":"4"},
		{"id":"5a1008ab6d4f93fb","type":"text","text":"# Variable Length Binary Encodings\n\nIn generale, il concetto di ***alfabeto*** è esteso ad un insieme $\\calX$ di ***simboli*** ($|\\calX|<\\infty$). $\\calM$ è l'insieme delle ***parole*** (o ***codewords***) di un certo ***codice*** costruito su $\\calX$ ($|\\calM|<\\infty$), ed $\\calM^*$ è l'insieme delle ***sequenze di parole*** $m\\in\\calM$ ($|\\calM^*|=\\infty$).\n\nQui ci limitiamo però ad un ***alfabeto binario***, quindi $\\calX=\\{0,1\\}$. Non solo: permettiamo parole di lunghezza variabile (perché stiamo facendo compressione, per i canali rumorosi $l$ si fissa).\n\nUn ***variable length binary encoding*** è una funzione iniettiva $f:\\calM\\to\\{0,1\\}^*$, i.e. ogni $m\\in\\calM$ è mappata in una sequenza binaria distinta da tutte le altre (non è biettiva perché $\\{0,1\\}^*$ è un insieme infinito, non è vero che ogni sequenza binaria codifica una $m\\in\\calM$).\n\nTrovare $f$ sembra sufficiente, ma solo se trasmetto una parola alla volta. Di norma voglio trasmetterne diverse, quindi devo trovare una $f^*:\\calM^*\\to \\{0,1\\}^*$ iniettiva. Il che ovviamente non è facile! Chiaro che $f^*(m^*)=f(m_1)...f(m_n)$, ma proprio per questo se codifico `A = 0`, `B = 1` e `C = 01`, la stringa `001` può voler dire sia `AAB` che `AC`!\n\nSegue che $f$ è ***univocamente decodificabile*** (UD) se $f^*$ è iniettiva. Quindi la domanda è: come si costruisce una $f^*$ iniettiva? Ci serve che nessuna coppia di parole $m,m'\\in\\calM$ sia codificata da $f$ in modo ambiguo, i.e. che $$\\forall\\, m,m'\\in\\calM \\,|\\, m\\ne m'\\to f(m)\\not\\trianglelefteq f(m')$$ovvero che per ogni coppia $m,m'$ $f(m)$ non sia un prefisso di $f(m')$. Se ciò si verifica, $f$ è detta ***codifica prefix-free*** (PF). Intuitivamente, $x$ è prefisso di $y$ se $\\exists\\,z\\in\\{0,1\\}^*$ t.c. $y=zx$. Le codifiche prefix-free sono un ***sottoinsieme*** di quelle UD. Pertanto, $$\\text{PF} \\so \\text{UD}\\qquad\\text{ma}\\qquad \\text{UD} \\not\\so \\text{PF}$$\nOk, ma come costruisco una codifica PF? Intanto la disuguaglianza di Kraft$$\\sum_{m\\in\\calM}2^{-l_m}\\le1$$fornisce una condizione sufficiente: se scelgo delle lunghezze $l_m$ tali che questa viene rispettata, allora esiste una codifica PF avente le $f(m)$ ti tali lunghezze. <span style=\"color:rgb(236, 155, 14)\">Qui è dove avrei voluto trovare un algoritmo reale, ma non ne ho voglia.</span>","x":3280,"y":-4843,"width":759,"height":922,"color":"4"},
		{"id":"54d0a7ecb87b5c26","type":"text","text":"# Internet of Things (IoT)\n\nCon la ***miniaturizzazione dei processori*** che permette di inserire intelligenza praticamente ovunque e ***IPv6*** che permette di assegnare un indirizzo univoco a $O(10^{38})$ dispositivi, è facile immaginare un mondo in cui qualsiasi oggetto può collegarsi ad Internet.\n\n***Internet of Things*** (***IoT***) è il successore di quello che oggi conosciamo come Internet: se ai nodi aggiungiamo ***sensori*** per monitorare l'ambiente e ***attuatori*** per modificarlo, di fatto estendiamo il concetto di ***servizio*** (e.g. mail, video) a un qualcosa che viene materialmente fatto (in modo automatico e ottimizzato) nel mondo fisico di tutti i giorni (e.g. domotica).\n\nEssendo tanti, l'intelligenza e l'autonomia media di un singolo nodo IoT è abbastanza bassa. Questo apre a tutta una serie di problemi sulla sicurezza della comunicazione hop-to-hop e sulla necessità di protocolli energy-efficient ad hoc (e.g. ***BLE***, ***6LoWPAN***, ***MQTT***).","x":4285,"y":-999,"width":759,"height":387,"color":"5"},
		{"id":"e3f90e15d76f3ca5","type":"text","text":"# Comunicazione\n\nSe i contatti tra Gateway e Cloud avvengono generalmente via cavo, raggiungere le Things ci obbliga ad usare metodi ***wireless***. Servono due elementi:\n\n- Una ***stack protocollare*** ad hoc per l'IoT, dal momento che i dispositivi embedded\n\t- hanno poca capacità di calcolo e non possono supportare protocolli pesanti. Questo interessa solo le Things, ma di fatto si riflette su tutta la stack;\n\t- potrebbero perdere il segnale e avere lunghi momenti di silenzio. Servono quindi protocolli in grado di tollerare frequenti disconnessioni.\n- Tecnologie per realizzare ***antenne*** miniaturizzate e adatte alla specifica applicazione;\n- Uno standard per la ***modulazione dei segnali EM*** che definisca come vengono comunicati i ***simboli*** lungo il ***canale*** (cfr. ***Teoria dell'Informazione***).","x":-6806,"y":-1000,"width":759,"height":387,"color":"6"},
		{"id":"2d43e95958d0e621","type":"text","text":"# Stack Protocollare IoT\n\nL'Internet serve alle Things per comunicare comandi e dati raccolti. Come?\n\nEssendo dispositivi semplici, i classici protocolli di TCP/IP sono troppo dispendiosi in termini di energia e di overhead (e.g. `HTTP` ha un header di lunghissimo. `MQTT`, i.e. un protocollo che lo sostituisce in IoT, usa solo `2 byte`).\n\nIn pratica possiamo sfruttare le idee di TCP/IP per \"poggiarci sopra\" una stack protocollare più leggera, aiutati dal fatto che `IPv6` \"unifica\" `IPv4` e `MAC`.\n\n- ***Sensor/Perception Layer*** (***Edge***) - Il layer delle Things vere e proprie. Qui di norma vengono impacchettati un botto di dati da inviare al gateway;\n\t- Per via della limitata potenza delle Things, è difficile fare preprocessing a livello di Edge Computing. Al più, i sensori provano a mandare i dati solo quando servono (i.e. provano a fare ***Batching***, cfr. ***Efficienza Energetica***).\n- ***Gateway/Network Layer*** (***Fog***) - Qua si fondono il DLL e il Network Layer di TCP/IP, perché ***IPv6*** unifica i ruoli di `MAC` e `IPv4`. La logica resta quella di un ***gateway*** che media l'accesso ad Internet per conto delle Things, ma solo perché queste non sono abbastanza potenti da gestire una connessione completa;\n\t- I protocolli di tipo \"DLL\" includono roba come ***Wi-Fi*** e ***BLE***. Cito questi perché essendo standard garantiscono compatibilità, ma in generale posso costruirne a piacimento: la scelta del protocollo di \"DLL\" è dettata dalla specifica applicazione, perché è sempre un ***trade-off tra potenza e portata*** (stando ovviamente attenti alla complessità di comunicazione);\n\t- Qui si alleggerisce il carico del Cloud tramite ***Fog Computing*** (i.e. preprocessing in vista dell'arrivo al Cloud). Questa architettura mira a garantire la scalabilità del sistema. Tipicamente un gateway è anche un ***fog node***;\n\t- I protocolli di tipo rete poggiano tutti su `IPv6`.\n- ***Application Layer*** (***Cloud***) - Qua si fondono invece il layer omonimo di TCP/IP e quello di Trasporto: `TCP` e `UDP` vengono dati \"per scontati\" insieme al protocollo Applicazione di alto livello. L'idea cardine di questo layer in versione IoT è che un protocollo come `HTTP` è troppo pesante e non tollera disconnessioni frequenti (cosa che invece qui accade). Abbiamo quindi un paio di sue varianti:\n\t- ***MQTT*** (**Message Queuing Telemetry Transport**)\n\t- ***CoAP*** (**Constrained Application Protocol**)","x":-6805,"y":-4843,"width":759,"height":922,"color":"4"},
		{"id":"5a3d80b291a0be6b","type":"text","text":"# [Antenne](https://www.youtube.com/watch?v=ZaXm6wau-jc&ab_channel=SabinCivilEngineering) e Circuiti a Radio-Frequenze (RF)\n\nSappiamo che le frequenze più adatte a comunicare cadono nello spettro delle ***onde radio***.\nLe intermedie incontrano troppi ostacoli, quelle alte sono dannose per la vita in generale.\n\nPosto quindi che devo produrre delle onde radio tramite un circuito, come lo realizzo? Far oscillare un campo EM non è sufficiente a trasmettere un segnale. Dobbiamo usare un ***dipolo oscillante*** di lunghezza $L=\\l/2$, dove $\\l$ è la lunghezza d'onda che vogliamo trasmettere o ricevere, come descritto nel link presente nel titolo. Un segnale a $2\\text{ GHz}$ richiede un'antenna $L\\sim15\\text{ cm}$, mentre per $100\\text{ kHz}$ arriviamo a $3\\text{ km}$. \n\nUn ***circuito RF*** consta in genere di tre parti:\n\n- ***Modulator*** - Dato un input binario (i.e. onda quadra), lo traduce in segnale analogico tramite un ***DAC***. Per capire com'è fatto questo segnale, cfr. ***Modulare i Segnali***;\n\t- Se l'antenna è usata in ricezione, il segnale passa invece per un ***ADC***.\n- ***Upconverter*** - Visto che le antenne devono essere piccole, questo modulo ***aumenta la frequenza*** del segnale generato dal Modulator;\n\t- Potrei fare questo passaggio nel DAC? Sì, ma costerebbe e consumerebbe tanto.\n- ***Amplifier*** - ***Aumenta l'ampiezza*** del segnale per mitigare gli effetti dell'***attenuazione*** e del ***rumore*** (che di norma sono costanti), sia in trasmissione che in ricezione.\n\nTutto questo ci porta a produrre diversi tipi di ***antenne***:\n\n- ***Omnidirectional*** - Tipo quelle dei router domestici, trasmettono in modo più o meno omogeneo rispetto all'angolo $\\th$ (meno rispetto a $\\f$, i.e. poco nella direzione della punta);\n- ***Directional*** - Ottimizza il segnale in una specifica direzione, in due modi principali:\n\t- ***Yagi*** - Ha una barra-dipolo (**driven element**) e diversi elementi di supporto, distinti in **directors** (si trovano davanti e focalizzano il segnale verso il dipolo) e **reflectors** (si trovano dietro e, appunto, riflettono il segnale verso il dipolo);\n\t- ***Parabolica*** - Focalizza il segnale nel fuoco (wow), dove si trovano generalmente due dipoli ortogonali (usando ***polarizzazioni ortogonali*** raddoppio la bandwidth).\n- ***Embedded*** - Stampate direttamente sul chip, quindi dette ***Printed Circuit Board*** (***PCB***), possono essere sia uni- che omnidirectional. Posso anche montargli sopra un'antenna con un chip dedicato, in questo caso sarà tendenzialmente omnidirectional.","x":-6806,"y":119,"width":759,"height":911,"color":"4"},
		{"id":"c9aefb01554841f8","type":"text","text":"# Multi-Input Multi-Output (MIMO)\n\nSulla falsariga di quanto detto per l'antenna parabolica, perché usare una sola antenna?\n\nQuesta domanda arriva in risposta al problema della propagazione ***multi-path***, perché con una sola coppia TX-RX non sono in grado di controllare il tipo di interferenza: potrebbe tranquillamente risultare distruttiva ed eliminare completamente il segnale.\n\nUna tecnologia ***MIMO*** usa più TX e più RX per sfruttare (anziché subire) il multi-path. Questo avviene tramite tre diverse strategie, che risolvono tre diversi problemi.\n\n- ***Spatial Diversity*** - Le interferenze distruttive degradano il segnale (***multi-path fading***). Allora uso più antenne (poste idealmente a distanza $\\ge \\l/2$ tra loro) per inviare lo stesso segnale. Ogni onda così inviata sperimenterà un path diverso, aumentando la possibilità che all'RX ne arrivi almeno una \"buona\". I diversi segnali vengono poi ricostruiti con tecniche di ***Maximal Ratio Combination*** (***MRC***);\n- ***Spatial Multiplexing*** - Una singola antenna è limitata nella velocità di trasmissione dalle caratteristiche del rumore sul canale (cfr. ***Capacità di Canale***). Diverse antenne allora trasmettono diversi flussi di dati, che \"incastrandosi\" a destinazione aumentano il throughput. Ovviamente questa è una visione molto semplificata. Ognuna delle $N$ antenne RX vede diversi segnali, i quali vengono poi ricombinati con tecniche algebriche complesse che non ho alcun interesse a sentir nominare;\n- ***Beamforming*** - Abbiamo capito che meno mi allargo meno rischio il multi-path, e inoltre aumento la potenza del segnale. Posso allora manipolare le diverse antenne in parallelo (i.e. fase e ampiezza) per ingegnerizzare un'interferenza costruttiva nella direzione che preferisco, focalizzando ulteriormente il fascio.\n\nPosso infine sfruttare queste tecniche per realizzare un ***Multi-User MIMO***, i.e. creo diversi fasci super-focused in aria, tipo cavi ethernet invisibili. Ovviamente se i dispositivi si spostano (e.g. in ***WiFi*** o ***5G***) diventa tutto più complicato, quindi c'è tutto un discorso di overhead dovuto all'aggiornamento della posizione, che qui però ignoreremo.","x":-6806,"y":1280,"width":759,"height":858,"color":"4"},
		{"id":"bfc2cb8cd0a7da23","type":"text","text":"# Modulare i Segnali\n\nTrasportare informazioni con segnali analogici (i.e. onde EM) richiede una ***codifica***, i.e. una interpretazione delle ***variazioni di frequenza, ampiezza e fase***, in genere di una ***sinusoide***.\n\nQuesto processo di ***encoding***, detto ***modulazione***, avviene tramite l'uso di due segnali:\n\n- ***Modulating signal***, a frequenza più ***bassa***. Questa costituisce la ***frequenza centrale*** del segnale risultante, i.e. l'informazione che verrà \"letta\" a destinazione;\n- ***Carrier wave***, a frequenza più ***alta***. Modifica il segnale di partenza per aumentare l'efficienza di trasmissione (riduce dell'impatto del rumore e delle perdite), e permette di implementare il ***multiplexing*** (i.e. al variare della frequenza della portante).\n\nDiversi modi di combinare queste due frequenze portano a diverse tecniche di codifica. I modi più ovvi sono tre:\n\n- ***Amplitude Shift Keying*** (***ASK***) - Il segnale modula l'ampiezza della portante. Richiede HW semplice, ma è suscettibile al rumore (e.g. radio AM);\n- ***Frequency Shift Keying*** (***FSK***) - Il segnale modula la frequenza della portante. Più robusto in generale, ma chiaramente occupa più banda (e.g. radio FM);\n- ***Phase Shift Keying*** (***PSK***) - Qui è il caso di menzionare il fatto che in una modulazione digitale il segnale è un'onda quadra. Si può usare anche con segnale analogico, ma ha meno senso. La cosa comoda di questa tecnica è che puoi rappresentare `0` e `1` come punti in un ***constellation diagram***, in questo caso sfasati di $180°$.\n\nIn generale, l'interpretazione \"di base\" di queste tecniche prevedono l'encoding di un `bit` alla volta. Un `simbolo` (cfr. ***Teoria dell'Informazione***) è quindi dato da `0` o `1`, e (sorgente permettendo) ognuno di essi trasporta $1\\bit$ di informazione.\n\nÈ possibile superare questo limite definendo diversi punti distinti sul constellation diagram, i.e. scegliendo diverse combinazioni di ampiezza/fase.","x":-5798,"y":120,"width":759,"height":910,"color":"4"},
		{"id":"12ef443e8fc2d15f","type":"text","text":"# Constellation Diagrams\n\nUn ***constellation diagram*** è un grafico in coordinate polari in cui $r$ è l'ampiezza e $\\th$ la fase. Un punto su tale grafico è una ***codeword*** (o `simbolo`, o `parola`, come ti pare).\n\nNelle codifiche ovvie come ASK e PSK abbiamo due punti, `0` e `1`, e di conseguenza un ***transmission rate*** $R=1$. Possiamo però migliorare la codifica. `2 bit` definiscono `4` possibili combinazioni, e di conseguenza `4` possibili punti sul piano. Diverse combinazioni di ampiezza/fase individuano univocamente una di queste combinazioni. In questo modo, con un singolo simbolo è possibile inviare `2` o più `bit`, rendendo $R>1$.\n\nSegue che la definizione di $R$ qui è un po' diversa, essendo data da$$R=\\log_2(DN)$$dove $N$ è il numero di punti del diagramma e $D$ è il numero di diagrammi utilizzati (i.e. sto lavorando a frequenza fissata, quindi esiste un diagramma per ogni frequenza), e.g. ***WiFi*** usa i famosi `16 canali`, uno ogni $2\\text{ MHz}$, in cui divide la banda $2.4\\text{ GHz}$. Per evitare overlap (e quindi casini quando ricostruisci con Fourier) tali canali sono ben separati in frequenza.\n\nAumentare $D$ equivale ad aumentare la bandwidth $B$, di conseguenza la capacità di canale$$C=B\\log_2(1+\\SNR)$$\nTutto questo ci porta a distinguere il ***symbol rate*** dal ***bit rate***, essendo legati dalla relazione$$\\text{bit rate}=\\text{symbol rate}\\times R$$\nL'antenna RX riceverà in generale un segnale diverso da uno dei punti prefissati, a causa delle distorsioni di canale. Bisogna quindi distanziare sufficientemente i punti, in genere aumentando l'ampiezza, in modo da rendere possibile risalire in modo non ambiguo al giusto simbolo. Vale sempre il solito discorso, più comprimo più è facile sbagliare.\n\nNonostante sulla carta (Shannon-Hartley) tutto lo spettro è equivalente, in pratica le alte frequenze sono più pregiate. Questo perché\n\n- Le basse frequenze sono più \"intasate\" da applicazioni semplici, e.g. cellulari, IoT, WiFi;\n- La modulazione e il design delle antenne sono più efficienti ad alte frequenze.","x":-5798,"y":1280,"width":759,"height":858,"color":"4"},
		{"id":"e9808cbf25675093","type":"file","file":"ModulazioniComplesse.png","x":-5797,"y":2393,"width":758,"height":346},
		{"id":"423c2cb4b7a56ccb","type":"file","file":"DSSS.png","x":-4789,"y":1280,"width":758,"height":295},
		{"id":"c7e2f44140b2cd8e","type":"text","text":"   ### **2.2. Network Layer (Comunicazione e Trasporto Dati)**\n   \n- **Particolarità:** A differenza di TCP/IP classico, qui il livello di rete può **conservare dati** (data storage).\n\n### **2.4. Application Layer (Analisi e Automazione)**\n\n- **Causa:** I dati aggregati devono essere interpretati e usati per prendere decisioni.\n- **Effetto:** Si utilizzano protocolli di comunicazione applicativa come MQTT (publish-subscribe) o CoAP (REST).\n\n**CAUSA:** Un singolo dispositivo è inutile senza un’infrastruttura di comunicazione.\n**EFFETTO:** Servono protocolli di rete e standard per la trasmissione dati.\n\n- **Connettività**: BLE consuma meno energia di WiFi, ma ha un range più corto.\n    \n\n## 5. Protocolli di comunicazione\n\nI dispositivi IoT devono scambiarsi dati in modo efficiente. I protocolli sono scelti in base a **consumo energetico, latenza, scalabilità e sicurezza**.\n\n### Principali protocolli\n\n- **MQTT**: Leggero, basato su publish/subscribe, perfetto per connessioni instabili.\n- **CoAP**: Simile a HTTP ma ottimizzato per dispositivi a basso consumo.    \n- **Zigbee e LoRa**: Utilizzati per reti mesh e lungo raggio.\n    \n\n### Causa-effetto nella scelta del protocollo\n\n- **MQTT vs. HTTP**: HTTP è pesante e non adatto a IoT, mentre MQTT è ottimizzato per reti intermittenti.    \n- **Zigbee vs. WiFi**: Zigbee è ottimo per dispositivi a basso consumo ma con throughput ridotto.\n\n\n1. **CAUSA:** L’IoT richiede comunicazioni leggere ed efficienti, spesso su reti con poca banda.\n2. **EFFETTO:** MQTT (Message Queuing Telemetry Transport) usa un modello publisher/subscriber per trasmettere dati in modo efficiente.\n\n- Un \"publisher\" (es. un sensore) invia dati a un \"broker\".\n- I \"subscriber\" (es. altri dispositivi o server) ricevono solo i dati di loro interesse\n- Questo riduce il traffico di rete e il consumo energetico.\n\n### **4. Comunicazione e consumo energetico**\n\nQuando un dispositivo trasmette dati (WiFi, Bluetooth, LoRa, ZigBee...), consuma energia. La trasmissione RF è spesso uno dei principali colli di bottiglia energetici.\n\n- **WiFi:** Alta potenza, ma alta velocità\n    \n- **BLE (Bluetooth Low Energy):** Ottimizzato per consumi ridotti, ma a corto raggio\n    \n- **LoRa:** Ideale per lunghe distanze e consumi bassissimi, ma bassa velocità\n    \n\nStrategie per ridurre il consumo:\n\n- Trasmettere meno spesso\n- Usare protocolli a basso consumo (MQTT, CoAP)\n- Ridurre la potenza del segnale se non serve lungo raggio\n\n","x":-21600,"y":-6992,"width":930,"height":1358},
		{"id":"24e729d51fa94980","type":"text","text":"\nil NL è un po' diverso da quello di TCP/IP, può fare addirittura data storage. BLE e WiFi sono considerati protocolli di questo layer\n\n\n### **4.2. Standardizzazione e Interoperabilità**\n\n- **Causa:** Ogni produttore usa formati di dati e protocolli diversi.\n    \n- **Effetto:** Si cerca di definire standard unificati (es. Open Connectivity Foundation, MQTT, CoAP).\n    \n\n### **4.3. Adattabilità ai Cambiamenti Ambientali**\n\n- **Causa:** I nodi fog possono spegnersi, cambiare posizione o avere variazioni di capacità.\n    \n- **Effetto:** I sistemi devono essere **dinamici** e adattarsi ai cambiamenti in tempo reale.\n    ","x":-20143,"y":-6622,"width":643,"height":540},
		{"id":"713d15910e78e93b","type":"text","text":"## ☁️ **XaaS: l’idea alla base del Cloud**\n\nImmagina di avere bisogno di **potenza di calcolo**, **spazio di archiviazione**, o semplicemente di **un'applicazione che funzioni**. Prima dell’avvento del cloud, significava comprare hardware, installare software, mantenerlo, aggiornarlo, fare backup...\n\nCon il cloud, invece, **tutto questo diventa un servizio a richiesta**. Come l’acqua o l’elettricità: apri il rubinetto (o l’API), e arriva.\n\nDa qui il concetto di **“as a Service”**: non possiedi le cose, **le affitti**. Ma attenzione: a **diversi livelli di astrazione**.\n\n---\n\n## 🧱 **I tre pilastri: IaaS, PaaS, SaaS**\n\nImmagina di voler aprire una pizzeria digitale 🍕. Hai diverse opzioni, a seconda di quanto vuoi fare tu e quanto vuoi delegare:\n\n---\n\n### 🏗️ 1. **IaaS – Infrastructure as a Service**\n\n> Hai il mattone, ma devi costruire la casa.\n\n- Ti affittano **server virtuali**, storage, rete.\n    \n- Tu ci installi sopra OS, database, librerie, codice…\n    \n- Sei responsabile della **gestione**: patch, backup, scaling.\n    \n\n👨‍🍳 **Esempio pizzeria**: ti danno un locale vuoto e il forno. Tu porti ingredienti, assumi personale, fai tutto.\n\n🖥️ **Esempi reali**:\n\n- Amazon EC2 (server virtuali)\n    \n- Google Compute Engine\n    \n- Microsoft Azure VM\n    \n\n📦 **Use case tipico**: hai già un'app custom e vuoi solo non occuparti dell’hardware fisico.\n\n---\n\n### 🛠️ 2. **PaaS – Platform as a Service**\n\n> Hai la cucina pronta, devi solo cucinare.\n\n- Ti danno un ambiente di sviluppo già configurato: OS, runtime, database, servizi.\n    \n- Tu **ci carichi il codice**.\n    \n- Scalabilità, patch, sicurezza... tutto gestito dal provider.\n    \n\n👨‍🍳 **Esempio pizzeria**: affitti una cucina con staff base. Tu porti le ricette.\n\n🖥️ **Esempi reali**:\n\n- Google App Engine\n    \n- Heroku\n    \n- Azure App Services\n    \n\n📦 **Use case tipico**: vuoi solo scrivere codice e testare, senza perdere tempo a configurare ambienti.\n\n---\n\n### 📱 3. **SaaS – Software as a Service**\n\n> Ti siedi e mangi.\n\n- L’app è già pronta.\n    \n- Tu ti limiti a **usarla** via web o app.\n    \n- Non gestisci nulla, nemmeno l’installazione.\n    \n\n👨‍🍳 **Esempio pizzeria**: ordini su JustEat. Ti arriva la pizza.\n\n🖥️ **Esempi reali**:\n\n- Gmail\n    \n- Google Docs\n    \n- Dropbox\n    \n- Salesforce\n    \n\n📦 **Use case tipico**: vuoi solo accedere a una funzionalità senza curarti del \"come\".\n\n---\n\n## 🎯 Schema riassuntivo\n\n|Livello|Chi controlla cosa|Pro|Contro|\n|---|---|---|---|\n|**IaaS**|Tu gestisci quasi tutto|Massima flessibilità|Complessità gestionale|\n|**PaaS**|Tu gestisci il codice|Rapido sviluppo|Meno controllo|\n|**SaaS**|Usi e basta|Zero gestione|Nessuna personalizzazione|\n\n---\n\n## 🔁 E se andiamo oltre?\n\nCi sono anche altre sigle:\n\n- **FaaS** – Function as a Service (serverless: carichi una funzione e parte quando serve)\n    \n- **BaaS** – Backend as a Service (es: Firebase, ti dà DB + auth + API)\n    \n- **DBaaS** – Database as a Service\n    \n- **MLaaS** – Machine Learning as a Service (es: modelli già pronti da usare)\n    \n\nE infine: **Everything as a Service (XaaS)** – è il futuro, dove ogni componente IT (e non solo) diventa affittabile via API.\n\n---\n\n## 🧩 Relazione con Fog/Edge\n\nQuesta gerarchia vale **anche nel fog computing**, con una differenza chiave: **la latenza e la localizzazione**.\n\n- Un **fog node** può offrire **IaaS** (es: una piccola VM nel router di casa), o **PaaS** (un ambiente già pronto per analisi video), o addirittura **SaaS** (una app embedded nel semaforo che decide il verde).\n    \n- Ma tutto avviene **vicino all’origine del dato**.\n    \n\nIl paradigma rimane lo stesso: **a cosa vuoi delegare? e quanto controllo ti serve?**\n\n---\n\nSe vuoi, posso integrarti anche un diagramma a blocchi tipo matrioska (SaaS dentro PaaS dentro IaaS) oppure delle analogie più \"da mondo reale\" (es: trasporto: comprare un'auto, noleggiarla, prendere un taxi). Fammi sapere!","x":-19880,"y":-10267,"width":759,"height":2914},
		{"id":"52143f689630afcd","type":"text","text":"# Geographic Routing\n\n\"Se devo raggiungere un nodo a nord, che senso ha propagare l'informazione a sud?\".\n\nEd è proprio da questa domanda che realizzo di poter sfruttare una ***topologia nota*** della rete (o comunque una conoscenza approssimativa della mia posizione e di quella del nodo destinazione, e.g. tramite ***GPS***) per evitare trasmissioni inutili.\n\nE quindi a chi mando il pacchetto? Ho diverse alternative:\n\n- ***Most Forward within Range*** - Scelgo il nodo entro la mia gittata che più si avvicina alla zona che voglio raggiungere (i.e. il più lontano da me, ma anche il più vicino al target);\n- ***Nearest Node with Forward Progress*** - Voglio avvicinarmi al target ma non voglio neanche consumare troppa energia, quindi scelgo il più vicino nodo che mi garantisce progresso nella direzione che mi interessa;\n- ***Directional Routing*** - Scelgo il nodo con la minima deviazione angolare rispetto alla direzione del mio target;\n- ***Geocasting*** - Mando il pacchetto a tutti i nodi di una zona geografica (e.g. emergency alert per la popolazione).\n\nI problemi principali di una cosa del genere sono\n\n- ***Buchi di copertura*** - Non ci sono nodi entro il mio range nella direzione di interesse;\n- ***Dead End*** - Tra me e il mio \"nodo ottimale\" c'è un muro;\n- ***Loops*** - Alcune strategie possono portare a cicli infiniti.","x":-11860,"y":-4697,"width":759,"height":631,"color":"4"},
		{"id":"417ac07ed91bc074","type":"text","text":"# Protocolli di Rete\n\n`IPv4` non è adatto alle applicazioni IoT, usiamo `IPv6` (cfr. ***Practical Network Defense***).\n\nMa neanche questo basta. Pur vero che `IPv6` è più snello rispetto a `IPv4`, le reti di sensori hanno bisogno di protocolli ancora più leggeri. È per questo che si usa una variante che comprime il pacchetto `IPv6` standard: ***6LoWPAN***.\n\nInizialmente, questo protocollo rendeva compatibile `IPv6` con ***802.15.4***, ora è più flessibile. L'IETF ha infatti standardizzato diverse versioni che poggiano su diversi layer `MAC`, e.g. `IPv6 over BLE`.\n\nAnche qui abbiamo i simpatici protocolli di routing, per riempire le tabelle di routing.","x":-8823,"y":-4575,"width":759,"height":387,"color":"6"},
		{"id":"96854b62f8df3dc5","type":"text","text":"# Routing in a WSN\n\nCi sono due principali tipologie di flussi di comunicazione in una WSN:\n\n- ***Broadcast*** - Il Sink fa da coordinatore e dissemina le informazioni di controllo a tutti;\n- ***Convergecast*** - Un gruppo di sensori comunica i propri dati al Sink.\n\nLa comunicazione è in generale ***multi-hop***, si assumono ***nodi fissi***. In questa circostanza posso usare i metodi classici. Se poi ho anche informazioni sulla topologia della rete (i.e. ho un'idea di dove si trova un certo nodo rispetto a me) posso usare Geographic Routing.\n\nTutto questo si rompe se i sensori si muovono e la topologia cambia (e.g. DRONET).","x":-10850,"y":-4575,"width":759,"height":387,"color":"6"},
		{"id":"a6a561ce43fe8afd","type":"file","file":"Antenne.png","x":-7815,"y":-200,"width":759,"height":225},
		{"id":"1c886c1918d2f851","type":"text","text":"# Metriche di Riferimento per Antenne\n\nUn'***antenna isotropa*** è un oggetto ideale che emette in modo uniforme su tutto l'angolo solido. Di norma, un'antenna ha delle direzioni privilegiate. Il ***gain*** di un'antenna in ***trasmissione*** lungo una specifica direzione (i.e. porzione di angolo solido) è dato da$$G=\\eta\\times D={P_{\\text{radiated}}\\over P_{\\text{input}}}\\times{U\\over U_{\\text{isometric}}}$$dove $\\eta$ è l'efficienza energetica dell'antenna (i.e. che percentuale della potenza in input viene convertita in potenza EM irradiata), e $D$ è il rapporto tra l'intensità $U$ emessa dalla mia antenna e l'intensità $U_{\\text{isometric}}$ emessa dall'antenna isotropa, data una direzione. Quest'ultima cosa significa a rigore \"fissata la distanza $R$ alla quale misuro, il $\\D A$ sulla sfera di raggio $R$ intercettato da un angolo solido $\\D\\O$). Vabbè, era per dire.\n\nIl gain si misura in ***Decibel*** (***dB***), che è un'unità di misura un po' particolare. Si usa solo per misurare ***rapporti***, quindi ha senso parlare di Decibel solo in relazione ad una grandezza di riferimento $G_0$. Dopodiché, ci interessa l'***ordine di grandezza*** del rapporto, quindi mettiamo un $\\log_{10}$. Infine, visto che così vengono risultati troppo piccoli, moltiplichiamo per $10$. Il risultato di questo delirio è ad esempio$$P(\\text{dBmW})=10\\log_{10}\\bigg({P\\over1\\text{mW}}\\bigg)$$i.e. il gain di un segnale rispetto alla potenza di riferimento di $1\\text{mW}$. Una potenza di $20\\text{dBmW}$ significa $100\\text{mW}$, $-10\\text{dBmW}$ è un segnale di $0.1\\text{mW}$ e ovviamente $0\\text{ dBmW}=1\\text{mW}$. Per le antenne, il riferimento è l'antenna isotropa erogante la stessa potenza: usiamo i $\\text{dBi}$.\n\nIn ***ricezione*** possiamo definire il gain come efficienza nel convertire input in segnale. Se pensiamo alle antenne paraboliche, più area significa più segnali convogliati nel fuoco. A parità di area, però, posso comunque avere un'antenna più efficiente di un'altra. Definiamo l'***effective aperture*** come $A_e$, intendendo un'area virtuale equivalente da cui poi definisco$$G={4\\pi A_e\\over\\l^2}$$\nInfine, il range di frequenze supportato dall'antenna è detto ***bandwidth***. Antenne con ampia bandwidth reggono le reti cellulari, mentre le ***narrowband*** (range stretto) sono più in uso in dispositivi IoT (e.g. per BLE).","x":-7815,"y":119,"width":759,"height":911,"color":"4"},
		{"id":"1c92973033afe842","type":"text","text":"# Perdite\n\nAnche nel caso ideale in cui l'antenna trasmette nello spazio vuoto, l'onda EM si propaga come una sfera, e di conseguenza la potenza del segnale decade come $1/r^2$.\n\nMa di norma non trasmetti nel vuoto, quindi c'è anche l'***attenuazione*** del mezzo, qui anche detta ***shadowing*** se si parla di ostacoli da attraversare (e.g. muri). Non sempre è una cosa negativa: in ambienti \"densi\" (e.g. uffici), è possibile installare molti Access Point (AP) con l'idea che l'interferenza tra essi sarà mitigata dall'attenuazione (i.e. ne metto più del dovuto perché a causa dello shadowing il segnale di uno non arriva agli altri).\n\nOvviamente questo non è l'unico elemento di ***degradazione*** del segnale. ***Rifrazione*** (e.g. metti che piove) e ***diffrazione*** (nel superare ostacoli) possono \"spostare\" il focus del segnale, ***riflessione*** e ***scattering*** possono generare zone d'ombra e fenomeni ***multi-path***.\n\nQuesti ultimi possono essere gestiti in due modi:\n\n- Definendo il concetto di ***zone di Fresnel***, i.e. degli ellissoidi aventi come estremi transmitter (***TX***) e receiver (***RX***) e che poi si allargano sempre di più al crescere di $n$ (i.e. la prima zona è l'ellissoide più stretto, la seconda un po' più largo, e così via, con raggio corto $r\\propto \\sqrt n$). Il senso di sta roba è che il segnale si allarga quando viene inviato, ma oltre un certo allargamento non potrà più essere captato dal ricevitore. Si può dimostrare che gli oggetti che spostano il segnale situati nelle zone con $n$ pari ***tendono*** a rafforzare il segnale (i.e. interferenza costruttiva), mentre le zone con $n$ dispari ***tendono*** a distruggerlo. In pratica, si cerca di tenere libera la prima zona;\n- Utilizzando una tecnologia ***MIMO***, che prova a sfruttarli anziché subirli.\n\nInfine, si possono ottimizzare le perdite dovute a collisioni risolvendo un problema di ***vertex coloring*** (cfr. esame di ***Network Algorithms***), i.e. assegnando diverse frequenze a diverse coppie di antenne.","x":-7815,"y":1280,"width":759,"height":858,"color":"4"},
		{"id":"87d8679e76321ae5","type":"file","file":"Attenuazione.png","x":-7815,"y":2373,"width":759,"height":385},
		{"id":"114f642c2da6ef87","type":"text","text":"# Multiplexing & Spread Spectrum\n\nBella la modulazione dei segnali, ma tutto questo vale per una singola comunicazione. Come faccio se ce ne sono diverse?\n\n- ***Space Division Multiplexing*** (***SDM***) - Sfruttando la tecnologia ***MIMO***, focalizzo i vari flussi di dati direttamente sulla posizione geografica dell'antenna RX;\n\t- Nota che non c'entra nulla con Spatial Multiplexing.\n- ***Frequency Division Multiplexing*** (***FDM***) - Come ***WiFi*** con il meccanismo dei canali, i.e. divido in sub-channels aventi frequenze disgiunte utilizzabili in modo continuo;\n\t- Non ha bisogno di MIMO, è semplice ma irrealizzabile per le reti cellulari (immagina avere un sub-channel per ogni dispositivo connesso...).\n- ***Time Division Multiplexing*** (***TDM***) - Come ***BLE***, usiamo tutti la stessa frequenza ma trasmettiamo solo in specifici time slots esclusivi.\n\nE se volessi trasmettere nello stesso slot temporale e alla stessa frequenza? Se finora sto ragionando \"dividendo\" la banda a disposizione, posso provare ad usarla tutta in modo intelligente. 100 persone in una stanza non usano TDM o FDM, si comportano normalmente e implicitamente usano un ***codice*** (e.g. diverse lingue). Nel caos generale in cui si sentono tutti e nessuno, solo il vicino interlocutore \"sintonizzato\" sul giusto codice riesce a scindere il messaggio dal rumore. Questa è l'idea di base delle tecniche ***Spread Spectrum***, i.e. a parità di potenza mando un segnale spalmato in frequenza (quindi poco piccato) con l'idea che solo chi ha il giusto codice riuscirà a distinguerlo dal rumore. Come?\n\n- ***Frequency Hopping Spread Spectrum*** (***FHSS***) - Combinando FDM e TDM, ad ogni slot temporale posso scegliere tra $N$ frequenze a cui trasmettere. Ciascuna coppia TX-RX concorda un pattern (e.g. \"`trasmetterò, in ordine, alle frequenze 1, 3, 1, 2`\"), detto ***hopping sequence***, e sa come muoversi per decodificare lungo l'intera banda;\n\t- La durata di ogni slot (***dwell time*** $t_d$) è in generale diversa dal tempo necessario a trasmettere un `bit` $t_b$. Se $t_d>t_b$ parliamo di ***slow hopping***, i.e. trasmetto diversi `bit` per ogni slot, viceversa siamo in ***fast hopping***, i.e. mi servono più slot per trasmettere un singolo `bit`.\n- ***Direct Sequence Spread Spectrum*** (***DSSS***) - Ogni `bit` viene moltiplicato (`XOR`) per una sequenza binaria, detta ***chipping code***. Dall'esterno i messaggi sembrano rumore, ma a destinazione tramite un secondo `XOR` si risale al messaggio originale. Se questi codici sono anche ortogonali realizziamo un ***Code Division Multiplexing*** (***CDM***).","x":-4788,"y":119,"width":758,"height":911,"color":"4"},
		{"id":"49b5d7791ae4ef9a","type":"text","text":"# Privacy & Sicurezza\n\nSpecie all'inizio, molti dispositivi IoT non richiedevano autenticazione, o le credenziali erano standard. \n\nspesso si preferiscono device leggeri piuttosto che sicuri. la conseguenza è che spesso finiscono per mandare roba compromettente in chiaro, tipo la Network Key.","x":4285,"y":1516,"width":759,"height":387},
		{"id":"723d7c0d38a272e4","type":"text","text":"ogni channel della tv ha un diverso chip code","x":-3760,"y":-80,"width":250,"height":60},
		{"id":"eacf5041cde00c4c","type":"text","text":"# Secondo Esonero","x":-4788,"y":-240,"width":758,"height":260,"color":"5"},
		{"id":"277e360d02f736f7","type":"text","text":"# Protocolli Fisici & DLL\n\nL'***Institute of Electrical and Electronics Engineers*** (***IEEE***), il cui ***comitato 802*** si occupa di standard sulle reti, ha prodotto diversi standard per i livelli più bassi delle architetture IoT. Ne sono esempi ***Wi-Fi*** (***802.11***) e il più leggero ***WPAN*** (***802.15***). \n\nCiò detto, diverse aziende proprietarie hanno usato questi standard come punto di partenza per le proprie implementazioni. ***Bluetooth*** è stato successivamente standardizzato come ***802.15.1***, altri (e.g. **ZigBee Alliance**, oggi **Connectivity Standards Alliance**) hanno invece costruito su ***801.15.4***. Altri (e.g. **LoRa Alliance** con la stack ***LoRaWAN***) hanno creato una stack protocollare proprietaria che non ha nulla in comune con gli standard IEEE.\n\nOgni protocollo sceglie se sfruttare ***bande licenziate*** (affidabili ma a pagamento secondo le norme vigenti, e.g. rete cellulare) o meno (e.g. $2.4 \\text{ GHz}$ o $<1 \\text{ GHz}$, affollate ma gratuite).","x":-4790,"y":-4575,"width":760,"height":387,"color":"6"},
		{"id":"1f0970b33a4cb76f","type":"file","file":"NetworkProtocols.png","x":-6804,"y":-3680,"width":758,"height":408},
		{"id":"b725719f537219ad","type":"text","text":"# Sprechi Energetici e Duty Cycle\n\nGli sprechi energetici sono dati da un eccesso di pacchetti inviati, a causa di\n\n- ***collisioni*** (e quindi continue ritrasmissioni);\n- ***control packets overhead***, i.e. troppi messaggi di coordinamento perché la struttura di rete non è ottimale.\n\nma anche se resto (immotivatamente) in ascolto quando\n\n- i pacchetti sono destinati ad altri (***overhearing***);\n- non c'è nessun messaggio da ascoltare (***idle listening***).\n\n***S-MAC*** ha la pretesa di risolvere tutto questo con il ***Duty Cycle***, al costo di un po' di latenza in più. Definisco che entro un periodo c'è una finestra del $10\\%$ (o di quanto serve per la rete in questione) di tempo in cui il sensore ascolta il canale.\n\nQuesto permette di risparmiare una grande quantità di energia (l'idle listening è *un botto* costoso), ma introduce la necessità di ***sincronizzazione*** tra nodi (i.e. non posso mandarti un messaggio se stai dormendo). Come?\n\n- Definiamo un ***synchronization period*** come una certa finestra temporale entro la quale i nodi possono scambiarsi le informazioni di sincronizzazione, i.e. dei pacchetti `SYNC` che constano di due pezzi: `SENDER ID` e `NEXT SLEEP TIME`;\n- Tutti i nodi iniziano il protocollo ascoltando il canale per un tempo $T\\ge\\text{SYNC Period}$ casuale, in attesa appunto di messaggi `SYNC`. Possono succedere due cose:\n\t- Se il nodo non riceve nessun messaggio `SYNC`, al termine del tempo di ascolto $T$ sceglie in modo casuale il proprio Duty Cycle e fa broadcast della propria `SYNC`. L'idea è che i ***primi vicini*** di tale nodo si sincronizzino con lui (i.e. devono essere svegli quando anche lui è sveglio, per poter scambiare messaggi). Se ciò accade, il nodo in questione viene chiamato ***Syncronizer***;\n\t- Se il nodo riceve un messaggio `SYNC` prima di aver scelto il proprio Duty Cycle, allora si adatterà al Duty Cycle del nodo da cui ha ricevuto la `SYNC`, diventando un ***Follower***. A questo punto attende un tempo casuale e fa a sua volta broadcast.\n- Questo in generale crea dei ***cluster*** aventi stesso Duty Cycle. Non è quindi in generale garantito che tutta la rete segua lo stesso ritmo. Al contrario, è verosimile che si formino dei ***nodi di frontiera*** che ricevono `SYNC` indicanti Duty Cycle differenti (e che in generale vengono salvati in una ***tabella degli schedule***). Questi ultimi dovranno rispettare entrambi i ritmi per permettere ai due cluster di comunicare, il che li porterà ad avere maggiore consumo energetico rispetto al resto della rete.","x":-4788,"y":-9026,"width":759,"height":988,"color":"4"},
		{"id":"c5a09c41adcea73c","type":"text","text":"# Sleeping MAC (S-MAC)\n\nDal momento che il consumo energetico è davvero un bisogno primario, creo un protocollo MAC apposito per le reti di sensori.\n\nL'idea è imporre una schedule (***Duty Cycle***) al sensore in modo tale che resti in ibernazione per la maggior parte del tempo (consumando poca batteria) per poi attivarsi in una breve finestra utile a scambiare i dati (***Duty Time***), che in genere si attesta sul $10\\%$ del totale.\n\nQuesto step verso l'energy efficiency deve però al contempo garantire un buon throughput, una bassa latenza e una buona flessibilità (scalability, adaptability to changes).","x":-4788,"y":-7803,"width":758,"height":304,"color":"6"},
		{"id":"6d17894ec5808534","type":"text","text":"# Collision Avoidance\n\nChiaro che, per quanto detto finora, quando i sensori si scambiano messaggi questi possono collidere.\n\nNiente di incredibile, mi pare. Usa la sequenza RTS/CTS/DATA/ACK come in CSMA/CA. Quando riceve un messaggio di coordinamento aggiorna il suo NAV e sa quanto tempo deve aspettare per proporsi a sua volta.\n\nPer facilitare tutto questo, nelle implementazioni il tempo viene diviso in \"mini-slots\" entro i quali mandare una `SYNC`, una `RTS` o qualsiasi messaggio di coordinamento.","x":-3780,"y":-8682,"width":759,"height":300,"color":"4"},
		{"id":"77c4b53f94a1298a","type":"text","text":"# CSMA/CA\n\nIn virtù del **problema dell'uomo sulla montagna** e dell'**hidden terminal problem** non posso usare Collision Detection. Allora implemento una ***Collision Avoidance*** (***CA***), cioè evito a priori che si possano mai verificare collisioni. Come?\n\nPer ovviare al problema dell'uomo sulla montagna:\n\n- Introduco degli intervalli tra un frame e l'altro, detti ***InterFrame Space*** (***IFS***);\n\t- Il mittente ascolta il canale per un tempo ***DIFS*** (***Distributed IFS***). Se Carrier Sense non rileva segnali in ingresso, al termine del DIFS manda il frame;\n\t- Se il destinatario riceve il frame senza interferenze, aspetta un tempo ***SIFS*** (***Short IFS***, di durata $SIFS < DIFS$) e manda un ***ACK*** di conferma;\n- Introduco una ***finestra di contesa*** per stabilire la durata del DIFS;\n\t- La grandezza della finestra segue il ***Backoff Esponenziale***;\n\nPer ovviare al problema del terminale nascosto:\n\n- Introduco un meccanismo di ***prenotazione del canale***:\n\t- La sorgente (A) aspetta un DIFS e manda una ***Request To Send*** (***RTS***), con cui comunica alla destinazione (B) quanti dati vuole mandare e per quanto tempo serve prenotare il canale. Tale tempo è detto ***NAV*** (***Network Allocation Vector***);\n\t- Se B riceve RTS senza interferenze, attende un SIFS e manda a tutti un messaggio ***Clear To Send*** (***CTS***) con cui \n\t\t- avvisa la sorgente che può procedere a inviare;\n\t\t\t- Se A non riceve il CTS assume che il canale non sia libero, aggiorna il backoff esponenziale e riprova dopo un tempo estratto casualmente;\n\t\t- invita tutti gli altri (compresi gli hidden terminal C) a starsi zitti finché non finisce il NAV;\n\t\t\t- Se C sta già ricevendo qualcos'altro potrebbe non sentire il CTS;\n\t\t\t- Questo potrebbe bloccare anche comunicazioni che non avrebbero interferito con A e B (B urla a tutti di fare silenzio anche quando non è strettamente necessario);\n\t- Una volta che il canale è prenotato, A aspetta solo un SIFS piuttosto che un DIFS;\n\t- Questo meccanismo viene usato solo per pacchetti \"grandi\".\n","x":-3780,"y":-10160,"width":759,"height":899,"color":"4"},
		{"id":"25c54a470eca044a","type":"text","text":"# Ethernet CSMA/CD\n\nProtocollo per regolamentare il \"vecchio\" Ethernet a cavo condiviso (adesso è punto-punto, si collega direttamente ad una porta fisica dello switch o del router.\n\nSi articola in diversi passaggi, in cui la scheda di rete (NIC)\n\n1. riceve il datagramma dal livello di rete e crea il frame;\n2. ascolta (*sense*) il canale:\n\t- se è inattivo avvia la trasmissione;\n\t- se è occupato attende che si liberi, quindi trasmette (1-persistente);\n3. trasmette il frame, restando in ascolto per eventuali collisioni;\n\t- Se non avvengono collisioni, tutto ok;\n\t- Altrimenti, interrompe la trasmissione e invia un segnale di `jam` ($48\\,bit$, avvisa tutti gli altri NIC);\n\t\t- Dopo questa comunicazione, il NIC entra in fase di ***backoff binario***:\n\t\t\t- dopo l'$n$-esima collisione, il NIC estrae a caso un valore $k$ nell'intervallo $[0, 2^n-1]$, attende $k$ slot ($\\Rightarrow$ tempo per tramettere un frame di $512\\,bit$) e torna al punto 2;\n\t\t\t- più collisioni allungano l'intervallo di backoff;\n\t\t\t- I tempi si aggiornano in modo un po' caotico, non è ovvio prevederne il comportamento a livello teorico.\n\nEmpiricamente, l'efficienza di questo algoritmo in condizioni ragionevoli è $\\simeq 50\\%$. Facendo probabilmente dei calcoli che non mi va di fare si può arrivare all'espressione$$\\eta = \\frac{1}{1 + 5\\frac{t_{P}}{t_{T}}}$$","x":-4788,"y":-10160,"width":759,"height":899,"color":"4"},
		{"id":"17fdb97962c8ef46","type":"text","text":"# Classic Routing\n\nPer mandare un pacchetto ad un nodo, al solito, devo sapere dov'è, i.e. devo averlo nella mia tabella di routing. Queste possono essere costruite in tre modi:\n\n- ***Proactive*** - Aggiorno continuamente le tabelle con tutti gli elementi della rete, anche se non mi servono costantemente tutti. Questo mi porta a rispondere ad ogni cambiamento della rete (e.g. un nodo che si sposta o un collegamento cade);\n\t- Pro: So sempre dove mandare un pacchetto; Contro: Overhead;\n\t- Per un esempio vedi ***Destination Sequence Distance Vector*** (***DSDV***). In pratica è  ***Bellman-Ford*** con un meccanismo di ***Aging*** che associa ad ogni entry delle Routing Tables un codice sequenziale. Questo permette sia di preferire quelle più recenti sia di evitare i loop.\n- ***Reactive*** - Mi impegno a trovare la via per A solo se devo mandargli un pacchetto. \n\t- Se sei particolarmente pigro non la trovi nemmeno, ti limiti a fare ***flooding***. Scelta caotica, ma delle $N$ copie del pacchetto sono certo che almeno una arriverà a destinazione in tempo ottimale, al costo di intasare un po' la rete;\n\t- Se oltre che pigro sei anche pazzo fai flooding, ma solo ad alcuni neighbors scelti a caso (si chiama ***gossiping***, e direi che il suo allineamento è chaotic evil);\n\t\t- Meme a parte, nonostante palesemente sub-ottimali, entrambi i metodi possono essere utilizzati sul serio in situazioni in cui ho ***bassa potenza*** computazionale, ci sono ***pochi nodi***, o ***la rete è stata appena lanciata*** e bisogna essere certi di diffondere a tutti le informazioni di configurazione.\n\t- ***Dynamic Source Routing*** (***DSR***, RFC 4728) - Quando `A` manda un pacchetto a `B`, questo tiene traccia dei nodi per i quali è passato. Quando `B` riceve il messaggio, conosce automaticamente la route inversa;\n\t\t- Chiaramente il primo nodo che invia un pacchetto deve fare necessariamente ***route discovery***. Questo in genere avviene con un messaggio broadcast di tipo `Route Request`, al quale ogni nodo aggiunge il proprio tag in sequenza. Un messaggio di `Route Reply` viene quindi rispedito al mittente dal target;\n\t\t- Questo ovviamente porta ogni nodo ad avere diversi path per raggiungere lo stesso nodo. Se ho abbastanza memoria, la ridondanza è una cosa buona: se una route cade, posso subito provarne un'altra senza rifare la discovery;\n\t- ***Ad-hoc On-Demand Distance Vector*** (***AODV***) - Un nome complicatissimo per dire \"faccio Bellman-Ford, ma solo se serve\". In pratica, prendi DSR e tieni traccia solo del `Next Hop` per andare verso la destinazione (i.e. costruisce una classica RT invece di salvare l'intero path verso la destinazione). Ogni nodo intermedio impara di conseguenza il reverse path.\n- ***Hybrid*** - Ci sono implementazioni che mixano questi due paradigmi.","x":-10850,"y":-5826,"width":759,"height":1012,"color":"4"},
		{"id":"8302904d4e264e7c","type":"text","text":"# Who won? Who's next? You decide!\n\nManco a dirlo, la scelta dell'algoritmo migliore dipende dalla situazione.\n\n- I metodi proactive sono veloci ma causano un botto di overhead;\n- I metodi reactive sono efficienti ma ci mettono più tempo;\n- I metodi ibridi sono probabilmente quelli più utilizzati;\n- Geographic Routing permette di risparmiare energia, ma tocca conoscere la rete.","x":-11860,"y":-5442,"width":759,"height":244,"color":"4"},
		{"id":"14cd685daa476b20","type":"text","text":"# Aggiunte\n\nLe rotte di DSR possono essere salvate in ***cache***. Sia la dimensione della cache sia il TTL delle routes al suo interno sono tunable parameters. Esiste inoltre il messaggio di `Route Error` (`RERR`) per segnalare la caduta di un link.\n\nSe una destinazione è momentaneamente irraggiungibile perché sono caduti i collegamenti, posso aspettare che si ricolleghi per fare forwarding. O magari prima o poi qualcun altro pubblicizzerà una rotta alternativa. Parliamo in questo caso di ***delay-tolerant networking***.\n\nTendenzialmente quest'ultimo approccio non è pensato per IoT standard (e.g. domotica), ma piuttosto per ambienti estremi (e.g. satelliti, disastri naturali, zone sottomarine).","x":-10850,"y":-6388,"width":759,"height":327,"color":"4"},
		{"id":"408cffa305a01d86","type":"text","text":"# Mesh Networks\n\nUna topologia di rete ben definita può aiutare la comunicazione. Nel caso di rete mesh (i.e. grafo), i protocolli possono essere scritti per sfruttare i nodi vicini come ripetitori di segnale per raggiungere quelli lontani, esattamente come avviene con i router su Internet.\n\nQuesto apre a due questioni principali:\n\n- Come ***indicizzare i nodi*** sul grafo? Può sembrare banale, ma se mi limito ad usare gli indirizzi `MAC` non sto sfruttando in alcun modo la topologia (sono in generale in \"ordine sparso\"), inoltre sono spesso scomodi da inserire negli header perché troppo lunghi. La buona notizia è che ho diverse alternative possibili:\n\t- ***Geographic Addressing*** - Indicizzo i nodi come coordinate su un piano cartesiano;\n\t- ***Hierarchical Addressing*** - Scegli un nodo affidabile e rendilo la radice di uno spanning tree sul grafo mesh, utilizzando un semplice protocollo per assegnare i numeri (e.g. se prevedo `2048` elementi, la radice è `0`, il figlio destro è `1` e sarà la radice del sottoalbero dei nodi `1-1023`, quello sinistro è `1024` e fa capo ai nodi nel range `1024-2047`). La cosa brutta è che aggiungere nodi porta a continui ricalcoli;\n\t\t- Questo metodo viene ad esempio adottato da ***ZigBee***. Ogni nodo ha un `ID` di `16 bit`, e in fase preliminare vengono definiti i parametri come la `MaxDepth` dell'albero `L`, il `MaxChildPerParent C` e il massimo numero di figli che possono essere a loro volta genitori, `R`. Ovviamente, $R\\le C$ e i restanti figli sono foglie (e.g. sensori). Segue un esempio di come calcolare l'indirizzo di un generico nodo, che finirà in un riquadro dedicato.\n\t- ***Stochastic Addressing*** - Autoesplicativo, semplice quindi molto adottato.\n- Quale ***algoritmo di routing*** scegliere? Qui andiamo in un riquadro a parte.","x":-8823,"y":-2527,"width":759,"height":902,"color":"4"},
		{"id":"8514afe7843217b3","type":"text","text":"# Protocolli di Routing\n\nSegue un brutale copia e incolla da Reti di Elaboratori e Autonomous Networking, più qualche dettaglio aggiuntivo. Lo schema logico è il seguente:\n\n- ***Reti*** - Overview sui due macro-meccanismi di mesh routing;\n- ***Autonomous*** - Overview sui protocolli ***DSR*** e ***AODV*** + ***Geographical Routing***;\n- A parte mettiamo ***OLSR***;\n- Qui menzioniamo l'esistenza del ***Tree Routing***, che sì, è esattamente quello che sembra e funziona in modo simile al Hierarchical Addressing di ZigBee.\n\nTutto questo funziona per reti mesh relativamente stabili. Se però sono instabili al punto da creare più componenti connesse può aver senso ad esempio fare più forwarding possibile in attesa che le componenti si riconnettano. Sono utili in tal senso gli algoritmi di ***gossiping***.","x":-9833,"y":-3335,"width":759,"height":407,"color":"6"},
		{"id":"e5e31f4d5bfef004","type":"text","text":"# Routing su Internet Classico\n\nQuesta roba serve solo alla tipologia ***Link-State*** e ***Distance-Vector***.","x":-10850,"y":-2075,"width":759,"height":387,"color":"6"},
		{"id":"11aabae6a7528131","type":"file","file":"TopologiaRete.png","x":-12277,"y":-2075,"width":587,"height":387},
		{"id":"735cd8f334c4de8b","type":"text","text":"# Optimized Link State Routing - OLSR ([RFC 3626](https://www.rfc-editor.org/rfc/rfc3626.html))\n\nQuesto algoritmo è ancora ***proactive***, ma ottimizza l'overhead di comunicazione. Come?\n\nL'idea di base è la seguente: è inutile che tutti propaghino le informazioni in `broadcast`. Se (immagine sotto) sono `v` e voglio pubblicizzare a tutti una mia nuova rotta, non serve che tutti i miei primi vicini la inoltrino in `broadcast` per raggiungere tutto il resto della rete: è sufficiente che lo faccia `w`. Questo ovviamente riduce esponenzialmente il numero di messaggi scambiati (se tutti facessero `broadcast` sarebbe un delirio).\n\nTutto questo si generalizza nel seguente modo:\n\n- Ogni nodo costruisce il proprio set di primi vicini e di secondi vicini;\n- Dati questi due set, si chiede: qual è il subset minimo dei miei primi vicini tale che i nodi in esso contenuti possono raggiungere tutti i miei secondi vicini?\n\t- Chiamiamo i nodi di siffatto subset ***Multi-Point Relays***, ***MPRs***;\n\t- L'idea è appunto questa: se individuo i MPRs posso inviare i miei messaggi solo a loro ed essere certo che raggiungeranno ogni mio secondo vicino.\n- Una volta risolto il problema e trovati i MPRs, posso ridurre il tutto ad un classico Dijkstra. L'unica differenza è che gli unici nodi a fare broadcast degli aggiornamenti sui link sono tutti e soli i MPRs.\n\nTrovare per ogni nodo il subset ottimale di primi vicini è però in generale un problema $\\NPC$, ed è per questo che si usano algoritmi ***greedy*** come ***MPR Selection Algorithm***, che funziona più o meno così:\n\n- Seleziona anzitutto i primi vicini che coprono nodi raggiungibili solo da loro;\n- Tra i primi vicini non ancora selezionati, prendi quello che copre il maggior numero di secondi vicini, e ripeti fino a copertura totale.\n\nPur vero che questa roba riduce l'overhead, riduce la dimensione delle tabelle di routing e permette a più nodi di andare in `sleep mode`, crea un'asimmetria: i MPRs sono costretti a rimanere attivi più a lungo degli altri nodi, e la loro batteria si consumerà prima. ","x":-12868,"y":-3611,"width":759,"height":960,"color":"4"},
		{"id":"07d370c1b1fb30ea","type":"text","text":"# il resto delle slides 5_1\n\n\"spalmare il segnale lo rende più simile al rumore e costituisce un layer di sicurezza\" (ma in che senso???)\n\nsicuramente hoppare secondo un pattern costituisce sicurezza, ma va settato bene! forse lo è anche la chipping sequence (CodeDivisionMultiplexing). sono tipo superimposed codes?? la domanda è sempre: come faccio ad essere certo che il receiver sia allineato?","x":-4790,"y":1760,"width":759,"height":293},
		{"id":"8be5b3cff5d5df79","type":"text","text":"# Algoritmo di Dijkstra (Link-State)\n\nLa premessa di ogni algoritmo Link-State è che ogni router comunichi a tutti gli altri router tutti i costi (e.g. livelli di \"intasamento\") di tutte le porte. Una volta acquisite tutte le informazioni globali, ogni nodo risolve il proprio Dijkstra (i.e. quel Dijkstra che ha se stesso come nodo di partenza).\n\nL'algoritmo si può dividere in due parti:\n\n- ***Inizializzazione*** - Definisco il nodo di partenza e per ogni nodo $k$ della rete inizializzo il valore di $D(k)$ a\n\t- $c_{u, k}$ se $k$ è direttamente collegato a $u$;\n\t- $\\infty$ altrimenti (in pratica scelgo un `terror_value` molto grande);\n- ***Loop*** - Ciclo le seguenti operazioni finché non riempio $N$ con tutti i nodi:\n\t- `i = find()` - A questo punto ho un insieme di nodi non ancora in $N$. Tra questi, seleziono quello per cui $D(i)$ è minima;\n\t\t- Sono sempre sicuro di non selezionare un \"falso minimo\";\n\t- `add_to_N(i)` - Una volta trovato, lo aggiungo ad $N$. In questo modo ho trovato il percorso ottimale definitivo per $i$, quindi non devo più cercarlo.\n\t- `for (j adjacent_to i) and (j not in N)` - Mi metto in $i$ e guardo i primi vicini, ignorando quelli per cui ho già trovato il percorso ottimale;\n\t- `D(j) = min(D(j), D(i) + c_{i,j})` - Aggiorno le stime provvisorie per tutti i $j$. Questa riga mi dice sostanzialmente che le possibilità sono due:\n\t\t- Avevo già una stima migliore di quella attuale, lascio quella;\n\t\t- Ho trovato una stima migliore, sostituisco.\n\t- Ricomincio.\n\nUna volta che converge, ogni router conosce il percorso ottimale per raggiungere qualsiasi altro router sulla rete.\n\nDijkstra funziona bene per reti piccole, altrimenti è un problema far conoscere a tutti la topologia della rete. Se $n$ router inviano ciascuno $n$ messaggi, la ***complessità di comunicazione*** (i.e. l'overhead del processo di scambio di messaggi) è $O(n^2)$.\n\nPuò avere ***comportamenti patologici*** se si definiscono male i pesi degli archi. Se ad esempio uso il volume istantaneo di traffico, ogni aggiornamento sposta i flussi creando nuovi bottleneck, che portano ad un nuovo ricalcolo, che sposta i flussi, ... (***oscillazioni***). \n\nIn generale, ad ogni variazione di anche un solo costo bisogna ricalcolare tutto (c'è un *refresh rate*, diciamo ogni $t$ secondi).\n\n","x":-12868,"y":-1517,"width":759,"height":1051,"color":"4"},
		{"id":"bd46921336c24c88","type":"text","text":"# Algoritmo di Bellman-Ford (Distance-Vector)\n\nNasce dall'idea che se i costi cambiano *poco* voglio eseguire *poco* codice.\n\nL'inizializzazione è identica a Dijkstra: supponiamo di essere il router $u$ e di avere una stima $D_u(w) = 5$, mentre ad esempio $x$ avrà una stima $D_x(w) = 3$.\n\nA questo punto tutti i router inviano ai primi vicini le proprie stime. In particolare, $x$ comunica la sua stima $D_x(w)$ ad $u$, il quale ricalcola $D_u(w)$ tramite l'***equazione di Bellman-Ford***\n\n$$D_u(w) = \\min\\limits_{i}(c_{u,i} + D_i(w)) = \\min\\limits_{i}(\\text{distanza}_{ui} + \\text{minima distanza}_{iw})$$\n\ndove $i$ sono tutti e soli i primi vicini. Quando $i = x$, $u$ si accorge di aver trovato una stima migliore e la comunica ai propri primi vicini. $v$ riceve questa nuova stima ma la sua vecchia $D_v(w) = 3$ è ancora la scelta più conveniente, quindi non la aggiorna e non la comunica ai primi vicini. Riassumendo, ogni router\n\n- ***Attende*** la modifica del costo di un link a cui è direttamente collegato, oppure un messaggio da un router vicino;\n\t- Algoritmo ***asincrono*** - non ha un un *refresh rate* fisso, ma aspetta un evento. **Se in qualche modo non cambiano i costi, il router non calcola niente**;\n- ***Ricalcola*** le proprie stime;\n- Se cambiano, ***avvisa*** i vicini.\n\t- In quanto algoritmo ***distribuito*** nessun nodo conosce il percorso globale, e spesso il cambiamento dei costi influisce solo su una piccola parte di rete.\n\nNotare che ***l'informazione si propaga a velocità finita***, quindi quando il singolo router calcola le proprie stime lo sta in realtà facendo con dati vecchi. In realtà la velocità di propagazione dell'informazione dipende dal tipo di notizia, e porta a due ***comportamenti patologici***:\n\n- Le buone notizie si propagano velocemente. Questo può portare rapidamente ad una situazione di ***black-holing***, in cui un router pubblicizza dei costi molto bassi, il traffico viene massicciamente spostato su di lui e si crea un bottleneck;\n- Le cattive notizie si propagano lentamente, in particolare se si rompe un cavo si verifica il ***conteggio all'infinito***.\n\n\n\n","x":-11859,"y":-1517,"width":759,"height":1051,"color":"4"},
		{"id":"4141a3b604b7463d","type":"text","text":"# Quale usare?\n\n| Aspetto                          | **Link State (e.g. Dijkstra)**                                           | **Distance Vector (e.g. Bellman-Ford)**                            |\n| -------------------------------- | ------------------------------------------------------------------------ | ------------------------------------------------------------------ |\n| **Modello di routing**           | Ogni nodo conosce **l’intera topologia** della rete                      | Ogni nodo conosce **solo i costi verso i vicini**                  |\n| **Computazione**                 | Ogni nodo calcola localmente il cammino minimo verso tutti               | Ogni nodo aggiorna iterativamente le distanze basandosi sui vicini |\n| **Complessità computazionale**   | $O(n^2)$ naïve, ottimizzabile a $O(n \\log n)$                            | $O(n)$ per iterazione (convergenza in $O(n)$ iterazioni)           |\n| **Complessità di comunicazione** | $O(n^2)$: ogni nodo invia il proprio stato a tutti gli altri (broadcast) | $O(n \\cdot m)$: scambi locali tra nodi adiacenti, ma può oscillare |\n| **Topologie adatte**             | Grandi reti **dense**                                                    | Reti **piccole e sparse**                                          |\n| **Gestione pesi negativi**       | ❌ No (Dijkstra non supporta pesi negativi)                               | ✅ Sì (Bellman-Ford può gestirli)                                   |\n| **Convergenza**                  | Rapida e deterministica                                                  | Lenta, soggetta a **loop e instabilità** (count-to-infinity)       |\n| **Utilizzo tipico**              | Intra-AS (es. OSPF, IS-IS), SDN (con controller centrale)                | Inter-AS (es. BGP si ispira a DV, seppur molto più complesso)      |\n- **Link State** è adatto a scenari in cui i nodi possono permettersi di avere una visione globale e risorse computazionali maggiori. È tipico nelle **SDN** dove un **controller centrale** gestisce il grafo completo e calcola i cammini.\n    \n- **Distance Vector** è più leggero da implementare e scalabile in reti con limitata visibilità locale, ma la sua **convergenza può essere lenta** e soggetta a problemi (come il **count-to-infinity**) se non si adottano accorgimenti come _poison reverse_ o _split horizon_.","x":-12868,"y":-248,"width":759,"height":777,"color":"4"},
		{"id":"799772413b2646e9","type":"text","text":"# Conteggio all'Infinito\n\n- $y$ ha un pacchetto per $x$, controlla il cavo e si accorge che il costo è aumentato;\n- Nota allora che $z$ afferma di poter arrivare ad $x$ con costo $5$;\n\t- $z$ dice così perché sta usando l'informazione non aggiornata di $y$, e si basa sul mandare il pacchetto proprio ad $y$;\n- $y$ aggiorna la sua *best route* per $x$, perché \"`z dice che ci mette 5, io per z ci metto 1, 6 è meglio di 60`\". Ora nella tabella di $y$ c'è scritto $x \\rightarrow 6$, e prevede di mandare i pacchetti a $z$;\n- $y$ aggiorna $z$, dicendogli che per arrivare ad $x$ ci mette $6$;\n- $z$ aggiorna le sue stime, trovando che \"`y dice che ci mette 6, io per y ci metto 1, 7 è meglio di 50`\";\n- $z$ aggiorna $y$, dicendogli che per arrivare ad $x$ ci mette $7$;\n- \\[...\\]\n\nIn pratica, se si rompe il cavo tra $x$ ed $y$, $y$ e $z$ aggiornano il costo sommando ciclicamente il costo del collegamento tra loro due.\n\nCome si risolve il problema delle ***rotte cicliche***?\n\n- ***Split Horizon*** - Tutto questo sta succedendo perché $z$ invia ad $y$ aggiornamenti dei percorsi che prevedono di passare da $y$ stesso (idem per $y$). Quanto poco senso ha per un umano dire \"`ciao z io ci metto 5 passando da z`\"? Non ha senso dire a $z$ le informazioni che mi ha già dato lui, quindi semplicemente gli comunico tutte le rotte **tranne** quelle che prevedono di passare da lui;\n- ***Poisoned Reverse*** - Una specie di \"non ti azzardare a rimandarmi quello che ti mando io\". In pratica comunico a $z$ che il costo del nostro link è appena diventato *enorme*, in modo da rompere la rotta ciclica;","x":-11859,"y":-248,"width":759,"height":777,"color":"4"},
		{"id":"d34e0a48234d6477","type":"text","text":"# LoRaWAN\n\nImmaginiamo di dover monitorare la temperatura in $1000$ silos e l'umidità nei campi di una cooperativa agricola. Parliamo di un gran numero di sensori disposti in un'area enorme, e in più lontani da qualsiasi infrastruttura WiFi o LTE. C'è ovviamente il problema del consumo energetico, e in aggiunta servono protocolli Delay-Tolerant per gestire le disconnessioni.\n\nPer rispondere a queste necessità è stata costruita la stack protocollare ***LoRaWAN***, figlia di un lavoro congiunto tra ***LoRa Alliance*** e ***Semtech***. Qui ci limitiamo ai livelli più bassi:\n\n- ***Long Range*** (***LoRa***) - Il layer fisico, che definisce la modulazione del segnale;\n- ***LoRaWAN MAC*** - Il `DLL` di questa stack costruita su LoRa;\n- ***Sicurezza*** - Implementata a livello di rete, ma applicata a livello `MAC`.","x":-2772,"y":-4575,"width":759,"height":387,"color":"4"},
		{"id":"98f38f0e4cb340e1","type":"text","text":"# Famiglie IEEE per l'IoT\n\nA livello fisico, comunicano sulla banda $2.4 \\text{ GHz}$ oppure su frequenze $\\text{sub-GHz}$ (i.e. $<1\\text{ GHz}$).\n\nPERCHé USARE UN PROTOCOLLO PIUTTOSTO CHE UN ALTRO??","x":-4788,"y":-3476,"width":760,"height":387,"color":"6"},
		{"id":"b1315405f1c2f335","type":"text","text":"# Attribute Protocol - ATT\n\nCome detto, ATT è una sorta di linguaggio di interrogazione. Visto che il `client` non sa a priori quali sono i dati contenuti nel `server`, potrebbe iniziare il suo magico viaggio su ATT con una `Find Information Request`. Il `server` risponderà con una lista avente elementi\n\n```\nHandle 0x0001 → UUID 0x2A19\n```\n\nPotrei essere interessato a sapere il livello residuo della batteria, se è presente nella tabella (i.e. se il `server` ***espone*** quell'`Attributo`). Visto che l'`UUID` è standard, posso farlo con una `Read By Type Request`. Altrimenti, dovrei conoscere l'`Handle` corrispondente all'`UUID` che mi interessa, ed eseguire invece una `Read Request`.\n\nTutti questi messaggi sono identificati da un `opcode`, i.e. i primi `8 bit` del messaggio ATT. A seconda di cosa dice l'`opcode`, il resto del messaggio è interpretato in modo diverso.\n\n- In una `Write Request` (`opcode = 0x12`), i successivi `2 byte` rappresentano l'`Handle` dell'`Attributo` su cui scrivere, e i successivi `N byte` il `Valore` da scrivere;\n- Una `Write Response` (`opcode = 0x13`) costa di un solo `byte` (di fatto è un `ACK`).\n\nOltre ai messaggi di `Request` e di `Response`, BLE definisce altri tipi di ***Protocol Data Units*** (***PDU***), i.e. `Command`, `Indication`, `Confirmation` e `Notification`. Non ho alcuna voglia di entrare nei dettagli, lei non lo fa. Piuttosto, affrontiamo un altro problema.\n\nATT non ti dice che `0x2A19` è il livello di carica della batteria, lo sai solo perché è un valore standard. Servirebbe qualcosa in grado di fare un'ulteriore astrazione, raggruppando gli `Attributi` e creando `Servizi` gestibili ad alto livello. Questo qualcosa è ***GATT***. ","x":-4786,"y":-1888,"width":758,"height":701,"color":"4"},
		{"id":"9e2dab65ddb6d818","type":"text","text":"# 802.15.4\n\nLo standard ***802.15.4*** è un protocollo semplice per nodi alimentati a batteria che richiedono basso throughput. Prevede $16$ canali \"veloci\" (i.e. $250\\text{ kbps}$ in totale) nella banda $2.4 \\text{ GHz}$ utilizzabili a livello globale e diverse bande $\\text{sub-GHz}$ regionali. Supporta diversi tipi di modulazione del segnale (DSSS, ASK, ...) e diversi tipi di protocolli MAC. \n\nIl `frame` fisico prevede `6 byte` di preambolo (sincronizzazione) e `128 byte` di `payload`. Nota che questo è molto minore rispetto ai tipici valori di `Maximum Transmission Unit` (`MTU`) dei protocolli di rete come `IPv6` (per il quale il minimo è `1280 byte`). Segue che `IPv6` deve necessariamente ***frammentare i pacchetti***.\n\nA diversi preamboli corrispondono diversi tipi di `frame`, i.e. `Data` (autoesplicativo), `Beacon` (per il pairing), `ACK` (autoesplicativo) e soprattutto `MAC`. Quest'ultimo contiene nel `payload` l'intero protocollo di accesso al mezzo condiviso, e prevede indirizzi da `64 bit` assegnati dal vendor o da `16 bit`, assegnati dal coordinatore per ridurre l'overhead dei messaggi. \n\nA livello di indirizzi fisici, la rete può prevedere diverse topologie (cfr. ***Mesh Networks***). Qui in particolare possiamo definire due tipi di nodi:\n\n- ***Full-Function*** - Nodi come il coordinatore o i router sono in grado di implementare funzioni complesse come il forwarding o la gestione dell'addressing di sotto-nodi;\n- ***Reduced-Function*** - Nodi estremali che devono solo inviare e ricevere dati.\n\nOk, ma chi è questo ***coordinatore***? Semplicemente, è il nodo che gestisce parametri di configurazione complessi come ***scelta del canale***, implementa il protocollo MAC tramite i beacon e i periodi contention-free e contention-access e si comporta da ***trusted node*** per la distribuzioni di chiavi di sicurezza nella rete (tipicamente, 802.15.4 usa ***AES***).\n\nTra gli altri, ***ZigBee*** e ***6LoWPAN*** si poggiano su 802.15.4 per implementare i livelli PHY/MAC.","x":-3778,"y":-2854,"width":759,"height":731,"color":"4"},
		{"id":"0b0d751910025a05","type":"text","text":"# Generic Attribute Protocol - GATT\n\nVisto che vorrei evitare di interpretare ogni volta a mano i bit di ATT, costruiamogli al di sopra un protocollo in grado di tradurre i numeri in ***nomi*** e organizzarli in una ***gerarchia***.\n\nSe incontro un `Attributo` avente `UUID = 0x2800`, il messaggio che vuole lanciarmi GATT è il seguente: da qui fino al prossimo `Attributo` avente `UUID = 0x2800`, tutte le righe che leggo faranno parte dello stesso macro-argomento. In altre parole, è come definire una ***cartella in un filesystem***, o più in generale un ***contenitore logico***. Cosa contiene? Anche qui, abbiamo dei `Valori` standard come `0x180F → Batteria` (formalmente si chiamano ***UUID Semantici***). Questi `Attributi` sono detti ***Servizi***, e possono essere sia `Primari` (`0x2800`) che `Secondari` (`0x2801`). Questo non significa che i `Secondari` siano \"sotto-cartelle\" dei `Primari`, ma che alcuni `Servizi` sono più importanti di altri (e.g. un `Servizio Primario` potrebbe dichiarare di appoggiarsi ad un `Servizio Secondario`).\n\nBene, cosa c'è dentro i `Servizi`? Chiaro che la `Batteria` può avere diversi valori associati, tipo uno `Status` (`Acceso/Spento`) o il `Livello di Carica`. Ognuno di essi prende il nome di ***Caratteristica***, e funziona in modo simile ai `Servizi`: è un contenitore logico dichiarato con `UUID = 0x2803` e ha come `Valore` un `UUID Semantico` di ciò che viene dopo.\n\n\"Eh ma se so che la batteria ha solo il `Livello di Carica` come `Valore` posso saltare la `Caratteristica` mettendo direttamente `0x2A19` dopo il `Servizio`, no?\". ***No***. Devi per forza passare dalla `Caratteristica`, anche perché oltre al `Valore` standard potrebbero esserci ulteriori metadati. Tipo, ok, ho il `Valore` della `Caratteristica` \"`Temperatura`\", ma qual è l'unità di misura? Questa cosa va specificata entro la `Caratteristica` con un ***Descriptor*** (e.g. ad `UUID = 0x2901` è associato come `Valore` un'etichetta testuale, `UUID = 0x2906` definisce un `Valid Range` per il `Valore`, `0x2902` con `Valore = 0x001` significa attivare le notifiche se il `Valore` della `Caratteristica` cambia).  ***I Descriptor sono opzionali***.","x":-3778,"y":-1888,"width":759,"height":701,"color":"4"},
		{"id":"f352958e1e3ff824","type":"text","text":"# WiFi HaLow (802.11ah, 2017)\n\nLa prima versione di Wi-Fi per le applicazioni IoT, usa frequenze $\\text{sub-GHz}$ (coprendo quindi distanze maggiori, fino a $1\\text{ km}$) e prevede fino a $8192$ dispositivi connessi per AP. I segnali sono modulati secondo OFDM, e supporta MIMO e Spatial Multiplexing (seppure ad oggi poco usato). Di contro, ha meno banda a disposizione e raggiunge al più qualche Mbps.\n\nMigliora di molto i consumi energetici, grazie a diversi meccanismi a livello MAC:\n\n- Il `frame` è ridotto rispetto alle altre varianti 802.11a/b/g/n/ac, contenendo solo `Frame Control` (tipo di `frame`), `Sequence Control` (mitiga la duplicazione dei messaggi), `Duration` (tempo di occupazione del mezzo), `Indirizzi` vari e `QoS Control`\n- ***Null Data Packet*** (***NDP***) - Particolari frame senza payload, usati per inviare messaggi di controllo riducendo al minimo l'overhead;\n- ***Target Wake Time*** (***TWT***) - L'AP fornisce ai nodi una ***sleeping schedule*** (implementa di fatto un protocollo di tipo Sleeping MAC);\n- ***Restricted Access Window*** (***RAW***) - Se TWT è una sorta di CSMA/CA, qua si aggiunge un layer di TDMA: entro il proprio periodo di veglia, si parla solo al proprio turno;\n\nCi sono poi meccanismi di fino, come gli ***Short Beacons*** (nome fuorviante, li invia con rate più basso, quindi li \"spalma\" su più temp e li rende meno invasivi), ***Hierarchical Addressing*** (il nodo genitore diventa responsabile dell'intero sottogruppo, riducendo l'overhead di comunicazione verso i figli) e ***Group Sectorization*** (i.e. se l'AP lo consente, implemento Spatial Multiplexing).\n\nDovendoci essere un AP collegato ai nodi, la ***topologia*** naturale è a ***stella***. La sicurezza è implementata con ***AES***.","x":-5795,"y":-2854,"width":759,"height":731,"color":"4"},
		{"id":"9740cb9c346b232e","type":"text","text":"# Generic Access Profile - GAP\n\nIl protocollo GAP definisce come i dispositivi si trovano e si connettono.\n\n- Si parte da un dispositivo (***Advertiser***) che trasmette beacon per pubblicizzarsi;\n\t- In realtà, il processo potrebbe anche fermarsi qui. Se vogliamo realizzare una ***Broadcast Communication*** basta che il dispositivo invii i suoi dati in modo unidirezionale, senza aspettare risposta (e.g. in un museo, la targa intelligente comunica al telefono la storia del quadro). Se invece voglio realizzare una ***Connection-Oriented Communication*** possiamo proseguire con i ruoli.\n- Un altro dispositivo (***Scanner***) è in ascolto per individuare gli `Advertisers`). Quando lo `Scanner` trova qualcuno di interessante, gli invia una richiesta di connessione, assumendo il ruolo di ***Initiator***;\n- ll dispositivo a cui arriva la richiesta di connessione (che verosimilmente era un `Advertiser`, ma non per forza: magari conoscevo già il suo `ID` senza che questo facesse `Advertisement`) la accetta, assumendo il nome di ***Peripheral***;\n- Il dispositivo che fa partire la connessione e la gestisce è infine detto ***Central*** (di nuovo, tipicamente era l'`Initiator`, ma non è detto);\n- Tipicamente, un cellulare è un `Central`, mentre le cuffie sono un `Peripheral`. Lo stesso dispositivo può comunque svolgere entrambi i ruoli contemporaneamente.\n\nOra, nonostante ci sia una connessione, visto che le informazioni sono gestite come entries di una tabella di memoria (i.e. ogni riga è un \"oggetto\", detto ***Attributo***), uno scambio di dati qui è più in stile `DNS/UDP` (i.e. è come se stessi \"interrogando un database\" remoto).\n\nIl protocollo per interrogare e/o modificare questo \"DB\" di `Attributi` è ***ATT***.","x":-5794,"y":-1888,"width":758,"height":701,"color":"4"},
		{"id":"e13ddecfd4fa3c0d","type":"text","text":"# Traffic Adaptive Medium Access (TRAMA)\n\nProtocollo diviso in tre moduli:\n\n- ***Neighbor Protocol*** (***NP***) - Mando beacons ai vicini per costruire il mio ***Interference Set*** (i.e. i nodi con cui potrei collidere). Arriva fino a due hop di distanza;\n\t- Questa roba viene implementata come puoi immaginare, con messaggi di tipo `keep-alive`. Se un vicino non risponde per un `tot`, smetti di considerarlo vicino.\n- ***Schedule Exchange Protocol*** (***SEP***) - Ogni nodo pubblica gli slot che intende utilizzare per trasmettere secondo un ***TDMA*** classico, allegando un hash del proprio ID per definire una ***priorità***. Se più nodi vogliono usare quello slot, vince la priorità maggiore;\n\t- Nota che queste prime due fasi sono ***Contention-Based***, perché ancora le varie schedule non sono state comunicate. A livello di frame, questo si traduce in una fase iniziale di ***signalling slots***.\n- ***Adaptive Election Algorithm*** (***AEA***) - Sulla base delle informazioni così dedotte, posso scegliere in quali slot posso permettermi di dormire e in quali di inviare.\n\t- Da qui in poi diventa tutto ***Contention-Free***, gli slot diventano ***transmission slots***.\n\nTutto questo rende TDMA estremamente efficiente, al prezzo di un po' di overhead di setup. Gli unici messaggi che possono collidere sono quelli di signalling, ma serve poco tempo per risolvere le contese e passare ad una divisione del tempo deterministica.","x":-3782,"y":-6012,"width":759,"height":615,"color":"4"},
		{"id":"feca841d9a7cfa1b","type":"text","text":"# Quando ti Svegli? (Contention-Based)\n\nSe uso un protocollo di tipo ***Sleeping-MAC*** (e.g. ***Sensor-MAC***) si pone il problema di dover sincronizzare i periodi sonno-veglia dei vari nodi. Chiaro che se mando dei dati mentre il mio target dorme, questi andranno persi. Ci sono due macro-tipologie di metodi:\n\n- ***Beacon Mode*** - Intuibilmente, usa i beacon per vedere se gli altri sono svegli prima di provare ad inviargli dei dati, secondo due possibili paradigmi:\n\t- ***Non-Beacon Tracking*** (***NBT***) - Non so perché gli abbiano dato questo nome, forse i beacon in senso stretto sono periodici mentre questa modalità è ***asincrona***: mi sveglio, mando un segnale e resto sveglio per un po' in attesa di segnali. Nota che non c'è alcun coordinatore e si pone il problema delle durate dei ***duty cycle*** (ma si può risolvere con il Reinforcement Learning, cfr. Autonomous Networking);\n\t- ***Beacon Tracking*** (***BT***) - Viene eletto un coordinatore che sincronizza tutti i nodi sfruttando una struttura di base di tipo TDMA. Essendo un sistema ***sincrono*** ci sono meno collisioni e meno ascolti passivi, ma creo un singolo *point-of-failure*.\n\t\t- E se sono fuori range rispetto al coordinatore? Posso fare ***Multi-Hop Beacon Tracking***, i.e. il coordinatore elegge dei coordinatori secondari che coordinano diverse sottoreti. Poi vabbè si pone il problema di non far collidere tra loro i beacon dei coordinatori, ma non approfondiamo troppo). Il punto è che in generale rete più grande $\\so$ maggiore consumo energetico.\n- ***Non-Beacon Mode*** - Qua non ci stanno i beacon prima di inviare dati, quindi se devo farlo inizio a parlare finché non mi dici `aoo ho capito stai zitto!!`, più comunemente detto `ACK`. Ovviamente questo fa consumare un sacco di batteria a chi parla, nonché un sacco di pazienza a chi ascolta.\n\t- Formalmente, questa roba si chiama ***Long Preamble Emulation*** (***LPE***), perché mandare a spam le `Write Request` è simile a mandare un *lungo preambolo* al messaggio vero e proprio (similmente a quello che avviene in WiFi, posso arrivare a inviare fino a `16 byte` per sincronizzare la frequenza e allineare la fase, solo che qua serve a sincronizzare la *veglia*). A questo possiamo aggiungere dei `Write ACK`.\n\nSulla base di questo possiamo costruire diversi protocolli MAC di tipo ***Contention-Based***, i.e. per provare ad ottimizzare la latenza corro un piccolo rischio di collisione (nei protocolli ***Contention-Free*** come TDMA puro chiaramente le collisioni sono impossibili).","x":-4790,"y":-7035,"width":758,"height":902,"color":"4"},
		{"id":"2b90ecf4bdbdb286","type":"text","text":"# Protocolli MAC\n\nSe il multiplexing fornisce gli strumenti per separare gli utenti a livello fisico, i protocolli MAC sono quelli che li usano per garantire che tale divisione avvenga per davvero.\n\nCome sappiamo, i protocolli che prevedono Collision Detection sono di fatto impossibili per comunicazioni wireless. Quelli di ***Collision Avoidance*** si appoggiano sui multiplexing naive come FDM e TDM, ma anche su cose più sofisticate come CDM.\n\nPer le WSN è comune usare protocolli ***Sleeping-MAC***, mentre per reti WiFi e cellulari non è così fondamentale ottimizzare il consumo energetico. Qui riporto un rapido riassunto delle cose note e approfondisco solo quelle non note (ci sono sempre cose nuove, eh?).\n\nPer le cose non approfondite, cfr. esami di ***Reti di Elaboratori*** e ***Autonomous Networking***.","x":-4792,"y":-5898,"width":760,"height":386,"color":"6"},
		{"id":"6554f3430b521ead","type":"text","text":"# Riassuntone Cose Note\n\nFDMA e TDMA sono le naturali estensioni del multiplexing con FDM e TDM. Per ottenere un canale full-duplex bisogna combinarle (i.e. TDM con TX su una frequenza ed RX su un'altra).\n\nTDMA è ottimo per l'efficienza di banda e per la possibilità di costruirci sopra dei duty cycles, di contro c'è overhead di sincronizzazione (e di \"guard times\" tra uno slot utilizzato e l'altro), alta latenza (in quanto non ottimizzata come parametro) e problemi di fairness (chi deve trasmettere `1` ha gli stessi slot di chi deve trasmettere `100`).\n\nFDMA è ottimo per applicazioni real-time ma spreca un sacco di banda al crescere del numero di utenti, nonché risulta costoso da implementare a livello HW.\n\nUna roba leggermente più articolata è ALOHA, magari nella versione Slotted. Che sia o meno *p-persistente*, un miglioramento ovvio è il meccanismo di prenotazione del canale tramite RTS e CTS, che però presenta qualche problemino di overhead e scalabilità. Questa cosa a quanto pare si chiama ***MACA*** (lo sapevate? sapevatelo!).\n\nCDMA era usato per le reti cellulari 3G in quanto super efficiente sia a livello di banda che di resistenza al rumore, nonché di fatto costituente un layer di sicurezza (se non conosci la chip sequence buona fortuna a capire quello che sto dicendo), ma di contro è difficilmente scalabile (a un certo punto i codici iniziano ad interferire, nonostante siano ortogonali).\n\nPassa poi ad accennare WiFi (IEEE 802.11) con o senza Accesso Point (e.g. reti ad-hoc come AirDrop), reti cellulari, MANETs e WSN con rispettive necessità (che non ripeto).","x":-5799,"y":-6012,"width":759,"height":615,"color":"4"},
		{"id":"8be3d9b2c31c6b23","type":"text","text":"# Bluetooth (802.15.1)\n\nNonostante ancora oggi alcuni dispositivi utente (e.g. cuffie) usino il \"vecchio\" `Bluetooth` (comunque comodo per stream audio continuo), lo standard *de-facto* per le comunicazioni tra sensori IoT è la sua variante ***Bluetooth Low Energy*** (***BLE***, i.e. da `Bluetooth 4.0` in poi).\n\nBLE comunica a $2.4 \\text{ GHz}$, con $40$ canali a disposizione (tre di advertising, gli altri di dati). Non crea reti mesh e non ha bisogno di infrastrutture fisse, lavora a coppie o a piccoli gruppi.\n\nLa memoria di un dispositivo BLE è strutturata come ***tabella*** con delle entries (similmente ad un ***database***), ognuna rappresentante un dato diverso, detto ***Attributo***:\n\n```\nHandle    UUID    Valore    Permessi\n```\n\ndove `Handle` è l'indice di riga della tabella e `UUID` un identificatore utile ad interpretare univocamente il significato del contenuto della voce `Valore`.\n\n- Alcuni `UUID` sono standard, e.g. se leggo `UUID = 0x2A19` so per certo che il `Valore` andrà interpretato come `Livello di carica della Batteria`. Questi `UUID` sono sempre lunghi `16 bit`, e sono definiti dalla ***Bluetooth Special Interest Group*** (***Bluetooth SIG***, organizzazione che sviluppa e standardizza questa tecnologia);\n- Altri sono proprietari, a `128 bit`, e il loro significato dipende dal produttore.\n\nLa comunicazione viene costruita in tre step, corrispondenti a tre protocolli:\n\n- ***Generic Access Profile*** (***GAP***) - Definisce come i dispositivi si trovano e si connettono.\n- ***Attribute Protocol*** (***ATT***) - Questo protocollo si comporta come un primitivo ***linguaggio di interrogazione***, permettendo di interrogare e/o modificare le tabelle del `server`;\n- ***Generic Attribute Protocol*** (***GATT***) - Definisce semantica e gerarchia sopra ATT.","x":-4786,"y":-2854,"width":758,"height":731,"color":"6"},
		{"id":"916a3e8fd0a77e2e","type":"text","text":"# Long Range - LoRa\n\nImmaginiamo di dover monitorare la temperatura in $1000$ silos e l'umidità nei campi di una cooperativa agricola. Parliamo di un gran numero di sensori disposti in un'area enorme, e in più lontani da qualsiasi infrastruttura WiFi o LTE. C'è ovviamente il problema del consumo energetico, e in aggiunta servono protocolli Delay-Tolerant per gestire le disconnessioni.\n\nPer rispondere a queste necessità è stata costruita la stack protocollare ***LoRaWAN***, figlia di un lavoro congiunto tra ***LoRa Alliance*** e ***Semtech***. Qui ci limitiamo ai livelli più bassi.\n\nLa ***modulazione fisica*** del segnale è uno standard Semtech. I simboli vengono trasmessi sotto forma di ***chirp***, i.e. un segnale la cui frequenza varia nel tempo (e.g. un suono che parte grave e diventa acuto), e l'efficienza è tale da riuscire a trasmettere con un $\\SNR$ fino a $-20\\text{ dB}$ (i.e. ricevo dati anche quando il segnale è sepolto dal rumore). Come?\n\nAnzitutto, a livello fisico un chirp su LoRa è una sinusoide la cui frequenza aumenta (o diminuisce) linearmente nel tempo. Come si vede dalla figura sopra, un ***simbolo*** è definito dalla forma del segnale chirp ricevuto in un certo intervallo di tempo.\n\nChiaramente ho a disposizione solo un certo range di frequenze, diciamo da `a` a `b`. Se faccio partire l'`up-chirp` dalla frequenza `a`, entro un intervallo di tempo arriverà a `b`. Se però l'`up-chirp` parte da `a + k`, è chiaro che nello stesso intervallo di tempo dovrà arrivare a `b + k`. Ma `b + k` non è tra le frequenze che posso usare! E quindi? Quando arrivo a `b` mi fermo e ricomincio a trasmettere da `a`, fino ad arrivare ad `a + k`. Una sorta di condizione al bordo, in cui di fatto codifico il simbolo nell'***offset di frequenza*** `k`.\n\nEssendo `k` l'unica informazione utile, il processo di decoding consiste nell'effettuare una ***FFT*** (***Fast Fourier Transform***) sul segnale moltiplicato per un chirp di riferimento, che senza entrare troppo in dettaglio mi produce una delta sulla frequenza `k`.\n\nIl parametro chiave qui è lo ***Spreading Factor*** (***SF***), che definisce quanti diversi simboli (i.e. quanti diversi offset) posso codificare in un intervallo di tempo. LoRa definisce un range per SR da $7$ a $14$, e il numero di simboli sono calcolati come $2^{SF}$. Ovviamente, segue che più simboli codifico più diventa difficile separarli, e più il singolo simbolo contiene informazione.\n\nPer questo che a ***valori alti di SF*** si associa un contestuale ***rallentamento del segnale*** (mi serve più tempo per far convergere meglio la FFT) e quindi del bitrate (sì, non compensa il fatto che il singolo simbolo è più informativo) nonché ***più energia consumata***. Il valore di SF è gestito da un algoritmo di ***Adaptive Data Rate*** (***ADR***).","x":-2773,"y":-6181,"width":759,"height":935,"color":"4"},
		{"id":"3597ccf3b344202f","type":"file","file":"ChirpsEncoding.png","x":-2772,"y":-6736,"width":758,"height":326},
		{"id":"ba42152a4874f4ca","type":"file","file":"LoRaSF.png","x":-1764,"y":-5916,"width":758,"height":404},
		{"id":"b54be15714c61b19","type":"file","file":"SF_DataRate.png","x":-1764,"y":-5359,"width":758,"height":113},
		{"id":"fa9a4a253814f58f","type":"text","text":"# LoRaWAN - Sicurezza\n\nQuando un sensore invia dei dati, non ho alcuna sicurezza che questi non vengano ascoltati e/o falsificati per \"attacchi replay\" da un'entità esterna. Allora la creo.\n\nLoRaWAN implementa due livelli di sicurezza, rispettivamente al livello di Rete e al livello Applicazione. Il motivo è semplice: chi gestisce il corretto funzionamento della Rete non deve essere in grado di leggere i payload applicazione.\n\n- ***Message Integrity Code*** (***MIC***) - Per essere certo che il frame che sto leggendo sia partito proprio dal mio nodo e che non sia stato modificato allego una firma crittografica in coda ad esso. Il MIC è un hash calcolato dal nodo (con algoritmo ***AES-CMAC***) e verificato dal ***network server*** utilizzando una ***Network Session Key*** (***NwkSKey***) condivisa con il nodo. Questo garantisce integrità ed autenticazione;\n\t- Oltre a questo, il frame è protetto dai replay con un counter incrementale.\n- ***Crittografia End-To-End*** - Il payload Applicazione è crittato da una chiave condivisa dal nodo e dall'***application server***, detta ***Application Session Key*** (***AppSKey***).\n\nTutto molto bello, ma come fa il nodo ad ottenere queste chiavi condivise? Quando entra nella rete, ogni nodo può ottenere le chiavi in due modi:\n\n- ***Activation By Personalization*** (***ABP***) - Le chiavi sono state già caricate sul nodo prima che questo venisse disposto sul territorio. Di buono c'è che questo è subito pronto, ma di contro le chiavi sono statiche: se un attaccante compromette il nodo, nessuno sarà in grado di cambiare le chiavi per togliergli l'accesso. Pertanto si usa solo in fase di test;\n- ***Over-The-Air Activation*** (***OTAA***) - C'è un ***Join Server*** che salva una chiave (***AppKey***) hard-coded nel nodo che vuole unirsi alla rete. Questo invia una ***Join Request*** firmata con la propria chiave condivisa, il `Join Server` verifica autenticità e integrità e risponde con una `NwkSKey` ed una `AppSKey` su un messaggio di ***Join Accept*** cifrato con la `AppKey`. Le chiavi vengono rinegoziate ad ogni nuova attivazione del nodo.","x":-1760,"y":-4776,"width":759,"height":789,"color":"4"},
		{"id":"1e3fd2b7a4b6a7cc","type":"text","text":"# HowTo Build IoT Networks\n\nPur essendo molto diversi fra loro, tutti i sistemi IoT poggiano sulla stessa architettura:\n\n- ***Cloud*** - Il cervellone che ha il quadro completo della situazione e sa cosa fare si trova su Internet. Per raggiungere i dispositivi deve passare attraverso il loro Gateway;\n\t- Se il sistema è complesso, può distribuirsi sul territorio tramite i ***fog nodes***.\n- ***Gateway*** - Comunica con il Cloud tramite protocolli Internet (TCP/IP), e con i dispositivi tramite protocolli locali (e.g. BLE, ZigBee, WiFi, 6LoWPAN);\n\t- Nota che il Gateway tendenzialmente non è il router domestico, piuttosto un hub che accede ad Internet tramite esso e poi si interfaccia con i dispositivi.\n- ***Embedded Devices*** - I dispositivi veri e propri (***Things***).\n\nNel complesso, possiamo individuare una ***stack protocollare*** propria delle reti IoT.","x":258,"y":-1000,"width":759,"height":387,"color":"6"},
		{"id":"cde7b123e5b31576","type":"text","text":"# Progetto?","x":10158,"y":-999,"width":759,"height":387},
		{"id":"6e29127a1ccbdbb7","type":"text","text":"# LoRaWAN MAC\n\nUn `frame` qui consta di `1 byte` di `header`, un `payload` di lunghezza variabile ed una coda di `4 byte` che funge da `MAC Integrity Code` (`MIC`). A livello logico, la topologia tipica è a stella, eventualmente applicabile a cascata realizzando una \"***star of stars***\", in cui dal server partono i gateway e da essi gli endpoint o altri eventuali gateway.\n\nDetto questo, il livello MAC è implementato con tre classi di funzionalità:\n\n- `A` - Supportato da tutti i device. Definisce i periodi di trasmissione e due brevi finestre di ricezione, adatto ad invii sporadici e risposte veloci, buona efficienza energetica;\n- `B` - Oltre alle cose della classe `A`, questa prevede messaggi di sincronizzazione dai gateway per aprire finestre di ricezione più complesse;\n- `C` - Questi device ascoltano sempre, eccetto quando trasmettono.\n\nNon serve entrare troppo in dettaglio perché lei queste classi non le ha manco nominate.\n\n","x":-2773,"y":-3517,"width":759,"height":422,"color":"4"},
		{"id":"fce100942ec32122","type":"text","text":"# Quindi in pratica...\n\nIn pratica tutti i dispositivi BLE usano GATT, quindi gli `Attributi` sono organizzati come\n\n```\nService (Service Semantic UUID)\n\tCharacteristic Declaration (props, reference handle, Char. Semantic UUID)\n\t\tValue (Char. Semantic UUID)\n\t\tDescriptors (Not Mandatory)\n\tCharacteristic Declaration (props, reference handle, Char. Semantic UUID)\n\t\t[...]\nService (Service Semantic UUID)\n\t[...]\n```\n\nSe prendiamo l'esempio della batteria potremmo avere\n\n```\n\n0x0001 | 0x2800 | Primary Service           | 0x180F (Battery)\n0x0002 | 0x2803 | Characteristic | notify+read, handle: 0x0003, UUID: 0x2A19\n0x0003 | 0x2A19 | Battery Level             | 0x4F\n0x0004 | 0x2902 | CCCD                      | 0x0001  (notify attivo)\n```\n\nL'insieme dei `Servizi` è detto ***Profilo***. Un `client` che non conosce il `server` invia una `GATT Primary Service Discovery` e si vede rispondere una lista di `Service Semantic UUIDs`. Poi può mandare la richiesta sul singolo `Servizio`, e il `server` risponde con le `Characteristics` di quel `Servizio`. Abbiamo appena scoperto in modo gerarchico e logico quali informazioni offre il `server`.","x":-2769,"y":-1888,"width":755,"height":701,"color":"4"},
		{"id":"4c4f09f460fb5852","type":"text","text":"# 6LoWPAN\n\nAcronimo per il nome chilometrico ***IPv6 over Low Power Wireless Personal Area Network***, è un protocollo che snellisce lo standard `IPv6` per adattarlo alle reti di sensori IoT.\n\nIn quanto tale, non è propriamente un protocollo di Rete (quello semmai è `IPv6`), piuttosto si situa tra la Rete ed il DLL, dovendo adattare `IPv6` a cose tipo ***802.15.4***. In che senso? I protocolli DLL per IoT sono tendenzialmente leggeri e inaffidabili nel trasporto dati. Nello specifico, `802.15.4` ha un `MTU` di `127 byte`, e se ci metti `40 byte` solo di `header IPv6` ti sei giocato un terzo di spazio disponibile.\n\nLa naturale risposta è ridurre la dimensione dell'`header IPv6`, rendendolo un ***IPv6 Header Compression*** (***IPHC***). In realtà è facile, perché molti dei campi sono prevedibili o ridondanti. I primi `4 bit` si possono omettere (la versione del protocollo sarà sempre `6`), poi abbiamo:\n\n- `Traffic Class` e `Flow Label` di norma sono entrambi `0`, quindi nel dubbio non li invii, e in caso li invii compressi (i.e. usando meno `bit` dei `28` previsti), se serve;\n- `Payload Length` è inutile, in quanto deducibile dallo stesso campo presente nel `frame` del `DLL`. Altri `16 bit` tagliati;\n- `Next Header` e `Hop Limit` entrambi vengono compressi, passando da `8 bit` a `2 bit` ciascuno: il `payload` è quasi sempre `UDP` o `ICMPv6`, posso ridurre a `4` scelte, e lascio per `Hop Limit` solo le possibilità `Default` (spesso `64`), `1`, `64` e `255`);\n- Di norma questo protocollo fa parlare il gateway con i nodi, quindi abbiamo una rete `IPv6` locale in cui uso indirizzi `Link Local`. Se i nodi conoscono il `prefisso di rete` del gateway, evito di mandarlo nel campo `Source Address`. Se poi gli indirizzi sono generati a partire da un `MAC Address` tramite `EUI-64` posso evitare di mandare anche l'`ID`. Altrimenti mi tocca mandare tutti e `128` i `bit`;\n- Discorsi simili si applicano al `Destination Address`, verosimilmente derivabile dal `MAC Address`. Se poi devo fare multicast locale, `6LoWPAN` lo rappresenta con `1`.\n\nIl ***risultato*** di tutto questo è che il nuovo `header IPHC` è sempre lungo `2 byte` e contiene dei `flag bit` che indicano se un certo campo è compresso o meno.\n\nChiaramente ci piacerebbe che tutto questo sia già sufficiente, ma non è detto. Come già accade su `IP` classico, potrebbe essere necessario implementare la ***frammentazione***.","x":-8823,"y":-5826,"width":759,"height":1012,"color":"4"},
		{"id":"39acf2fe787406cf","type":"text","text":"# Frammentazione & Routing\n\nImmaginiamo di avere una rete con nodi `{A, B, C, D}`, e di dover instradare un pacchetto `6LoWPAN` da `A` a `D` passando per `B` e `C`. Il ***routing*** può avvenire a due livelli:\n\n- ***Route-Over*** - Il forwarding è a livello di Rete. Questo significa che ogni nodo deve decapsulare fino al protocollo di Rete, decomprimere l'`header IPHC` in uno `IPv6`, capire dove sta andando quel pacchetto e infine inoltrarlo. È il comportamento classico di un ***router***, ma ciò implica che `B` e `C` devono gestire completamente la ***frammentazione***, i.e. se il pacchetto è frammentato devono\n\t- Mantenere in memoria tutti i frammenti;\n\t- Ricomporre il pacchetto `IPv6`;\n\t- Decidere sulla base di `IPv6` dove inoltrarlo;\n\t- Ri-frammentarlo, se necessario.\n- ***Mesh-Under*** - Il forwarding è gestito a livello `MAC` (similmente a come fa ZigBee, cfr. ***ZigBee Address Assignment***). Qui la frammentazione `IP` è più semplice, perché non dovendo decapsulare oltre il DLL neanche si vede. Inoltre, richiede meno risorse (sia in termini di memoria che di energia), non dovendo risalire la stack.\n\nÈ chiaro che detta così il secondo metodo sembra migliore, e su reti locali semplici in cui non sono interessato a gestire singolarmente il singolo nodo è così. \n\nLo svantaggio è chiaramente che non ho visibilità interna, i.e. se facessi `traceroute` nel percorso `A → D` troverei letteralmente solo `D`: quelli intermedi non sono nodi `IPv6`. Questo limita il controllo che ho sulla rete.\n\nRoute-Over va inoltre affiancato ad un protocollo di routing, tipicamente ***Routing Protocol for Low-power and Lossy Networks*** (***RLP***, che fantasia eh?).","x":-9832,"y":-5826,"width":759,"height":1012,"color":"4"},
		{"id":"35bb9ae08bb9455f","type":"text","text":"# Protocolli Applicazione\n\nCome detto, qui fondiamo i layer di Trasporto e Applicazione di TCP/IP. Segue che abbiamo sostanzialmente due protocolli:\n\n- ***MQTT*** - Protocollo simil-TCP per connessioni leggere ma persistenti, con una buona tolleranza rispetto a frequenti disconnessioni;\n- ***CoAP*** - Protocollo simil-UDP che richiama un po' lo stile di `HTTP` (ha i `metodi`).\n\n... o meglio, qua ne vediamo un paio, giusto per capire. Ovviamente ogni applicazione proprietaria si fa il suo, tipo ***ZCL*** (**ZigBee Cluster Library**). La cosa buona è che o si basano su questi oppure fanno proprio parte di un'intera stack `non-IP` (tipo appunto ZCL).","x":-6805,"y":-6777,"width":759,"height":386,"color":"6"},
		{"id":"115ce219e6656c06","type":"text","text":"# MQTT\n\n***Message Queuing Telemetry Transport*** (***MQTT***) è un protocollo Applicazione basato su ***TCP*** e sul paradigma ***publisher-broker-subscriber***, che è di fatto una variante del classico `client`-`server` in cui distinguiamo `sender` e `receiver`. Il ruolo del `broker` è di ricevere i messaggi dai `publisher`, eventualmente filtrarli e infine distribuirli correttamente ai `subscriber`. Questo di fatto costituisce una sorta di filtro spaziotemporale, visto che il `subscriber` non ha neanche bisogno che il `publisher` sia online per leggere i messaggi.\n\nMa come funziona, detto un po' meglio?\n\nIl `broker` organizza i dati gerarchicamente, come in un filesystem. Questa roba viene realizzata con il meccanismo dei ***topics***. Ipotizziamo di avere diverse stanze e diversi sensori per ogni stanza. Il `broker` crea una roba del tipo\n\n```\nhome\n\tkitchen\n\t\ttemperature\n\t\thumidity\n\t\t[...]\n\t[...]\n```\n\nI sensori mandano una `CONNECT` al `broker` e stabiliscono un connessione `MQTT`, poi:\n\n- Quelli dei termosifoni sono interessati alla temperatura della propria stanza, quindi quello della cucina invia una `SUBSCRIBE` in cui specifica `home/kitchen/temperature` come `topic`. Questo significa che il `broker` lo aggiornerà sulle variazioni;\n- Quelli di temperatura in questo scenario sono i `publisher`. Quello della cucina manda periodicamente una `PUBLISH` al `broker` specificando `home/kitchen/temperature` come `topic` e ovviamente il valore da pubblicizzare;\n- Quando arriva la `PUBLISH`, il `broker` notifica i sensori iscritti a quel `topic`.\n\nSegue naturalmente che la topologia logica è a stella.","x":-7811,"y":-7035,"width":756,"height":902,"color":"4"},
		{"id":"70cc3edb86043d4a","type":"text","text":"# SPACING","x":-5544,"y":-7152,"width":250,"height":235,"color":"5"},
		{"id":"b029f2e213858cf0","type":"file","file":"ConstellationDiagram.png","x":-4788,"y":2299,"width":759,"height":534},
		{"id":"972bcba6f6b492b7","type":"text","text":"# ZigBee Address Assignment\n\nCome detto, $R\\ne C$. Questo implica che esistono figli router e figli non router.\n\n- Se il figlio è un `end device` (foglia) il suo indirizzo è calcolato come$$\\text{LeafAddress}_{d+1}^n=\\text{FatherAddress}_d+S(d)\\times R + n$$Ok, che è sta roba?\n\t- Intanto se il $\\text{FatherAddress}$ si trova a livello $d$, il $\\text{LeafAddress}$ si trova al livello $d+1$;\n\t- Il termine $S(d)\\times R$ è lo spazio di indirizzamento di cui avranno bisogno tutti ed $R$ i figli $\\text{Router}$ (loro stessi compresi) per assegnare un indirizzo a tutti i possibili nodi dell'albero completo che parte dal $\\text{Father}$. In altre parole, prima lascio lo spazio per tutti i possibili sotto-alberi che partono dai figli $\\text{Router}$, dopodiché passo alle $\\text{Leaf}$;\n\t- $n$ è banalmente l'offset perché sto allocando l'$n$-esimo $\\text{LeafAddress}$.\n- Se il figlio è un `router device` (potenziale radice di un altro albero) abbiamo invece$$\\text{RouterAddress}_{d+1}^m=\\text{FatherAddress}_d+S(d)\\times (m-1)+1$$Qui per il primo figlio $\\text{Router}$ ($m=1$) non c'è bisogno di lasciare alcuno spazio, è semplicemente l'indirizzo successivo rispetto a quello del padre.\n\nPer i più curiosi (io avrei fatto a meno, ma c'è scritto sulle slides), $S(d)$ si calcola come\n$$S(d)=\\begin{cases}\n0&\\text{se }R=0\\\\\n1+C(L-d-1)&\\text{se }R=1\\\\\n{CR^{L-d-1}-1-C+R\\over R-1}&\\text{se }R>1\n\\end{cases}$$\nEsce fuori una progressione geometrica, ma non ho assolutamente voglia di dimostrarlo.","x":-7800,"y":-2412,"width":759,"height":673,"color":"4"},
		{"id":"37bbc6e1153b3dc2","type":"text","text":"## Integrazione e Punti Chiave Aggiuntivi\n\n- **IEEE 802.15.4:** Zigbee è costruito sopra lo standard IEEE 802.15.4, che definisce i livelli fisico (PHY) e di controllo dell'accesso al mezzo (MAC). L'indirizzamento gerarchico è una caratteristica del livello di rete (NWK) di Zigbee, che si appoggia sulle funzionalità MAC di IEEE 802.15.4. La topologia ad albero è una delle topologie supportate da IEEE 802.15.4 e usata da Zigbee per questo schema.\n- **Coordinatore Zigbee (ZC):** È il nodo radice dell'albero (livello 0), tipicamente con indirizzo 0. È responsabile dell'avvio della rete.\n- **Router Zigbee (ZR):** Sono i nodi intermedi che possono instradare il traffico e permettere ad altri dispositivi di unirsi alla rete.\n- **Dispositivi Finali Zigbee (ZED):** Sono i nodi \"foglia\" dell'albero. Tipicamente sono dispositivi a basso consumo che comunicano solo con il loro genitore (un router o il coordinatore) e non instradano traffico.\n- **Overflow di Indirizzi:** Lo schema è progettato per essere efficiente, ma in reti molto grandi o dense, la gestione degli indirizzi e il rischio di esaurire gli indirizzi in un particolare sotto-albero possono diventare una sfida. Ci sono meccanismi (come l'uso di indirizzi stocastici o la riorganizzazione della rete) per gestire queste situazioni, anche se non sono dettagliati in queste slide.\n- **Conflitti di Indirizzo:** Sebbene lo schema sia progettato per assegnare indirizzi univoci, in scenari dinamici o con errori, possono teoricamente verificarsi conflitti, che la rete deve essere in grado di rilevare e risolvere.","x":-7800,"y":-3150,"width":759,"height":593},
		{"id":"bc4657e96dfd6f9a","type":"text","text":"# Modulazione dei Segnali\n\namplitude + phase shift molto usato\n\nconstellation diagrams ti permettono di encodare diverse combinazioni di bit con una certa combinazione ampiezza-fase. Il receiver riceve il punto rosso e inferisce qual è il messaggio più probabile. in pratica puoi definire un constellation diagram per definire il numero di simboli (o words) che trasmetti con il singolo \"quanto\" d'onda. Nota che simboli $\\ne$ bit. Se sono 4 ho `00 01 10 11`, i.e. ogni simbolo consta di DUE bit.\n\nTransmission rate = $\\log(DN)$ dove D \"numero di diagrammi\" (?) e N numero di punti per ogni diagramma. se aumento il numero di bit per simbolo ogni simbolo diventa più informativo. distinguiamo quindi il bitrate dal symbol rate.\n\nerrori - devo ovviamente separare al meglio i punti per facilitare l'inferenza. Lo faccio aumentando l'ampiezza. la potenza del segnale è data dall'ampiezza media. immagino che si codificano i least used symbols con punti poco potenti e viceversa. rivedi slide 86. fa discorso sul fatto che se faccio simboli super informativi è facile sbagliare grossi pezzi di info, allora devo alzare la potenza per separare meglio i punti.\n\nè chiaro che bitrate $\\propto$ potenza. Ma anche bandwidth? Sì, ovviamente. questo giochino dei diagrammi di costellazione lo faccio a frequenza fissata, quindi usare più frequenze significa usare più diagrammi (la $D$ della formula di prima che non avevo capito cosa significasse). Tipo, WiFi ne usa 16 (la famosa banda 2.4GHz), ogni 2 MHz.\n\nla roba dell'allargamento in frequenza la presenta al contrario: l'idea è che devi usare un botto di frequenze per realizzare Fourier. (ma bastano quelle contigue dello spettro??)\n\nChannel Capacity C = B log_2 (1+SNR), quindi se aumento la bandwidth aumento la channel capacity meglio di se aumento SNR\n\nSlide 95 - In teoria i due canali hanno la stessa capacità, in pratica per le interferenze le frequenze più alte sono più efficienti. anche perché \"less crowded\". molti protocolli (anche IoT) usano le frequenze basse, quindi c'è un botto di collision risk.\n\nquesta roba è vera anche per i cavi oltre che per il wifi, ma usano tutte le frequenze fisicamente disponibili?","x":-6806,"y":2404,"width":759,"height":858},
		{"id":"5eca9353fa7428da","type":"text","text":"# REST-like (GPT)\n\nUn **protocollo REST-like** (o **RESTful-like**) è un protocollo di comunicazione che **segue i principi fondamentali di REST** (Representational State Transfer), **senza aderirvi rigidamente**. In pratica, è \"ispirato\" a REST ma può semplificare, adattare o omettere alcune sue caratteristiche.\n\nPrincipi REST (semplificati):\n\nUn protocollo è pienamente RESTful se:\n\n1. **È stateless**: ogni richiesta contiene tutte le informazioni necessarie.\n    \n2. **Espone risorse tramite URI**.\n    \n3. **Usa metodi HTTP coerentemente** (`GET`, `POST`, `PUT`, `DELETE`, ecc.).\n    \n4. **Usa rappresentazioni standard (es. JSON, XML)**.\n    \n5. **Supporta il caching** dove possibile.\n    \n6. **Usa HATEOAS** (Hypermedia As The Engine Of Application State), cioè fornisce collegamenti ipertestuali per guidare il client.\n\nREST-like = parzialmente RESTful\n\nUn protocollo è detto **REST-like** se:\n\n- **segue solo alcune delle regole** sopra (es. espone risorse e usa JSON, ma non è del tutto stateless),\n    \n- **semplifica per vincoli pratici** (es. in ambienti a bassa potenza come l’IoT),\n    \n- **non usa HATEOAS** (che è spesso ignorato).\n### 📌 Esempi:\n\n- **CoAP (Constrained Application Protocol)**: spesso descritto come REST-like perché:\n    \n    - Usa metodi simili a HTTP (`GET`, `PUT`, `POST`, `DELETE`),\n        \n    - Espone risorse indirizzabili,\n        \n    - Ma funziona su UDP (non TCP), e omette molte feature HTTP (come HATEOAS).\n        \n- **API interne leggere**: molte micro-API usano solo `GET/POST` e JSON, senza seguire pienamente tutti i principi REST → sono REST-like.\n    \n\n---\n\n### 🧠 In sintesi:\n\n> Un protocollo REST-like **si ispira a REST** per organizzare la comunicazione a base di risorse e operazioni standardizzate, **ma si adatta a vincoli di semplicità, efficienza o contesto tecnico** (come nel caso dell’IoT o dei protocolli leggeri).","x":-7811,"y":-8102,"width":756,"height":902},
		{"id":"d2ec2dd53be1d5c1","type":"text","text":"# CoAP\n\n***Constrained Application Protocol*** (***CoAP***) è un classico `client`-`server` basato su `UDP`, molto simile nel complesso ad `HTTP` (***REST-like***, vedi a fianco). Poi, uno ovviamente dice `client`-`server` ma di fatto qui si comunica tra nodi, quindi è tipo `client`-`client` (qualcuno azzarda addirittura a dire `peer-to-peer`, ma non vorrei esagerare).\n\nE niente, di base è `HTTP`: ci stanno\n\n- La `GET` per recuperare le informazioni identificate dall'`URI`;\n\t- Come bonus posso trasformarla in una `OBSERVE`, una sorta di `GET CONDIZIONALE` che dice `inviami sta roba solo se cambia`.\n- La `POST`, per creare nuove risorse remote, con la sua variante `PUT` che aggiorna la risorsa e la crea solo se non c'è;\n- La `DELETE`, autoesplicativa.\n\nSegue una breve disamina sull'`header`, ma mi annoia. L'unica cosa da notare è che prevede direttamente un `Token` per identificare la \"connessione\" (che bravi, ma allora qualche cosa l'abbiamo imparata da `HTTP`!).\n\nSu questo poi, aggiungo, si basa ***LwM2M*** (***Lightweight M2M***), una sorta di SNMP per l'IoT.","x":-6803,"y":-8102,"width":756,"height":902,"color":"4"},
		{"id":"68a90a1d6066f059","type":"text","text":"Domanda centrata — e tocca un punto sottile ma cruciale.\n\nHai ragione nel dire che i protocolli **MAC (Medium Access Control)** nascono per **coordinare l’accesso al mezzo condiviso**, e che i metodi di **multiplexing** (FDM, TDM, CDM, OFDM, NOMA…) sono appunto tecniche per separare gli utenti. Quindi: se ho già separato tutto elegantemente a livello fisico, _perché dovrei aver bisogno di un MAC?_\n\nLa risposta sta nel **livello di astrazione** a cui stai guardando il sistema.\n\n---\n\n## 🔁 Multiplexing ≠ Access Control\n\n**Multiplexing** ti dà _gli strumenti per separare_.\n\n**MAC** ti dice _chi li usa, quando, come_.\n\n---\n\n### Esempi concreti:\n\n#### ✅ **TDM classico (es: BLE, GSM)**\n\n- Le risorse (slot temporali) sono rigide e numerate.\n    \n- Il MAC è quasi banale: basta assegnare lo slot.\n    \n- Ma _chi_ assegna gli slot? → **Scheduler → MAC layer.**\n    \n\n#### ⚠️ **Slotted Aloha / Random Access**\n\n- Nessuna pianificazione → rischio collisioni → MAC serve eccome: gestisce backoff, retry, probabilità di accesso…\n    \n\n#### 🧠 **CDM (es: 3G)**\n\n- Tutti trasmettono sulla **stessa frequenza**, **nello stesso tempo**.\n    \n- Separazione logica = codici ortogonali (Walsh, Gold…).\n    \n- Ma:\n    \n    - **Quali codici dare a chi?**\n        \n    - **Quanti utenti posso supportare prima che il rumore multiplo mi soffochi?**\n        \n    - → qui il MAC si occupa di **gestire l’allocazione dei codici** e **decidere chi può accedere** (es. con scheduling basato su interferenza attesa).\n        \n\n#### ⚙️ **OFDM / LTE / 5G**\n\n- Le risorse sono **griglie tempo-frequenza** (RB = Resource Blocks).\n    \n- MAC decide **quali RB assegnare a chi**, **ogni millisecondo**, sulla base di priorità, carico, QoS…\n    \n- Il PHY non fa nulla senza istruzioni dal MAC.\n    \n\n---\n\n## ⛓️ In sintesi: il MAC non sparisce, cambia solo lavoro\n\n|Multiplexing|Ruolo del MAC|\n|---|---|\n|TDM rigido|Assegna slot|\n|TDM casuale|Risolve collisioni|\n|FDM|Assegna canali (es. WiFi)|\n|CDM|Alloca codici e controlla interferenza|\n|OFDM|Scheduler → decide come usare la griglia|\n|NOMA|Gestisce potenze relative + decodifica SIC|\n\n---\n\n### 💡 Analogia\n\n> Il multiplexing è come costruire un’autostrada con 8 corsie (slot, codici, canali…).\n\n> Il MAC è il casellante (o meglio il vigile urbano smart) che decide chi entra, su quale corsia, e a che velocità, cercando di evitare incidenti e ingorghi.\n\n---\n\nPosso mostrarti uno schema (gerarchia stack PHY/MAC/scheduling) se vuoi un quadro visivo. Vuoi?","x":-12109,"y":965,"width":759,"height":1897},
		{"id":"faf2da1cb4d38aaa","type":"text","text":"Domanda perfetta — e la risposta svela uno dei punti più delicati del **CDMA**: l'apparente magia dell’**ortogonalità dei codici** _non è gratis_ e _non è garantita in ogni condizione_. Vediamo perché.\n\n---\n\n## ✅ In teoria: ortogonalità perfetta = nessuna interferenza\n\nNel CDMA (Code Division Multiple Access), ogni utente ha un suo **codice di spreading** ci(t)c_i(t), e il segnale trasmesso è il prodotto del dato di(t)d_i(t) con il codice:\n\nsi(t)=di(t)⋅ci(t)s_i(t) = d_i(t) \\cdot c_i(t)\n\nA ricezione, se i codici sono ortogonali, hai:\n\n⟨ci,cj⟩=0per i≠j\\langle c_i, c_j \\rangle = 0 \\quad \\text{per } i \\ne j\n\nQuesto significa che il ricevitore può \"filtrare\" il segnale di uno specifico utente con il suo codice, e tutto il resto si annulla.\n\n→ Nessuna interferenza. Su carta.\n\n---\n\n## ❌ In pratica: l’ortogonalità è fragile\n\nNella realtà delle reti cellulari, diversi fattori rovinano questa condizione ideale:\n\n### 1. **Asincronia tra utenti**\n\nNel mondo reale, gli utenti non trasmettono in perfetta sincronia (specialmente in uplink). Anche un leggero sfasamento temporale **rompe l’ortogonalità** tra codici.\n\n> L’ortogonalità è _tempo-dipendente_. Se i segnali arrivano disallineati, non si “cancellano” più.\n\n🔧 Le reti come **3G UMTS** usano codici **Walsh-Hadamard**, che sono ortogonali **solo se sincronizzati**. In uplink, si passa a **codici pseudo-random** (es. Gold) che hanno buone proprietà anche asincrone, ma non perfette.\n\n---\n\n### 2. **Rumore e canale reale**\n\n- **Fading**, **rumore**, **ritardi multipath**: tutto questo altera il segnale ricevuto.\n    \n- I codici non arrivano più “puliti”, e l’operazione di correlazione non riesce a separare perfettamente i flussi.\n    \n\n→ Si introduce **Multiple Access Interference (MAI)**.\n\n---\n\n### 3. **Numero di utenti (overloading)**\n\nCDMA può supportare un numero di utenti _maggiore_ del numero di codici ortogonali, sfruttando il fatto che i codici non devono essere perfetti.\n\nMa ogni nuovo utente introduce **interferenza additiva** sul segnale degli altri. Se sei in un ambiente già carico, questa interferenza **non è trascurabile**.\n\n→ La qualità cala, il BER aumenta, e devi **abbassare la data rate** o ridurre gli utenti attivi.\n\n---\n\n## 💡 Conclusione: l’ortogonalità è un'illusione utile, non una garanzia\n\n> CDMA funziona bene finché riesco a tenere sotto controllo **la sincronia**, **la potenza relativa tra utenti** (power control!), e **il numero di utenti attivi**.\n\nQuando uno di questi parametri va fuori scala, i codici iniziano a “parlarsi sopra” e la prestazione degrada rapidamente.\n\n---\n\nPosso mostrarti un esempio numerico con correlazione di due codici con piccolo sfasamento se vuoi. Ti interessa?","x":-11069,"y":965,"width":759,"height":1793},
		{"id":"efa33c7c0a47d3b4","type":"text","text":"# SPACING","x":-15280,"y":3320,"width":250,"height":235,"color":"5"},
		{"id":"1a2cecdba2fe3a3e","type":"text","text":"Perfetto, allora concludiamo la carrellata collegando questi concetti all'evoluzione reale delle reti, sempre nel tuo stile:\n\n---\n\n### 📱 CDMA nella pratica: il caso del 3G\n\nCDMA è stato **l’eroe silenzioso della terza generazione di reti mobili (3G)**.\n\n🧾 Due grandi famiglie di standard 3G:\n\n- **UMTS** (Europa) → usa **W-CDMA** (Wideband CDMA), una versione più larga di DSSS.\n    \n- **CDMA2000** (USA, Qualcomm) → stesso principio, altri dettagli.\n    \n\n🎯 Perché CDMA ha senso nel mobile:\n\n- Tutti condividono la stessa frequenza → _non serve pianificare celle su frequenze diverse_ (come nel GSM).\n    \n- Robustezza al rumore e alla **mobilità** → un utente che si muove può essere seguito più facilmente.\n    \n- Codici ortogonali = separazione logica tra utenti, anche se parlano “insieme”.\n    \n\n📉 Però…\n\n- Non scala bene quando gli utenti sono troppi → i codici ortogonali iniziano a interferire.\n    \n- Decodifica complessa → richiede hardware più potente.\n    \n- Non si presta bene alla **trasmissione dati ad alta velocità** con flussi bursty.\n    \n\n👉 Risultato: **ottimo per voce**, ma **non per Internet mobile moderno**.\n\n---\n\n### 🚧 CDMA nel WiFi? No grazie\n\nIl WiFi (sia 802.11a/b/g/n/ac/ax...) **non usa CDMA**. In compenso, implementa:\n\n- FDM (sotto forma di **OFDM**, ne parliamo dopo)\n    \n- TDM (scheduling a livello MAC)\n    \n\nPerché non CDMA?\n\n- Coordinazione dei codici in ambiente decentralizzato = difficile.\n    \n- Conflitti e interferenze tra reti vicine = complicazioni.\n    \n- Lo standard IEEE ha scelto altre strade più facili da implementare.\n    \n\n---\n\n### 🔄 Transizione moderna: OFDM e MIMO\n\nCDMA è ormai _legacy_. Le reti moderne (LTE, 5G, WiFi 6+) preferiscono:\n\n- **OFDM** (Orthogonal Frequency Division Multiplexing) = FDM “potenziato”:\n    \n    - Divide lo spettro in tanti sotto-canali ortogonali.\n        \n    - Ogni utente può usare una combinazione dinamica di questi.\n        \n    - Molto efficiente in ambienti con riflessione e multipath (cioè… ovunque).\n        \n- **MIMO** (Multiple Input Multiple Output) = SDM reale:\n    \n    - Usa più antenne per mandare più stream contemporaneamente.\n        \n    - Se l’ambiente ha riflessioni, **le sfruttiamo** invece di combatterle.\n        \n\n📈 Risultato: CDMA è stato importante **come step concettuale**, ma oggi è stato superato da tecnologie più flessibili e scalabili.\n\n---\n\n### In chiusura\n\nCDMA è l’alternativa “matematica” a FDM e TDM: in luogo di tempo e frequenza, separa i segnali usando **codici ortogonali**. È stato usato con successo in reti mobili (3G), ma oggi è stato quasi del tutto abbandonato a favore di:\n\n- **OFDM** per l’efficienza spettrale.\n    \n- **MIMO** per l’efficienza spaziale.\n    \n- E **MAC layer scheduling** per ottimizzare accesso e priorità.\n    \n\n🔚 Nonostante ciò, capire CDMA e DSSS è fondamentale perché:\n\n- Ci insegna come codifica e ortogonalità possano diventare _risorse_.\n    \n- Sono ancora usati in contesti specifici (GPS, reti militari, sensori a basso bitrate, RFID...).\n    \n\nVuoi che continui con OFDM e MIMO nel dettaglio, oppure andiamo su NOMA e altre tecniche più moderne?","x":-14360,"y":965,"width":840,"height":1870},
		{"id":"c8f665ef67bbc260","type":"text","text":"# `0-1 Knapsack` & Bin Packing Problem\n\nHai uno zaino con una ***capacità massima*** (e.g. 7 kg). Davanti a te hai un mucchio di oggetti. Ognuno ha un ***peso*** e un ***valore*** (quanto ti serve o quanto è prezioso). Puoi prendere ogni oggetto una sola volta (0 o 1 volte). La sfida è: quali oggetti scegli per massimizzare il valore totale nello zaino, senza superare il peso massimo? Esempio:\n\n- Laptop - 3 kg, 2000€;\n- Bottiglia d’acqua - 2 kg, 10€;\n- Oro - 5 kg, 3000€;\n- Libro - 4 kg, 100€\n\nNon puoi prendere \"mezzo oro\" o \"mezzo laptop\". Devi decidere: o lo prendi tutto, o niente. Con tanti oggetti, le possibili combinazioni esplodono e rendono il problema $\\NPC$. Serve una strategia intelligente, perché il brute force non funzionerà.\n\nTra le possibili strategie:\n\n- ***Algoritmi Greedy*** - Prendi gli oggetti col miglior rapporto valore/peso;\n- ***Programmazione dinamica*** - Costruisci una tabella che ti dice il valore massimo ottenibile per ogni sottopeso;\n- ***Branch & bound*** - Esplori l’albero delle soluzioni tagliando i rami inutili.\n\nTutto questo vale per uno zaino e prende il nome di `0-1 Knapsack Problem`. Se fossero $F$, avremmo il ***Bin Packing Problem*** (cfr. ***Fog Node Assignment Problem***).\n\nEsistono varianti di questo problema, e.g. **Fractional knapsack** (i.e. puoi prendere frazioni di oggetti, diventa più facilmente risolvibile in modo greedy).","x":2276,"y":741,"width":759,"height":695,"color":"4"},
		{"id":"1d4c9d197fab6065","type":"text","text":"# Gurobi\n\nVedi codice colab. Esegui, gioca. C'è un problema di ottimizzazione su classroom\n\ngurobi cerca soluzioni esatte, non è approssimante \n\npoi ha fatto una roba sull'ottimizzazione lineare in generale\n\n\n\nottimizzazione lineare in N dimensioni: $\\min_x c^Tx = \\min_x \\sum_i c_ix_i$ con constraints$$Ax\\le b\\quad A_ex=b_e\\quad x\\in D$$\nnel problema di prima questi constraints (credo siano restrizioni di dominio e condizioni al contorno) diventano$$\\sum_ix_ir_i\\le g\\quad \\sum_{i\\ne j}x_{ij}=1\\quad x\\in\\Z$$\nho scritto \"copia tablet\" ma non trovo questi fantomatici appunti a riguardo.","x":2276,"y":1656,"width":759,"height":902},
		{"id":"50577e8138d4ae08","type":"text","text":"# Distributed Data Analysis\n\n","x":258,"y":120,"width":759,"height":386,"color":"6"},
		{"id":"9b2cfe41270520f4","type":"text","text":"# Secondo Esonero","x":-751,"y":183,"width":759,"height":260,"color":"5"},
		{"id":"c778fab4c43a3675","type":"text","text":"# Federated Learning","x":-751,"y":741,"width":759,"height":695},
		{"id":"d700a52cca1cdc2a","type":"text","text":"# Fog Computing\n\nIl Cloud, seppur potente, è costoso e lontano (nonché potenzialmente offline, in caso di guasti). Alcune applicazioni potrebbero richiedere decisioni rapide (e.g. un sensore di caduta per persone anziane è costretto a decidere rapidamente se mandare l'allarme), in altre bisogna considerare che una rete IoT può essere usata per gli obiettivi più disparati, e che per questo sia HW che SW sono fortemente specifici dell'applicazione.\n\nViene quindi naturale capire che in una rete IoT vanno elaborati dati ***eterogenei***, sia nel senso che diversi sensori producono diversi formati di output (i.e. i ***dati*** nel complesso sono ***non-strutturati***) sia che diverse informazioni hanno diverse ***priorità***. È scomodo far gravare tutto il peso di un'analisi dati fortemente diversificata su un unico server centrale.\n\nQuesto problema viene mitigato con i ***fog nodes***, i.e. distribuisco il server di analisi dati. Il ***Fog Computing*** è in pratica una via di mezzo tra l'Edge Computing e il Cloud Computing, in cui sono i ***gateway*** stessi a pre-processare i dati prima di inviarli al Cloud (o addirittura a decidere cosa vale la pena mandargli e cosa no).\n\nTutto molto bello, ma c'è un problema: ogni sensore genera un carico di lavoro variabile, e i fog nodes hanno capacità limitate (sia in termini di `FLOPs` che di memoria). Tradotto, bisogna trovare un algoritmo per assegnare dinamicamente le richieste dei sensori al fog node ottimale per evitare colli di bottiglia (l'assegnazione viene tipicamente svolta da un ***dispatcher*** che si trova tra le Things e i fog nodes).\n\nQuesto è un ***Bin Packing Problem*** (o `0-1 Knapsack Problem`), pertanto $\\NPC$. Per piccole/medie dimensioni esistono algoritmi di ottimizzazione che forniscono soluzioni esatte, ma diventano esponenzialmente più lenti al crescere dell'input (cfr. ***Gurobi***). Si cercano quindi euristiche ed algoritmi approssimanti.\n\n","x":1267,"y":741,"width":759,"height":695,"color":"4"},
		{"id":"ea6c2db0218bf20e","type":"text","text":"# Fog Node Assignment Problem\n\nPrendiamo l'esempio del *fall detector*. Ogni sensore invia una task (e.g. `questi sono i dati che ho raccolto, puoi fare i tuoi potenti calcoli e dirmi se vogliono dire che nonna è caduta?`) a un ***dispatcher***, che decide a quale fog node inoltrarlo.\n\nTraduciamo questa roba in matematica. Abbiamo:\n\n- $N$ sensori $s_i$, a cui corrispondono risorse richieste $r_i$ (i.e. se il sensore $s_i$ invia le proprie task ad un fog node, questo consumerà $_i$ per risolverle, e.g. in termini di `FLOPs`);\n- $F$ fog nodes $f_j$ che per funzionare richiedono risorse $g_j$ (e di conseguenza costi $c_j$). Tipicamente $N\\gg F$ (altrimenti il problema sarebbe molto semplice!);\n- Un dispatcher $D$ che raccoglie i dati e li smista ai vari fog nodes. $D$ conosce i $c_j$ di ciascun $f_j$, ed è a lui che spetta il compito di ottimizzare l'assegnazione.\n\n Definiamo due grandezze binarie:\n \n- $y_j=1 \\iff f_j$ viene utilizzato;\n- $x_{ij}=1 \\iff$  una task di $s_i$ è assegnata ad $f_j$.\n\nA questo punto il compito di $D$ è trovare la soluzione di$$\\min_y\\sum_jy_j\\,c_j$$il che ovviamente minimizza il costo complessivo. Mancano i constraints, perché così com'è la soluzione migliore è scegliere $y$ identicamente nullo. Allora mettiamo$$\\sum_jx_{ij}=1\\quad \\forall\\,i$$i.e. voglio che tutti i task siano eseguiti (altrimenti può essere che nonna cade e l'allarme non parte). Inoltre non posso eccedere la capacità totale di ciascun fog node, i.e.$$\\sum_ix_{ij}\\,r_i\\le g_j\\,y_j\\quad \\forall\\,j$$Abbiamo ufficialmente formulato il problema come ***ILP***. Questa roba è più generale rispetto ad un ***Bin Packing Problem***, perché (contrariamente ai fog nodes) gli zaini (bin) non hanno un costo associato e le loro capacità sono tutte uguali.","x":1267,"y":1656,"width":759,"height":902,"color":"4"},
		{"id":"ff3b9035a56b4e9e","type":"text","text":"# Things\n\nUna Thing ha bisogno di fare essenzialmente tre cose:\n\n1. ***Percepire l’ambiente*** - Un ***sensore*** sfrutta un fenomeno fisico (e.g. una resistenza che varia in funzione del calore) per convertire la misura da prendere in un segnale EM. Successivamente, un ADC converte il segnale da analogico a digitale, e tramite un *protocollo/architettura* ad-hoc i dati vengono inviati al processore;\n\t- Li chiamo *protocolli/architetture* perché non definiscono solo cose tipo \"`prima di mandare il segnale successivo aspetta tre colpi di clock`\", ma anche il numero e lo scopo dei fili utilizzati per farlo. Questo significa che per parlare la lingua di un certo protocollo il microcontrollore deve avere l'HW adatto;\n\t\t- ... o quasi. Esistono modi per emulare il comportamento di un protocollo via SW, motivo per cui si chiamano \"protocolli\" e non \"*protocolli/architetture*\".\n\t- Tra i più noti citiamo ***SPI*** (**Serial Peripheral Interface**, velocissimo ma richiede tanti fili), ***I2C*** (**Inter-Integrated Circuit**, lento ma ne richiede meno) e ***UART*** (**Universal Asynchronous Receiver-Transmitter**, come dice il nome si usa per la compatibilità).\n2. ***Interagire fisicamente*** - Un ***attuatore*** funziona intuitivamente al contrario: riceve un segnale dal processore (per come descritto sopra), eventualmente converte in segnale analogico con un DAC e passa il risultato al motore, che si muove di conseguenza;\n\t- Dico \"eventualmente\" perché non tutti i motori funzionano con segnali analogici. È un attuatore anche uno switch che modifica un circuito elettrico;\n\t- I requisiti vanno dalla reattività real-time alla robustezza a condizioni atmosferiche.\n3. ***Elaborare dati e prendere decisioni locali*** - Il cuore di un sistema informatico è sempre il processore. Qui distinguiamo tra due tipi di architetture:\n    - ***MCU*** (***Microcontroller Unit***) - Un singolo chip che contiene CPU, memorie e periferiche (e.g. SPI, I2C). Consuma poco ed è ottimizzato per task specifici (i.e. esegue un singolo programma, senza SO). Ne è un esempio ***ESP32***, utilizzato per le lampadine smart, ma anche ***Arduino***;\n    - ***MPU*** (***Microprocessor Unit***) - Letteralmente la CPU che metti nel tuo computer, che deve appoggiarsi ad una MoBo e che quindi è in grado di reggere roba complessa come un SO Linux. Ovvio che in IoT la MoBo deve essere piccolissima: meglio parlare di ***System-on-Chip*** (***SoC***), che differisce da una classica MoBo perché non è affatto scalabile o espandibile (... è letteralmente un chip già saldato). Ovviamente si usa RISC, e un esempio tipico è il ***Raspberry Pi***.","x":258,"y":-2644,"width":759,"height":911,"color":"4"},
		{"id":"2ce83f8e9814f3bc","type":"file","file":"IoT_Architecture.png","x":2272,"y":-1039,"width":759,"height":465},
		{"id":"a94d060ea349fc00","type":"text","text":"# Efficienza Energetica\n\nMolti dispositivi IoT sono alimentati a batteria, ed ogni milliwatt risparmiato prolunga la durata operativa. Questo costituisce sempre un trade-off tra il consumo e la precisione dei sensori (se devo spegnerli ogni `tot` per ridurne il consumo rischio di perdere dati utili, ma per risparmiare posso anche ridurre i bit di precisione o la frequenza di campionamento).\n\nSi rende efficiente un sistema embedded implementando la Sleep Mode e ottimizzando il codice, l'uso dei sensori e delle strategie di comunicazione.","x":258,"y":-3439,"width":759,"height":261,"color":"6"},
		{"id":"c39cda918518baad","type":"text","text":"# Sleep Mode\n\nIn ***Sleep Mode*** il processore attua una serie di comportamenti per ridurre i consumi:\n\n- ***Clock Gating*** - Disattiva il clock su alcune unità, che smettono quindi di assorbire corrente (e.g. se non serve il DAC, evito di farlo girare a vuoto);\n- ***Power Gating*** - Stacca l'alimentazione da alcune unità (e.g. in una CPU multi-core, può non essere sempre necessaria tutta la potenza computazionale parallela);\n- ***Dynamic Voltage and Frequency Scaling*** (***DVFS***) - Se non devo effettuare calcoli complessi, posso ridurre la tensione e la frequenza di clock (e.g. smartphones).\n\nTutto questo viene implementato in modo massiccio su ***MPU***, mentre su MCU il discorso è più complesso. Intanto tocca complicare l'HW (e non è scontato poterlo fare). Inoltre, un MCU ha bisogno di reagire in tempo reale agli interrupt dei sensori, evitando latenze dovute a lenti processi di risveglio (***wakeup latency***). Spesso gli MCU implementano direttamente il ***Deep Sleep*** (riduce le attività sia della CPU che della RAM) o l'***Ibernazione*** (salva lo stato su memoria non volatile e spegne tutto).\n\nIl fatto che su MCU ci sia meno margine per entrare in Sleep Mode non deve ingannare: essendo dispositivi ottimizzati, sono comunque loro che consumano di meno.\n\nOvviamente il consumo energetico non si azzera in Sleep Mode, per diversi motivi:\n\n- Anche se faccio Clock Gating, gli elementi circuitali esclusi sono comunque alimentati da una tensione (posso staccarla facendo Power Gating, ma in quel caso cancello tutti i bit!), che per effetti quantistici sulle giunzioni dei transistor continua a far scorrere una piccola ***leakage current*** (la quale aumenta esponenzialmente con la temperatura);\n- Anche il Power Gating può avere perdite minime sul transistor \"ponte\", che serve a staccare/riattaccare la corrente alla zona in sleep;\n- In ogni caso, non potrei mai spegnere completamente tutto il processore: ho sempre bisogno di qualcosa di attivo che riattivi gli elementi in sleep.","x":1267,"y":-3738,"width":759,"height":858,"color":"4"},
		{"id":"2d2e02a310bea4bd","type":"text","text":"# SPACING","x":-2325,"y":-167,"width":250,"height":235,"color":"5"},
		{"id":"d11ebd7b1efd8ff7","type":"text","text":"# Ottimizzazione del Codice e Riferimenti\n\nChiaro che è il codice a decidere quando andare in Sleep Mode e quando trasmettere. Questo si traduce nell'ottimizzare i periodi di ***idle*** (i.e. quando conviene disattivare cosa) e quelli di ***tempo attivo*** (i.e. se sono sveglio, allora devo fare più cose possibile).\n\n- ***Parallelismo*** - Riduce il tempo attivo eseguendo operazioni in parallelo;\n- ***Batching*** - Aspetto di avere tante cose da fare prima di attivarmi. Questo ottimizza i costi di accensione/spegnimento, riducendo la frequenza delle transizioni di stato (i.e. `ON`, `IDLE` e `HIGH DUTY`, e.g. un protocollo come BLE preferisce inviare 10 pacchetti ogni secondo piuttosto che 1 ogni decimo di secondo). Questo di fatto ottimizza il ***Duty Cycle***: il dispositivo non misura/attua/invia/riceve costantemente, ma a intervalli regolari diluiti nel tempo;\n- ***Event-Driven Sampling*** - I sensori si attivano o comunicano dati solo in risposta ad un cambiamento significativo (e.g. uno smartphone accende il giroscopio solo se l'accelerometro rileva una forte accelerazione, o un termostato comunica con il gateway solo se ci sono variazioni di temperatura).\n\nAbbiamo poi due branche che si occupano di ridurre l'overhead di comunicazione:\n\n- ***Compressione dati*** - Trasmettere meno dati per trasmissione significa meno energia spesa per la comunicazione (cfr. ***Teoria dell'Informazione***);\n- ***Edge Computing*** - Ottimizza il numero di trasmissioni sulla rete (cfr. ***Fog Computing***).\n\nInfine, abbiamo i protocolli ***Sleeping-MAC*** per \n","x":-751,"y":-3738,"width":759,"height":858,"color":"4"},
		{"id":"43767a936de8e8b1","type":"text","text":"# Da dove prendo l'Energia?\n\nPotrei farlo da diverse fonti. Partiamo con l'escludere il caso in cui riesco a connettermi direttamente alla rete elettrica, perché è banale: posso permettermi alti consumi, quindi verosimilmente uso un MPU. Restano due scenari principali, in cui si usano gli MCU:\n\n- ***Batterie*** - Soluzione alla quale si cerca con sempre più forza di trovare un'alternativa. Hanno capacità limitata, e il loro sviluppo in termini di potenza erogata su dimensioni non sta dietro all'esponenziale evoluzione dei dispositivi embedded. Si cerca quindi di ridurre i consumi energetici a tutti i costi, ma questo si traduce in minore potenza di calcolo e velocità di trasmissione;\n- ***Energy Harvesting*** - Idea in via di sviluppo che prevede di raccogliere l'energia dall'ambiente in cui il dispositivo è immerso.\n\t- Questo può, a seconda dell'architettura,\n\t\t- eliminare l'uso delle batterie. Parliamo di uno schema ***Harvest-Use***, i.e. uso in diretta l'energia che raccolgo, se non ce n'è abbastanza mi spengo;\n\t\t- limitare l'uso delle batterie. Schema ***Harvest-Store-Use***, i.e. accumulo energia anche quando non sono attivo per usarla successivamente (in pratica è una batteria ricaricabile).\n\t- Il concetto di fonte di energia va dal fotovoltaico/termoelettrico/eolico al calore e al movimento corporeo.","x":258,"y":-4538,"width":759,"height":565,"color":"4"},
		{"id":"9b1a993fbf97aa5e","type":"text","text":"# Energy Harvesting come MDP\n\nSe hai voglia, pacco di slides 3_3_1\n\nRiferimenti:\n\n- CdM in generale: cfr. esame di ***Computer Network Performance***;\n- MDP e Q-Learning: cfr. esame di ***Autonomous Networking***.","x":258,"y":-5003,"width":759,"height":227,"color":"1"},
		{"id":"617bc5508509a069","type":"text","text":"# Microcontrollori CortexM\n\nQuesta famiglia di microcontrollori ha dato una bella spinta allo sviluppo di IoT dal 2004.\n\nSono tutti basati su architettura `ARM` a `32 bit`, dal più semplice e meno energivoro `M0` ai più avanzati `M7`, che contengono supporto per **Digital Signal Processing** (**DSP**, che serve per l'elaborazione *real time* di immagini, audio e controlli di attuatori robotici) e `float`.\n\nTutti hanno in comune la gestione dei registri (`r0`$\\to$`r15`, di cui gli ultimi tre sono `Stack Pointer`, `Link Register`, che sarebbe `Return Address`, e `Program Counter`), e della memoria (in sequenza, `Flash`, `SRAM`, `Periferiche` e `Registri`). Alcuni implementano `User/Kernel Mode` e conseguente `Memory Protection Unit` (`MPU`) per impedire l'accesso all'area riservata al `Kernel`.\n\ncioè un microcontroller può avere RAM, ROM, Flash, EEPROM, NVRAM (RAM per operazioni temporanee. Flash ROM o EEPROM per firmware e dati persistenti)\n\nci stanno anche le porte I/O...\n\nse hai voglia, slides 3_2 n 23+\n\n\n## cortex (il malvagio)\n\ntutti ARM. Memory Protection Unit fa switch tra  user e kernel mode.\nDMA (vedi sistemi operativi immagino)\nvbb è tutto un ripassone di cose (+ specifiche processori cortex) fino a slide 27, poi entra in dettaglio sugli interrupt (e.g. int. request (IRQ) - viene dal sensore, è il più comune) con tutta la parte tecnica (yeee).\nirrisorie differenze in costi diventano gargantuesche se moltiplicate per il numero di things. segue esempio. ma non su questo! sul fatto che tra sleep ed active consumption passa un universo mondo di potenza. poi aggiunge lo stato di transizione tra sleep  ed active (non ditelo a Donald).\n\n\n\nUn’interruzione è un evento (es. un sensore che invia un segnale) che forza la CPU a:\n\n1. **Sospendere l’esecuzione attuale**\n2. **Passare in Kernel Mode**\n3. **Eseguire un Interrupt Service Routine (ISR)**\n4. **Riprendere il programma precedente**\nLe interruzioni hanno 3 stati:\n- **Inattivo:** Nessun evento\n- **Pending:** L’interruzione è avvenuta, ma la CPU non l’ha ancora gestita\n- **Attivo:** Il codice ISR sta risolvendo l’interruzione\nEsempi di sorgenti di interrupt:\n- **Hardware:** ADC, Timer, GPIO\n- **Software:** divisioni per zero, errori di memoria\n\nTutte le interruzioni sono associate a un indirizzo specifico memorizzato in una **IVT (Interrupt Vector Table)**, che mappa le interruzioni ai loro handler.\n\n**Gestione della priorità:** Se due interrupt arrivano contemporaneamente, quello con priorità più alta viene gestito per primo.","x":1267,"y":-2644,"width":759,"height":911,"color":"3"},
		{"id":"4c794fe5a6070164","type":"file","file":"SAM4L_Modes.png","x":-751,"y":-1498,"width":759,"height":304},
		{"id":"03e26affba62b324","type":"text","text":"# Esempi di MCU Cortex-Based\n\n\nNonostante siano un po' datati, restano ad oggi un punto di riferimento per applicazioni che richiedono basso consumo energetico. Esempi di configurazioni sono\n\n- ***Atmel SAM4L (Cortex-M4)*** - Consuma $4.3 \\text{ mA @ }48 \\text{ MHz}$ (i.e. alla velocità massima di $48\\times10^3$ colpi al secondo assorbe $4.3\\text{ mA}$) e supporta USB, SPI, I2C, UART e 15 canali di DMA (i.e. mette una CPU potente e ne ottimizza l'uso permettendo alle periferiche di bypassarla con un accesso diretto a memoria, se il suo intervento non è necessario);\n\t- Possiamo risalire all'assorbimento di corrente per ciclo di clock:$$I_C={4.3 \\cdot 10^{-3}\\text{ A/s}\\over48 \\cdot 10^6\\text{ Cycle/s}}\\simeq0.09\\,\\mu\\text{A/Cycle}$$\n\t- Sì, la gente in Computer Science non sa usare le dimensioni.\n- ***Nordic nRF51 (Cortex-M0 + BLE)*** - CPU meno potente ($\\sim 2.6 \\text{ mA/s @ }16 \\text{ MHz}$) che però va usata più spesso. Inoltre, abbiamo un sistema di trasmissione BLE che usa fino a $16 \\text{ mA @ TX}$ (i.e. $16 \\text{ mA}$ per trasmissione).\n\t- Questa CPU ha un costo più alto per ciclo di clock, ma va più lenta:$$I_C={2.6\\cdot 10^{-3}\\text{ A/s}\\over16 \\cdot 10^6\\text{ Cycle/s}}\\simeq0.16\\,\\mu\\text{A/Cycle}$$\n\t- Perché mai realizzare un processore che consuma più corrente per ciclo e poi mettergli un clock più lento? L'`M0` è realizzato usando meno transistor rispetto all'`M4`. Se da un lato questo lo rende meno ottimizzato (è costretto a fare le stesse operazioni in più cicli), dall'altro questo riduce le ***leakage currents*** (i.e. quelle micro-correnti che determinano il consumo quando il processore è in ***sleep mode***, che sono proporzionali al numero di transistor). In pratica, l'`M0` è ottimale se va usato poco, cosa che accade se il focus è su BLE;\n\t\t- Nota che questo effetto di leak in sleep mode è tanto più presente quanto più riduciamo le dimensioni dei transistor, per effetto del tunneling quantistico.\n\t- Piccolo ***focus su BLE***: trasmette pacchetti di dimensione fissa, e tipicamente non lo fa in modo continuativo. Ogni trasmissione dura di norma $\\sim 1\\text{ ms}$, e se ad esempio trasmettesse una volta al secondo (i.e. ***duty cycle*** di ${1\\text{ ms}/1\\text{ s}}=0.001$) avremmo qui (e sottolineo qui, perché quel $16 \\text{ mA @ TX}$ dipende dall'HW e dalla configurazione) un consumo di $16 \\text{ mA}\\times0.001 = 16\\,\\mu\\text{A}$.","x":-751,"y":-2644,"width":759,"height":911,"color":"4"},
		{"id":"cc865f4cd6000ab4","type":"text","text":"# ARM (Architettura degli Elaboratori)\n\nArchitettura poco energivora, quindi particolarmente adatta a smartphone e tablet (è infatti utilizzata da praticamente tutti i produttori, da Apple a **Samsung** e **Huawei**), come pure a smartwatch, dispositivi *embedded* e di tipo *Internet of Things* (come *Raspberry Pi*).\n\nARM ha sviluppato nel tempo diverse ISA, volte principalmente a migliorare l'efficienza del codice e il consumo di memoria, ma soprattutto nel 2011 ha rilasciato la propria estensione a 64 bit, **ARMv8**, dando un forte impulso all'industria dei dispositivi portatili.","x":1267,"y":-1476,"width":759,"height":261,"color":"4"},
		{"id":"4e74763561558c8d","type":"text","text":"# SPACING","x":2402,"y":-280,"width":250,"height":235,"color":"5"},
		{"id":"e20c10b33cf4b8f0","type":"text","text":"# Federated Learning\n\n(parte di Distributed Data Analysis)\n\nalcune funzioni (tipo emoji prediction) possono essere fatte con un certo delay di risposta, i.e. posso appoggiarmi ad un cloud. Per la guida autonoma che deve prendere decisioni in modo istantaneo forse non è il caso. Per questo esiste il local learning. (vbb anche perché potrebbero essere dati privati e/o sensibili, e anche perché come detto in fog computing i dati potrebbero diventare troppi per un singolo server). Di contro, il local learning spesso ha un dataset limitato.\n\nFL prende il best of both worlds. Esegue il modello in locale e condivide solo i parametri con i vicini. Nella speranza che il risultato sia simile a quello che si otterrebbe centralizzando i raw data. realisticamente, il risultato è \"faccio meglio a partecipare piuttosto che a non partecipare\".\n\ndue modelli: parallelo (ogni server allena l'intero modello con pezzetti di dataset) o pipeline (ogni server allena sequenzialmente un pezzetto di modello).\n\nProblemi: local datasets sono non identicamente distribuiti (ognuno ha un bias diverso); un attaccante può ricostruire i dati guardando i pesi condivisi dai server; i server (parallelo) sono dispositivi IoT, potrebbero non essere sempre disponibili e di certo non sono potenti. Ci serve un algoritmo che selezioni a quale nodo chiedere i pesi invece di andare a vuoto. Questo però creerà un problema di fairness, perché nodi con poca potenza verranno scelti poco. Esempio di algoritmo: ***FedAvg*** (nelle slides successive). Rapido riassunto: il client definisce un numero di step da eseguire prima di mandare i dati, li esegue, fa back-propagation con stochastic gradient descent e invia. Il server accorpa i theta, fa una media e restituisce a tutti. si ricomincia. (cos'è i.i.d.?? independent & identically distributed)\n\ndecentralized di base è un modello p2p in cui tutti si scambiano dati. in questa versione di FedAvg ci sta una mixing matrix che per ogni nodo definisce quanto peso deve dare ai pesi (no pun intended) dei vicini. anche qui, local update, invio, ricevo, aggiorno, ricomincio. Posso anche fare diversi local updates, come prima. in un local update basta mettere la mixing matrix = identità (i.e. pesa solo te stesso con 1, gli altri 0). Anche qui, problema di minimo per scegliere tau e I_max con constraints di budget sulle risorse.\n\nNon-i.i.d. data - singoli client possono divergere parecchio dal vero optimum. Qui il punto è che non posso usare la media e basta, servono robe più complesse. Non le facciamo, e skippa anche FedZero (client selection based on forecast energy).\n\nProxyFL - modello privato (i cui pesi non sono divulgati, ma sono quelli da ottimizzare) e pubblico (proxy, i pesi del privato vengono aggiornati sulla base dei pesi di questo, che sono invece divulgati e aggiornati). Differentially-private (vedi meaning). il punto è che lo è il modello proxy, per cui un attaccante non riesce a inferire (cosa??)\n\nh è il proxy model, f il privato, sta spiegando codice ma va troppo veloce.\n\nkullback-leibler è un po' info theory\n\nQ2: non ho capito veramente niente!!\n\n\nSegue PhD che fa roba su FedAvg.\n\n\nnella convoluzione (CNN) impari i pesi filtri","x":-751,"y":1560,"width":759,"height":1255},
		{"id":"35f8a2a30acf38e4","type":"text","text":"Oggi, per allenare un modello di machine learning, prendi tanti dati → li spedisci in cloud → lì addestri la tua rete neurale. Funziona bene, ma...  \n**E se i dati fossero privati?**  \n**E se fossero dispersi su milioni di dispositivi?**  \n**E se spostarli in cloud fosse troppo lento, costoso o rischioso?**\n\nEntra in gioco il **Federated Learning**.\n\n---\n\n## 🧠 Problema\n\nImmagina di voler allenare un modello per migliorare l'autocorrezione della tastiera su Android. I dati perfetti sono **sui telefoni degli utenti**: cosa scrivono, come correggono, quali parole scelgono.  \nMa non puoi semplicemente prendere e caricare tutto in cloud:\n\n- **Privacy:** Sarebbe un disastro etico e legale.\n    \n- **Volume:** I dati sono troppi. Milioni di utenti, gigabyte a testa.\n    \n- **Banda:** Trasferire tutto su Internet? Troppo costoso.\n    \n\n### 🔥 Quindi, come fai?\n\nRovesci l’idea classica: **invece di spostare i dati dove c’è il modello**,  \n**sposti il modello dove ci sono i dati**.\n\n---\n\n## 🚀 Idea chiave del Federated Learning\n\n> I dati restano sul dispositivo.  \n> Il modello viene spedito ai dispositivi, addestrato localmente, e solo gli **aggiornamenti** (e non i dati) vengono inviati al server centrale.\n\nQuesto è il cuore del **federated learning**.\n\n### 📦 Flusso generale (simplificato)\n\n1. Il server ha un modello base.\n    \n2. Lo invia a molti client (es. smartphone).\n    \n3. Ogni client lo allena **solo sui propri dati locali**.\n    \n4. I client inviano **solo i pesi aggiornati** (o un delta) al server.\n    \n5. Il server **aggrega** questi aggiornamenti (es. media pesata).\n    \n6. Il modello globale si aggiorna.\n    \n7. Si ricomincia.\n    \n\n---\n\n## 🧰 Domande chiave (e relative soluzioni)\n\n### 🤔 **Ma così non si rischia di ricostruire i dati utente dagli aggiornamenti?**\n\nSì, **in teoria**.  \nPer questo spesso si usa:\n\n- **Differential Privacy:** aggiungo rumore statistico agli aggiornamenti.\n    \n- **Secure Aggregation:** il server vede solo la media complessiva, non i singoli update.\n    \n\n---\n\n### 🧠 **Che tipo di apprendimento è?**\n\nFederated Learning ≠ solo distributed learning.  \nQui i dati **non sono mai centralizzati** e il dataset è **non IID** (non indipendente e identicamente distribuito).  \nEs: un telefono scrive in italiano, uno in inglese, uno in slang — i dati non sono rappresentativi del tutto.\n\nQuesto rende la convergenza più **difficile**.\n\n---\n\n### 📶 **E se un client ha la connessione lenta o si spegne?**\n\nNon è un problema.  \nIl server raccoglie solo gli update disponibili in un round.  \nL’apprendimento è **tollerante ai fallimenti**: anche se partecipano solo 10% dei dispositivi ogni volta, il modello migliora comunque.\n\n---\n\n## 🔄 Aggregazione\n\n> Come faccio a combinare tutti gli aggiornamenti?\n\nIl metodo base è la **Federated Averaging** (FedAvg):\n\n```text\nw_new = sum_i ( n_i / N ) * w_i\n```\n\nDove:\n\n- `w_i` è il vettore di pesi dal client i\n    \n- `n_i` è il numero di dati locali del client i\n    \n- `N` è la somma di tutti i `n_i`\n    \n\nQuindi gli update dei client con **più dati** pesano di più.\n\n---\n\n## 🛡️ Pro e Contro\n\n### ✅ Vantaggi\n\n- **Privacy-preserving** (i dati restano sul dispositivo)\n    \n- **Scalabile** (usiamo la potenza dei device esistenti)\n    \n- **Banda ridotta** (invio solo aggiornamenti)\n    \n- **Learning continuo** (il modello si aggiorna in tempo reale)\n    \n\n### ❌ Svantaggi\n\n- I dati sono **non uniformi**, **non sincronizzati**, **non bilanciati**\n    \n- Il modello può **convergere lentamente**\n    \n- Serve **infrastruttura lato client** (CPU, storage, sicurezza)\n    \n\n---\n\n## 📍 Esempi reali\n\n- **Google Gboard** → migliora la predizione delle parole senza vedere cosa scrivi\n    \n- **Android Health APIs** → modelli che apprendono da dati sensibili su salute\n    \n- **Apple Siri / Face ID** → apprendimento locale per migliorare la user experience\n    \n\n---\n\n## 🧠 In sintesi\n\n|Aspetto|Descrizione sintetica|\n|---|---|\n|Obiettivo|Allenare un modello senza spostare dati|\n|Dove si allena|Sul client (es. smartphone, edge device)|\n|Cosa si invia|Solo aggiornamenti del modello (non i dati!)|\n|Chi coordina|Un server centrale, che aggrega|\n|Cosa si ottiene|Modello aggiornato e personalizzato, rispettando privacy|\n\n---\n\nSe vuoi possiamo anche entrare nei dettagli di:\n\n- **Personalized Federated Learning**\n    \n- **Federated Transfer Learning**\n    \n- **Framework come TensorFlow Federated o PySyft**\n    \n\nBasta chiedere!","x":-1760,"y":1560,"width":759,"height":3552},
		{"id":"469a1094f676e542","type":"text","text":"# Sicurezza\n\nI dispositivi IoT, in quanto dispositivi connessi alla rete, sono vulnerabili a cyber-attacchi e manipolazioni fisiche. Questo rende necessario implementate misure di sicurezza HW e SW.\n\nChiaro, ma cosa c'è di nuovo? Il fatto è che questi dispositivi sono poco potenti, quindi devo limitarmi a protocolli leggeri ed efficienti.\n\n#### TPM (Trusted Platform Module) (HW)\n1. **CAUSA:** Un attaccante può tentare di modificare il software di un dispositivo per prenderne il controllo.\n2. **EFFETTO:** TPM immagazzina chiavi crittografiche in hardware per proteggere l’integrità del dispositivo.\n\n- TPM genera e protegge chiavi di crittografia.\n- Può autenticare l’hardware impedendo modifiche non autorizzate.\n   \n##### Secure Boot (HW/SW)\n1. **CAUSA:** Un firmware modificato può compromettere l’intero sistema.\n2. **EFFETTO:** Secure Boot verifica la firma digitale del firmware prima di avviarlo.\n   \n**Motivi per aggiornare il firmware:**\n\n- Correggere vulnerabilità di sicurezza.\n- Aggiungere nuove funzionalità senza sostituire l’hardware.\n\n#### Autenticazione e controllo accessi\n1. **CAUSA:** Senza autenticazione, chiunque potrebbe accedere ai dispositivi IoT.\n2. **EFFETTO:** Si usano metodi come password, certificati digitali e autenticazione a due fattori.\n   \n- Un termostato smart richiede autenticazione prima di essere controllato da remoto.\n- Un sistema di videosorveglianza cifra i dati per impedire accessi non autorizzati.\n\n\n\n## 6. Sicurezza nei dispositivi IoT\n\nLa sicurezza è un problema critico: un dispositivo IoT vulnerabile può compromettere un’intera rete.\n\n### Strategie di sicurezza\n\n- **Secure Boot**: Impedisce che firmware malevoli vengano eseguiti → fondamentale perché molti dispositivi IoT devono aggiornarsi da remoto (OTA updates).\n    \n- **Trusted Platform Module (TPM)**: Hardware dedicato alla crittografia e protezione delle chiavi → essenziale per autenticazione sicura.\n    \n- **Autenticazione e controllo accessi**: Limitare chi può accedere ai dispositivi per prevenire attacchi.\n    \n\n### Causa-effetto nella sicurezza\n\n- **Un firmware non autenticato può compromettere l’intera rete** → Secure Boot impedisce esecuzione di codice non verificato.\n    \n- **Un dispositivo compromesso può diffondere malware** → TPM protegge chiavi crittografiche.\n    \n- **L’uso di password deboli facilita attacchi** → Autenticazione forte e aggiornamenti regolari.\n    ","x":4560,"y":2100,"width":1360,"height":1287},
		{"id":"032d9aeb665be7c1","type":"text","text":"\n## **4. Problemi Aperti e Considerazioni Finali**\n\n### **4.1. Sicurezza e Privacy**\n\n- **Causa:** L’IoT spesso lavora con dati sensibili (sanità, sorveglianza, automobili connesse).\n    \n- **Effetto:** Servono protocolli di sicurezza **leggeri ma efficaci** (es. DTLS, crittografia elliptic curve per dispositivi a bassa potenza).\n    \n\n\n**Approfondimenti consigliati:**\n\n- Ricerca su **Bin Packing Problem** e tecniche di risoluzione (branch-and-cut, metaeuristiche).\n    \n- Studio di protocolli MQTT e CoAP per comprendere le differenze pratiche.\n    \n- Analisi di casi studio reali di fog computing per applicazioni industriali.","x":7340,"y":1220,"width":759,"height":404},
		{"id":"cba677f965076335","type":"text","text":"\n- **Tecnologia**: digitale, voce compressa e cifrata.\n    \n- **Multiplexing**: **TDM + FDM** → es: GSM ha 124 canali FDM × 8 slot TDM.\n    \n- **Dati**: solo **circuit-switched** (GPRS/EDGE = 2.5G), lenti (~100 Kbps).\n    \n- **Esempi**: GSM (Europa), IS-95 (USA, che usa **CDMA**!).\n    \n\n---\n\n### 📡 **3G – Mobile Internet (anni 2000)**\n\n- **Tecnologia**: **CDMA-based**, trasporto dati integrato.\n    \n- **Multiplexing**: **CDM** → tutti sulla stessa frequenza, separati da codici ortogonali.\n    \n- **Velocità**: Mbps, videochiamate, browsing decente.\n    \n- **Esempi**:\n    \n    - **UMTS/W-CDMA** (Europa)\n        \n    - **CDMA2000** (USA, Qualcomm)\n        \n- **Problema**: CDMA va in crisi se aumentano gli utenti → limite di scala.\n    \n\n---\n\n### 📶 **4G – Everything over IP (anni 2010)**\n\n- **Tecnologia**: tutto IP (voce inclusa), alta capacità, alta velocità.\n    \n- **Multiplexing**:\n    \n    - **OFDM** → FDM ortogonale con sotto-portanti ravvicinate.\n        \n    - **MIMO** → SDM con riflessioni sfruttate, non evitate.\n        \n- **Scheduling**: dinamico → la base station decide chi trasmette quando e su che sottoportanti.\n    \n- **Velocità**: 100+ Mbps reali.\n    \n- **Esempio**: **LTE** (Long Term Evolution).\n    \n\n---\n\n### 📡🧠 **5G – Flexibility, Latency & Massive IoT (anni 2020)**\n\n- **Tecnologia**: tutto software-defined, architettura modulare.\n    \n- **Multiplexing**:\n    \n    - Ancora **OFDM**, ma flessibile (diversi numeri di sottoportanti, subcarrier spacing).\n        \n    - **Massive MIMO** → decine di antenne.\n        \n    - **Beamforming** → indirizzamento spaziale dinamico.\n        \n    - **NOMA** (Non-Orthogonal Multiple Access): più utenti per risorsa, separati da potenza.\n        \n- **Features**:\n    \n    - **eMBB**: enhanced Mobile Broadband.\n        \n    - **URLLC**: ultra-low latency (ms).\n        \n    - **mMTC**: massive Machine Type Communication (IoT).\n        \n- **Spettro**: da sub-6GHz a mmWave (>24GHz).\n    \n\n---\n\n### 🧬 **6G – In arrivo (~2030?)**\n\n- Ancora in studio, ma si parla di:\n    \n    - **THz communication**\n        \n    - **AI-driven networking**\n        \n    - **3D coverage (drone, satellite, terra)**\n        \n    - **Risorse condivise via learning (radio intelligente)**\n        \n\n---\n\n### 💡 Osservazioni finali\n\n- **1G–3G**: cambiano i **metodi di separazione degli utenti**: FDM → TDM → CDM.\n    \n- **4G–5G**: diventano flessibili, **l’accesso è dinamico e ortogonale** (e talvolta non ortogonale!), e **l’hardware è controllato via software**.\n    \n- **Tendenza**: da sistemi rigidi (slot e canali fissi) a **sistemi adattivi e “softwarizzati”**, ottimizzati in tempo reale in base al carico, alla topologia e al canale radio.\n    \n\n---\n\nVuoi una tabella riassuntiva comparativa oppure vuoi approfondire una specifica generazione (es. il perché del successo di LTE)?","x":-9640,"y":1480,"width":759,"height":2197},
		{"id":"1f59605ef76af35f","x":-9833,"y":119,"width":760,"height":911,"type":"text","text":"# 4G LTE"},
		{"id":"1c57fcd84bd5c9a7","x":-10842,"y":-248,"width":759,"height":777,"color":"4","type":"text","text":"# Celle\n\nSe il mio obiettivo è ricoprire un'area di interesse, posso scegliere diverse forme per le celle. Quella più usata è l'esagonale, che porta ad una ***honeycomb grid***. Ovviamente, quando vado a implementarla diventa una roba tutta deformata e storta per via delle interferenze, ma facciamo del nostro meglio.\n\nCome detto, se ogni cella usa una diversa frequenza questo diventa un problema di ***vertex coloring***. In una honeycomb grid concludiamo che i $6$ vicini di ogni cella devono per forza usare frequenze diverse. Queste $7$ celle formano un ***cluster*** che posso usare come \"mattonelle\" per ricoprire l'area e risolvere il problema di coloring.\n\nPosso in realtà definire il cluster in diversi modi, portando a diverse ***reuse distance*** $D$ (i.e. la distanza minima tra due celle con la stessa frequenza), da cui diversi ***reuse factor*** $q$ (i.e. il rapporto tra $D$ e il raggio dell'esagono). Tipicamente si sceglie una valore di  $q$ basso per aree rurali e alto per zone densamente popolate.\n\nInfine, come in ogni problema di coloring che si rispetti, se $D$ non è sufficientemente grande c'è il rischio che due celle che usano la stessa frequenza interferiscano. Possiamo mitigare questo problema usando tre antenne direzionali sull'area dell'esagono, dove ognuna partendo dal centro copre un angolo di $120°$ (***cell sectoring***).\n\nAbbiamo infine una simpatica pratica: se c'è troppa gente in una zona e dobbiamo aumentare $g$, aumentiamo il numero di celle creando delle sotto-celle (***cell splitting***)."},
		{"id":"060a9737ff05bef6","type":"text","text":"# Furti di Identità\n\nCome abbiamo detto, la SIM è stata introdotta con il 2G. E prima come facevano?\n\nPrima la SIM era \"fusa\" col cellulare. Ne compri uno, ha al suo interno un codice che ti identifica univocamente in quanto acquirente del dispositivo. Tra l'altro, appena lo accendevi quello si connetteva alla cella più vicina inviando il codice in chiaro, chiunque poteva ascoltarlo e clonarlo per fare ***spoofing***.\n\nLa SIM (che infatti sta per ***Subscriber Identity Module***) serve proprio a disaccoppiare l'utente dal dispositivo fisico, nonché a fornire un po' più di privacy. Da un lato, infatti, le comunicazioni in 2G sono crittate (seppur non benissimo), quindi il codice identificativo dell'utente associato alla SIM (***IMSI***, **International Mobile Subscriber Identity**, da non confondere con l'IMEI che invece identifica il cellulare e si visualizza col mitico `*#06#`, il tuo telefono è maschio o femmina?) non viene mai mandato in chiaro, dall'altro di fatto non viene proprio quasi mai mandato.\n\nQuesto perché dopo essersi autenticato sulla rete con l'IMSI, strutturato come\n\n```\nxxx           yy             zzzzzzzzzz\nCountry Code  Provider Code  User\n```\n\nla rete assegna a quella SIM un ***TMSI*** (**Temporary Mobile Subscriber Identity**), che oltre ad essere utilizzato al posto dell'IMSI viene pure cambiato frequentemente.\n\nL'IMSI permette alla rete di autenticarti, sia nel tuo paese che all'estero (nel qual caso il provider locale deve avere degli accordi con il tuo, altrimenti non ti fa parlare).","x":-8823,"y":-248,"width":759,"height":777,"color":"4"},
		{"id":"39c97c8304fdd288","type":"text","text":"# SPACING","x":-8860,"y":-620,"width":250,"height":235,"color":"5"},
		{"id":"5f3720ab82faf186","type":"text","text":"# Secondo Esonero","x":-6806,"y":-1979,"width":759,"height":260,"color":"5"},
		{"id":"311277f15366802b","type":"text","text":"# Secondo Esonero","x":-7815,"y":-936,"width":759,"height":260,"color":"5"},
		{"id":"dbcfad7eab2d91a5","type":"text","text":"# Reti Cellulari\n\nLa storia della telefonia parte con la classica commutazione di circuito, fatta inizialmente a mano dagli operatori, poi da sistemi elettro-meccanici e infine da sistemi digitali.\n\nLa svolta concettuale si ha con la tecnologia delle ***Base Stations*** (***BS***), i.e. antenne in grado di coprire un'area denominata ***cella***. Nel 1979 con questa tecnologia (poi denominata \"***prima generazione***\", ***1G***) nascono i ***cellulari***.\n\nQuesto avviene con un semplice schema analogico di ***FDM*** (con annessi problemi di graph coloring, cfr. ***Network Algorithms***), con i dati che viaggiano senza cifratura e vittime del rumore. Risultato: bassa qualità e zero privacy, ma hey, grazie all'***handover*** posso staccarmi da una cella ed attaccarmi ad un'altra ogni volta che mi muovo! Questa cosa però era ancora molto acerba, e non c'era alcuno standard internazionale (zero compatibilità).\n\nVisto che ovviamente questa tecnologia aveva dei limiti, nei primi anni '90 il ***2G*** introduce la ***digitalizzazione*** tramite lo standard ***GSM*** (**Global System for Mobile Communications**, che però è ancora ***circuit switching***), nonché la ***SIM***, gli ***SMS***, il ***roaming*** e un handover più preciso. Questa tecnologia usava sia FDM che TDM, e ogni utente aveva i propri slot.\n\nMigliorie tecniche portano negli anni successivi alle evoluzioni\n\n- ***GPRS*** (**General Packet Radio Service**, detto a volte **2.5G**), che implementa il ***packet switching*** e apre quindi le porte al moderno Internet mobile;\n- ***EDGE*** (**Enhanced Data rates for GSM Evolution**), che introduce la modulazione ***8-PSK*** (cfr. ***Constellation Diagrams***) e velocizza la trasmissione dei dati.\n\nNel 2001 con la tecnologia ***UMTS*** (**Universal Mobile Telecommunications System**, i.e. ***3G***) si passa ad una doppia natura della trasmissione dati digitale:\n\n- La voce torna su circuit switching, come in GSM (FDM + TDM);\n- I dati passano definitivamente al packet switching, su `IP`. Il multiplexing avviene con ***CDMA***, il che permette di usare tutto lo spettro in parallelo.\n\nQuesto (insieme al fatto che hanno allocato bande più grandi per la telefonia) aumenta di molto la velocità di Internet sui telefoni, ma la vera svolta si ha col ***4G/LTE***.\n","x":-9833,"y":-1238,"width":759,"height":864,"color":"4"}
	],
	"edges":[
		{"id":"6883460e8c227a3c","fromNode":"1e3fd2b7a4b6a7cc","fromSide":"bottom","toNode":"50577e8138d4ae08","toSide":"top","label":"Distributed Data Analysis"},
		{"id":"fcc82691ef115619","fromNode":"54d0a7ecb87b5c26","fromSide":"left","toNode":"1e3fd2b7a4b6a7cc","toSide":"right"},
		{"id":"b6bb6d947657dd64","fromNode":"1e3fd2b7a4b6a7cc","fromSide":"left","toNode":"e3f90e15d76f3ca5","toSide":"right","label":"Communication"},
		{"id":"1d3252b9a19eabde","fromNode":"1e3fd2b7a4b6a7cc","fromSide":"top","toNode":"ff3b9035a56b4e9e","toSide":"bottom","label":"Embedded Devices"},
		{"id":"32f7122c19c5f94f","fromNode":"03e26affba62b324","fromSide":"bottom","toNode":"4c794fe5a6070164","toSide":"top"},
		{"id":"1288a997ee3a73a0","fromNode":"a94d060ea349fc00","fromSide":"top","toNode":"43767a936de8e8b1","toSide":"bottom"},
		{"id":"e03e1fee77478baf","fromNode":"54d0a7ecb87b5c26","fromSide":"top","toNode":"d51f893becdde7b8","toSide":"bottom"},
		{"id":"7b87ead8ae666d28","fromNode":"d51f893becdde7b8","fromSide":"left","toNode":"796fa6183e62d341","toSide":"right"},
		{"id":"d1f37c577b563bec","fromNode":"d51f893becdde7b8","fromSide":"top","toNode":"bc00b250b7b24ec0","toSide":"bottom","label":"Sorpresa"},
		{"id":"4dfd9f9014332940","fromNode":"bc00b250b7b24ec0","fromSide":"left","toNode":"953ba1b6df1d2cf5","toSide":"right"},
		{"id":"3dc0f2ed3e704ef9","fromNode":"5a1008ab6d4f93fb","fromSide":"bottom","toNode":"953ba1b6df1d2cf5","toSide":"top"},
		{"id":"651f2457eb20db33","fromNode":"d51f893becdde7b8","fromSide":"top","toNode":"953ba1b6df1d2cf5","toSide":"bottom","label":"Compressione"},
		{"id":"47991328da85437e","fromNode":"d51f893becdde7b8","fromSide":"top","toNode":"886eeef68d17e333","toSide":"bottom","label":"Comunicazione"},
		{"id":"28eb958601576b35","fromNode":"d51f893becdde7b8","fromSide":"right","toNode":"2df7743f9594ebe8","toSide":"left"},
		{"id":"1ab5a72fdd598058","fromNode":"bc00b250b7b24ec0","fromSide":"right","toNode":"886eeef68d17e333","toSide":"left"},
		{"id":"2552b2c3b89df497","fromNode":"886eeef68d17e333","fromSide":"top","toNode":"eadc00ddd47569d3","toSide":"bottom"},
		{"id":"ec92e44eac2419cf","fromNode":"2df7743f9594ebe8","fromSide":"right","toNode":"344ee0d6725a4b78","toSide":"left"},
		{"id":"c400ebb453f7eafd","fromNode":"eadc00ddd47569d3","fromSide":"left","toNode":"20f0389aed3f57c6","toSide":"right"},
		{"id":"6fe75ddac75b8201","fromNode":"eadc00ddd47569d3","fromSide":"right","toNode":"19dbf5244a8bbdc1","toSide":"left"},
		{"id":"2a6fffe38a308845","fromNode":"183cc241a018e501","fromSide":"bottom","toNode":"20f0389aed3f57c6","toSide":"top"},
		{"id":"804fa366dfada83f","fromNode":"eadc00ddd47569d3","fromSide":"top","toNode":"183cc241a018e501","toSide":"bottom"},
		{"id":"8b54eb2d2acd9697","fromNode":"eadc00ddd47569d3","fromSide":"right","toNode":"51edfc0fd55ad3f4","toSide":"left"},
		{"id":"7abb5a2c1542f216","fromNode":"886eeef68d17e333","fromSide":"right","toNode":"51edfc0fd55ad3f4","toSide":"left"},
		{"id":"3547eb57612173eb","fromNode":"20f0389aed3f57c6","fromSide":"top","toNode":"03bb0206eb695483","toSide":"bottom","fromEnd":"arrow"},
		{"id":"f72add853a3aaec8","fromNode":"03bb0206eb695483","fromSide":"right","toNode":"183cc241a018e501","toSide":"left","fromEnd":"arrow"},
		{"id":"06c2bb10d9195ec4","fromNode":"51edfc0fd55ad3f4","fromSide":"right","toNode":"887e35db37687bdc","toSide":"left"},
		{"id":"8f0fe63c00069c47","fromNode":"a94d060ea349fc00","fromSide":"left","toNode":"d11ebd7b1efd8ff7","toSide":"right"},
		{"id":"b57a4afc37693e7a","fromNode":"a94d060ea349fc00","fromSide":"right","toNode":"c39cda918518baad","toSide":"left"},
		{"id":"3c0e8c8f8a9f5098","fromNode":"e3f90e15d76f3ca5","fromSide":"bottom","toNode":"5a3d80b291a0be6b","toSide":"top"},
		{"id":"b7d53260632d4353","fromNode":"5a3d80b291a0be6b","fromSide":"left","toNode":"1c886c1918d2f851","toSide":"right"},
		{"id":"6c16e589f7cac8bd","fromNode":"5a3d80b291a0be6b","fromSide":"bottom","toNode":"1c92973033afe842","toSide":"top"},
		{"id":"8cc437d9ac917247","fromNode":"1c886c1918d2f851","fromSide":"bottom","toNode":"1c92973033afe842","toSide":"top"},
		{"id":"c362c3ffffb7b050","fromNode":"1c92973033afe842","fromSide":"bottom","toNode":"87d8679e76321ae5","toSide":"top"},
		{"id":"45d9435479573224","fromNode":"5a3d80b291a0be6b","fromSide":"bottom","toNode":"c9aefb01554841f8","toSide":"top"},
		{"id":"76eda889b183c750","fromNode":"1c92973033afe842","fromSide":"right","toNode":"c9aefb01554841f8","toSide":"left"},
		{"id":"a39dd4df69177364","fromNode":"5a3d80b291a0be6b","fromSide":"left","toNode":"a6a561ce43fe8afd","toSide":"right"},
		{"id":"7e3a306a85d826c5","fromNode":"54d0a7ecb87b5c26","fromSide":"bottom","toNode":"49b5d7791ae4ef9a","toSide":"top"},
		{"id":"82ddcba4a928e1cb","fromNode":"54d0a7ecb87b5c26","fromSide":"right","toNode":"cde7b123e5b31576","toSide":"left"},
		{"id":"c63400c468f160e5","fromNode":"e3f90e15d76f3ca5","fromSide":"top","toNode":"2d43e95958d0e621","toSide":"bottom"},
		{"id":"c97ecd7fbd072f7a","fromNode":"5a3d80b291a0be6b","fromSide":"right","toNode":"bfc2cb8cd0a7da23","toSide":"left"},
		{"id":"69146c5b1f5d5cd0","fromNode":"bfc2cb8cd0a7da23","fromSide":"bottom","toNode":"12ef443e8fc2d15f","toSide":"top"},
		{"id":"8702dcf5f52431e9","fromNode":"bfc2cb8cd0a7da23","fromSide":"right","toNode":"114f642c2da6ef87","toSide":"left"},
		{"id":"a648abd0232fa28e","fromNode":"2d43e95958d0e621","fromSide":"left","toNode":"417ac07ed91bc074","toSide":"right"},
		{"id":"09d69fef07de0377","fromNode":"417ac07ed91bc074","fromSide":"bottom","toNode":"408cffa305a01d86","toSide":"top"},
		{"id":"6228361a1154a81c","fromNode":"2d43e95958d0e621","fromSide":"top","toNode":"35bb9ae08bb9455f","toSide":"bottom"},
		{"id":"ad27d4e5fc371bd7","fromNode":"12ef443e8fc2d15f","fromSide":"bottom","toNode":"e9808cbf25675093","toSide":"top"},
		{"id":"7c48edd8c195a5b0","fromNode":"114f642c2da6ef87","fromSide":"bottom","toNode":"423c2cb4b7a56ccb","toSide":"top"},
		{"id":"1753ea7eb5c32f10","fromNode":"c5a09c41adcea73c","fromSide":"top","toNode":"b725719f537219ad","toSide":"bottom"},
		{"id":"24b65854ce5f01db","fromNode":"c5a09c41adcea73c","fromSide":"right","toNode":"6d17894ec5808534","toSide":"bottom"},
		{"id":"dbf7008bced5f2d8","fromNode":"b725719f537219ad","fromSide":"right","toNode":"6d17894ec5808534","toSide":"left"},
		{"id":"48ffab405a12b599","fromNode":"6d17894ec5808534","fromSide":"top","toNode":"77c4b53f94a1298a","toSide":"bottom","label":"Reti di Elaboratori"},
		{"id":"109f9e6e2cfcf37a","fromNode":"77c4b53f94a1298a","fromSide":"left","toNode":"25c54a470eca044a","toSide":"right","label":"Esempio di\nBackoff"},
		{"id":"8285432b6ed48dfe","fromNode":"417ac07ed91bc074","fromSide":"top","toNode":"4c4f09f460fb5852","toSide":"bottom"},
		{"id":"fcd1674ee23ee405","fromNode":"417ac07ed91bc074","fromSide":"left","toNode":"8514afe7843217b3","toSide":"right"},
		{"id":"7972cc2022f8d5da","fromNode":"408cffa305a01d86","fromSide":"left","toNode":"8514afe7843217b3","toSide":"right"},
		{"id":"59a5e7f49f14848d","fromNode":"8514afe7843217b3","fromSide":"left","toNode":"e5e31f4d5bfef004","toSide":"right","label":"Reti di Elaboratori"},
		{"id":"c96ca2b6d3f9dc86","fromNode":"11aabae6a7528131","fromSide":"bottom","toNode":"bd46921336c24c88","toSide":"top"},
		{"id":"581b14b5485aeb74","fromNode":"11aabae6a7528131","fromSide":"bottom","toNode":"8be5b3cff5d5df79","toSide":"top"},
		{"id":"9318d1e03ae23702","fromNode":"bd46921336c24c88","fromSide":"bottom","toNode":"799772413b2646e9","toSide":"top"},
		{"id":"ab97ecf48aee31fb","fromNode":"8514afe7843217b3","fromSide":"left","toNode":"96854b62f8df3dc5","toSide":"right","label":"Autonomous Networking"},
		{"id":"2b1ffadb4ad341fd","fromNode":"52143f689630afcd","fromSide":"top","toNode":"8302904d4e264e7c","toSide":"bottom"},
		{"id":"b57ccf2f8eb41b0e","fromNode":"17fdb97962c8ef46","fromSide":"left","toNode":"8302904d4e264e7c","toSide":"right"},
		{"id":"07a1b5c71694fd35","fromNode":"96854b62f8df3dc5","fromSide":"top","toNode":"17fdb97962c8ef46","toSide":"bottom"},
		{"id":"4106de8a643e6184","fromNode":"96854b62f8df3dc5","fromSide":"left","toNode":"52143f689630afcd","toSide":"right"},
		{"id":"b5e0fdf7aa867eeb","fromNode":"e5e31f4d5bfef004","fromSide":"left","toNode":"11aabae6a7528131","toSide":"right"},
		{"id":"655ab92e8c281119","fromNode":"8be5b3cff5d5df79","fromSide":"top","toNode":"735cd8f334c4de8b","toSide":"bottom"},
		{"id":"bb13f06ef9ea18c2","fromNode":"8514afe7843217b3","fromSide":"left","toNode":"735cd8f334c4de8b","toSide":"right"},
		{"id":"687c3cecf48e80b6","fromNode":"17fdb97962c8ef46","fromSide":"top","toNode":"14cd685daa476b20","toSide":"bottom"},
		{"id":"8a515124b5575a6d","fromNode":"eacf5041cde00c4c","fromSide":"bottom","toNode":"114f642c2da6ef87","toSide":"top"},
		{"id":"5814dc30f4c2fcb2","fromNode":"feca841d9a7cfa1b","fromSide":"top","toNode":"c5a09c41adcea73c","toSide":"bottom","label":"Autonomous Networking"},
		{"id":"00a3af97820b77d8","fromNode":"2d43e95958d0e621","fromSide":"right","toNode":"277e360d02f736f7","toSide":"left"},
		{"id":"283feeef8977f87f","fromNode":"e3f90e15d76f3ca5","fromSide":"bottom","toNode":"bfc2cb8cd0a7da23","toSide":"top"},
		{"id":"349dd5001860e674","fromNode":"277e360d02f736f7","fromSide":"top","toNode":"2b90ecf4bdbdb286","toSide":"bottom"},
		{"id":"e1865d4eca88fb96","fromNode":"2b90ecf4bdbdb286","fromSide":"top","toNode":"feca841d9a7cfa1b","toSide":"bottom"},
		{"id":"b5f33684b66bbdad","fromNode":"2b90ecf4bdbdb286","fromSide":"right","toNode":"e13ddecfd4fa3c0d","toSide":"left"},
		{"id":"994ac5dc4ee48c73","fromNode":"8be5b3cff5d5df79","fromSide":"bottom","toNode":"4141a3b604b7463d","toSide":"top"},
		{"id":"3ecc53759d80112e","fromNode":"bd46921336c24c88","fromSide":"bottom","toNode":"4141a3b604b7463d","toSide":"top"},
		{"id":"89c93255c9a9445f","fromNode":"799772413b2646e9","fromSide":"left","toNode":"4141a3b604b7463d","toSide":"right","fromEnd":"arrow"},
		{"id":"24be09acc5c1b4d7","fromNode":"2b90ecf4bdbdb286","fromSide":"left","toNode":"6554f3430b521ead","toSide":"right"},
		{"id":"5add7a875ce1d671","fromNode":"277e360d02f736f7","fromSide":"bottom","toNode":"98f38f0e4cb340e1","toSide":"top"},
		{"id":"fb55ca1deb2a5784","fromNode":"277e360d02f736f7","fromSide":"right","toNode":"d34e0a48234d6477","toSide":"left"},
		{"id":"15e56a6a9a78ab59","fromNode":"98f38f0e4cb340e1","fromSide":"bottom","toNode":"f352958e1e3ff824","toSide":"top"},
		{"id":"fe64a659158a3413","fromNode":"98f38f0e4cb340e1","fromSide":"bottom","toNode":"8be3d9b2c31c6b23","toSide":"top"},
		{"id":"e683d22b91f297eb","fromNode":"98f38f0e4cb340e1","fromSide":"bottom","toNode":"9e2dab65ddb6d818","toSide":"top"},
		{"id":"43f8e887be192a6d","fromNode":"96854b62f8df3dc5","fromSide":"bottom","toNode":"735cd8f334c4de8b","toSide":"top"},
		{"id":"20988928959a7eab","fromNode":"d34e0a48234d6477","fromSide":"top","toNode":"916a3e8fd0a77e2e","toSide":"bottom","label":"Layer I\nModulazione Fisica"},
		{"id":"17f7ba8f22ae5269","fromNode":"916a3e8fd0a77e2e","fromSide":"top","toNode":"3597ccf3b344202f","toSide":"bottom"},
		{"id":"d8bc931dea4f3dfa","fromNode":"916a3e8fd0a77e2e","fromSide":"right","toNode":"ba42152a4874f4ca","toSide":"left"},
		{"id":"d5433741cf98cbb1","fromNode":"d34e0a48234d6477","fromSide":"bottom","toNode":"6e29127a1ccbdbb7","toSide":"top","label":"Layer II\nMAC"},
		{"id":"a315f57f0da3a8a8","fromNode":"d34e0a48234d6477","fromSide":"right","toNode":"fa9a4a253814f58f","toSide":"left"},
		{"id":"0078df030693d897","fromNode":"8be3d9b2c31c6b23","fromSide":"bottom","toNode":"9740cb9c346b232e","toSide":"top"},
		{"id":"4cc0b6cc175dda3e","fromNode":"8be3d9b2c31c6b23","fromSide":"bottom","toNode":"b1315405f1c2f335","toSide":"top"},
		{"id":"55bf02785ced9086","fromNode":"8be3d9b2c31c6b23","fromSide":"bottom","toNode":"0b0d751910025a05","toSide":"top"},
		{"id":"dba147b99a482e67","fromNode":"9740cb9c346b232e","fromSide":"right","toNode":"b1315405f1c2f335","toSide":"left"},
		{"id":"4e8dff4bdd68de63","fromNode":"b1315405f1c2f335","fromSide":"right","toNode":"0b0d751910025a05","toSide":"left"},
		{"id":"3c7bf065f6e80814","fromNode":"0b0d751910025a05","fromSide":"right","toNode":"fce100942ec32122","toSide":"left"},
		{"id":"c7b6a3c4ff028caf","fromNode":"4c4f09f460fb5852","fromSide":"left","toNode":"39acf2fe787406cf","toSide":"right"},
		{"id":"099b252e3b8236dc","fromNode":"35bb9ae08bb9455f","fromSide":"top","toNode":"d2ec2dd53be1d5c1","toSide":"bottom"},
		{"id":"142b304309a2eab6","fromNode":"35bb9ae08bb9455f","fromSide":"left","toNode":"115ce219e6656c06","toSide":"right"},
		{"id":"9ddb950469683cb4","fromNode":"12ef443e8fc2d15f","fromSide":"bottom","toNode":"b029f2e213858cf0","toSide":"top"},
		{"id":"c76f40a7802f035a","fromNode":"408cffa305a01d86","fromSide":"right","toNode":"972bcba6f6b492b7","toSide":"left"},
		{"id":"0a4773fa45abd48e","fromNode":"972bcba6f6b492b7","fromSide":"top","toNode":"37bbc6e1153b3dc2","toSide":"bottom"},
		{"id":"bbcfe676a1c42466","fromNode":"e3f90e15d76f3ca5","fromSide":"left","toNode":"dbcfad7eab2d91a5","toSide":"right"},
		{"id":"3a5c37211ef29446","fromNode":"d2ec2dd53be1d5c1","fromSide":"left","toNode":"5eca9353fa7428da","toSide":"right"},
		{"id":"d127cbad3910d2af","fromNode":"d700a52cca1cdc2a","fromSide":"bottom","toNode":"ea6c2db0218bf20e","toSide":"top"},
		{"id":"cf480aac437be5a1","fromNode":"d700a52cca1cdc2a","fromSide":"right","toNode":"c8f665ef67bbc260","toSide":"left"},
		{"id":"80f418195ce5f513","fromNode":"50577e8138d4ae08","fromSide":"right","toNode":"d700a52cca1cdc2a","toSide":"top"},
		{"id":"ee3837a08335bab9","fromNode":"ea6c2db0218bf20e","fromSide":"right","toNode":"1d4c9d197fab6065","toSide":"left"},
		{"id":"d7306cf6064cd7b9","fromNode":"50577e8138d4ae08","fromSide":"left","toNode":"c778fab4c43a3675","toSide":"top"},
		{"id":"58e4b1f4a198e6b3","fromNode":"43767a936de8e8b1","fromSide":"top","toNode":"9b1a993fbf97aa5e","toSide":"bottom"},
		{"id":"0df6b690357c8d04","fromNode":"ff3b9035a56b4e9e","fromSide":"top","toNode":"a94d060ea349fc00","toSide":"bottom"},
		{"id":"f9f6d4f5893c068d","fromNode":"617bc5508509a069","fromSide":"bottom","toNode":"cc865f4cd6000ab4","toSide":"top"},
		{"id":"866b537e71a2b963","fromNode":"ff3b9035a56b4e9e","fromSide":"right","toNode":"617bc5508509a069","toSide":"left"},
		{"id":"ba50912e7639bebf","fromNode":"ff3b9035a56b4e9e","fromSide":"left","toNode":"03e26affba62b324","toSide":"right"},
		{"id":"7f7643aa00154512","fromNode":"dbcfad7eab2d91a5","fromSide":"bottom","toNode":"1c57fcd84bd5c9a7","toSide":"right"},
		{"id":"5edec17ca58443e0","fromNode":"dbcfad7eab2d91a5","fromSide":"bottom","toNode":"1f59605ef76af35f","toSide":"top"},
		{"id":"1e2f4cb650991715","fromNode":"dbcfad7eab2d91a5","fromSide":"bottom","toNode":"060a9737ff05bef6","toSide":"left"}
	]
}