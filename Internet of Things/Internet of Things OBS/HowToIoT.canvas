{
	"nodes":[
		{"id":"1e3fd2b7a4b6a7cc","type":"text","text":"# HowTo Build IoT Networks\n\nPur essendo molto diversi fra loro, tutti i sistemi IoT poggiano sulla stessa architettura:\n\n- ***Cloud*** - Il cervellone che ha il quadro completo della situazione e sa cosa fare si trova su Internet. Per raggiungere i dispositivi deve passare attraverso il loro Gateway;\n\t- Se il sistema è complesso, può distribuirsi sul territorio tramite i ***fog nodes***.\n- ***Gateway*** - Comunica con il Cloud tramite protocolli Internet (TCP/IP), e con i dispositivi tramite protocolli locali (e.g. BLE, ZigBee, WiFi, 6LoWPAN);\n\t- Nota che il Gateway tendenzialmente non è il router domestico, piuttosto un hub che accede ad Internet tramite esso e poi si interfaccia con i dispositivi con BLE.\n- ***Embedded Devices*** - I dispositivi veri e propri.\n\nNel complesso, possiamo individuare una ***stack protocollare*** propria delle reti IoT.","x":-1760,"y":-680,"width":759,"height":387,"color":"6"},
		{"id":"c7e2f44140b2cd8e","type":"text","text":"\n## 4. Embedded Systems: Elaborare e prendere decisioni\n\nUn **sistema embedded** è un dispositivo con un processore dedicato a una funzione specifica. Funziona come “cervello” dei dispositivi IoT.\n\n### Architettura\n\n1. **Microcontrollori (MCU) vs. Microprocessori (MPU)**:\n    \n    - Le **MCU** (es. ESP8266, STM32) sono più efficienti e adatte a compiti specifici.\n        \n    - Le **MPU** (es. Raspberry Pi) sono più potenti, ma consumano più energia.\n        \n2. **Memoria e storage**:\n    \n    - RAM per operazioni temporanee.\n        \n    - Flash ROM o EEPROM per firmware e dati persistenti.\n        \n3. **Interfacce di comunicazione**:\n    \n    - **I2C, SPI, UART** per sensori e attuatori.\n        \n    - **WiFi, BLE, Zigbee** per connessione a Internet o reti locali.\n        \n\n### Causa-effetto nella scelta dell’architettura\n\n- **MCU vs. MPU**: Un sistema batteria-driven preferisce MCU per risparmiare energia.\n    \n- **RAM e Storage**: Più memoria migliora le prestazioni, ma aumenta il costo e il consumo.\n    \n- **Connettività**: BLE consuma meno energia di WiFi, ma ha un range più corto.\n    \n\n## 5. Protocolli di comunicazione\n\nI dispositivi IoT devono scambiarsi dati in modo efficiente. I protocolli sono scelti in base a **consumo energetico, latenza, scalabilità e sicurezza**.\n\n### Principali protocolli\n\n- **MQTT**: Leggero, basato su publish/subscribe, perfetto per connessioni instabili.\n    \n- **CoAP**: Simile a HTTP ma ottimizzato per dispositivi a basso consumo.\n    \n- **Zigbee e LoRa**: Utilizzati per reti mesh e lungo raggio.\n    \n\n### Causa-effetto nella scelta del protocollo\n\n- **MQTT vs. HTTP**: HTTP è pesante e non adatto a IoT, mentre MQTT è ottimizzato per reti intermittenti.\n    \n- **Zigbee vs. WiFi**: Zigbee è ottimo per dispositivi a basso consumo ma con throughput ridotto.\n    \n\n## 6. Sicurezza nei dispositivi IoT\n\nLa sicurezza è un problema critico: un dispositivo IoT vulnerabile può compromettere un’intera rete.\n\n### Strategie di sicurezza\n\n- **Secure Boot**: Impedisce che firmware malevoli vengano eseguiti → fondamentale perché molti dispositivi IoT devono aggiornarsi da remoto (OTA updates).\n    \n- **Trusted Platform Module (TPM)**: Hardware dedicato alla crittografia e protezione delle chiavi → essenziale per autenticazione sicura.\n    \n- **Autenticazione e controllo accessi**: Limitare chi può accedere ai dispositivi per prevenire attacchi.\n    \n\n### Causa-effetto nella sicurezza\n\n- **Un firmware non autenticato può compromettere l’intera rete** → Secure Boot impedisce esecuzione di codice non verificato.\n    \n- **Un dispositivo compromesso può diffondere malware** → TPM protegge chiavi crittografiche.\n    \n- **L’uso di password deboli facilita attacchi** → Autenticazione forte e aggiornamenti regolari.\n    \n\n## 7. Ottimizzazione energetica\n\nI dispositivi IoT sono spesso alimentati a batteria → ridurre il consumo energetico è essenziale.\n\n### Tecniche di risparmio energetico\n\n- **Dynamic Voltage Scaling (DVS)**: Adatta la tensione di alimentazione per ridurre consumi senza perdere performance.\n    \n- **Duty Cycling**: I dispositivi IoT entrano in modalità sleep e si attivano solo quando necessario.\n    \n- **Edge Computing**: Evita di trasmettere dati inutilmente riducendo il carico di rete.\n    \n\n### Causa-effetto nelle scelte energetiche\n\n- **Batteria limitata → Uso di DVS e Duty Cycling** per massimizzare la durata.\n    \n- **Trasmissione dati costosa → Edge Computing riduce dati inviati al cloud**.\n    \n\n## Conclusione\n\nOgni scelta nell’IoT è un compromesso tra **prestazioni, consumo energetico, sicurezza e scalabilità**. Il design di un dispositivo IoT deve bilanciare questi aspetti per creare soluzioni efficienti e affidabili.","x":-5200,"y":-220,"width":1320,"height":3293},
		{"id":"d1d9dd6861616577","type":"text","text":"\n## **3. Ottimizzazione dell’Allocazione delle Risorse: Fog Computing e ILP**\n\nL’elaborazione dei dati non avviene solo nel cloud, ma **vicino ai dispositivi**, nei cosiddetti **Fog Nodes**, per ridurre latenza e consumo di banda.\n\n### **3.1. Problema dell'Allocazione delle Risorse nei Fog Nodes**\n\n- **Causa:** Ogni sensore genera un carico di lavoro variabile, e i nodi fog hanno capacità limitate.\n    \n- **Effetto:** Serve un modo per assegnare dinamicamente le richieste ai nodi fog in modo efficiente.\n    \n\n### **3.2. Modellazione Matematica: Integer Linear Programming (ILP)**\n\n- **Variabili:**\n    \n    - $x_{ij} = 1$ se il task del sensore $s_i$ è assegnato al nodo fog $f_j$, altrimenti 0.\n        \n    - $y_j = 1$ se il nodo $f_j$ è attivato, altrimenti 0.\n        \n- **Funzione Obiettivo:** Minimizzare il costo totale di attivazione dei nodi: min⁡y∑jyjcj\\min_y\\sum_j y_j c_j\n    \n- **Vincoli:**\n    \n    - Ogni task deve essere eseguito: ∑jxij=1∀i\\sum_j x_{ij} = 1 \\quad \\forall i\n        \n    - Nessun nodo può superare la sua capacità massima: ∑ixijri≤gjyj∀j\\sum_i x_{ij} r_i \\leq g_j y_j \\quad \\forall j\n        \n\n### **3.3. Complessità Computazionale e Soluzioni Approximate**\n\n- **Causa:** Il problema rientra nella classe **NP-Complete** (Bin Packing Problem), quindi non è risolvibile esattamente in tempi brevi per sistemi di grandi dimensioni.\n    \n- **Effetto:** Si usano soluzioni approssimate:\n    \n    - Algoritmi **greedy** per una prima distribuzione.\n        \n    - **Metaeuristiche** come Simulated Annealing e Algoritmi Genetici per migliorare la soluzione.\n        \n    - **Gurobi** per soluzioni esatte di problemi di dimensione media.","x":-1760,"y":-2640,"width":759,"height":977},
		{"id":"ad40467c90bb74c9","type":"text","text":"# ILP\n\n\n- N sensori $s_i$ cui corrispondono risorse richieste $r_i$\n- un dispatcher D raccoglie i dati e li manda ad un fog node.\n- F fog nodes $f_j$ che richiedono risorse $g_j$ e che di conseguenza a $g_j$ hanno costi $c_j$\n\t- Tipicamente $N<<F$\n- D conosce i costi di ciascun fog node, e cerca di ottimizzare la data distribution.\n\n Definiamo $y_j$ come 1 sse usiamo il fog $f_j$, ed $x_{ij}$ se una task di $s_i$ è offloaded su $f_j$. Il compito di D è trovare la soluzione di$$\\min_y\\sum_jy_j\\,c_j$$il che ovviamente minimizza il costo complessivo. Mancano i constraints, perché così com'è la soluzione migliore è scegliere $y$ identicamente nullo. Allora mettiamo$$\\sum_jx_{ij}=1$$i.e. voglio che tutti i task siano eseguiti, inoltre non posso eccedere la capacità totale di ciascun fog node, i.e.$$\\sum_ix_{ij}\\,r_i\\le g_j\\,y_j$$Abbiamo ufficialmente formulato il problema come ILP. Si chiama Bin Packing problem se metti tutti i $c_i=1$ (cercalo, fog nodes con c=1 sono i bin, tasks sono gli item da mettere dentro e resources=capacities), ed è $\\NPC$ (si risolvono con algoritmi branch-and-cut? cerca). Allora cerco heuristics e approssimazioni, tendenzialmente greedy. Esistono robe $\\a$-approssimanti, vedi gurobi (codice caricato su colab)! (non so se è $\\a$-approssimante, check please). c'è un errore, aspetta versione patchata","x":-860,"y":-2400,"width":584,"height":948},
		{"id":"2d43e95958d0e621","type":"text","text":"# Internet of... (SLIDES 2, parte 1)\n\nL'Internet serve alle Things per comunicare comandi e dati raccolti. Come?\n\n\n\nSimile a TCP/IP ma i layer centrali sono fusi: non devo fare trasporto in giro, ma mi serve IPv6 al posto di MAC per indirizzare i messaggi. Quindi Applicazione, Gateway/network (che sarebbe fusione di trasporto, rete e DLL) e Fisico.\n\n- Sensor Layer - impacchetta un botto di dati  per il livello di rete. poi se fa tutta na serie de problemi tipo \"se move? non se move? ce sta la batteria?\" di cui non capisco bene il senso. hai detto che è application-specific, no?\n- Network Layer - un po' diverso, può fare addirittura data storage. BLE e WiFi sono considerati protocolli di questo layer\n","x":-2800,"y":-680,"width":759,"height":387},
		{"id":"d700a52cca1cdc2a","type":"text","text":"# Fog Computing\n\nUna rete IoT può essere usata per gli obiettivi più disparati, e che per questo sia HW che SW sono fortemente specifici dell'applicazione.\n\nViene quindi naturale capire che in una rete IoT complessa in cui vanno elaborati i dati di dispositivi ***eterogenei*** (i.e. diversi sensori producono diversi formati di output, il che in pratica porta a dire che nel complesso i ***dati*** sono ***non-strutturati***) è scomodo far gravare tutto il peso di un'analisi dati fortemente diversificati su un unico server centrale. Questo problema viene risolto con i ***fog nodes***, i.e. distribuisco il server di analisi dati.\n\n# SLIDES 2, parte 2","x":-1760,"y":-1480,"width":759,"height":600,"color":"3"},
		{"id":"663e4c46e5c7e51b","type":"text","text":"\nottimizzazione lineare in N dimensioni: $\\min_x c^Tx = \\min_x \\sum_i c_ix_i$ con constraints$$Ax\\le b\\quad A_ex=b_e\\quad x\\in D$$\nnel problema di prima questi constraints (credo siano restrizioni di dominio e condizioni al contorno) diventano$$\\sum_ix_ir_i\\le g\\quad \\sum_{i\\ne j}x_{ij}=1\\quad x\\in\\Z$$\n","x":-1600,"y":-3080,"width":794,"height":334},
		{"id":"9bc5e22487feb01e","type":"text","text":"# Sicurezza","x":-2800,"y":-21,"width":759,"height":221},
		{"id":"ff3b9035a56b4e9e","type":"text","text":"# ... Things\n\nUn Thing ha bisogno di fare essenzialmente tre cose:\n\n1. ***Percepire l’ambiente*** - Un ***sensore*** sfrutta un fenomeno fisico (e.g. una resistenza che varia in funzione del calore) per convertire la misura da prendere in un segnale EM. Successivamente, un ADC converte il segnale da analogico a digitale, e tramite un *protocollo/architettura* ad-hoc i dati vengono inviati al processore;\n\t- Li chiamo *protocolli/architetture* perché non definiscono solo cose tipo \"`prima di mandare il segnale successivo aspetta il colpo di clock`\", ma anche il numero e lo scopo dei fili utilizzati per farlo. Questo significa che per parlare la lingua di un certo protocollo, il microcontrollore deve avere l'HW adatto!\n\t\t- ... o quasi. Esistono modi per emulare il comportamento di un protocollo via SW, motivo per cui si chiamano \"protocolli\" e non \"*protocolli/architetture*\".\n\t- Tra i più noti citiamo ***SPI*** (**Serial Peripheral Interface**, velocissimo ma richiede tanti fili), ***I2C*** (**Inter-Integrated Circuit**, lento ma ne richiede meno) e ***UART*** (**Universal Asynchronous Receiver-Transmitter**, come dice il nome si usa per la compatibilità).\n2. ***Interagire fisicamente*** - Un ***attuatore*** funziona intuitivamente al contrario: riceve un segnale dal processore (per come descritto sopra), eventualmente converte in segnale analogico con un DAC e passa il risultato al motore, che si muove di conseguenza;\n\t- Dico \"eventualmente\" perché non tutti i motori funzionano con segnali analogici. È un attuatore anche uno switch che modifica un circuito elettrico;\n\t- I requisiti vanno dalla reattività real-time alla robustezza a condizioni atmosferiche.\n3. ***Elaborare dati e prendere decisioni locali*** - Il cuore di un sistema informatico è sempre il processore. Qui distinguiamo tra due tipi di architetture:\n    - ***MCU*** (***Microcontroller Unit***) - Un singolo chip che contiene CPU, memorie e periferiche (e.g. SPI, I2C). Consuma poco ed è ottimizzato per task specifici (i.e. esegue un singolo programma, senza SO). Ne è un esempio ***ESP32***, utilizzato per le lampadine smart, ma anche ***Arduino***;\n    - ***MPU*** (***Microprocessor Unit***) - Letteralmente la CPU che metti nel tuo computer, che deve appoggiarsi ad una MoBo e che quindi è in grado di reggere roba complessa come un SO Linux. Ovvio che in IoT la MoBo deve essere piccolissima: meglio parlare di ***System-on-Chip*** (***SoC***), che differisce da una classica MoBo perché non è affatto scalabile o espandibile (... è letteralmente un chip già saldato). Ovviamente si usa RISC, e un esempio tipico è il ***Raspberry Pi***.","x":-1760,"y":-21,"width":759,"height":911,"color":"4"},
		{"id":"db1024436256a3a8","type":"text","text":"# Lec 3\n\nrisolve il problema messo su classroom. pare sia un 0-1 knapsack problem ($\\NPC$). usa gurobi.\n\nN sensors, $r_i  \\forall sensor s_i$ , \n\n- greedy - sort sensors by priority. non ho alcuna garanzia costante entro cui trovo sol.\n- dynamic programming (wikipedia).\n\n# copia tablet","x":-2980,"y":-2700,"width":720,"height":358},
		{"id":"469a1094f676e542","type":"text","text":"\n# Sicurezza\n\n**CAUSA:** I dispositivi IoT sono vulnerabili a cyber attacchi e manipolazioni fisiche.\n**EFFETTO:** Devono essere implementate misure di sicurezza sia hardware che software.\n\n#### TPM (Trusted Platform Module) (HW)\n1. **CAUSA:** Un attaccante può tentare di modificare il software di un dispositivo per prenderne il controllo.\n2. **EFFETTO:** TPM immagazzina chiavi crittografiche in hardware per proteggere l’integrità del dispositivo.\n\n- TPM genera e protegge chiavi di crittografia.\n- Può autenticare l’hardware impedendo modifiche non autorizzate.\n   \n##### Secure Boot (HW/SW)\n1. **CAUSA:** Un firmware modificato può compromettere l’intero sistema.\n2. **EFFETTO:** Secure Boot verifica la firma digitale del firmware prima di avviarlo.\n   \n**Motivi per aggiornare il firmware:**\n\n- Correggere vulnerabilità di sicurezza.\n- Aggiungere nuove funzionalità senza sostituire l’hardware.\n\n#### Autenticazione e controllo accessi\n1. **CAUSA:** Senza autenticazione, chiunque potrebbe accedere ai dispositivi IoT.\n2. **EFFETTO:** Si usano metodi come password, certificati digitali e autenticazione a due fattori.\n   \n- Un termostato smart richiede autenticazione prima di essere controllato da remoto.\n- Un sistema di videosorveglianza cifra i dati per impedire accessi non autorizzati.","x":-2800,"y":271,"width":759,"height":1006},
		{"id":"2ce83f8e9814f3bc","type":"file","file":"IoT_Architecture.png","x":-900,"y":-940,"width":632,"height":387},
		{"id":"4a96114a73310984","type":"text","text":"\n##### **3.1 Protocolli di comunicazione specifici per IoT**\n\n#### **MQTT - Perché è usato nell’IoT?**\n\n1. **CAUSA:** L’IoT richiede comunicazioni leggere ed efficienti, spesso su reti con poca banda.\n2. **EFFETTO:** MQTT (Message Queuing Telemetry Transport) usa un modello publisher/subscriber per trasmettere dati in modo efficiente.\n    \n\n**Funzionamento:**\n\n- Un \"publisher\" (es. un sensore) invia dati a un \"broker\".\n    \n- I \"subscriber\" (es. altri dispositivi o server) ricevono solo i dati di loro interesse.\n    \n- Questo riduce il traffico di rete e il consumo energetico.\n    \n\n#### **CoAP - Perché è utile per dispositivi a bassissima potenza?**\n\n- CoAP (Constrained Application Protocol) è simile a HTTP ma molto più leggero.\n    \n- È progettato per dispositivi con poca RAM e potenza computazionale.\n    \n","x":-2800,"y":-1381,"width":759,"height":513},
		{"id":"0d666c43006d53cb","type":"text","text":"\n### **4.2. Standardizzazione e Interoperabilità**\n\n- **Causa:** Ogni produttore usa formati di dati e protocolli diversi.\n    \n- **Effetto:** Si cerca di definire standard unificati (es. Open Connectivity Foundation, MQTT, CoAP).\n    \n\n### **4.3. Adattabilità ai Cambiamenti Ambientali**\n\n- **Causa:** I nodi fog possono spegnersi, cambiare posizione o avere variazioni di capacità.\n    \n- **Effetto:** I sistemi devono essere **dinamici** e adattarsi ai cambiamenti in tempo reale.\n    ","x":-2800,"y":-1793,"width":759,"height":313},
		{"id":"186290919cb9a852","type":"text","text":"\n## **2. Architettura dell’IoT: Struttura e Funzionalità**\n\nL’IoT **non segue esattamente il modello TCP/IP**, perché le necessità di comunicazione sono diverse. Si può schematizzare in **4 livelli funzionali:**\n\n### **2.1. Sensor Layer (Livello Fisico e Raccolta Dati)**\n\n- **Causa:** È necessario raccogliere dati dal mondo reale (temperatura, umidità, posizione, stato di un macchinario...)\n    \n- **Effetto:** Vengono usati **sensori** che trasformano grandezze fisiche in dati digitali.\n    \n- **Problema:** I sensori consumano energia, quindi la trasmissione deve essere ottimizzata.\n    \n\n### **2.2. Network Layer (Comunicazione e Trasporto Dati)**\n\n- **Causa:** I dati raccolti devono essere trasmessi a nodi di elaborazione o archiviazione.\n    \n- **Effetto:** Si usano protocolli di comunicazione come BLE, WiFi, ZigBee e LPWAN.\n    \n- **Particolarità:** A differenza di TCP/IP classico, qui il livello di rete può **conservare dati** (data storage).\n    \n\n### **2.3. Gateway/Edge Computing Layer (Aggregazione ed Elaborazione Locale)**\n\n- **Causa:** Se ogni sensore inviasse dati grezzi alla rete, ci sarebbe un eccessivo consumo di banda e ritardi.\n    \n- **Effetto:** Un **gateway o nodo edge** raccoglie e pre-elabora i dati prima di inoltrarli.\n    \n- **Esempio:** Un sensore di temperatura non invia ogni singolo valore, ma solo quando cambia significativamente.\n    \n\n### **2.4. Application Layer (Analisi e Automazione)**\n\n- **Causa:** I dati aggregati devono essere interpretati e usati per prendere decisioni.\n    \n- **Effetto:** Si utilizzano protocolli di comunicazione applicativa come MQTT (publish-subscribe) o CoAP (REST).","x":-3700,"y":-1614,"width":759,"height":980},
		{"id":"1d2b642fa388ec52","type":"text","text":"# Focus memorie?\n\ncioè un microcontroller può avere RAM, ROM, Flash, EEPROM, NVRAM\n\nci stanno anche le porte I/O...\n\nse hai voglia, slides 3_2 n 23+","x":-800,"y":1057,"width":600,"height":261},
		{"id":"889656ca3deaaf7e","type":"text","text":"### Causa-effetto nel design dei sensori\n\n\n- **Comunicazione dati**: Sensori cablati sono più affidabili, ma meno flessibili rispetto a quelli wireless.\n","x":-3700,"y":-486,"width":759,"height":116},
		{"id":"617bc5508509a069","x":-840,"y":-21,"width":759,"height":911,"type":"text","text":"# Microcontrollori CortexM"},
		{"id":"442ecb8952c528e2","type":"text","text":"## cortex (il malvagio)\n\ntutti ARM. Memory Protection Unit fa switch tra  user e kernel mode.\nDMA (vedi sistemi operativi immagino)\nvbb è tutto un ripassone di cose (+ specifiche processori cortex) fino a slide 27, poi entra in dettaglio sugli interrupt (e.g. int. request (IRQ) - viene dal sensore, è il più comune) con tutta la parte tecnica (yeee).\nirrisorie differenze in costi diventano gargantuesche se moltiplicate per il numero di things. segue esempio. ma non su questo! sul fatto che tra sleep ed active consumption passa un universo mondo di potenza. poi aggiunge lo stato di transizione tra sleep  ed active (non ditelo a Donald).","x":1080,"y":1400,"width":720,"height":315},
		{"id":"d51f893becdde7b8","type":"text","text":"# Teoria dell'Informazione","x":1320,"y":-1280,"width":759,"height":340},
		{"id":"54d0a7ecb87b5c26","type":"text","text":"# Internet of Things (IoT)\n\nCon la ***miniaturizzazione dei processori*** che permette di inserire intelligenza praticamente ovunque e ***IPv6*** che permette di assegnare un indirizzo univoco a $O(10^{38})$ dispositivi, è facile immaginare un mondo in cui qualsiasi oggetto può collegarsi ad Internet.\n\n***Internet of Things*** (***IoT***) è il successore di quello che oggi conosciamo come Internet: se ai nodi aggiungiamo ***sensori*** per monitorare l'ambiente e ***attuatori*** per modificarlo, di fatto estendiamo il concetto di ***servizio*** (e.g. mail, video) a un qualcosa che viene materialmente fatto (in modo automatico e ottimizzato) nel mondo materiale di tutti i giorni (e.g. domotica).\n\nEssendo tanti, l'intelligenza e l'autonomia media di un singolo nodo IoT è abbastanza bassa. Questo apre a tutta una serie di problemi sulla sicurezza della comunicazione hop-to-hop e sulla necessità di protocolli energy-efficient ad hoc (e.g. da ***BLE*** a ***6LoWPAN***).","x":1320,"y":-680,"width":759,"height":387,"color":"6"},
		{"id":"a94d060ea349fc00","type":"text","text":"### **2.2 Efficienza energetica e gestione dell’alimentazione**\n\nPer dispositivi IoT alimentati a batteria, ogni milliwatt risparmiato prolunga la durata operativa.\n\n- **Precisione vs. Consumo energetico**: Sensori molto precisi richiedono più energia e processore, ma in IoT l’ottimizzazione energetica è essenziale.\n- **Efficienza energetica**: Un attuatore sempre attivo consuma troppa energia → Strategie di **power management**.\n\n\n### Dynamic Voltage Scaling (DVS)\n**CAUSA:** Un processore non ha sempre bisogno della massima potenza.\n**EFFETTO:** DVS regola dinamicamente la tensione e la frequenza della CPU per ottimizzare il consumo energetico.\n\n- Se il processore è in idle, si abbassa la tensione per ridurre il consumo.\n- Se serve più potenza (es. analisi dati complessa), si aumenta la tensione.\n- Questo riduce sprechi di energia e aumenta la durata della batteria.\n   \n**CAUSA:** Un singolo dispositivo è inutile senza un’infrastruttura di comunicazione.\n**EFFETTO:** Servono protocolli di rete e standard per la trasmissione dati.\n","x":-1760,"y":1227,"width":759,"height":1000},
		{"id":"1c081b05e8facdeb","x":40,"y":-408,"width":920,"height":2930,"type":"text","text":"## **ARM Cortex-M: Una Panoramica Essenziale**\n\n### **1. La famiglia Cortex-M: Piccoli ma potenti**\n\nTutti i microcontrollori Cortex-M condividono un’architettura a 32 bit e si dividono in tre macro-famiglie:\n\n- **ARMv6-M:** Cortex-M0, Cortex-M0+, Cortex-M1 → i più semplici, bassi consumi, meno potenza\n    \n- **ARMv7-M:** Cortex-M3 → medio livello, più prestazioni rispetto a M0\n    \n- **ARMv7E-M:** Cortex-M4, Cortex-M7 → i più avanzati, con supporto a DSP e floating point\n    \n\n**Cosa definisce un Cortex-M?**\n\n- **Set di istruzioni:** indica quali operazioni la CPU può eseguire\n    \n- **Funzionalità di base del core** (es. gestione interruzioni, stack pointer, program counter)\n    \n\n---\n\n### **2. Funzionalità opzionali dei Cortex-M**\n\nAlcuni Cortex-M integrano extra che migliorano sicurezza e performance:\n\n- **Memory Protection Unit (MPU):** evita che il codice utente acceda a memoria riservata al kernel\n    \n- **SysTick Timer:** timer standard per task periodici\n    \n- **Periferiche mappate in memoria:** tutto (USB, ADC, UART...) è accessibile come un blocco di memoria\n    \n\n---\n\n### **3. Un esempio concreto: Atmel SAM4L (Cortex-M4)**\n\nCaratteristiche:\n\n- CPU Cortex-M4, 48 MHz\n    \n- 128-512 KB Flash, 32-64 KB RAM\n    \n- **Bassi consumi:** 4.3 mA @ 48MHz\n    \n- **Supporto USB, UART, SPI, I²C**\n    \n- **15 canali DMA:** trasferimenti di dati tra periferiche senza coinvolgere la CPU (ottimo per il real-time)\n    \n\nDMA → CPU libera da operazioni di I/O pesanti → maggiore efficienza\n\n---\n\n### **4. Un altro esempio: Nordic nRF51 (Cortex-M0 + BLE)**\n\nDifferenze con SAM4L:\n\n- CPU Cortex-M0 (meno potente)\n    \n- Supporto Bluetooth Low Energy (BLE)\n    \n- Consumi superiori in trasmissione (fino a 16 mA TX)\n    \n- **Conclusione:** Qui l’ottimizzazione non riguarda la CPU, ma la gestione del radio per minimizzare il consumo\n    \n\n---\n\n### **5. Mappatura della Memoria nei Cortex-M**\n\nGli elementi hardware interni sono mappati come regioni di memoria:\n\n- **0x00000000 → Memoria codice (Flash)**\n    \n- **0x20000000 → SRAM**\n    \n- **0x40000000 → Periferiche (es. ADC, UART, GPIO, etc.)**\n    \n- **0xE0000000 → Registri di sistema**\n    \n\n---\n\n### **6. Registri del Core e Modalità di Esecuzione**\n\nIl processore ARM ha **16 registri principali** (r0-r15), tra cui:\n\n- **r13 → Stack Pointer (SP)**: punta all’ultimo valore dello stack\n    \n- **r14 → Link Register (LR)**: memorizza il ritorno da una funzione\n    \n- **r15 → Program Counter (PC)**: indica l’istruzione successiva\n    \n\nI Cortex-M possono operare in due modalità:\n\n- **User Mode (limitato):** evita accesso diretto all’hardware, sicurezza aumentata\n    \n- **Kernel Mode (completo accesso):** necessario per compiti critici (scheduling, I/O, gestione memoria)\n    \n\n---\n\n### **7. Interruzioni e Interrupt Controller**\n\nUn’interruzione è un evento (es. un sensore che invia un segnale) che forza la CPU a:\n\n1. **Sospendere l’esecuzione attuale**\n    \n2. **Passare in Kernel Mode**\n    \n3. **Eseguire un Interrupt Service Routine (ISR)**\n    \n4. **Riprendere il programma precedente**\n    \n\nLe interruzioni hanno 3 stati:\n\n- **Inattivo:** Nessun evento\n    \n- **Pending:** L’interruzione è avvenuta, ma la CPU non l’ha ancora gestita\n    \n- **Attivo:** Il codice ISR sta risolvendo l’interruzione\n    \n\nEsempi di sorgenti di interrupt:\n\n- **Hardware:** ADC, Timer, GPIO\n    \n- **Software:** divisioni per zero, errori di memoria\n    \n\n---\n\n### **8. Interrupt Vector Table (IVT)**\n\nTutte le interruzioni sono associate a un indirizzo specifico memorizzato in una **IVT (Interrupt Vector Table)**, che mappa le interruzioni ai loro handler.\n\n**Gestione della priorità:** Se due interrupt arrivano contemporaneamente, quello con priorità più alta viene gestito per primo.\n\n---\n\n## **Conclusione**\n\nI Cortex-M sono fondamentali nei sistemi embedded per il loro equilibrio tra potenza, efficienza energetica e versatilità. La gestione della memoria, delle interruzioni e delle periferiche li rende ideali per applicazioni real-time, dispositivi IoT e microcontrollori a basso consumo."},
		{"id":"032d9aeb665be7c1","type":"text","text":"\n## **4. Problemi Aperti e Considerazioni Finali**\n\n### **4.1. Sicurezza e Privacy**\n\n- **Causa:** L’IoT spesso lavora con dati sensibili (sanità, sorveglianza, automobili connesse).\n    \n- **Effetto:** Servono protocolli di sicurezza **leggeri ma efficaci** (es. DTLS, crittografia elliptic curve per dispositivi a bassa potenza).\n    \n\n\n**Approfondimenti consigliati:**\n\n- Ricerca su **Bin Packing Problem** e tecniche di risoluzione (branch-and-cut, metaeuristiche).\n    \n- Studio di protocolli MQTT e CoAP per comprendere le differenze pratiche.\n    \n- Analisi di casi studio reali di fog computing per applicazioni industriali.","x":2520,"y":-459,"width":1055,"height":332},
		{"id":"a8dcb3193cec51a3","type":"text","text":"# L7 & L8\n\nInformation Theory, vedi quaderno","x":2160,"y":897,"width":720,"height":320},
		{"id":"bb5a7945372dc391","type":"text","text":"# L5 & L6\n\nSaltate, vedi slides","x":2160,"y":540,"width":720,"height":320},
		{"id":"d6502f7b02f95013","type":"text","text":"# Lec 1 & 2\n\nslide 41 paper non ancora presentato, video yt alla fine delle references\n","x":2160,"y":20,"width":720,"height":100},
		{"id":"16780e52dae3921b","x":2160,"y":200,"width":720,"height":220,"type":"text","text":"# L3 & L4\n\nTablet (circa)"}
	],
	"edges":[
		{"id":"6883460e8c227a3c","fromNode":"1e3fd2b7a4b6a7cc","fromSide":"top","toNode":"d700a52cca1cdc2a","toSide":"bottom","label":"Distributed Cloud"},
		{"id":"e03e1fee77478baf","fromNode":"54d0a7ecb87b5c26","fromSide":"top","toNode":"d51f893becdde7b8","toSide":"bottom"},
		{"id":"fcc82691ef115619","fromNode":"54d0a7ecb87b5c26","fromSide":"left","toNode":"1e3fd2b7a4b6a7cc","toSide":"right"},
		{"id":"b6bb6d947657dd64","fromNode":"1e3fd2b7a4b6a7cc","fromSide":"left","toNode":"2d43e95958d0e621","toSide":"right","label":"Communication"},
		{"id":"1d3252b9a19eabde","fromNode":"1e3fd2b7a4b6a7cc","fromSide":"bottom","toNode":"ff3b9035a56b4e9e","toSide":"top","label":"Embedded Devices"},
		{"id":"b49c09a5e045bfc2","fromNode":"2d43e95958d0e621","fromSide":"bottom","toNode":"9bc5e22487feb01e","toSide":"top"},
		{"id":"1b2d138f8ffa4754","fromNode":"ff3b9035a56b4e9e","fromSide":"left","toNode":"9bc5e22487feb01e","toSide":"right"},
		{"id":"de576ac895022535","fromNode":"ff3b9035a56b4e9e","fromSide":"right","toNode":"1d2b642fa388ec52","toSide":"left"},
		{"id":"a4ca303b3a8531b2","fromNode":"ff3b9035a56b4e9e","fromSide":"right","toNode":"617bc5508509a069","toSide":"left"},
		{"id":"e6a2fdd6320150b3","fromNode":"ff3b9035a56b4e9e","fromSide":"bottom","toNode":"a94d060ea349fc00","toSide":"top"}
	]
}