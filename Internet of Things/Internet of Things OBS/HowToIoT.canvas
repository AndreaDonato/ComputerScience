{
	"nodes":[
		{"id":"1e3fd2b7a4b6a7cc","type":"text","text":"# HowTo Build IoT Networks\n\nPur essendo molto diversi fra loro, tutti i sistemi IoT poggiano sulla stessa architettura:\n\n- ***Cloud*** - Il cervellone che ha il quadro completo della situazione e sa cosa fare si trova su Internet. Per raggiungere i dispositivi deve passare attraverso il loro Gateway;\n\t- Se il sistema è complesso, può distribuirsi sul territorio tramite i ***fog nodes***.\n- ***Gateway*** - Comunica con il Cloud tramite protocolli Internet (TCP/IP), e con i dispositivi tramite protocolli locali (e.g. BLE, ZigBee, WiFi, 6LoWPAN);\n\t- Nota che il Gateway tendenzialmente non è il router domestico, piuttosto un hub che accede ad Internet tramite esso e poi si interfaccia con i dispositivi.\n- ***Embedded Devices*** - I dispositivi veri e propri (***Things***).\n\nNel complesso, possiamo individuare una ***stack protocollare*** propria delle reti IoT.","x":-1760,"y":-1000,"width":759,"height":387,"color":"6"},
		{"id":"ff3b9035a56b4e9e","type":"text","text":"# Things\n\nUna Thing ha bisogno di fare essenzialmente tre cose:\n\n1. ***Percepire l’ambiente*** - Un ***sensore*** sfrutta un fenomeno fisico (e.g. una resistenza che varia in funzione del calore) per convertire la misura da prendere in un segnale EM. Successivamente, un ADC converte il segnale da analogico a digitale, e tramite un *protocollo/architettura* ad-hoc i dati vengono inviati al processore;\n\t- Li chiamo *protocolli/architetture* perché non definiscono solo cose tipo \"`prima di mandare il segnale successivo aspetta il colpo di clock`\", ma anche il numero e lo scopo dei fili utilizzati per farlo. Questo significa che per parlare la lingua di un certo protocollo, il microcontrollore deve avere l'HW adatto!\n\t\t- ... o quasi. Esistono modi per emulare il comportamento di un protocollo via SW, motivo per cui si chiamano \"protocolli\" e non \"*protocolli/architetture*\".\n\t- Tra i più noti citiamo ***SPI*** (**Serial Peripheral Interface**, velocissimo ma richiede tanti fili), ***I2C*** (**Inter-Integrated Circuit**, lento ma ne richiede meno) e ***UART*** (**Universal Asynchronous Receiver-Transmitter**, come dice il nome si usa per la compatibilità).\n2. ***Interagire fisicamente*** - Un ***attuatore*** funziona intuitivamente al contrario: riceve un segnale dal processore (per come descritto sopra), eventualmente converte in segnale analogico con un DAC e passa il risultato al motore, che si muove di conseguenza;\n\t- Dico \"eventualmente\" perché non tutti i motori funzionano con segnali analogici. È un attuatore anche uno switch che modifica un circuito elettrico;\n\t- I requisiti vanno dalla reattività real-time alla robustezza a condizioni atmosferiche.\n3. ***Elaborare dati e prendere decisioni locali*** - Il cuore di un sistema informatico è sempre il processore. Qui distinguiamo tra due tipi di architetture:\n    - ***MCU*** (***Microcontroller Unit***) - Un singolo chip che contiene CPU, memorie e periferiche (e.g. SPI, I2C). Consuma poco ed è ottimizzato per task specifici (i.e. esegue un singolo programma, senza SO). Ne è un esempio ***ESP32***, utilizzato per le lampadine smart, ma anche ***Arduino***;\n    - ***MPU*** (***Microprocessor Unit***) - Letteralmente la CPU che metti nel tuo computer, che deve appoggiarsi ad una MoBo e che quindi è in grado di reggere roba complessa come un SO Linux. Ovvio che in IoT la MoBo deve essere piccolissima: meglio parlare di ***System-on-Chip*** (***SoC***), che differisce da una classica MoBo perché non è affatto scalabile o espandibile (... è letteralmente un chip già saldato). Ovviamente si usa RISC, e un esempio tipico è il ***Raspberry Pi***.","x":-1760,"y":120,"width":759,"height":911,"color":"4"},
		{"id":"617bc5508509a069","type":"text","text":"# Microcontrollori CortexM\n\nQuesta famiglia di microcontrollori ha dato una bella spinta allo sviluppo di IoT dal 2004.\n\nSono tutti basati su architettura `ARM` a `32 bit`, dal più semplice e meno energivoro `M0` ai più avanzati `M7`, che contengono supporto per **Digital Signal Processing** (**DSP**, che serve per l'elaborazione *real time* di immagini, audio e controlli di attuatori robotici) e `float`.\n\nTutti hanno in comune la gestione dei registri (`r0`$\\to$`r15`, di cui gli ultimi tre sono `Stack Pointer`, `Link Register`, che sarebbe `Return Address`, e `Program Counter`), e della memoria (in sequenza, `Flash`, `SRAM`, `Periferiche` e `Registri`). Alcuni implementano `User/Kernel Mode` e conseguente `Memory Protection Unit` (`MPU`) per impedire l'accesso all'area riservata al `Kernel`.\n\ncioè un microcontroller può avere RAM, ROM, Flash, EEPROM, NVRAM (RAM per operazioni temporanee. Flash ROM o EEPROM per firmware e dati persistenti)\n\nci stanno anche le porte I/O...\n\nse hai voglia, slides 3_2 n 23+\n\nUn’interruzione è un evento (es. un sensore che invia un segnale) che forza la CPU a:\n\n1. **Sospendere l’esecuzione attuale**\n2. **Passare in Kernel Mode**\n3. **Eseguire un Interrupt Service Routine (ISR)**\n4. **Riprendere il programma precedente**\nLe interruzioni hanno 3 stati:\n- **Inattivo:** Nessun evento\n- **Pending:** L’interruzione è avvenuta, ma la CPU non l’ha ancora gestita\n- **Attivo:** Il codice ISR sta risolvendo l’interruzione\nEsempi di sorgenti di interrupt:\n- **Hardware:** ADC, Timer, GPIO\n- **Software:** divisioni per zero, errori di memoria\n\nTutte le interruzioni sono associate a un indirizzo specifico memorizzato in una **IVT (Interrupt Vector Table)**, che mappa le interruzioni ai loro handler.\n\n**Gestione della priorità:** Se due interrupt arrivano contemporaneamente, quello con priorità più alta viene gestito per primo.","x":-751,"y":120,"width":759,"height":911,"color":"3"},
		{"id":"03e26affba62b324","type":"text","text":"# Esempi di MCU Cortex-Based\n\n\nNonostante siano un po' datati, restano ad oggi un punto di riferimento per applicazioni che richiedono basso consumo energetico. Esempi di configurazioni sono\n\n- ***Atmel SAM4L (Cortex-M4)*** - Consuma $4.3 \\text{ mA @ }48 \\text{ MHz}$ (i.e. alla velocità massima di $48\\times10^3$ colpi al secondo assorbe $4.3\\text{ mA}$) e supporta USB, SPI, I2C, UART e 15 canali di DMA (i.e. mette una CPU potente e ne ottimizza l'uso permettendo alle periferiche di bypassarla con un accesso diretto a memoria, se il suo intervento non è necessario);\n\t- Possiamo risalire all'assorbimento di corrente per ciclo di clock:$$I_C={4.3 \\cdot 10^{-3}\\text{ A/s}\\over48 \\cdot 10^6\\text{ Cycle/s}}\\simeq0.09\\,\\mu\\text{A/Cycle}$$\n\t- Sì, la gente in Computer Science non sa usare le dimensioni.\n- ***Nordic nRF51 (Cortex-M0 + BLE)*** - CPU meno potente ($\\sim 2.6 \\text{ mA/s @ }16 \\text{ MHz}$) che però va usata più spesso. Inoltre, abbiamo un sistema di trasmissione BLE che usa fino a $16 \\text{ mA @ TX}$ (i.e. $16 \\text{ mA}$ per trasmissione).\n\t- Questa CPU ha un costo più alto per ciclo di clock, ma va più lenta:$$I_C={2.6\\cdot 10^{-3}\\text{ A/s}\\over16 \\cdot 10^6\\text{ Cycle/s}}\\simeq0.16\\,\\mu\\text{A/Cycle}$$\n\t- Perché mai realizzare un processore che consuma più corrente per ciclo e poi mettergli un clock più lento? L'`M0` è realizzato usando meno transistor rispetto all'`M4`. Se da un lato questo lo rende meno ottimizzato (è costretto a fare le stesse operazioni in più cicli), dall'altro questo riduce le ***leakage currents*** (i.e. quelle micro-correnti che determinano il consumo quando il processore è in ***sleep mode***, che sono proporzionali al numero di transistor). In pratica, l'`M0` è ottimale se va usato poco, cosa che accade se il focus è su BLE;\n\t\t- Nota che questo effetto di leak in sleep mode è tanto più presente quanto più riduciamo le dimensioni dei transistor, per effetto del tunneling quantistico.\n\t- Piccolo ***focus su BLE***: trasmette pacchetti di dimensione fissa, e tipicamente non lo fa in modo continuativo. Ogni trasmissione dura di norma $\\sim 1\\text{ ms}$, e se ad esempio trasmettesse una volta al secondo (i.e. ***duty cycle*** di ${1\\text{ ms}/1\\text{ s}}=0.001$) avremmo qui (e sottolineo qui, perché quel $16 \\text{ mA @ TX}$ dipende dall'HW e dalla configurazione) un consumo di $16 \\text{ mA}\\times0.001 = 16\\,\\mu\\text{A}$.","x":258,"y":120,"width":759,"height":911,"color":"4"},
		{"id":"c39cda918518baad","type":"text","text":"# Sleep Mode\n\nIn ***Sleep Mode*** il processore attua una serie di comportamenti per ridurre i consumi:\n\n- ***Clock Gating*** - Disattiva il clock su alcune unità, che smettono quindi di assorbire corrente (e.g. se non serve il DAC, evito di farlo girare a vuoto);\n- ***Power Gating*** - Stacca l'alimentazione da alcune unità (e.g. in una CPU multi-core, può non essere sempre necessaria tutta la potenza computazionale parallela);\n- ***Dynamic Voltage and Frequency Scaling*** (***DVFS***) - Se non devo effettuare calcoli complessi, posso ridurre la tensione e la frequenza di clock (e.g. smartphones).\n\nTutto questo viene implementato in modo massiccio su ***MPU***, mentre su MCU il discorso è più complesso. Intanto tocca complicare l'HW (e non è scontato poterlo fare). Inoltre, un MCU ha bisogno di reagire in tempo reale agli interrupt dei sensori, evitando latenze dovute a lenti processi di risveglio (***wakeup latency***). Spesso gli MCU implementano direttamente il ***Deep Sleep*** (riduce le attività sia della CPU che della RAM) o l'***Ibernazione*** (salva lo stato su memoria non volatile e spegne tutto).\n\nIl fatto che su MCU ci sia meno margine per entrare in Sleep Mode non deve ingannare: essendo dispositivi ottimizzati, sono comunque loro che consumano di meno!\n\nOvviamente il consumo energetico non si azzera in Sleep Mode, per diversi motivi:\n\n- Anche se faccio Clock Gating, gli elementi circuitali esclusi sono comunque alimentati da una tensione (posso staccarla facendo Power Gating, ma in quel caso cancello tutti i bit!), che per effetti quantistici sulle giunzioni dei transistor continua a far scorrere una piccola ***leakage current*** (la quale aumenta esponenzialmente con la temperatura);\n- Anche il Power Gating può avere perdite minime sul transistor \"ponte\", che serve a staccare/riattaccare la corrente alla zona in sleep;\n- In ogni caso, non potrei mai spegnere completamente tutto il processore: ho sempre bisogno di qualcosa di attivo che riattivi gli elementi in sleep.","x":-751,"y":1280,"width":759,"height":773,"color":"4"},
		{"id":"4c794fe5a6070164","type":"file","file":"SAM4L_Modes.png","x":258,"y":1266,"width":759,"height":304},
		{"id":"a94d060ea349fc00","type":"text","text":"# Efficienza Energetica\n\nMolti dispositivi IoT sono alimentati a batteria, ed ogni milliwatt risparmiato prolunga la durata operativa. Questo costituisce sempre un trade-off tra il consumo e la precisione dei sensori (se devo spegnerli ogni `tot` per ridurne il consumo rischio di perdere dati utili, ma per risparmiare posso anche ridurre i bit di precisione o la frequenza di campionamento).\n\nSi rende efficiente un sistema embedded implementando la Sleep Mode e ottimizzando il codice, l'uso dei sensori e delle strategie di comunicazione.","x":-1760,"y":1536,"width":759,"height":261,"color":"6"},
		{"id":"d11ebd7b1efd8ff7","type":"text","text":"# Ottimizzazione del Codice e Riferimenti\n\nChiaro che è il codice a decidere quando andare in Sleep Mode e quando trasmettere. Questo si traduce nell'ottimizzare i periodi di ***idle*** (i.e. quando conviene disattivare cosa) e quelli di ***tempo attivo*** (i.e. se sono sveglio, allora devo fare più cose possibile).\n\n- ***Parallelismo*** - Riduce il tempo attivo eseguendo operazioni in parallelo;\n- ***Batching*** - Aspetto di avere tante cose da fare prima di attivarmi. Questo ottimizza i costi di accensione/spegnimento, riducendo la frequenza delle transizioni di stato (i.e. `ON`, `IDLE` e `HIGH DUTY`, e.g. un protocollo come BLE preferisce inviare 10 pacchetti ogni secondo piuttosto che 1 ogni decimo di secondo). Questo di fatto ottimizza il ***Duty Cycle***: il dispositivo non misura/attua/invia/riceve costantemente, ma a intervalli regolari diluiti nel tempo;\n- ***Event-Driven Sampling*** - I sensori si attivano o comunicano dati solo in risposta ad un cambiamento significativo (e.g. uno smartphone accende il giroscopio solo se l'accelerometro rileva una forte accelerazione, o un termostato comunica con il gateway solo se ci sono variazioni di temperatura).\n\nAbbiamo poi due branche che si occupano di ridurre l'overhead di comunicazione:\n\n- ***Compressione dati*** - Trasmettere meno dati per trasmissione significa meno energia spesa per la comunicazione (cfr. ***Teoria dell'Informazione***);\n- ***Edge Computing*** - Ottimizza il numero di trasmissioni sulla rete (cfr. ***Fog Computing***).","x":-2769,"y":1280,"width":759,"height":773,"color":"4"},
		{"id":"43767a936de8e8b1","type":"text","text":"# Da dove prendo l'Energia?\n\nPotrei farlo da diverse fonti. Partiamo con l'escludere il caso in cui riesco a connettermi direttamente alla rete elettrica, perché è banale: posso permettermi alti consumi, quindi verosimilmente uso un MPU. Restano due scenari principali, in cui si usano gli MCU:\n\n- ***Batterie*** - Soluzione alla quale si cerca con sempre più forza di trovare un'alternativa. Hanno capacità limitata, e il loro sviluppo in termini di potenza erogata su dimensioni non sta dietro all'esponenziale evoluzione dei dispositivi embedded. Si cerca quindi di ridurre i consumi energetici a tutti i costi, ma questo si traduce in minore potenza di calcolo e velocità di trasmissione;\n- ***Energy Harvesting*** - Idea in via di sviluppo che prevede di raccogliere l'energia dall'ambiente in cui il dispositivo è immerso.\n\t- Questo può, a seconda dell'architettura,\n\t\t- eliminare l'uso delle batterie. Parliamo di uno schema ***Harvest-Use***, i.e. uso in diretta l'energia che raccolgo, se non ce n'è abbastanza mi spengo;\n\t\t- limitare l'uso delle batterie. Schema ***Harvest-Store-Use***, i.e. accumulo energia anche quando non sono attivo per usarla successivamente (in pratica è una batteria ricaricabile).\n\t- Il concetto di fonte di energia va dal fotovoltaico/termoelettrico/eolico al calore e al movimento corporeo.","x":-1760,"y":2288,"width":759,"height":565,"color":"4"},
		{"id":"cc865f4cd6000ab4","type":"text","text":"# ARM (Architettura degli Elaboratori)\n\nArchitettura poco energivora, quindi particolarmente adatta a smartphone e tablet (è infatti utilizzata da praticamente tutti i produttori, da Apple a **Samsung** e **Huawei**), come pure a smartwatch, dispositivi *embedded* e di tipo *Internet of Things* (come *Raspberry Pi*).\n\nARM ha sviluppato nel tempo diverse ISA, volte principalmente a migliorare l'efficienza del codice e il consumo di memoria, ma soprattutto nel 2011 ha rilasciato la propria estensione a 64 bit, **ARMv8**, dando un forte impulso all'industria dei dispositivi portatili.","x":-751,"y":-376,"width":759,"height":261,"color":"4"},
		{"id":"9b1a993fbf97aa5e","type":"text","text":"# Energy Harvesting come MDP\n\nSe hai voglia, pacco di slides 3_3_1\n\nRiferimenti:\n\n- CdM in generale: cfr. ***Computer Network Performance***;\n- MDP e Q-Learning: cfr. ***Autonomous Networking***.","x":-1760,"y":3040,"width":759,"height":227,"color":"1"},
		{"id":"d700a52cca1cdc2a","type":"text","text":"# Fog Computing\n\nIl Cloud, seppur potente, è costoso e lontano (nonché potenzialmente offline, in caso di guasti). Alcune applicazioni potrebbero richiedere decisioni rapide (e.g. un sensore di caduta per persone anziane è costretto a decidere rapidamente se mandare l'allarme), in altre bisogna considerare che una rete IoT può essere usata per gli obiettivi più disparati, e che per questo sia HW che SW sono fortemente specifici dell'applicazione.\n\nViene quindi naturale capire che in una rete IoT vanno elaborati dati ***eterogenei***, sia nel senso che diversi sensori producono diversi formati di output (i.e. i ***dati*** nel complesso sono ***non-strutturati***) sia che diverse informazioni hanno diverse ***priorità***. È scomodo far gravare tutto il peso di un'analisi dati fortemente diversificata su un unico server centrale.\n\nQuesto problema viene mitigato con i ***fog nodes***, i.e. distribuisco il server di analisi dati. Il ***Fog Computing*** è in pratica una via di mezzo tra l'Edge Computing e il Cloud Computing, in cui sono i ***gateway*** stessi a pre-processare i dati prima di inviarli al Cloud (o addirittura a decidere cosa vale la pena mandargli e cosa no!).\n\nTutto molto bello, ma c'è un problema: ogni sensore genera un carico di lavoro variabile, e i fog nodes hanno capacità limitate (sia in termini di `FLOPs` che di memoria). Tradotto, bisogna trovare un algoritmo per assegnare dinamicamente le richieste dei sensori al fog node ottimale per evitare colli di bottiglia (l'assegnazione viene tipicamente svolta da un ***dispatcher*** che si trova tra le Things e i fog nodes).\n\nQuesto è un ***Bin Packing Problem*** (o `0-1 Knapsack Problem`), pertanto $\\NPC$. Per piccole/medie dimensioni esistono algoritmi di ottimizzazione che forniscono soluzioni esatte, ma diventano esponenzialmente più lenti al crescere dell'input (cfr. ***Gurobi***). Si cercano quindi euristiche ed algoritmi approssimanti.\n\n","x":-1760,"y":-2428,"width":759,"height":695,"color":"4"},
		{"id":"c8f665ef67bbc260","type":"text","text":"# `0-1 Knapsack` & Bin Packing Problem\n\nHai uno zaino con una ***capacità massima*** (e.g. 7 kg). Davanti a te hai un mucchio di oggetti. Ognuno ha un ***peso*** e un ***valore*** (quanto ti serve o quanto è prezioso). Puoi prendere ogni oggetto una sola volta (0 o 1 volte). La sfida è: quali oggetti scegli per massimizzare il valore totale nello zaino, senza superare il peso massimo? Esempio:\n\n- Laptop - 3 kg, 2000€;\n- Bottiglia d’acqua - 2 kg, 10€;\n- Oro - 5 kg, 3000€;\n- Libro - 4 kg, 100€\n\nNon puoi prendere \"mezzo oro\" o \"mezzo laptop\". Devi decidere: o lo prendi tutto, o niente. Con tanti oggetti, le possibili combinazioni esplodono e rendono il problema $\\NPC$. Serve una strategia intelligente, perché il brute force non funzionerà.\n\nTra le possibili strategie:\n\n- ***Algoritmi Greedy*** - Prendi gli oggetti col miglior rapporto valore/peso;\n- ***Programmazione dinamica*** - Costruisci una tabella che ti dice il valore massimo ottenibile per ogni sottopeso;\n- ***Branch & bound*** - Esplori l’albero delle soluzioni tagliando i rami inutili.\n\nTutto questo vale per uno zaino e prende il nome di `0-1 Knapsack Problem`. Se fossero $F$, avremmo il ***Bin Packing Problem*** (cfr. ***Fog Node Assignment Problem***).\n\nEsistono varianti di questo problema, e.g. **Fractional knapsack** (i.e. puoi prendere frazioni di oggetti, diventa più facilmente risolvibile in modo greedy).","x":-751,"y":-2428,"width":759,"height":695,"color":"4"},
		{"id":"ea6c2db0218bf20e","type":"text","text":"# Fog Node Assignment Problem\n\nPrendiamo l'esempio del *fall detector*. Ogni sensore invia una task (e.g. `questi sono i dati che ho raccolto, puoi fare i tuoi potenti calcoli e dirmi se vogliono dire che nonna è caduta?`) a un ***dispatcher***, che decide a quale fog node inoltrarlo.\n\nTraduciamo questa roba in matematica. Abbiamo:\n\n- $N$ sensori $s_i$, a cui corrispondono risorse richieste $r_i$ (i.e. se il sensore $s_i$ invia le proprie task ad un fog node, questo consumerà $_i$ per risolverle, e.g. in termini di `FLOPs`);\n- $F$ fog nodes $f_j$ che per funzionare richiedono risorse $g_j$ (e di conseguenza costi $c_j$). Tipicamente $N\\gg F$ (altrimenti il problema sarebbe molto semplice!);\n- Un dispatcher $D$ che raccoglie i dati e li smista ai vari fog nodes. $D$ conosce i $c_i$ di ciascun $f_i$, ed è a lui che spetta il compito di ottimizzare l'assegnazione.\n\n Definiamo due grandezze binarie:\n \n- $y_j=1 \\iff f_j$ viene utilizzato;\n- $x_{ij}=1 \\iff$  una task di $s_i$ è assegnata ad $f_j$.\n\nA questo punto il compito di $D$ è trovare la soluzione di$$\\min_y\\sum_jy_j\\,c_j$$il che ovviamente minimizza il costo complessivo. Mancano i constraints, perché così com'è la soluzione migliore è scegliere $y$ identicamente nullo. Allora mettiamo$$\\sum_jx_{ij}=1\\quad \\forall\\,i$$i.e. voglio che tutti i task siano eseguiti (altrimenti può essere che nonna cade e l'allarme non parte). Inoltre non posso eccedere la capacità totale di ciascun fog node, i.e.$$\\sum_ix_{ij}\\,r_i\\le g_j\\,y_j\\quad \\forall\\,j$$Abbiamo ufficialmente formulato il problema come ***ILP***. Questa roba è più generale rispetto ad un ***Bin Packing Problem***, perché (contrariamente ai fog nodes) gli zaini (bin) non hanno un costo associato e le loro capacità sono tutte uguali.","x":-1760,"y":-3565,"width":759,"height":902,"color":"4"},
		{"id":"1d4c9d197fab6065","type":"text","text":"# Gurobi\n\nVedi codice colab. Esegui, gioca. C'è un problema di ottimizzazione su classroom\n\ngurobi cerca soluzioni esatte, non è approssimante \n\npoi ha fatto una roba sull'ottimizzazione lineare in generale\n\n\n\nottimizzazione lineare in N dimensioni: $\\min_x c^Tx = \\min_x \\sum_i c_ix_i$ con constraints$$Ax\\le b\\quad A_ex=b_e\\quad x\\in D$$\nnel problema di prima questi constraints (credo siano restrizioni di dominio e condizioni al contorno) diventano$$\\sum_ix_ir_i\\le g\\quad \\sum_{i\\ne j}x_{ij}=1\\quad x\\in\\Z$$\nho scritto \"copia tablet\" ma non trovo questi fantomatici appunti a riguardo.","x":-751,"y":-3565,"width":759,"height":902},
		{"id":"bb5a7945372dc391","type":"text","text":"# L5 & L6\n\nSaltate, vedi slides","x":1513,"y":514,"width":759,"height":320},
		{"id":"a8dcb3193cec51a3","type":"text","text":"# L7 & L8\n\nInformation Theory, vedi quaderno","x":1513,"y":871,"width":759,"height":320},
		{"id":"032d9aeb665be7c1","type":"text","text":"\n## **4. Problemi Aperti e Considerazioni Finali**\n\n### **4.1. Sicurezza e Privacy**\n\n- **Causa:** L’IoT spesso lavora con dati sensibili (sanità, sorveglianza, automobili connesse).\n    \n- **Effetto:** Servono protocolli di sicurezza **leggeri ma efficaci** (es. DTLS, crittografia elliptic curve per dispositivi a bassa potenza).\n    \n\n\n**Approfondimenti consigliati:**\n\n- Ricerca su **Bin Packing Problem** e tecniche di risoluzione (branch-and-cut, metaeuristiche).\n    \n- Studio di protocolli MQTT e CoAP per comprendere le differenze pratiche.\n    \n- Analisi di casi studio reali di fog computing per applicazioni industriali.","x":1513,"y":-420,"width":759,"height":404},
		{"id":"442ecb8952c528e2","type":"text","text":"## cortex (il malvagio)\n\ntutti ARM. Memory Protection Unit fa switch tra  user e kernel mode.\nDMA (vedi sistemi operativi immagino)\nvbb è tutto un ripassone di cose (+ specifiche processori cortex) fino a slide 27, poi entra in dettaglio sugli interrupt (e.g. int. request (IRQ) - viene dal sensore, è il più comune) con tutta la parte tecnica (yeee).\nirrisorie differenze in costi diventano gargantuesche se moltiplicate per il numero di things. segue esempio. ma non su questo! sul fatto che tra sleep ed active consumption passa un universo mondo di potenza. poi aggiunge lo stato di transizione tra sleep  ed active (non ditelo a Donald).","x":1513,"y":70,"width":759,"height":315},
		{"id":"07d370c1b1fb30ea","type":"text","text":"# il resto delle slides\n\n\"spalmare il segnale lo rende più simile al rumore e costituisce un layer di sicurezza\" (ma in che senso???)\n\nsicuramente hoppare secondo un pattern costituisce sicurezza, ma va settato bene! forse lo è anche la chipping sequence (CodeDivisionMultiplexing). sono tipo superimposed codes?? la domanda è sempre: come faccio ad essere certo che il receiver sia allineato?","x":5265,"y":-967,"width":759,"height":293},
		{"id":"183cc241a018e501","type":"text","text":"# Alfabeti, Simboli, Linguaggi, Furfanti, Licantropi, ...\n\nBoh io ho trovato sta roba un po' confusionaria, quindi facciamo ordine.\n\nNei DMC siamo partiti da un esempio semplice, in cui $\\calX=\\calY=\\{0,1\\}$. Questa scelta di fatto costituisce la quasi totalità delle applicazioni reali. Perché? Ma perché tutto l'HW del mondo è basato sulla codifica binaria! Secondo te se intercetti un'onda EM che trasmette dati, quale codifica trovi? In base 26?\n\nEcco, visto che però in genere vorrei trasmettere informazioni più complesse e l'HW parla in binario, sono costretto a codificare in binario. Sia $\\calX$ che $\\calY$ nel quotidiano parlano binario! Ma quindi la trattazione generica con $\\calX\\ne \\calY$ serve solo al risultato formale? ***No***. Il fatto che la ***quasi*** totalità delle codifiche sia binaria non significa che lo siano tutte.\n\nQuello che può però trarre in inganno è l'abitudine ad usare i `bit`, che come abbiamo capito vengono molto facilmente confusi con i $\\bit$. Facciamo quindi un esempio più generale per capire che diavolo sta succedendo.\n\n$\\calX=\\{A, B, C\\}$, $\\calY=\\{\\a,\\b,\\g, \\d\\}$. Il canale potrebbe conoscere più simboli di quelli che l'input gli comunica, o viceversa. In entrambi i casi esce una matrice $W$ non quadrata, tipo\n$$W(Y|X)=\\begin{bmatrix}\nP(\\a \\mid A) & P(\\b \\mid A) & P(\\g\\mid A) & P(\\d\\mid A) \\\\\nP(\\a \\mid B) & P(\\b \\mid B) & P(\\g\\mid B) & P(\\d\\mid B) \\\\\nP(\\a \\mid C) & P(\\b \\mid C) & P(\\g\\mid C) & P(\\d\\mid C) \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0.7 & 0.2 & 0.1 & 0.0 \\\\\n0.1 & 0.6 & 0.2 & 0.1 \\\\\n0.0 & 0.1 & 0.3 & 0.6 \\\\\n\\end{bmatrix}$$\nTutto questo ci sta dicendo che se viene inviato il simbolo $A$ è più probabile che in output venga ricevuto il simbolo $\\a$, e via dicendo. Visto che questa roba è suscettibile agli errori non è troppo conveniente inviare un simbolo alla volta. Scegliamo un codice $\\calC^2$, i.e. decidiamo che `AA` significa `A`, `BB` è `B` e `CC` è `C`. Questo ha due effetti:\n\n- Visto che $P(\\a\\mid A)=0.7$, diventa meno probabile che `AA` venga trasformato in due simboli di output che non sono $\\a$ $\\so$ ***ottengo robustezza rispetto all'errore***;\n- Al contempo per inviare un singolo simbolo $A$ ho dovuto inviarne due (`AA`) $\\so$ ***riduco l'efficienza della comunicazione***. Di quanto? Posso quantificarlo con il ***transmission rate***, che però malauguratamente è definito assumendo che $n$ sia la lunghezza della codeword in `bit`. Ma lasciamolo spiegare meglio al riquadro sul Transmission Rate.","x":3279,"y":-5934,"width":759,"height":856,"color":"4"},
		{"id":"20f0389aed3f57c6","type":"text","text":"# Transmission Rate\n\nCos'è il Transmission Rate, e perché è un disastro che si chiami così? (spoiler: perché ci ho messo tre ore a capire che cazzo di trasmissione fosse.)\n\nPariamo con il dire che, come al solito, l'esempio fatto con i `bit` può essere fuorviante. Prima ho detto che sceglievo come codeword `1010` e `0101`, dando per scontato che ogni simbolo fosse binario. Potrei benissimo scegliere `ABBA` e `BACA` avendo come alfabeto `A B C`. Non cambierà nulla per quello che segue. O quasi. Ci arriviamo.\n\nIl ***transmission rate*** non è una qualche forma di throughput. O meglio, un po' lo è, ma la definirei piuttosto un'***efficienza***. De che? Della comunicazione, ovviamente.$$R = {\\bit \\text{ informativi}\\over \\text{bit fisici trasmessi}}\\le1$$\nIn pratica, quanti ***bit informativi*** riesco a trasmettere per ogni bit fisico. Ora, nel caso in cui utilizziamo ***sequenze binarie*** di $n$ `bit` possiamo scrivere $R$ come$$R={1\\over n}\\log_2|\\calC^n|\\in[0,1]$$\nHai presente quella legge che ti impone di usare solo sequenze binarie? No, vero? Infatti non esiste. Questa scrittura è infatti un caso particolare di$$R={1\\over n\\log_2|\\calX|}\\log_2|\\calC^n|\\in[0,1]$$\nOk, cambia solo la normalizzazione, ma è importante. Poniamo $n=4$ e $\\calC^n=16$.\n\n- Se usiamo l'alfabeto binario, $\\log_2|\\calX|=1$. Questo significa che con $16$ parole binarie ho un'efficienza $R=1$, i.e. sto sfruttando tutte le potenzialità del mio alfabeto. Questo però significa anche che ogni pezzetto di informazione è esattamente dove deve essere, il che la rende una situazione molto fragile e poco robusta rispetto al rumore;\n- Se usiamo l'alfabeto inglese, $\\log_2|\\calX|\\simeq4.7$, quindi con $16$ parole inglesi di lunghezza $4$ ho un'efficienza $R\\simeq0.21$. Non sto sfruttando appieno l'alfabeto, è vero, ma di contro sarà molto più facile distinguere tra `xykz` e `abcd`.\n\nIn pratica, se $R$ è alto significa che sto trasmettendo messaggi molto compressi (codeword vicine tra loro, rischio di fare più errori), viceversa la trasmissione è lenta rispetto al potenziale dell'alfabeto utilizzato, ma è robusta rispetto agli errori.","x":2272,"y":-4843,"width":759,"height":922,"color":"4"},
		{"id":"eadc00ddd47569d3","type":"text","text":"# Discrete Memoryless Channel (DMC)\n\nPartiamo da uno schema semplice: invio `0` o `1` e il `bit` può essere flippato con probabilità $\\e$. Possiamo descrivere i possibili scenari dovuti al rumore con una ***matrice stocastica***\n$$\n\\calW(Y|X)=\\begin{bmatrix}\nP(0 \\mid 0) & P(1 \\mid 0) \\\\\nP(0 \\mid 1) & P(1 \\mid 1)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 - \\varepsilon & \\varepsilon \\\\\n\\varepsilon & 1 - \\varepsilon\n\\end{bmatrix}\n$$\n\nNessuno però trasmette un `bit` alla volta: in questo modo posso comunicare solo risultati di eventi $X Y$ binari, e il rumore potenzialmente ribalta quello che voglio comunicare.\n\nGeneralizziamo a situazioni in cui l'input consta di ***simboli*** $x\\in\\calX$ e l'output di altri simboli $y\\in\\calY$ (i.e. metti che il tuo alfabeto di partenza è `A B C` ma il rumore ti fa ricevere una `D`). Questo si traduce in una matrice $|\\calY|\\times|\\calX|$ $$\\calW(\\calY|\\calX)=\\P(y_i|x_j)$$Se ricevo una sequenza di $n$ simboli, posso risalire alla probabilità che questi siano esattamente quelli che erano stati inviati in input:$$W^n(Y=\\vec{y}\\mid X=\\vec x)=\\prod_{k=1}^n\\calW(y_k\\mid x_k)$$dove la produttoria indica la proprietà di ***assenza di memoria*** del canale.\n\nDefiniamo un ***encoder*** $\\calC^n$ come un subset $\\sse \\calX^n$ di tutte le possibili sequenze di `n bit` realizzabili sull'alfabeto $\\calX$: $c\\in\\calC^n\\in\\calX^n$ sono le ***codeword***, e vengono inviate sul DMC. In output, un ***decoder*** $\\varphi^n$ prova a ricondurre la sequenza $s\\in\\calY^n$ che osserva ad una $c\\in\\calC^n$. Un ***errore*** si verifica quando il decoder ricostruisce una codeword diversa da quella che era stata inviata dall'encoder.\n\nSbagliare è tanto più facile quanto più le codeword sono vicine. Se le uniche due codeword sono `1010` e `0101` ho scelto solo `2` messaggi su `16` stringhe disponibili (in particolare queste due sono ***ortogonali***), quindi sarà più difficile sbagliarsi. Viceversa, se ne uso `14` su `16` disponibili anche un solo `bit flip` cambierà il significato della parola. Né posso avere un $n$ stratosferico, perché significa spendere troppe risorse per ogni parola.\n\nBisogna quindi trovare un compromesso tra $n$ e $|\\calC^n|$, tramite il malauguratamente detto ***Transmission Rate*** (davvero eh Claude... un nome peggiore non potevi trovarlo).","x":3279,"y":-4843,"width":759,"height":922,"color":"4"},
		{"id":"bc00b250b7b24ec0","type":"text","text":"# Informazione, Sorpresa ed Entropia\n\nL'idea fondamentale alla base di questo modello è che gli eventi rari ci sorprendono più di quelli frequenti. Prendiamo ad esempio un evento binario i cui outcome hanno probabilità $\\P[A]=t$ e $\\P[B]=1-t=q$ e fissiamo $t=0.99$. Non saremo affatto sorpresi se si verifica l'evento $A$. In altri termini, il verificarsi di $A$ non costituisce un'***informazione*** significativa. Se però viceversa si verifica $B$ (che ha probabilità $q=0.01$) le cose cambiano: saremo sorpresi, e in un mare di eventi $A$ il verificarsi di $B$ sarà un'informazione significativa.\n\nIn particolare, più $q$ si avvicina a $0$ più il verificarsi di $B$ sarà un evento sorprendente. Viceversa, quando $q\\to1$ la sorpresa va ad annullarsi. Un buon modo per modellizzare a livello matematico questo comportamento è definire il ***contenuto informativo*** (o ***sorpresa***) di un evento $E$ che si verifica con probabilità $\\P[E]$ come$$\\I[E]=-\\log_2\\bigg(\\P[E]\\bigg)=\\log_2\\bigg({1\\over\\P[E]}\\bigg)$$\nIl logaritmo ha senso, quella base $2$ sembra un po' arbitraria ma sarà chiara a breve. Il punto è che adesso abbiamo la sorpresa per un evento, vediamo che succede se sommiamo su tutte le possibilità. Limitiamoci un attimo ad eventi binari e scriviamo l'***entropia binaria***$$h(t)=t\\log_2\\bigg({1\\over t}\\bigg)+(1-t)\\log_2\\bigg({1\\over 1-t}\\bigg)\\in[0,1]$$dove $t\\in(0,1)$ è la probabilità di uno dei due eventi. Possiamo facilmente estendere per continuità a $t\\in[0,1]$ definendo $h(0)=h(1)=0$, e per com'è scritta ha un massimo in $t=0.5$. Tale massimo vale $1$: la logica della base $2$ del logaritmo è quindi normalizzare la binary entropy. Essendo un oggetto del tipo \"somma di (sorpresa $\\times$ probabilità della sorpresa)\", l'entropia costituisce un ***valore atteso di sorpresa***. Di chi? Della ***sorgente di informazioni***!\n\nQuesto significa che possiamo caratterizzare il grado di imprevedibilità (o caos, se ci piace il parallelismo con la fisica) di una sorgente di eventi probabilistici tramite questa funzione: una sorgente è \"poco sorprendente\" se $t\\sim 0$ o $t\\sim1$ (non ha senso lanciare una moneta se esce sempre testa!), e \"molto sorprendente\" per $t\\sim 0.5$ (massima casualità).\n\nNota che in realtà posso estendere tutto questo anche a sorgenti non binarie. Sia $X$ una random variable (RV) che può assumere valori $\\{x_1, ..., x_n\\}$ con probabilità $p_i = \\P[X=x_i]$ (i.e. $X$ è una sorgente di informazioni). L'***entropia di Shannon*** di $X$ è data da$$H(X)=-\\sum_ip_i\\log_2(p_i)=\\sum_ip_i\\log_2\\bigg({1\\over p_i}\\bigg)\\in[0, \\log_2n]$$che è massima se la pdf è piatta (i.e. una moneta truccata ha meno entropia di una \"pulita\").\n\nRiassumendo: la ***sorpresa*** è legata all'***evento***, l'***entropia*** alla ***distribuzione***.","x":2272,"y":-3693,"width":759,"height":1030,"color":"4"},
		{"id":"03bb0206eb695483","type":"text","text":"# \"Contenuto di Informazione per Simbolo\"\n\nQuando diciamo che un alto valore di $R$ implica un alta velocità di trasmissione, si intende che ogni singolo simbolo della codeword porta molta informazione.\n\nPrendiamo l'esempio delle `16` codeword con `4 bit`, i.e. il massimo possibile: ogni singolo `bit` è fondamentale per distinguere tra due codeword. Se ricevo `100` e manca l'ultimo bit, questo sta ancora decidendo al $50\\%$ tra `1000` e `1001`, da cui $R=1$ (perché posso fare questo stesso discorso per ogni `bit`.\n\nSe invece abbiamo l'alfabeto inglese e riceviamo `ABB`, l'ultimo `simbolo` magari porta $0$ informazione, perché esiste una sola codeword che inizia per `ABB` (e.g. `ABBA`). Chiaro, non tutti i simboli hanno un contenuto informativo pari a $0$, ma se su $26^4=456976$ codeword ne scelgo solo `16` verosimilmente queste saranno molto distanti, quindi basterà poco per discriminare tra esse. Magari il primo `simbolo` riduce le possibilità da `16` a `2`, mentre nel caso binario ogni `simbolo` (`bit`) prende una scelta al $50\\%$ su un albero binario.\n\nInsomma, nel primo caso ogni `bit` è una scelta con $\\P=0.5$ (massima entropia, da cui nel complesso uscirà $R=1$), mentre nel secondo caso il primo simbolo potrebbe avere $\\P=0.1$ e il  secondo $\\P=0.99$. Da qui otteniamo un'informazione media di $R\\simeq0.21 \\bit/$`simbolo`.","x":2272,"y":-5761,"width":759,"height":511,"color":"4"},
		{"id":"886eeef68d17e333","type":"text","text":"# Correlazione, Rumore e Comunicazione\n\nPer come l'abbiamo definita, quella di Shannon è un'entropia ***marginale*** (i.e. riguarda solo una sorgente, e.g. $X$). Poniamo di averne un'altra, e.g. $Y$. Se vogliamo caratterizzare un evento il cui outcome consta di un pezzo che discende da $X$ ed uno che deriva invece da $Y$, ci sono altre grandezze che dobbiamo introdurre.\n\n- ***Conditional Entropy*** - Se $X$ è l'incertezza tra il lanciare un dado o una moneta e $Y$ un outcome da $1$ a $6$, è chiaro che conoscere il risultato di $X$ influenza la distribuzione di probabilità su $Y$. Quindi la domanda della conditional entropy è: se conosco $X$, qual è la sorpresa residua su $Y$? Matematicamente, questa roba si scrive$$H(Y|X)=\\sum_{x\\in \\calX}\\P(x)\\,H(Y|X=x)=-\\sum_{x,y}\\P(x,y)\\log_2\\P(y|x)$$\n- ***Mutual Information*** - Ma quanto esattamente conoscere $X$ riduce la sorpresa su $Y$?$$I(X;Y)=H(Y)-H(Y|X)=H(X)-H(X|Y)=I(Y;X)$$\n\t- Nota che è sempre $\\ge 0$, l'uguaglianza vale per variabili indipendenti.\n- ***Joint Entropy*** - Quantifica l'informazione media necessaria a descrivere nel complesso l'evento che consta delle due parti $X$ ed $Y$. L'informazione necessaria a descrivere $(X,Y)$ è pari a quella per conoscere $X$ più quella residua (nel senso di conditional entropy) per conoscere $Y$ (e viceversa, perché è chiaramente simmetrica):$$H(X,Y)=H(X)+H(Y|X)= H(Y)+H(X|Y)=-\\sum_{x,y}\\P(x,y)\\log_2\\P(x,y)$$\n\nTutto questo mi serve a correlare due sorgenti in particolare: l'input e l'output di un ***Canale di Comunicazione***. Dato un input $x$, il ***rumore*** produrrà in generale un output $y\\ne x$. Segue che il mio compito di ascoltatore sarà di risalire a $x$ dato $y$.\n\nIn pratica, non possiamo a cuor leggero comprimere il messaggio da inviare fino al limite dato dall'entropia: ogni piccolo errore produrrebbe grandi incomprensioni. Per ottenere robustezza rispetto al rumore siamo costretti ad introdurre ***ridondanza*** rispetto alla compressione ottimale.","x":3279,"y":-3693,"width":759,"height":1030,"color":"4"},
		{"id":"51edfc0fd55ad3f4","type":"text","text":"# Capacità di Canale\n\nUn ***Discrete Memoryless Channel*** (***DMC***) è definito da una tripla $(\\calX, \\calY, W)$, dove $W$ è la matrice stocastica del ***rumore***. Segue quindi che è $W$ che caratterizza il canale. Possiamo definire un ***rate di trasmissione*** $R$ che ci dà due indicazioni complementari:\n\n- Quanto \"velocemente\" stiamo trasmettendo, i.e. data la lunghezza $n$ della codeword qual è il contenuto informativo (sorpresa) medio per ognuno degli $n$ `simboli`;\n- Quanto stiamo rischiando di non farci capire a destinazione (i.e. più il singolo `simbolo` è informativo, più una sua modifica dovuta al rumore modifica il senso del messaggio).\n\nOgni valore di $R$ rappresenta quindi un compromesso tra velocità e rischio di errori. Ci si potrebbe aspettare quindi che l'unico modo per far sì che l'errore tenda a $0$ è che $R\\to0$. \n\n... e invece no!\n\nAnzitutto $e\\to0$ lo puoi ottenere anche per $n\\to\\infty$. Al crescere di $n$, è più facile creare codeword distanti tra loro (in ogni caso $|\\calC^n|$ deve crescere esponenzialmente con $n$).\n\nA questo punto facciamo una piccola costruzione matematica e diciamo che un certo rate $R_0$ è ***achievable*** su un DMC $(\\calC^n,\\calY^n,\\calW^n)$ se esiste una sequenza di encoder-decoder $\\{\\calC^n,\\varphi^n\\}_{n\\in\\N}$ tali che per $n\\to\\infty$ abbiamo$$e(\\calC^n,\\calY^n,\\calW^n)\\to0\\qquad\\limsup_{n\\to\\infty}{1\\over n}\\log|\\calC^n|\\ge R_0$$i.e. se possiamo trovare un codice tale che l'errore tende a zero pur mantenendo $R\\ge R_0$.\n\nOra, tutto questo sarebbe solo una bella costruzione matematica se non fosse che esiste lo ***Shannon Capacity Theorem for DMCs*** che ci dice che il massimo rate achievable$$C(\\calW)=\\max\\{R\\mid R\\text{ è un achievable rate}\\}$$sul canale rumoroso caratterizzato da $\\calW$ è pari alla ***massima mutual information*** tra il segnale di input $X$ e quello di output $Y$, i.e.$$C^*(\\calW)=\\max_{\\P(Y|X)\\sim\\calW(Y|X)}I(Y|X)\\quad\\so\\quad C(\\calW)=C^*(\\calW)$$dove $\\P(Y|X)\\sim\\calW(Y|X)$ significa che la pdf di $Y$ dato $X$ è data dalla matrice di rumore (ma in pratica l'unica cosa che posso variare è $\\P(X)$, perché il rumore è caratteristico del canale!).\n\nNota che questo è un limite teorico. Data una matrice di rumore, esiste un massimo rate per il quale è safe comunicare senza rischio di errore. Non sta dicendo ***come*** scrivere encoder e decoder. La sfida \"ingegneristica\" qui è appunto trovare codici quanto più possibile vicini al limite teorico per ottimizzare la comunicazione.","x":4288,"y":-3693,"width":759,"height":1030,"color":"4"},
		{"id":"887e35db37687bdc","type":"text","text":"# Codici Continui e Rumore Gaussiano\n\nQuando comunico con un'onda EM lo schema concettuale non è \"`simbolo` che diventa un altro `simbolo` a causa del rumore\", piuttosto è un ***segnale continuo*** che viene ***distorto***.\n\nVista la proprietà additiva dell'ampiezza delle onde, il modello sul segnale diventa$$Y=X+Z$$dove $Z\\sim\\calN(0,\\s^2)$ è il ***rumore gaussiano***. i.e. mi aspetto che la distorsione media sia $0$ ma con un certo allargamento $\\s^2$. $X$ e $Z$ sono anche qui indipendenti.\n\nA questo punto dovremmo traslare tutto il discorso dell'entropia al caso continuo.$$h(Z)=-\\int f_Z(z)\\log\\big[f_Z(z)\\big]dz$$è detta ***entropia differenziale***, e guarda caso è massima per $Z\\sim\\calN(0,\\s^2)$. Il massimo vale$$h(Z\\sim\\calN(0,\\s^2))={1\\over2}\\log(2\\pi e\\s^2)$$Ora, per ***massimizzare la mutual information*** nel caso continuo$$I(X;Y)=h(Y)-h(Y|X)$$ho bisogno di massimizzare $h(Y)$. Quindi anche $Y$ deve essere gaussiana. Ma se $Y=X+Z$ e $Z$ è gaussiana allora ***devo scegliere $X$ gaussiana***. Così facendo abbiamo che$$h(Y|X)=h(X+Z\\mid X)=h(Z)$$(la sorpresa di $X$ dato $X$ è zero, dopodiché $X$ e $Z$ sono indipendenti), e facendo i conti$$I(X;Y)=h(Y)-h(Z)={1\\over2}\\log(2\\pi e\\s^2_Y)-{1\\over2}\\log(2\\pi e\\s^2_Y)=[...]={1\\over2}\\log\\bigg(1+{\\s^2_X\\over\\s^2_Z}\\bigg)$$\nDefiniamo quindi il ***Signal to Noise Ratio*** (***SNR***) e usando il ***teorema di Nyquist-Shannon*** sul campionamento senza perdita di informazione su canale con bandwidth $B$ (i.e. devi campionare almeno al doppio della frequenza dell'onda che trasporta l'informazione) arriviamo a formulare il ***teorema di Shannon-Hartley***$$\\SNR={\\s^2_X\\over\\s^2_Z}\\quad\\so\\quad C(\\calW)=B\\log_2(1+\\SNR)$$\nQuesto risultato fornisce la capacità massima del canale in $\\bit/s$.\n\nL'informazione di questo teorema è \"Più banda hai, più segnali puoi inviare. Più forte è il tuo segnale rispetto al rumore, più informazione puoi comprimere in ciascun segnale\".","x":5297,"y":-3693,"width":759,"height":1030,"color":"4"},
		{"id":"d51f893becdde7b8","type":"text","text":"# Teoria dell'Informazione\n\nLa Teoria dell'Informazione si occupa dello studio della quantificazione, dell'archiviazione e del trasferimento dell'informazione. Nasce da tre osservazioni sulla comunicazione:\n\n1. Il ***contenuto informativo*** di un messaggio equivale alla ***sorpresa*** che genera;\n2. In ogni ***linguaggio***, le parole di ***uso comune*** sono più corte di quelle non-comuni;\n3. Se ti perdi qualche pezzetto di frase, sei ancora in grado di ***ricostruire il messaggio***.\n\nDa questi tre principi, la modellizzazione matematica tira fuori tre risultati principali:\n\n1. Data una ***sorgente d'informazioni***, l'***Entropia di Shannon*** quantifica il valore atteso della ***sorpresa*** (i.e. del ***contenuto informativo***) del generico ***messaggio*** che essa può produrre, definendo il concetto di $\\bit$ informativo come unità di misura dell'informazione. Costituisce inoltre il limite inferiore alla ***compressione*** di un messaggio;\n- Dato un ***alfabeto*** di ***simboli*** (i.e. ***eventi*** o ***messaggi***), una ***codifica*** mira a trasformare tali simboli in sequenze di simboli (dette ***codeword***) di un altro alfabeto, detto ***codice***;\n\t- Se sembra non avere senso, considera che ***ASCII*** è una ***codifica binaria*** che trasforma simboli dell'alfabeto in sequenze di `bit`;\n\t2. Se utilizzo una ***codifica a lunghezza variabile*** posso applicare una ***compressione***, i.e. sfrutto la pdf della sorgente di simboli per assegnare ai messaggi più frequenti una rappresentazione più breve, e di conseguenza ottimizzare la lunghezza media della codeword. Si capisce anche meglio perché il suo limite inferiore è l'entropia: la compressione mira a ***minimizzare il numero di `bit` per ***$\\bit$;\n\t3. Se utilizzo una ***codifica a lunghezza fissa*** posso costruire codici appositamente per essere robusti rispetto al ***rumore***, utile se devo ***trasferire l'informazione***.","x":2272,"y":-2428,"width":759,"height":695,"color":"6"},
		{"id":"2df7743f9594ebe8","type":"text","text":"# `Bit` Fisico vs $\\bit$ Informativo\n\n***Questa è una cosa molto importante.***\n\nLa Teoria dell'Informazione riconosce l'entità logica fondamentale $0/1$ come \"quanto\" di informazione, in quanto costituisce la risposta più semplice che si possa dare (i.e. scelta binaria). Tale quanto di informazione viene chiamato ***$\\bit$ informativo***.\n\n***Il $\\bit$ NON È il `bit`.*** \n\nIl `bit` inteso come entità che può assumere solo valori `0` e `1` si riferisce a questi due oggetti in quanto ***simboli*** di un ***alfabeto binario***. Potrebbero tranquillamente essere `A` e `B`. Insomma, ***i simboli non quantificano niente***.\n\nIpotizziamo che io faccia una domanda ad una macchina che risponde sempre `sì`.\n\n- Per recapitarmi la risposta, la macchina deve mandare un `bit` fisico;\n- Quando la risposta arriva, la mia sorpresa è esattamente $0$. So che rispondi sempre `sì`, questo `bit` che mi hai inviato non mi fornisce alcun $\\bit$ di informazione.\n\nOvviamente e malauguratamente ***questi due concetti a volte coincidono***. Se faccio la stessa domanda ad una macchina che risponde `sì` o `no` al $50\\%$, ogni `bit` che mi arriva in risposta coinciderà con esattamente un $\\bit$ di informazione.\n\nAltre volte è evidente che c'è qualcosa di strano. Se la macchina risponde `sì` il $75\\%$ delle volte e `no` il restante $25\\%$, ogni `bit` porta mediamente $0.81\\bit$ di informazione. Questa strana magia si chiama ***Entropia di Shannon***.\n\nMorale della favola: non tutti i `bit` che invii servono a comunicare qualcosa.","x":3279,"y":-2428,"width":759,"height":695,"color":"4"},
		{"id":"344ee0d6725a4b78","type":"text","text":"# Esempi e Metafore per Convincersi\n\nIl `bit` fisico ha un ***costo reale*** (e.g. tempo, energia, banda). È ciò che _trasporti_.\n\nIl $\\bit$ informativo è un \"quanto siamo sorpresi\" da un simbolo. È un'entità **astratta** che si misura in base 2. È ciò che *comunichi davvero*.\n\n- $1 \\bit$ = `1` evento binario con probabilità $0.5$.   \n- Il rapporto tra `bit` e $\\bit$ la quantifica il ***transmission rate***:$$R = {\\bit \\text{ informativi}\\over \\text{bit fisici trasmessi}}\\le1$$\n- Nota che un ***simbolo*** in generale può portare più di un $\\bit$ di informazione. Se ad esempio uso l'alfabeto inglese con pdf piatta, ricevere una `K` mi genera una sorpresa pari a $\\log_2(26)\\sim4.7$.\n### **Metafora cinematografica** (By AI)\n\n- I bit **fisici** sono le **pellicole** che usi per registrare un film.\n- I bit **informativi** sono la **storia** che stai raccontando.\n    - Se filmi due ore di schermo nero, stai usando tantissima pellicola (bit fisici) ma non stai dicendo nulla (bit informativi ≈ 0).\n    - Se filmi un thriller dove ogni minuto succede qualcosa di imprevedibile, ogni metro di pellicola è carico di informazione.","x":4288,"y":-2428,"width":759,"height":695,"color":"4"},
		{"id":"19dbf5244a8bbdc1","type":"text","text":"# Abuso di Notazione\n\nNonostante \"encoder\" e \"decoder\" suggeriscano entità omologhe, $\\calC^n$ è un ***codice*** (quindi un subset di tutte le possibili stringhe realizzabili con $n$ simboli, i.e. $\\calC^n \\sse \\calX^n$) mentre $\\varphi^n$ è una ***funzione*** $\\varphi^n:\\calY^n\\to \\calC^n\\sse \\calX^n$.\n\nUn ***encoder*** in senso stretto dovrebbe essere una funzione $\\calE^n:\\calM\\to\\calC^n\\sse\\calX^n$ che mappa messaggi $m\\in\\calM$ in codeword $c\\in\\calC^n$.\n\nDa quello che leggo questo passaggio logico viene comunemente saltato per alleggerire la notazione, io non sono d'accordo. Chiamalo codice, no? Che ti costa?","x":4288,"y":-4533,"width":759,"height":303,"color":"4"},
		{"id":"2b90ecf4bdbdb286","type":"text","text":"# Le nuove slides (6?) - Protocolli MAC\n\nogni channel della tv ha un diverso chip code","x":6221,"y":-2017,"width":759,"height":710},
		{"id":"953ba1b6df1d2cf5","type":"text","text":"# Compressione (lossless) dell'Informazione\n\nPoniamo di dover comunicare in binario codificando ogni lettera dell'alfabeto (`a, ..., z`). Posto che potrei usare `5 bit` (devo contare fino a più di `16` ma a meno di `32`) scegliendo `a = 00000`, `b = 00001`, `...`, esiste un modo più ottimizzato per scegliere la codifica?\n\nAnzitutto, c'è un'importante scelta da fare:\n\n- Se non accetto di perdere informazione nel processo (***compressione lossless***) devo trovare una corrispondenza biunivoca tra il messaggio codificato e la sua decodifica. Per fare ciò mi serve una ***binary encoding*** di tipo ***prefix-free***;\n- Se accetto di perdere informazione nel processo (***compressione lossy***) posso permettermi di ridurre le dimensioni oltre i limiti della versione lossless.\n\nLimitiamoci alla compressione lossless e troviamo il limite di compressione.\n\nPosto di aver trovato un prefix-free encoding e di avere un set di probabilità $\\P$ associate alle parole di $\\calM$ (i.e. sappiamo qual è la frequenza attesa delle varie parole), definiamo$$l(f)=\\sum_{m\\in\\calM}\\P[m]\\,\\bigg|f(m)\\bigg|=\\sum_{m\\in\\calM}\\P[m]\\,l_m$$lunghezza media di $f$ (i.e. della stringa prodotta da $f$ su $m\\in\\calM$ secondo $\\P$). Capiamo bene che il problema originale coincide con il minimizzare $l(f)$. Ma andiamo con ordine. La ***disuguaglianza di Kraft*** stabilisce una relazione per il codici prefix-free:$$\\sum_{m\\in\\calM}2^{-l_m}\\le1$$\nChe significa? Se interpretiamo la codifica PF come un albero binario (ogni nodo è un prefisso, ogni ramo `0/1` porta ad un nuovo prefisso), ogni $f(m)$ è il cammino dalla radice ad una foglia. Kraft dice che se quella somma fa più di $1$, allora stai cercando di usare più foglie di quante ne esistono. Di conseguenza, almeno una $f(m)$ non sarà una foglia, i.e. sarà il prefisso di una qualche $f(m')$.\n\nQuesto lemma si usa per dimostrare il ***Teorema di Codifica della Sorgente***: l'***entropia*** è il ***limite inferiore della compressione lossless***, i.e.$$l(f)\\ge H(\\P)$$dove l'uguaglianza vale solo per distribuzione $\\P$ uniforme.\n\nOra, uno potrebbe pensare che questo limite sia più stringente del dovuto, perché abbiamo preso un encoding prefix-free invece di uno univocamente decodificabile. Invece no: il limite resta questo anche se rilasso quella condizione.\n","x":1267,"y":-3693,"width":759,"height":1030,"color":"4"},
		{"id":"796fa6183e62d341","type":"text","text":"# Breve Storia della Teoria dell'Informazione\n\nGià durante gli anni '20 ***Nyquist*** e ***Hartley*** avevano pubblicato studi circa la trasmissione di informazioni, giungendo a forme funzionali del tipo $A = \\log B$. L'informazione veniva definita come la ***capacità del ricevitore di distinguere una sequenza di simboli da qualsiasi altra***.\n\n Durante il suo lavoro come crittografo nel corso della WWII, ***Shannon*** comprende che la codifica di messaggi segreti implica di fatto l'aggiunta di rumore ingannevole ai messaggi originali, e che la decodifica consiste nella rimozione di tale rumore. È forse ripensando a questo che quando gli viene chiesto di ottimizzare la comunicazione su canali rumorosi inizia a pensare ad un'astrazione teorica per modellizzare il problema.\n\nNel ***1948*** compare un suo articolo in cui definisce così il processo della comunicazione:\n\n- Dato un insieme di possibili messaggi, una ***sorgente di informazione*** ne seleziona uno; \n- Un ***trasmettitore*** codifica questo messaggio in un ***segnale***;\n- Il segnale viene inviato attraverso un ***canale***, dove può essere corrotto dal ***rumore***;\n- Un ***ricevitore*** decodifica quindi il segnale ricevuto per ricostruire il messaggio originale.\n\nLa rivoluzione di questo modello è l'uso della probabilità per modellare sorgente e rumore. Di conseguenza, le grandezze qui definite (e.g. l'***entropia dell'informazione***) trovano facili paralleli con la ***meccanica statistica***, e le applicazioni della teoria nel suo complesso spaziano oggi dalla codifica del DNA umano alle grandi teorie di unificazione in fisica.\n\nL'articolo del 1948 segna convenzionalmente l'inizio dell'***Era dell'Informazione***.","x":1267,"y":-2428,"width":759,"height":695,"color":"4"},
		{"id":"5a1008ab6d4f93fb","type":"text","text":"# Variable Length Binary Encodings\n\nIn generale, il concetto di ***alfabeto*** è esteso ad un insieme $\\calX$ di ***simboli*** ($|\\calX|<\\infty$). $\\calM$ è l'insieme delle ***parole*** (o ***codewords***) di un certo ***codice*** costruito su $\\calX$ ($|\\calM|<\\infty$), ed $\\calM^*$ è l'insieme delle ***sequenze di parole*** $m\\in\\calM$ ($|\\calM^*|=\\infty$).\n\nQui ci limitiamo però ad un ***alfabeto binario***, quindi $\\calX=\\{0,1\\}$. Non solo: permettiamo parole di lunghezza variabile (perché stiamo facendo compressione, per i canali rumorosi $l$ si fissa).\n\nUn ***variable length binary encoding*** è una funzione iniettiva $f:\\calM\\to\\{0,1\\}^*$, i.e. ogni $m\\in\\calM$ è mappata in una sequenza binaria distinta da tutte le altre (non è biettiva perché $\\{0,1\\}^*$ è un insieme infinito, non è vero che ogni sequenza binaria codifica una $m\\in\\calM$).\n\nTrovare $f$ sembra sufficiente, ma solo se trasmetto una parola alla volta. Di norma voglio trasmetterne diverse, quindi devo trovare una $f^*:\\calM^*\\to \\{0,1\\}^*$ iniettiva. Il che ovviamente non è facile! Chiaro che $f^*(m^*)=f(m_1)...f(m_n)$, ma proprio per questo se codifico `A = 0`, `B = 1` e `C = 01`, la stringa `001` può voler dire sia `AAB` che `AC`!\n\nSegue che $f$ è ***univocamente decodificabile*** (UD) se $f^*$ è iniettiva. Quindi la domanda è: come si costruisce una $f^*$ iniettiva? Ci serve che nessuna coppia di parole $m,m'\\in\\calM$ sia codificata da $f$ in modo ambiguo, i.e. che $$\\forall\\, m,m'\\in\\calM \\,|\\, m\\ne m'\\to f(m)\\not\\trianglelefteq f(m')$$ovvero che per ogni coppia $m,m'$ $f(m)$ non sia un prefisso di $f(m')$. Se ciò si verifica, $f$ è detta ***codifica prefix-free*** (PF). Intuitivamente, $x$ è prefisso di $y$ se $\\exists\\,z\\in\\{0,1\\}^*$ t.c. $y=zx$. Le codifiche prefix-free sono un ***sottoinsieme*** di quelle UD. Pertanto, $$\\text{PF} \\so \\text{UD}\\qquad\\text{ma}\\qquad \\text{UD} \\not\\so \\text{PF}$$\nOk, ma come costruisco una codifica PF? Intanto la disuguaglianza di Kraft$$\\sum_{m\\in\\calM}2^{-l_m}\\le1$$fornisce una condizione sufficiente: se scelgo delle lunghezze $l_m$ tali che questa viene rispettata, allora esiste una codifica PF avente le $f(m)$ ti tali lunghezze. <span style=\"color:rgb(236, 155, 14)\">Qui è dove avrei voluto trovare un algoritmo reale, ma non ne ho voglia.</span>","x":1267,"y":-4843,"width":759,"height":922,"color":"4"},
		{"id":"bc4657e96dfd6f9a","type":"text","text":"# Modulazione dei Segnali\n\namplitude + phase shift molto usato\n\nconstellation diagrams ti permettono di encodare diverse combinazioni di bit con una certa combinazione ampiezza-fase. Il receiver riceve il punto rosso e inferisce qual è il messaggio più probabile. in pratica puoi definire un constellation diagram per definire il numero di simboli (o words) che trasmetti con il singolo \"quanto\" d'onda. Nota che simboli $\\ne$ bit. Se sono 4 ho `00 01 10 11`, i.e. ogni simbolo consta di DUE bit.\n\nTransmission rate = $\\log(DN)$ dove D \"numero di diagrammi\" (?) e N numero di punti per ogni diagramma. se aumento il numero di bit per simbolo ogni simbolo diventa più informativo. distinguiamo quindi il bitrate dal symbol rate.\n\nerrori - devo ovviamente separare al meglio i punti per facilitare l'inferenza. Lo faccio aumentando l'ampiezza. la potenza del segnale è data dall'ampiezza media. immagino che si codificano i least used symbols con punti poco potenti e viceversa. rivedi slide 86. fa discorso sul fatto che se faccio simboli super informativi è facile sbagliare grossi pezzi di info, allora devo alzare la potenza per separare meglio i punti.\n\nè chiaro che bitrate $\\propto$ potenza. Ma anche bandwidth? Sì, ovviamente. questo giochino dei diagrammi di costellazione lo faccio a frequenza fissata, quindi usare più frequenze significa usare più diagrammi (la $D$ della formula di prima che non avevo capito cosa significasse). Tipo, WiFi ne usa 16 (la famosa banda 2.4GHz), ogni 2 MHz.\n\nla roba dell'allargamento in frequenza la presenta al contrario: l'idea è che devi usare un botto di frequenze per realizzare Fourier. (ma bastano quelle contigue dello spettro??)\n\nChannel Capacity C = B log_2 (1+SNR), quindi se aumento la bandwidth aumento la channel capacity meglio di se aumento SNR\n\nSlide 95 - In teoria i due canali hanno la stessa capacità, in pratica per le interferenze le frequenze più alte sono più efficienti. anche perché \"less crowded\". molti protocolli (anche IoT) usano le frequenze basse, quindi c'è un botto di collision risk.\n\nquesta roba è vera anche per i cavi oltre che per il wifi, ma usano tutte le frequenze fisicamente disponibili?","x":3800,"y":-1256,"width":759,"height":900},
		{"id":"54d0a7ecb87b5c26","type":"text","text":"# Internet of Things (IoT)\n\nCon la ***miniaturizzazione dei processori*** che permette di inserire intelligenza praticamente ovunque e ***IPv6*** che permette di assegnare un indirizzo univoco a $O(10^{38})$ dispositivi, è facile immaginare un mondo in cui qualsiasi oggetto può collegarsi ad Internet.\n\n***Internet of Things*** (***IoT***) è il successore di quello che oggi conosciamo come Internet: se ai nodi aggiungiamo ***sensori*** per monitorare l'ambiente e ***attuatori*** per modificarlo, di fatto estendiamo il concetto di ***servizio*** (e.g. mail, video) a un qualcosa che viene materialmente fatto (in modo automatico e ottimizzato) nel mondo materiale di tutti i giorni (e.g. domotica).\n\nEssendo tanti, l'intelligenza e l'autonomia media di un singolo nodo IoT è abbastanza bassa. Questo apre a tutta una serie di problemi sulla sicurezza della comunicazione hop-to-hop e sulla necessità di protocolli energy-efficient ad hoc (e.g. da ***BLE*** a ***6LoWPAN***).","x":2272,"y":-999,"width":759,"height":387,"color":"6"},
		{"id":"c7e2f44140b2cd8e","type":"text","text":"   ### **2.2. Network Layer (Comunicazione e Trasporto Dati)**\n   \n- **Particolarità:** A differenza di TCP/IP classico, qui il livello di rete può **conservare dati** (data storage).\n\n### **2.4. Application Layer (Analisi e Automazione)**\n\n- **Causa:** I dati aggregati devono essere interpretati e usati per prendere decisioni.\n- **Effetto:** Si utilizzano protocolli di comunicazione applicativa come MQTT (publish-subscribe) o CoAP (REST).\n\n**CAUSA:** Un singolo dispositivo è inutile senza un’infrastruttura di comunicazione.\n**EFFETTO:** Servono protocolli di rete e standard per la trasmissione dati.\n\n- **Connettività**: BLE consuma meno energia di WiFi, ma ha un range più corto.\n    \n\n## 5. Protocolli di comunicazione\n\nI dispositivi IoT devono scambiarsi dati in modo efficiente. I protocolli sono scelti in base a **consumo energetico, latenza, scalabilità e sicurezza**.\n\n### Principali protocolli\n\n- **MQTT**: Leggero, basato su publish/subscribe, perfetto per connessioni instabili.\n- **CoAP**: Simile a HTTP ma ottimizzato per dispositivi a basso consumo.    \n- **Zigbee e LoRa**: Utilizzati per reti mesh e lungo raggio.\n    \n\n### Causa-effetto nella scelta del protocollo\n\n- **MQTT vs. HTTP**: HTTP è pesante e non adatto a IoT, mentre MQTT è ottimizzato per reti intermittenti.    \n- **Zigbee vs. WiFi**: Zigbee è ottimo per dispositivi a basso consumo ma con throughput ridotto.\n\n\n1. **CAUSA:** L’IoT richiede comunicazioni leggere ed efficienti, spesso su reti con poca banda.\n2. **EFFETTO:** MQTT (Message Queuing Telemetry Transport) usa un modello publisher/subscriber per trasmettere dati in modo efficiente.\n\n- Un \"publisher\" (es. un sensore) invia dati a un \"broker\".\n- I \"subscriber\" (es. altri dispositivi o server) ricevono solo i dati di loro interesse\n- Questo riduce il traffico di rete e il consumo energetico.\n\n### **4. Comunicazione e consumo energetico**\n\nQuando un dispositivo trasmette dati (WiFi, Bluetooth, LoRa, ZigBee...), consuma energia. La trasmissione RF è spesso uno dei principali colli di bottiglia energetici.\n\n- **WiFi:** Alta potenza, ma alta velocità\n    \n- **BLE (Bluetooth Low Energy):** Ottimizzato per consumi ridotti, ma a corto raggio\n    \n- **LoRa:** Ideale per lunghe distanze e consumi bassissimi, ma bassa velocità\n    \n\nStrategie per ridurre il consumo:\n\n- Trasmettere meno spesso\n- Usare protocolli a basso consumo (MQTT, CoAP)\n- Ridurre la potenza del segnale se non serve lungo raggio\n\n","x":-7240,"y":-1485,"width":930,"height":1358},
		{"id":"e3f90e15d76f3ca5","type":"text","text":"# Comunicazione\n\nSe i contatti tra Gateway e Cloud avvengono generalmente via cavo, raggiungere le Things ci obbliga ad usare metodi ***wireless***. Servono due elementi:\n\n- Una ***stack protocollare*** ad hoc per l'IoT, dal momento che i dispositivi embedded\n\t- hanno poca capacità di calcolo e non possono supportare protocolli pesanti. Questo interessa solo le Things, ma di fatto si riflette su tutta la stack;\n\t- potrebbero perdere il segnale e avere lunghi momenti di silenzio. Servono quindi protocolli in grado di tollerare frequenti disconnessioni.\n- Tecnologie per realizzare ***antenne*** miniaturizzate e adatte alla specifica applicazione;\n- Uno standard per la ***modulazione dei segnali EM*** che definisca come vengono comunicati i ***simboli*** lungo il ***canale*** (cfr. ***Teoria dell'Informazione***).","x":-3778,"y":-1000,"width":759,"height":387,"color":"6"},
		{"id":"713d15910e78e93b","type":"text","text":"## ☁️ **XaaS: l’idea alla base del Cloud**\n\nImmagina di avere bisogno di **potenza di calcolo**, **spazio di archiviazione**, o semplicemente di **un'applicazione che funzioni**. Prima dell’avvento del cloud, significava comprare hardware, installare software, mantenerlo, aggiornarlo, fare backup...\n\nCon il cloud, invece, **tutto questo diventa un servizio a richiesta**. Come l’acqua o l’elettricità: apri il rubinetto (o l’API), e arriva.\n\nDa qui il concetto di **“as a Service”**: non possiedi le cose, **le affitti**. Ma attenzione: a **diversi livelli di astrazione**.\n\n---\n\n## 🧱 **I tre pilastri: IaaS, PaaS, SaaS**\n\nImmagina di voler aprire una pizzeria digitale 🍕. Hai diverse opzioni, a seconda di quanto vuoi fare tu e quanto vuoi delegare:\n\n---\n\n### 🏗️ 1. **IaaS – Infrastructure as a Service**\n\n> Hai il mattone, ma devi costruire la casa.\n\n- Ti affittano **server virtuali**, storage, rete.\n    \n- Tu ci installi sopra OS, database, librerie, codice…\n    \n- Sei responsabile della **gestione**: patch, backup, scaling.\n    \n\n👨‍🍳 **Esempio pizzeria**: ti danno un locale vuoto e il forno. Tu porti ingredienti, assumi personale, fai tutto.\n\n🖥️ **Esempi reali**:\n\n- Amazon EC2 (server virtuali)\n    \n- Google Compute Engine\n    \n- Microsoft Azure VM\n    \n\n📦 **Use case tipico**: hai già un'app custom e vuoi solo non occuparti dell’hardware fisico.\n\n---\n\n### 🛠️ 2. **PaaS – Platform as a Service**\n\n> Hai la cucina pronta, devi solo cucinare.\n\n- Ti danno un ambiente di sviluppo già configurato: OS, runtime, database, servizi.\n    \n- Tu **ci carichi il codice**.\n    \n- Scalabilità, patch, sicurezza... tutto gestito dal provider.\n    \n\n👨‍🍳 **Esempio pizzeria**: affitti una cucina con staff base. Tu porti le ricette.\n\n🖥️ **Esempi reali**:\n\n- Google App Engine\n    \n- Heroku\n    \n- Azure App Services\n    \n\n📦 **Use case tipico**: vuoi solo scrivere codice e testare, senza perdere tempo a configurare ambienti.\n\n---\n\n### 📱 3. **SaaS – Software as a Service**\n\n> Ti siedi e mangi.\n\n- L’app è già pronta.\n    \n- Tu ti limiti a **usarla** via web o app.\n    \n- Non gestisci nulla, nemmeno l’installazione.\n    \n\n👨‍🍳 **Esempio pizzeria**: ordini su JustEat. Ti arriva la pizza.\n\n🖥️ **Esempi reali**:\n\n- Gmail\n    \n- Google Docs\n    \n- Dropbox\n    \n- Salesforce\n    \n\n📦 **Use case tipico**: vuoi solo accedere a una funzionalità senza curarti del \"come\".\n\n---\n\n## 🎯 Schema riassuntivo\n\n|Livello|Chi controlla cosa|Pro|Contro|\n|---|---|---|---|\n|**IaaS**|Tu gestisci quasi tutto|Massima flessibilità|Complessità gestionale|\n|**PaaS**|Tu gestisci il codice|Rapido sviluppo|Meno controllo|\n|**SaaS**|Usi e basta|Zero gestione|Nessuna personalizzazione|\n\n---\n\n## 🔁 E se andiamo oltre?\n\nCi sono anche altre sigle:\n\n- **FaaS** – Function as a Service (serverless: carichi una funzione e parte quando serve)\n    \n- **BaaS** – Backend as a Service (es: Firebase, ti dà DB + auth + API)\n    \n- **DBaaS** – Database as a Service\n    \n- **MLaaS** – Machine Learning as a Service (es: modelli già pronti da usare)\n    \n\nE infine: **Everything as a Service (XaaS)** – è il futuro, dove ogni componente IT (e non solo) diventa affittabile via API.\n\n---\n\n## 🧩 Relazione con Fog/Edge\n\nQuesta gerarchia vale **anche nel fog computing**, con una differenza chiave: **la latenza e la localizzazione**.\n\n- Un **fog node** può offrire **IaaS** (es: una piccola VM nel router di casa), o **PaaS** (un ambiente già pronto per analisi video), o addirittura **SaaS** (una app embedded nel semaforo che decide il verde).\n    \n- Ma tutto avviene **vicino all’origine del dato**.\n    \n\nIl paradigma rimane lo stesso: **a cosa vuoi delegare? e quanto controllo ti serve?**\n\n---\n\nSe vuoi, posso integrarti anche un diagramma a blocchi tipo matrioska (SaaS dentro PaaS dentro IaaS) oppure delle analogie più \"da mondo reale\" (es: trasporto: comprare un'auto, noleggiarla, prendere un taxi). Fammi sapere!","x":-5520,"y":-4760,"width":759,"height":2914},
		{"id":"24e729d51fa94980","type":"text","text":"\nil NL è un po' diverso da quello di TCP/IP, può fare addirittura data storage. BLE e WiFi sono considerati protocolli di questo layer\n\n\n### **4.2. Standardizzazione e Interoperabilità**\n\n- **Causa:** Ogni produttore usa formati di dati e protocolli diversi.\n    \n- **Effetto:** Si cerca di definire standard unificati (es. Open Connectivity Foundation, MQTT, CoAP).\n    \n\n### **4.3. Adattabilità ai Cambiamenti Ambientali**\n\n- **Causa:** I nodi fog possono spegnersi, cambiare posizione o avere variazioni di capacità.\n    \n- **Effetto:** I sistemi devono essere **dinamici** e adattarsi ai cambiamenti in tempo reale.\n    ","x":-2681,"y":-4040,"width":643,"height":540},
		{"id":"2d43e95958d0e621","type":"text","text":"# Stack Protocollare IoT\n\nL'Internet serve alle Things per comunicare comandi e dati raccolti. Come?\n\nEssendo dispositivi semplici, i classici protocolli di TCP/IP sono troppo dispendiosi in termini di energia e di overhead (e.g. `HTTP` ha un header di lunghissimo. `MQTT`, i.e. un protocollo che lo sostituisce in IoT, usa solo `2 byte`).\n\nIn pratica possiamo sfruttare le idee di TCP/IP per \"poggiarci sopra\" una stack protocollare più leggera, aiutati dal fatto che `IPv6` \"unifica\" `IPv4` e `MAC`.\n\n- ***Sensor/Perception Layer*** (***Edge***) - Il layer delle Things vere e proprie. Qui di norma vengono impacchettati un botto di dati da inviare al gateway;\n\t- Per via della limitata potenza delle Things, è difficile fare preprocessing a livello di Edge Computing. Al più, i sensori provano a mandare i dati solo quando servono (i.e. provano a fare ***Batching***, cfr. ***Efficienza Energetica***).\n- ***Gateway/Network Layer*** (***Fog***) - Qua si fondono il DLL e il Network Layer di TCP/IP, perché ***IPv6*** unifica i ruoli di `MAC` e `IPv4`. La logica resta quella di un ***gateway*** che media l'accesso ad Internet per conto delle Things, ma solo perché queste non sono abbastanza potenti da gestire una connessione completa;\n\t- Qui si alleggerisce il carico del Cloud tramite ***Fog Computing*** (i.e. preprocessing in vista dell'arrivo al Cloud). Questa architettura mira a garantire la scalabilità del sistema. Tipicamente un gateway è anche un ***fog node***;\n\t- I protocolli includono roba come ***Wi-Fi*** e ***BLE***, su `IPv6`. Cito questi perché essendo standard garantiscono compatibilità, ma in generale posso costruirne a piacimento: la scelta del protocollo di Network è dettata dalla specifica applicazione, perché è sempre un ***trade-off tra potenza e portata*** (stando ovviamente attenti alla complessità di comunicazione).\n- ***Application Layer*** (***Cloud***) - Qua si fondono invece il layer omonimo di TCP/IP e quello di Trasporto: `TCP` e `UDP` vengono dati \"per scontati\" insieme al protocollo Applicazione di alto livello. L'idea cardine di questo layer in versione IoT è che un protocollo come `HTTP` è troppo pesante e non tollera disconnessioni frequenti (cosa che invece qui accade). Abbiamo quindi un paio di sue varianti:\n\t- ***MQTT*** (**Message Queuing Telemetry Transport**)\n\t- ***CoAP*** (**Constrained Application Protocol**)","x":-3778,"y":-2525,"width":759,"height":890,"color":"4"},
		{"id":"1f0970b33a4cb76f","type":"file","file":"NetworkProtocols.png","x":-3778,"y":-3071,"width":758,"height":408},
		{"id":"2ce83f8e9814f3bc","type":"file","file":"IoT_Architecture.png","x":-751,"y":-1580,"width":759,"height":465},
		{"id":"5a3d80b291a0be6b","type":"text","text":"# [Antenne](https://www.youtube.com/watch?v=ZaXm6wau-jc&ab_channel=SabinCivilEngineering) e Circuiti a Radio-Frequenze (RF)\n\nSappiamo che le frequenze più adatte a comunicare cadono nello spettro delle ***onde radio***.\nLe intermedie incontrano troppi ostacoli, quelle alte sono dannose per la vita in generale.\n\nPosto quindi che devo produrre delle onde radio tramite un circuito, come lo realizzo? Far oscillare un campo EM non è sufficiente a trasmettere un segnale. Dobbiamo usare un ***dipolo oscillante*** di lunghezza $L=\\l/2$, dove $\\l$ è la lunghezza d'onda che vogliamo trasmettere o ricevere, come descritto nel link presente nel titolo. Un segnale a $2\\text{ GHz}$ richiede un'antenna $L\\sim15\\text{ cm}$, mentre per $100\\text{ kHz}$ arriviamo a $3\\text{ km}$. \n\nUn ***circuito RF*** consta in genere di tre parti:\n\n- ***Modulator*** - Dato un input binario (i.e. onda quadra), lo traduce in segnale analogico tramite un ***DAC***. Per capire com'è fatto questo segnale, cfr. ***Modulare i Segnali***;\n\t- Se l'antenna è usata in ricezione, il segnale passa invece per un ***ADC***.\n- ***Upconverter*** - Visto che le antenne devono essere piccole, questo modulo ***aumenta la frequenza*** del segnale generato dal Modulator;\n\t- Potrei fare questo passaggio nel DAC? Sì, ma costerebbe e consumerebbe tanto.\n- ***Amplifier*** - ***Aumenta l'ampiezza*** del segnale per mitigare gli effetti dell'***attenuazione*** e del ***rumore*** (che di norma sono costanti), sia in trasmissione che in ricezione.\n\nTutto questo ci porta a produrre diversi tipi di ***antenne***:\n\n- ***Omnidirectional*** - Tipo quelle dei router domestici, trasmettono in modo più o meno omogeneo rispetto all'angolo $\\th$ (meno rispetto a $\\f$, i.e. poco nella direzione della punta);\n- ***Directional*** - Ottimizza il segnale in una specifica direzione, in due modi principali:\n\t- ***Yagi*** - Ha una barra-dipolo (**driven element**) e diversi elementi di supporto, distinti in **directors** (si trovano davanti e focalizzano il segnale verso il dipolo) e **reflectors** (si trovano dietro e, appunto, riflettono il segnale verso il dipolo);\n\t- ***Parabola*** - Focalizza il segnale nel fuoco (wow), dove si trovano generalmente due dipoli ortogonali (usando ***polarizzazioni ortogonali*** raddoppio la bandwidth).\n- ***Embedded*** - Stampate direttamente sul chip, quindi dette ***Printed Circuit Board*** (***PCB***), possono essere sia uni- che omnidirectional. Posso anche montargli sopra un'antenna con un chip dedicato, in questo caso sarà tendenzialmente omnidirectional.","x":-3778,"y":120,"width":759,"height":911,"color":"4"},
		{"id":"1c886c1918d2f851","type":"text","text":"# Metriche per Antenne\n\nUn'***antenna isotropa*** è un oggetto ideale che emette in modo uniforme su tutto l'angolo solido. Di norma, un'antenna ha delle direzioni privilegiate. Il ***gain*** di un'antenna in ***trasmissione*** lungo una specifica direzione (i.e. porzione di angolo solido) è dato da$$G=\\eta\\times D={P_{\\text{radiated}}\\over P_{\\text{input}}}\\times{U\\over U_{\\text{isometric}}}$$dove $\\eta$ è l'efficienza energetica dell'antenna (i.e. che percentuale della potenza in input viene convertita in potenza EM irradiata), e $D$ è il rapporto tra l'intensità $U$ emessa dalla mia antenna e l'intensità $U_{\\text{isometric}}$ emessa dall'antenna isotropa, data una direzione. Quest'ultima cosa significa a rigore \"fissata la distanza $R$ alla quale misuro, il $\\D A$ sulla sfera di raggio $R$ intercettato da un angolo solido $\\D\\O$). Vabbè, era per dire.\n\nIl gain si misura in ***Decibel*** (***dB***), che è un'unità di misura un po' particolare. Si usa solo per misurare ***rapporti***, quindi ha senso parlare di Decibel solo in relazione ad una grandezza di riferimento $G_0$. Dopodiché, ci interessa l'***ordine di grandezza*** del rapporto, quindi mettiamo un $\\log_{10}$. Infine, visto che così vengono risultati troppo piccoli, moltiplichiamo per $10$. Il risultato di questo delirio è ad esempio$$P(\\text{dBmW})=10\\log_{10}\\bigg({P\\over1\\text{mW}}\\bigg)$$i.e. il gain di un segnale rispetto alla potenza di riferimento di $1\\text{mW}$. Una potenza di $20\\text{dBmW}$ significa $100\\text{mW}$, $-10\\text{dBmW}$ è un segnale di $0.1\\text{mW}$ e ovviamente $0\\text{ dBmW}=1\\text{mW}$. Per le antenne, il riferimento è l'antenna isotropa erogante la stessa potenza: usiamo i $\\text{dBi}$.\n\nIn ***ricezione*** possiamo definire il gain come efficienza nel convertire input in segnale. Se pensiamo alle antenne paraboliche, più area significa più segnali convogliati nel fuoco. A parità di area, però, posso comunque avere un'antenna più efficiente di un'altra. Definiamo l'***effective aperture*** come $A_e$, intendendo un'area virtuale equivalente da cui poi definisco$$G={4\\pi A_e\\over\\l^2}$$\nInfine, il range di frequenze supportato dall'antenna è detto ***bandwidth***. Antenne con ampia bandwidth reggono le reti cellulari, mentre le ***narrowband*** (range stretto) sono più in uso in dispositivi IoT (e.g. per BLE).","x":-4780,"y":120,"width":759,"height":911,"color":"4"},
		{"id":"bfc2cb8cd0a7da23","type":"text","text":"# Modulare i Segnali","x":-4780,"y":-1216,"width":759,"height":820},
		{"id":"469a1094f676e542","type":"text","text":"# Sicurezza\n\nI dispositivi IoT, in quanto dispositivi connessi alla rete, sono vulnerabili a cyber-attacchi e manipolazioni fisiche. Questo rende necessario implementate misure di sicurezza HW e SW.\n\nChiaro, ma cosa c'è di nuovo? Il fatto è che questi dispositivi sono poco potenti, quindi devo limitarmi a protocolli leggeri ed efficienti.\n\n#### TPM (Trusted Platform Module) (HW)\n1. **CAUSA:** Un attaccante può tentare di modificare il software di un dispositivo per prenderne il controllo.\n2. **EFFETTO:** TPM immagazzina chiavi crittografiche in hardware per proteggere l’integrità del dispositivo.\n\n- TPM genera e protegge chiavi di crittografia.\n- Può autenticare l’hardware impedendo modifiche non autorizzate.\n   \n##### Secure Boot (HW/SW)\n1. **CAUSA:** Un firmware modificato può compromettere l’intero sistema.\n2. **EFFETTO:** Secure Boot verifica la firma digitale del firmware prima di avviarlo.\n   \n**Motivi per aggiornare il firmware:**\n\n- Correggere vulnerabilità di sicurezza.\n- Aggiungere nuove funzionalità senza sostituire l’hardware.\n\n#### Autenticazione e controllo accessi\n1. **CAUSA:** Senza autenticazione, chiunque potrebbe accedere ai dispositivi IoT.\n2. **EFFETTO:** Si usano metodi come password, certificati digitali e autenticazione a due fattori.\n   \n- Un termostato smart richiede autenticazione prima di essere controllato da remoto.\n- Un sistema di videosorveglianza cifra i dati per impedire accessi non autorizzati.\n\n\n\n## 6. Sicurezza nei dispositivi IoT\n\nLa sicurezza è un problema critico: un dispositivo IoT vulnerabile può compromettere un’intera rete.\n\n### Strategie di sicurezza\n\n- **Secure Boot**: Impedisce che firmware malevoli vengano eseguiti → fondamentale perché molti dispositivi IoT devono aggiornarsi da remoto (OTA updates).\n    \n- **Trusted Platform Module (TPM)**: Hardware dedicato alla crittografia e protezione delle chiavi → essenziale per autenticazione sicura.\n    \n- **Autenticazione e controllo accessi**: Limitare chi può accedere ai dispositivi per prevenire attacchi.\n    \n\n### Causa-effetto nella sicurezza\n\n- **Un firmware non autenticato può compromettere l’intera rete** → Secure Boot impedisce esecuzione di codice non verificato.\n    \n- **Un dispositivo compromesso può diffondere malware** → TPM protegge chiavi crittografiche.\n    \n- **L’uso di password deboli facilita attacchi** → Autenticazione forte e aggiornamenti regolari.\n    ","x":-4379,"y":2720,"width":1360,"height":1287},
		{"id":"efa33c7c0a47d3b4","type":"text","text":"# SPACING","x":-5280,"y":-322,"width":250,"height":235,"color":"5"},
		{"id":"1c92973033afe842","x":-4780,"y":1280,"width":759,"height":773,"type":"text","text":"# Perdite\n\ni.e. perché si riduce il gain\n\npath loss"},
		{"id":"a6a561ce43fe8afd","type":"file","file":"Antenne.png","x":-4780,"y":-204,"width":759,"height":225}
	],
	"edges":[
		{"id":"6883460e8c227a3c","fromNode":"1e3fd2b7a4b6a7cc","fromSide":"top","toNode":"d700a52cca1cdc2a","toSide":"bottom","label":"Distributed Data Analysis"},
		{"id":"fcc82691ef115619","fromNode":"54d0a7ecb87b5c26","fromSide":"left","toNode":"1e3fd2b7a4b6a7cc","toSide":"right"},
		{"id":"b6bb6d947657dd64","fromNode":"1e3fd2b7a4b6a7cc","fromSide":"left","toNode":"e3f90e15d76f3ca5","toSide":"right","label":"Communication"},
		{"id":"1d3252b9a19eabde","fromNode":"1e3fd2b7a4b6a7cc","fromSide":"bottom","toNode":"ff3b9035a56b4e9e","toSide":"top","label":"Embedded Devices"},
		{"id":"d2311340c023a06e","fromNode":"617bc5508509a069","fromSide":"top","toNode":"cc865f4cd6000ab4","toSide":"bottom"},
		{"id":"1fe790485df6f8ed","fromNode":"ff3b9035a56b4e9e","fromSide":"bottom","toNode":"a94d060ea349fc00","toSide":"top"},
		{"id":"32f7122c19c5f94f","fromNode":"03e26affba62b324","fromSide":"bottom","toNode":"4c794fe5a6070164","toSide":"top"},
		{"id":"ebbbf8f78d15509c","fromNode":"03e26affba62b324","fromSide":"bottom","toNode":"c39cda918518baad","toSide":"top"},
		{"id":"8ed146d7664a9824","fromNode":"c39cda918518baad","fromSide":"top","toNode":"03e26affba62b324","toSide":"bottom"},
		{"id":"1288a997ee3a73a0","fromNode":"a94d060ea349fc00","fromSide":"bottom","toNode":"43767a936de8e8b1","toSide":"top"},
		{"id":"5d6efd6cc943b5ac","fromNode":"2d43e95958d0e621","fromSide":"top","toNode":"1f0970b33a4cb76f","toSide":"bottom"},
		{"id":"4470f02e3cd1c2e6","fromNode":"d700a52cca1cdc2a","fromSide":"top","toNode":"ea6c2db0218bf20e","toSide":"bottom"},
		{"id":"19b438e2e9d61208","fromNode":"43767a936de8e8b1","fromSide":"bottom","toNode":"9b1a993fbf97aa5e","toSide":"top"},
		{"id":"272f669fbc7ee525","fromNode":"1e3fd2b7a4b6a7cc","fromSide":"top","toNode":"2ce83f8e9814f3bc","toSide":"left"},
		{"id":"dcc5106e2f1b86cb","fromNode":"d700a52cca1cdc2a","fromSide":"right","toNode":"c8f665ef67bbc260","toSide":"left"},
		{"id":"45a05cd6c68dac81","fromNode":"ea6c2db0218bf20e","fromSide":"right","toNode":"1d4c9d197fab6065","toSide":"left"},
		{"id":"e03e1fee77478baf","fromNode":"54d0a7ecb87b5c26","fromSide":"top","toNode":"d51f893becdde7b8","toSide":"bottom"},
		{"id":"7b87ead8ae666d28","fromNode":"d51f893becdde7b8","fromSide":"left","toNode":"796fa6183e62d341","toSide":"right"},
		{"id":"d1f37c577b563bec","fromNode":"d51f893becdde7b8","fromSide":"top","toNode":"bc00b250b7b24ec0","toSide":"bottom","label":"Sorpresa"},
		{"id":"4dfd9f9014332940","fromNode":"bc00b250b7b24ec0","fromSide":"left","toNode":"953ba1b6df1d2cf5","toSide":"right"},
		{"id":"3dc0f2ed3e704ef9","fromNode":"5a1008ab6d4f93fb","fromSide":"bottom","toNode":"953ba1b6df1d2cf5","toSide":"top"},
		{"id":"651f2457eb20db33","fromNode":"d51f893becdde7b8","fromSide":"top","toNode":"953ba1b6df1d2cf5","toSide":"bottom","label":"Compressione"},
		{"id":"47991328da85437e","fromNode":"d51f893becdde7b8","fromSide":"top","toNode":"886eeef68d17e333","toSide":"bottom","label":"Comunicazione"},
		{"id":"28eb958601576b35","fromNode":"d51f893becdde7b8","fromSide":"right","toNode":"2df7743f9594ebe8","toSide":"left"},
		{"id":"1ab5a72fdd598058","fromNode":"bc00b250b7b24ec0","fromSide":"right","toNode":"886eeef68d17e333","toSide":"left"},
		{"id":"2552b2c3b89df497","fromNode":"886eeef68d17e333","fromSide":"top","toNode":"eadc00ddd47569d3","toSide":"bottom"},
		{"id":"ec92e44eac2419cf","fromNode":"2df7743f9594ebe8","fromSide":"right","toNode":"344ee0d6725a4b78","toSide":"left"},
		{"id":"c400ebb453f7eafd","fromNode":"eadc00ddd47569d3","fromSide":"left","toNode":"20f0389aed3f57c6","toSide":"right"},
		{"id":"6fe75ddac75b8201","fromNode":"eadc00ddd47569d3","fromSide":"right","toNode":"19dbf5244a8bbdc1","toSide":"left"},
		{"id":"2a6fffe38a308845","fromNode":"183cc241a018e501","fromSide":"bottom","toNode":"20f0389aed3f57c6","toSide":"top"},
		{"id":"804fa366dfada83f","fromNode":"eadc00ddd47569d3","fromSide":"top","toNode":"183cc241a018e501","toSide":"bottom"},
		{"id":"8b54eb2d2acd9697","fromNode":"eadc00ddd47569d3","fromSide":"right","toNode":"51edfc0fd55ad3f4","toSide":"left"},
		{"id":"7abb5a2c1542f216","fromNode":"886eeef68d17e333","fromSide":"right","toNode":"51edfc0fd55ad3f4","toSide":"left"},
		{"id":"3547eb57612173eb","fromNode":"20f0389aed3f57c6","fromSide":"top","toNode":"03bb0206eb695483","toSide":"bottom","fromEnd":"arrow"},
		{"id":"f72add853a3aaec8","fromNode":"03bb0206eb695483","fromSide":"right","toNode":"183cc241a018e501","toSide":"left","fromEnd":"arrow"},
		{"id":"06c2bb10d9195ec4","fromNode":"51edfc0fd55ad3f4","fromSide":"right","toNode":"887e35db37687bdc","toSide":"left"},
		{"id":"8f0fe63c00069c47","fromNode":"a94d060ea349fc00","fromSide":"left","toNode":"d11ebd7b1efd8ff7","toSide":"right"},
		{"id":"b57a4afc37693e7a","fromNode":"a94d060ea349fc00","fromSide":"right","toNode":"c39cda918518baad","toSide":"left"},
		{"id":"a4ca303b3a8531b2","fromNode":"ff3b9035a56b4e9e","fromSide":"right","toNode":"617bc5508509a069","toSide":"left"},
		{"id":"dbe6aedd063a9a05","fromNode":"617bc5508509a069","fromSide":"right","toNode":"03e26affba62b324","toSide":"left"},
		{"id":"9c24529285e9b5d0","fromNode":"e3f90e15d76f3ca5","fromSide":"top","toNode":"2d43e95958d0e621","toSide":"bottom"},
		{"id":"be61e2d14f7c9beb","fromNode":"1e3fd2b7a4b6a7cc","fromSide":"left","toNode":"2d43e95958d0e621","toSide":"bottom"},
		{"id":"47aee227e49baef8","fromNode":"e3f90e15d76f3ca5","fromSide":"left","toNode":"bfc2cb8cd0a7da23","toSide":"right"},
		{"id":"3c0e8c8f8a9f5098","fromNode":"e3f90e15d76f3ca5","fromSide":"bottom","toNode":"5a3d80b291a0be6b","toSide":"top"},
		{"id":"9a7721be93fa5198","fromNode":"ff3b9035a56b4e9e","fromSide":"left","toNode":"5a3d80b291a0be6b","toSide":"right","label":"Comunicazione"},
		{"id":"b7d53260632d4353","fromNode":"5a3d80b291a0be6b","fromSide":"left","toNode":"1c886c1918d2f851","toSide":"right"},
		{"id":"6c16e589f7cac8bd","fromNode":"5a3d80b291a0be6b","fromSide":"bottom","toNode":"1c92973033afe842","toSide":"top"},
		{"id":"8cc437d9ac917247","fromNode":"1c886c1918d2f851","fromSide":"bottom","toNode":"1c92973033afe842","toSide":"top"}
	]
}