{
	"nodes":[
		{"id":"b34074a3a43e8d58","type":"text","text":"# Tree Based Protocols\n\nSia ***Binary Splitting*** (***BS***) che ***Query Tree*** (***QT***) tendono ad avere una struttura simile.\n\nPer BS è un po' più facile ricavare il valore asintotico (i.e. per $N\\to\\infty$) della $\\text{SE}$, che si attesta sul $38\\%$. Valori simili si trovano in genere per QT, ma dipende dalla lunghezza degli `ID` (nonché dalla loro omogeneità tra Tag diversi).\n\nTipicamente, questi valori teorici risultano essere delle ***sottostime*** dell'efficienza, in quanto non tengono conto di problemi pratici che tipicamente occorrono (e.g. interferenze).","x":1218,"y":-3058,"width":759,"height":276,"color":"6"},
		{"id":"e9efc94fac1f44e4","type":"text","text":"# Query Tree Protocol\n\nL'idea è implementare una roba gerarchica basata sull'`ID`.\n\n- Inizio chiedendo di rispondere a `tutti gli ID che iniziano per 0`;\n- Probabilmente mi risponderanno in tanti (statisticamente il $50\\%$), allora la richiesta successiva sarà indirizzata a `tutti gli ID che iniziano per 00`;\n- Ad un certo punto troverò un unico Tag con quel dato prefisso (e.g. `000`);\n- Lo step successivo è provare `001`;\n- Una volta esaurito il sotto-albero `00`, riprendo da `01`.\n\nSegue che la complessità computazionale è $O(N\\cdot L)$. dove $L$ è la lunghezza dell'`ID`.\n\nQuesto algoritmo è generalmente il preferito per un numero medio di Tag aventi `ID` di media lunghezza.","x":150,"y":-3135,"width":759,"height":430,"color":"4"},
		{"id":"67138e840671f086","type":"text","text":"# HowTo Performance Evaluation\n\nLa valutazione di un protocollo di lettura degli `ID` avviene tramite la ***System Efficiency***$$\\text{SE}={n\\over q}$$dove\n\n- $n$ è il numero di Tag identificati (i.e. $n\\le N$ numero totale di Tag);\n- $q$ è il numero totale di query inviate dal reader.\n\nOvviamente, come ogni misura di efficienza, all'atto pratico abbiamo $\\text{SE}<1$, tipicamente tra $0.3$ e $0.5$. Spesso inoltre (e di nuovo, ovviamente) il suo valore misurato (i.e. l'unico che conta veramente) è minore del suo valore teorico.\n\nQuesto assumendo che ogni richiesta del reader richieda sempre lo stesso tempo. Se così non è (e.g. **EPC GEN 2**) può essere utile definire la $\\text{Time\\_SE}$ come$$\\text{Time\\_SE}={R_{\\text{id}}\\over\\b R_{\\text{idle}}+R_{\\text{id}}+R_{\\text{c}}}$$dove\n- $R_{\\text{id}}$ è il numero di slot utilizzati per identificare un singolo Tag;\n- $R_{\\text{idle}}$ è il numero di slot in cui nessuno ha risposto:\n\t- Nei protocolli dinamici, gli slot $\\text{idle}$ durano una frazione $\\b<1$ rispetto agli slot di identificazione e di collisione (è a questo che servono i protocolli dinamici!).\n- $R_{\\text{C}}$ è il numero di slot in cui due i più Tag hanno risposto (collisione).\n\nÈ evidente che senza $\\b$ avremmo $R_{\\text{id}}+R_{\\text{idle}}+R_{\\text{C}}=N$. Questa nuova normalizzazione $<N$ ci sta dicendo che nei protocolli che usano tali accorgimenti $\\text{Time\\_SE}>\\text{SE}$.","x":2331,"y":-4020,"width":759,"height":738,"color":"4"},
		{"id":"07860fbdac8f9f5e","type":"text","text":"# Binary Splitting\n\nL'idea è dividere ricorsivamente i Tag in due gruppi finché non ne resta uno solo.\n\nTutti implementano un counter, e rispondono solo se questo è pari a `0`.\n\n- Tutti i Tag iniziano con counter `0`, quindi alla prima richiesta ho $N$ collisioni;\n- Ogni Tag che ha risposto genera un bit casuale che somma al counter. Chi ha ottenuto `1` si autoesclude dalle successive risposte, fino a nuovo ordine;\n\t- In media abbiamo uno split $50$ e $50$;\n- Alla seconda richiesta ho mediamente $N/2$ collisioni, e si ripete il gioco;\n- Ad un certo punto ne risponderà solo uno. Il reader sarà quindi in grado di rispondere con un `ACK` rivolto esplicitamente a lui, il quale si autoescluderà dal processo di identificazione in modo permanente;\n- Alla prossima richiesta, nessuno risponderà. Il reader allora manda una sorta di `OK, ricominciamo` con cui dice a tutti di rimettere il contatore a `0`.\n\t- Questa roba è un po' inefficiente se $N$ di partenza è molto grande, dato che ricomincia ogni volta da $N-1$;\n\t- Questi ultimi due step si possono fare insieme, ma in generale ciò aumenta la complessità dell'HW del Tag (quindi in pratica non si fa).\n\nSegue che la complessità computazionale è $O(N\\log N)$.","x":1218,"y":-3941,"width":759,"height":574,"color":"4"},
		{"id":"b00aab8306e43b32","type":"text","text":"# Aggiunte RFID\n\n\nin TSA i tag devono ricordare la collisione precedente (so she said, siamo sicuri?). la performance è 43% circa.","x":4760,"y":-4320,"width":620,"height":180},
		{"id":"4b21c821ca9a99a5","type":"text","text":"# Radio Frequency Identification (RFID)\n\nÈ un sistema che consta di tre componenti:\n\n- ***Tag*** - Circuiti molto semplici, al punto che spesso sono integrati in uno sticker. Identificati da un codice univoco tipicamente a `96 bit`, possono essere alimentati (attivi) e non (passivi). Il loro ruolo è rispondere ad uno stimolo EM esterno;\n- ***Reader*** - Dispositivi che emettendo un segnale EM forniscono ai Tag la potenza necessaria a rispondere (i.e. i Tag trasmettono per ***back-scattering***);\n- ***Server*** - Riceve e processa i dati ricevuti dal Reader.\n\nI Tag passivi sono spesso utilizzati per l'identificazione (e.g. come alternativa al codice a barre), in quanto sono low cost, battery free e non necessitano line of sight.\n","x":2331,"y":-2522,"width":759,"height":355,"color":"6"},
		{"id":"39bd0d24bf3d18c1","type":"file","file":"Reti di Elaboratori/RFID.png","x":1362,"y":-2522,"width":472,"height":355},
		{"id":"2d2a1ead3f62559a","type":"file","file":"TSA_Efficiency.png","x":4622,"y":-2555,"width":598,"height":423},
		{"id":"affb87dd75497bd6","type":"text","text":"# Partizionamento del Canale\n\nUn protocollo del genere divide il canale in slot più piccoli, dando l'esclusiva ad un solo host per ogni slot.\n\n- **Time Division Multiple Access** (***TDMA***) è un Time Division Multiplexing;\n- **Frequency Division Multiple Access** (***FDMA***) è un Frequency Division Multiplexing;\n\nSi possono usare in combinazione con i protocolli ad accesso casuale ad esempio riservare alcuni slot ad un certo NIC con TDMA lasciando uno Slotted Aloha sugli altri (e.g. DOCSIS, che non credo funzioni esattamente così ma idgaf).","x":13785,"y":-5122,"width":581,"height":412,"color":"4"},
		{"id":"5e772fe2702b3d44","type":"text","text":"# Bluetooth\n\nBluetooth (***IEEE 802.15***) è una rete a corto raggio ($10\\,\\text{m}$) che trasmette a velocità moderate ($1\\text{Mbps}$). Definisce due tipi di reti:\n\n- ***Piconet***, in cui vi possono essere 8 dispositivi al massimo, di cui uno primario (e.g. smartphone) e 7 secondari (e.g. cuffie, tastiera);\n- ***Scatternet***, in cui un dispositivo secondario di una Piconet diventa il primario di un'altra.\n\nUsa anch'esso la banda $2.4\\,\\text{GHz}$ (come Wi-Fi), ma la divide in 79 canali da $1\\,\\text{MHz}$ ciascuno. Questo significa che il protocollo deve evitare interferenze con 802.11b. E cosa fa il bimbo speciale? Si inventa un complesso sistema di specchi e leve che usa ***TDMA***.\n\nAnzitutto slottizza il tempo ($625 \\mu s$), alternando i ruoli di mittente e destinatario tra dispositivo primario e secondario (**half-duplex**). Ma ad ogni slot cambia anche frequenza, tra le 79 disponibili. Poco male se qualcuna di queste non funziona perché forse c'è anche il Wi-Fi, ne abbiamo altre! Inoltre, se ci sono più device connessi spetta al primario dire a chi tocca nel prossimo slot.\n\nCome se non bastasse, definisce una propria stack protocollare della quale non mi azzardo a parlare.","x":13785,"y":-4638,"width":581,"height":637,"color":"4"},
		{"id":"733d37bec4794264","type":"file","file":"Reti di Elaboratori/Bluetooth.png","x":13876,"y":-3960,"width":400,"height":164},
		{"id":"63119a3b9909af65","type":"text","text":"# Protocolli \"Semplici\"\n\nQuando l'HW si fa semplice, i protocolli efficienti smettono di giocare.\n\nSe ho un HW semplice non posso implementare algoritmi complessi.","x":14204,"y":-5321,"width":624,"height":150,"color":"6"},
		{"id":"80a40c0953bfe923","type":"text","text":"# Persistenza\n\nI protocolli di accesso multiplo si possono dividere in tre categorie, a seconda del tipo di comportamento.\n\n- ***Non-Persistente*** - **CSMA** senza CD:\n\t- Se trova il canale libero trasmette subito;\n\t- Se trova il canale occupato desiste (riprova ad ascoltare dopo un tempo casuale);\n- ***p-Persistente*** - Se trova il canale occupato resta in ascolto (*persiste*) in attesa che si liberi. Quando il canale è libero trasmette con probabilità $p$ (e.g. **Slotted Aloha**);\n\t- ***1-Persistente*** - Un sottocaso di *p-persistenza* in cui $p = 1$, cioè se trova il canale libero trasmette subito (e.g. **Ethernet CSMA/CD**).\n\n\n","x":16198,"y":-5820,"width":535,"height":419,"color":"4"},
		{"id":"cf066ff07b9dcf69","type":"file","file":"Reti di Elaboratori/CSMA_CD.png","x":16312,"y":-6164,"width":306,"height":263},
		{"id":"faa6429103579d88","type":"text","text":"# Ethernet CSMA/CD\n\nProtocollo per regolamentare il \"vecchio\" Ethernet a cavo condiviso (adesso è punto-punto, si collega direttamente ad una porta fisica dello switch o del router.\n\nSi articola in diversi passaggi, in cui la scheda di rete (NIC)\n\n1. riceve il datagramma dal livello di rete e crea il frame;\n2. ascolta (*sense*) il canale:\n\t- se è inattivo avvia la trasmissione;\n\t- se è occupato attende che si liberi, quindi trasmette (1-persistente);\n3. trasmette il frame, restando in ascolto per eventuali collisioni;\n\t- Se non avvengono collisioni, tutto ok;\n\t- Altrimenti, interrompe la trasmissione e invia un segnale di `jam` ($48\\,bit$, avvisa tutti gli altri NIC);\n\t\t- Dopo questa comunicazione, il NIC entra in fase di ***backoff binario***:\n\t\t\t- dopo l'$n$-esima collisione, il NIC estrae a caso un valore $k$ nell'intervallo $[0, 2^n-1]$, attende $k$ slot ($\\Rightarrow$ tempo per tramettere un frame di $512\\,bit$) e torna al punto 2;\n\t\t\t- più collisioni allungano l'intervallo di backoff;\n\t\t\t- I tempi si aggiornano in modo un po' caotico, non è ovvio prevederne il comportamento a livello teorico.\n\nEmpiricamente, l'efficienza di questo algoritmo in condizioni ragionevoli è $\\simeq 50\\%$. Facendo probabilmente dei calcoli che non mi va di fare si può arrivare all'espressione$$\\eta = \\frac{1}{1 + 5\\frac{t_{P}}{t_{T}}}$$","x":16785,"y":-6641,"width":700,"height":740,"color":"4"},
		{"id":"ed1a9855d26a488d","type":"text","text":"# Ethernet\n\nSe in origine la tecnologia Ethernet usava un cavo condiviso o un ***hub*** (che prendeva più cavi e li rendeva di fatto un cavo condiviso), oggi è sostanzialmente sempre punto-punto (**full-duplex**) con l'ausilio degli ***switch***.\n\nUn frame Ethernet si suddivide nel seguente modo:\n\n- ***Preambolo*** - Serve a sincronizzare la frequenza di invio dei dati con quella di lettura. A sua volta diviso in due parti:\n\t- i primi 7 byte (`10101010`) servono a dare il tempo a chi ascolta di adattarsi alla frequenza;\n\t- l'ultimo, detto **Start Frame Delimiter** (**SFD**, `10101011`) segna l'inizio del messaggio;\n- **Indirizzi di destinazione e sorgente**;\n- ***Type*** - Identificativo del protocollo di rete da usare per demultiplexare (tipicamente è IP);\n- ***Dati*** - C'è una ***lunghezza minima*** (**46 byte**) che insieme alla lunghezza massima del cavo garantisce che CSMA/CD sia in grado di identificare le collisioni. Se non li raggiungo faccio ***padding***;\n- ***CRC*** - Controllo degli errori.\n\nEsistono diverse implementazioni di Ethernet per adattarsi al tipo di canale (i.e. full-duplex o half-duplex) e al tipo di mezzo (e.g. doppino intrecciato, fibra ottica).","x":17673,"y":-6641,"width":612,"height":740,"color":"4"},
		{"id":"f19b3a4fa73ba9e8","type":"text","text":"# Non sapevo di essere in fase\n\nProssimamente, su DMAX.\n\nNo, seriamente: come faccio a sapere di essere in fase? Perché se non sono tutti perfettamente sincronizzati CDMA esplode malamente, e ho evitato ogni commento a riguardo.\n\nPare che esistano dei codici che restano ortogonali a tutti gli altri anche se sono sfasati (sprecando un po' di bit). Non entrerò nel dettaglio finché non finirò a lavorarci.","x":14685,"y":-7614,"width":535,"height":303,"color":"4"},
		{"id":"8c0119c21d2aab9f","type":"text","text":"# CDMA\n\n***Code Division Multiple Access*** (***CDMA***) è un metodo per consentire la trasmissione simultanea di diverse sorgenti su un singolo canale, utilizzando dei ***codici personali per demultiplexare le informazioni***.\n\nI codici sono sequenze ortogonali (***chip***) tali che\n- $\\langle i|j\\rangle$ = $\\delta_{ij}$\n- $|i|^2 = N$, dove N è il numero di stazioni che comunicano sul canale condiviso;\n\t- Per come vengono generati i codici ortogonali (tabelle di Walsh), ne escono fuori sempre $2^n$. Scegliere $N = 2^n$ significa ottimizzare il numero di stazioni che sfruttano quei codici (sicuramente deve essere $N\\leq2^n$);\n\nQuesti chip si accompagnano ad ogni bit inviato. `1` resta `1`, mentre `0` ***viene mappato nel segnale*** `-1`. Questo perché il silenzio (`0`) non è un segnale!\n\nCDMA viene usato nella telefonia mobile. I codici vengono assegnati agli host dalla cella, che\n\n- è l'unica a conoscerli tutti;\n- deve usare codici ortogonali alle celle vicine.\n\nIn realtà ci sono dei codici hard-coded nel telefono, il quale li testa per trovare il match migliore con la cella più veloce.\n\nIn passato CDMA è stato usato anche come codice di crittografia, ma i segnali non sono veramente casuali e un attaccante bravo può risalire al messaggio.","x":14685,"y":-6898,"width":535,"height":997,"color":"4"},
		{"id":"7453c854124ec469","type":"text","text":"## ... e il principio di sovrapposizione?!\n\nSe la collisione non avviene a destinazione, che mi importa? Vale il principio di sovrapposizione, per cui due onde dopo aver fatto interferenza tornano esattamente come prima, no?\n\n... no. Siamo in un cavo, non nel vuoto. La propagazione sfrutta le proprietà elettriche del mezzo, motivo per cui una sovrapposizione può indurre fenomeni non lineari o interferenze distruttive che non propagano il segnale.","x":15445,"y":-7031,"width":700,"height":260,"color":"4"},
		{"id":"c0bea95135c9c558","type":"text","text":"# CSMA/CD\n\n***Carrier Sense Multiple Access*** (***CSMA***) stabilisce delle regole per evitare che ci siano collisioni:\n\n- Se il canale è libero, invia l'intero frame;\n- Se il canale è occupato riprova più tardi.\n\nQuesto però non evita di per sé le collisioni: dal momento che la velocità di propagazione del segnale è finita, mentre A osserva che il canale è libero ed inizia a trasmettere, dall'altro lato del cavo B può aver già iniziato la trasmissione. Questo significa che da quando B inizia a trasmettere c'è un ***tempo di vulnerabilità*** pari ad un tempo di propagazione $t_P$ entro il quale A non dovrebbe mandare messaggi, pena la loro sovrapposizione.\n\nE se li manda lo stesso? Nel momento in cui rilevo una collisione (ovvero, mi rendo conto che arrivano dati mentre io sto trasmettendo) introduco un meccanismo di ***Collision Detection*** (***CD***) che interrompe la mia trasmissione.\n\nLa cosa importante, insomma, è essere in grado di rilevare la collisione. La chiave sta nella dimensione minima del frame che viene inviato. Perché il CD funzioni, il mittente deve poter rilevare la trasmissione in ingresso mentre sta trasmettendo, ovvero prima di inviare l’ultimo bit del proprio frame. Il caso peggiore è quello in cui B inizia a trasmettere un attimo prima di ricevere i primi bit da A, per cui prima che A si renda conto di questa collisione passerà $\\sim 2t_P$. \n\nQuindi è sufficiente porre per ogni frame un ***tempo di trasmissione minimo di ***$2t_P$.","x":15445,"y":-6641,"width":700,"height":740,"color":"4"},
		{"id":"c934a9e7d90eb7cc","type":"text","text":"# Accesso Casuale\n\nSi basano su due possibili approcci:\n\n- Cerco di impedire le collisioni (e.g. ***CSMA/CD***);\n- Cerco di recuperare dalle collisioni (e.g. ***Aloha***)","x":15568,"y":-5699,"width":455,"height":177,"color":"6"},
		{"id":"825165ad441d79f9","type":"text","text":"# Rotazione\n\nRound Robin con i dispositivi che devono trasmettere. Due modi principali di implementarlo:\n\n- ***Polling*** - Un ***nodo master*** invita a turno (con un messaggio di `poll`) i ***nodi slave*** a trasmettere. Tipicamente usato se questi nodi slave non hanno un HW/SW in grado di gestire protocolli complessi. Creare e inviare ogni volta il `poll` crea overhead, aspettarlo per inviare crea latenza, e infine c'è un unico *point-of-failure* (il nodo master);\n- ***Token Passing*** - Ci si mette in cerchio e si gioca a passarsi un ***token di controllo***. Chi ha il token trasmette. E se si perde il token? Non possiamo più giocare!","x":14666,"y":-5122,"width":581,"height":412,"color":"4"},
		{"id":"bd33a66a27f4e32d","type":"text","text":"# Radio Frequency Identification (RFID)\n\nÈ un sistema che consta di tre componenti:\n\n- ***Tag*** - Circuiti molto semplici, al punto che spesso sono integrati in uno sticker. Identificati da un codice univoco tipicamente a 96 bit, possono essere alimentati (attivi) e non (passivi). Il loro ruolo è rispondere ad uno stimolo EM esterno;\n- ***Reader*** - Dispositivi che emettendo un segnale EM forniscono ai Tag la potenza necessaria a rispondere;\n- ***Server*** - Riceve e processa i dati ricevuti dal Reader.\n\nI Tag passivi sono spesso utilizzati per l'identificazione (e.g. come alternativa al codice a barre), in quanto sono low cost, battery free e non necessitano line of sight.\n\nQuando un'antenna richiede gli ID di un gruppo di Tag, questi rispondono simultaneamente. Serve un protocollo semplice per evitare le collisioni, e viene rispolverato ***Aloha*** in versione un po' più semplice: il reader dice a tutti `generate un numero casuale da 1 a N, a ogni slot temporale decrementatelo e rispondete quando arriva a 0`. L'efficienza di questa roba è $\\sim 37\\%$, altrimenti c'è la sua variante ***Tree Slotted Aloha***: ogni slot in cui c'è collisione di $N$ Tag diventa la radice di un albero che iterativamente si occupa di risolvere solo quegli $N$ Tag (più facile a farsi che a dirsi).","x":14666,"y":-4638,"width":581,"height":637,"color":"4"},
		{"id":"8ae579769d34655f","type":"file","file":"Reti di Elaboratori/RFID.png","x":14757,"y":-3946,"width":400,"height":301},
		{"id":"30928e3765ea01bf","type":"text","text":"# Aloha\n\nInvia subito il frame, dopodiché se c'è stata una collisione aspetta un tempo estratto casualmente e riprova. Questo **assume che tutti i nodi siano in grado di rilevare le collisioni**. Ci sono due possibili implementazioni:\n\n- ***Slotted Aloha*** - Il più usato. Divide il tempo in slot, assumendo che tutti i frame abbiano la stessa dimensione e che tutti i nodi siano sincronizzati. Se avviene una collisione, a partire dallo slot successivo ogni nodo ha una probabilità $p$ di ritrasmettere. $p$ è estratta casualmente, altrimenti sarebbe molto probabile generare altre collisioni;\n\t- Abbastanza semplice: l'unica sincronizzazione è sugli slot;\n\t- Se c'è un solo nodo a trasmettere, può usare tutta la banda;\n\t- Per $N \\to \\infty$ nodi, la binomiale restituisce un'efficienza massima $1/e \\simeq 37\\%$;\n\t- Di contro, a seguito di collisioni potrebbero esserci slot inutilizzati;\n- ***Pure Aloha*** - Più semplice, ma meno efficiente. Non richiede nemmeno quel minimo di sincronizzazione degli slot, ma di contro aumenta la probabilità di collisione;\n\t- Ogni frame ha un ***tempo di vulnerabilità*** di $2\\,t_T$ (tempo di trasmissione), perché può fare overlap con un altro frame\n\t\t- che è partito fino a $1\\,t_T$ prima di lui;\n\t\t- che parte prima che sia stato trasmesso completamente ($1\\,t_T$);\n\t- Efficienza misurata $\\simeq 18\\%$.","x":15445,"y":-5261,"width":700,"height":623,"color":"4"},
		{"id":"93588f5566f63388","type":"file","file":"Reti di Elaboratori/SlottedAloha.png","x":15445,"y":-4581,"width":700,"height":181},
		{"id":"a984965221233e7a","type":"file","file":"Reti di Elaboratori/PureAloha.png","x":15445,"y":-4342,"width":700,"height":181},
		{"id":"895bc3f1bf8fd64a","type":"text","text":"## CDMA vs FDMA\n\nConcettualmente CDMA è simile a FDMA (volendo, sono gli 11 canali del Wi-Fi), nel senso che entrambi permettono l'accesso senza latenza al canale condiviso.\n\n- CDMA richiede hardware e software dedicato, ma può essere modificato più velocemente per adattarsi al numero di nodi nella rete (basta generare e assegnare nuovi codici);\n- FDMA può richiedere hardware costoso per gestire i filtri per gestire le diverse bande.","x":13785,"y":-7263,"width":780,"height":232,"color":"4"},
		{"id":"3f6df1e0812fdc42","type":"text","text":"# Tipi di frame 802.11\n\nLe informazioni sul tipo di messaggio sono contenute nei primi $2\\,byte$ dell'header 802.11.\n\nIn particolare si hanno\n\n- Due bit che identificano la categoria del messaggio (e.g. `00` è un frame di gestione, `10` un frame di dati);\n- Quattro bit che specificano un tipo entro la categoria. Entro i frame di controllo `01` troviamo RTS (`1011`), CTS (`1100`) e ACK (`1101`);\n- Due bit (`To DS` e `From DS`) che spiegano come leggere i quattro indirizzi MAC che seguono all'interno dell'header, ovvero\n\t- `00` - Comunicazione ad-hoc (p2p);\n\t- `01`, `10` - Voglio parlare ad un altro nodo tramite AP (come comunicare in LAN tramite uno switch);\n\t- `11` - Devo passare per diversi AP per raggiungere la mia destinazione (e.g. in aeroporto ci sono tanti AP diversi ma con lo stesso SSID che comunicano tra loro)\n\nIl formato del frame 802.11 è convertibile in Ethernet in modo semplice.","x":13785,"y":-6901,"width":780,"height":540,"color":"4"},
		{"id":"85f2794d386784c8","type":"file","file":"Reti di Elaboratori/CSMA_CA.png","x":13785,"y":-6301,"width":332,"height":400},
		{"id":"9761cb49699f7d24","type":"file","file":"Reti di Elaboratori/PrenotazioneCanale.png","x":14165,"y":-6240,"width":400,"height":279},
		{"id":"34ea13703634e6c8","type":"text","text":"# Protocolli di Accesso Multiplo (LAN)\n\nSu canale ***half-duplex***, due host non possono parlare insieme.\n\nSe un nodo ascolta più segnali contemporaneamente si verifica una ***collisione***.\n\nI protocolli provano ad impedire o a recuperare dalle collisioni sapendo che non esiste un canale di controllo out-of-band e cercando di garantire **fairness** sulla banda pro-capite.","x":14204,"y":-5750,"width":624,"height":279,"color":"6"},
		{"id":"332c0e8ffc8d1968","type":"text","text":"# Protocollo ARP\n\nPer comunicare il LAN devo conoscere l'indirizzo MAC del destinatario. Assumiamo di conoscerne già l'IP. Verifico prima di tutto che sia dentro la LAN (altrimenti devo passare dal router). Come? Confrontando il mio IP col suo attraverso la subnet mask.\n\n- Se l'IP che voglio raggiungere è in locale ma non so il suo MAC Address mando broadcast una ***richiesta ARP*** (RFC 826), includendo la mia coppia (IP, MAC) (una cosa del tipo `se hai IP 192.168.1.10, manda il tuo MAC alla coppia IP = 192.168.1.20 e MAC = AB:AD:DE:AD:CA:FE`. Chi non ha questo IP semplicemente ignora il messaggio). L'interessato riceve la richiesta, si segna la mia coppia (IP, MAC) nella ***cache ARP*** (associando un `TTL` tipicamente e procede a rispondermi unicast (perché a questo punto sa il mio MAC) con la sua coppia;\n- Se l'IP che voglio raggiungere NON è in locale devo passare dal gateway router. Faccio ARP sul gateway router (il cui IP è impostato di default come parametro di connessione), dopodiché se la vede lui con le proprie tabelle di routing. Questo ovviamente avviene solo la prima volta. Preso il MAC del gateway, se la vede lui.\n\t- Nota che alla stessa porta possono corrispondere diversi MAC. La porta fisica è \"dove andare per raggiungere questo MAC\", non \"SOLO questo MAC\"!","x":10968,"y":-4508,"width":752,"height":510,"color":"4"},
		{"id":"93d339019972442f","type":"text","text":"# Quindi cosa serve per comunicare?\n\nSe voglio comunicare ***in locale***, mi bastano due informazioni:\n\n- il mio ***IP***;\n- la ***maschera di sottorete***.\n\nAl resto pensa ARP.\n\nSe voglio comunicare ***al di fuori della mia sottorete***, mi servono ***anche***\n- ***IP del router*** (default gateway)\n- ***IP di un server DNS***.\n\nTutto questo viene configurato automaticamente al momento della creazione della connessione dal DHCP.","x":10968,"y":-3920,"width":752,"height":408,"color":"4"},
		{"id":"f7bb59d2b607b321","type":"text","text":"# VLAN (Virtual LAN)\n\nSe volessi dividere una rete in due sottoreti? Posso mettere un router e creare una nuova LAN, certo, ma introduco complessità (nonché il livello di Rete, qua stiamo in DLL!).\n\nPosso invece dividere le porte di un singolo switch fisico in due gruppi distinti, e costruire le tabelle MAC come se ogni gruppo fosse uno switch fisico separato dall'altro. Proprio come fossero fisicamente separati, questi ***switch virtuali*** così costruiti sono indipendenti l'uno dall'altro, e ad ognuno di essi corrisponde una ***LAN Virtuale*** (***VLAN***).\n\nSi sa, virtualizzare apre sempre le porte alle magie perché introduce il SW. Inoltre, la topologia virtuale non è vincolata alla topologia fisica.\n\nPosso assegnare ad ogni VLAN un codice identificativo (***VLAN Tag***) e collegare la `VLAN 10` di uno switch fisico con la `VLAN 10` di un altro tramite cavo (***Access***), creando un singolo switch virtuale fisicamente delocalizzato.\n\nSe voglio collegare diverse VLAN di uno switch fisico ad un altro switch fisico devo usare un cavo Access per ciascuna? No, esistono cavi che collegano in blocco più VLAN (detti ***Trunk***). C'è un campo dell'header per il VLAN Tag (`ID`, impostato dallo switch quando invia il frame su un Trunk) che serve allo switch fisico di destinazione per demultiplexare.\n\n- E se mi arriva un frame senza VLAN Tag? Definisco una ***Native VLAN*** a cui indirizzare di default i frame senza Tag.\n\t- Non serve solo a questo! Ipotizziamo la Native sia `ID = 10`. Se arriva una frame da un Access della VLAN `30`, lo switch controlla se `30` è la Native. Non lo è, allora mette il tag `30` e invia. Se invece arriva un frame da un Access della Native (`10` in questo esempio), lo switch non mette alcun tag!\n\t- I ***Trunk*** sono connessi alle ***Tagged Ports***, gli ***Access*** alle ***Untagged Ports***. La Native VLAN è l'unica che attraversa un Tagged Link senza Tag.\n- ***802.1q*** è la variante del protocollo Ethernet che include i VLAN Tag;","x":11925,"y":-5261,"width":780,"height":769,"color":"4"},
		{"id":"3babb9c1abd49799","type":"file","file":"Reti di Elaboratori/Confronto_VLAN_Header.png","x":11940,"y":-4093,"width":750,"height":173},
		{"id":"57643829e285a0ee","type":"file","file":"Reti di Elaboratori/VLAN_1.png","x":12819,"y":-5165,"width":400,"height":223},
		{"id":"7553697f9878b2c6","type":"file","file":"Reti di Elaboratori/VLAN_2.png","x":12819,"y":-4781,"width":400,"height":142},
		{"id":"fbefd18df3a53c86","type":"file","file":"Reti di Elaboratori/802.1q.png","x":12033,"y":-4400,"width":564,"height":220},
		{"id":"f87237b7fec09ab2","type":"text","text":"# Dataflow\n\nComplessivamente, tutto il traffico di Internet è interamente determinato da tre oggetti:\n\n- MAC Address Table - Mappa gli indirizzi MAC in porte fisiche (switchports);\n- ARP Table/Cache - Mappa gli indirizzi IP in indirizzi MAC;\n- Routing Table - Indirizza i datagrammi (contenenti gli indirizzi IP) al prossimo router.\n\nPercHé avvenga il flusso di informazioni, se uso la RT poi userò anche la ARP.","x":9400,"y":-3548,"width":619,"height":358},
		{"id":"895e1ffe72619a28","type":"text","text":"# Aggiunte ARP\n\n\"chi ha questo IP mi dica il suo MAC\"\nse arrivano due risposte?\ndipende dall'implementazione, alcune tengono solo la risposta più recente, altre restituiscono un errore (ARP conflict)\nesistono attacchi ARP spoofing in cui mi fingo un'altra interfaccia, ma poco interessante perché dovrei già trovarmi sulla LAN.\n\nswitch in cascata funzionano esattamente come un singolo switch\n\n","x":10267,"y":-3435,"width":600,"height":287},
		{"id":"4b4c321762d3e679","type":"text","text":"# Connettersi ad un AP\n\nLo standard 802.11 assegna dei range di frequenze per il protocollo ***Wireless Fidelity*** (***Wi-Fi***).\n\nLo spettro di frequenze $[2.4, 2.485]\\,GHz$  è diviso in 11 canali parzialmente sovrapposti numerati da $1$ a $11$. Spetta all'admin scegliere quali usare, tenendo conto che segnali distanti $3$ o meno canali possono fare interferenza tra loro. A questo punto:\n\n- L'AP invia segnali periodici, detti ***beacon***, che includono il suo identificatore univoco (Service Set Identifier, SSID) ed indirizzo MAC sui propri canali attivi;\n- I dispositivi in ascolto fanno un check su tutti i canali, intercettando eventuali beacon;\n\t- Inizialmente richiedeva minuti perché l'HW era lento;\n- Ogni dispositivo sceglie uno ed un solo AP, inviando una ***richiesta di associazione***;\n\t- Nel caso delle celle telefoniche, sceglierà l'AP il cui segnale è più forte;\n- L'AP risponde con una ***risposta di associazione*** che permette al dispositivo di effettuare la richiesta DHCP e tornare sostanzialmente al caso di LAN cablata.\n\nTutto questo vale su un singolo AP. Se ce ne sono diversi in contrasto con protocolli diversi, magari uno è molto più aggressivo degli altri e domina\n\n\n\"se sono sintonizzato su una frequenza, tutto il resto è rumore\"\n","x":11925,"y":-7809,"width":780,"height":760,"color":"3"},
		{"id":"840636eb4f2d40f4","type":"text","text":"# Wireless LAN (WLAN)\n\nSi basa sulla presenza di ripetitori (***base station*** per i dati mobili, ***access point*** per le WLAN domestiche) collegati alla rete cablata che propagano onde sferiche. È una trasmissione ***broadcast*** in cui il mezzo condiviso è l'aria.\n\nEsiste anche un paradigma non centralizzato in cui ogni host può comunicare direttamente con ogni altro (***rete ad-hoc*** o ***standalone***, protocolli ***WiFi Direct***) in cui il routing non è centralizzato (***rete mesh***).\n\nSembra semplice: arrivano onde EM e le ricevo. In realtà ci sono tre problemi principali:\n\n- ***Propagazione multi-path*** - quando il segnale sbatte contro una parete, questo viene in gran parte riflesso. Questo significa che l'host riceve una fauna di onde casualmente sfasate da tutte le direzioni (la distribuzione del segnale data dalle pareti di una stanza è un sistema caotico). Quando arrivano segnali sfasati in teoria ci sarebbero i battimenti (disastro a livello di segnale), ma gli access point sono intelligenti. Hanno più antenne e sono abbastanza in grado di ***ricostruire l'informazione di partenza***, a volte anche a potenziarla sommando in fase le due onde;\n\t- Quindi all'esterno questo problema non c'è? Purtroppo c'è, parte del segnale su grandi distanze rimbalza sulla ionosfera, ma un cellulare può ricostruire il segnale a partire da questi rimbalzi;\n- ***Attenuazione del segnale*** - La potenza si conserva sulla sfera, quindi cala come $1/r^2$;\n\t- Come conseguenza, è difficile rilevare una collisione come previsto da CSMA/CD, perché quando parlo la mia voce è molto più forte del segnale che ricevo (lo chiameremo simpaticamente ***problema dell'uomo sulla montagna***);\n\t\t- Le soluzioni richiedono o troppo effort energetico o HW troppo complicato;\n\t\t- Anche se fosse, A che parla con B può sottrarre il proprio rumore ma non può sottrarre il rumore di terminali che non conosce, ad esempio C, mentre quest'ultimo nemmeno se ne accorge (***hidden terminal problem***);\n\t- Se il segnale si attenua troppo può confondersi col ***rumore***, per cui si definisce un ***Signal to Noise Ratio*** (***SNR***);\n- ***Interferenze*** - Più ripetitori che usano le stesse frequenze possono interferire a destinazione. Anche il multi-path è considerabile un'interferenza\n\nLa IEEE stabilisce come standard ***802.11*** (cui segue una lettera ad indicare le specifiche tecniche, come frequenze utilizzate e larghezza di banda). L'equivalente di una LAN in cui l'access point fa le veci di uno switch è detto ***Basic Service Set*** (***BSS***). Più BSS organizzati in modo gerarchico formano un ***Extended Service Set*** (***ESS***).","x":11925,"y":-6901,"width":780,"height":1000,"color":"4"},
		{"id":"1dbf5273a42e5229","type":"file","file":"Reti di Elaboratori/ProtocolliWireless.png","x":12115,"y":-8159,"width":400,"height":214},
		{"id":"df043301b08dc4bc","type":"text","text":"# CSMA/CA\n\nIn virtù del **problema dell'uomo sulla montagna** e dell'**hidden terminal problem** non posso usare Collision Detection. Allora implemento una ***Collision Avoidance*** (***CA***), cioè evito a priori che si possano mai verificare collisioni. Come?\n\nPer ovviare al problema dell'uomo sulla montagna:\n\n- Introduco degli intervalli tra un frame e l'altro, detti ***InterFrame Space*** (***IFS***);\n\t- Il mittente ascolta il canale per un tempo ***DIFS*** (***Distributed IFS***). Se Carrier Sense non rileva segnali in ingresso, al termine del DIFS manda il frame;\n\t- Se il destinatario riceve il frame senza interferenze, aspetta un tempo ***SIFS*** (***Short IFS***, di durata $SIFS < DIFS$) e manda un ***ACK*** di conferma;\n- Introduco una ***finestra di contesa*** per stabilire la durata del DIFS;\n\t- La grandezza della finestra segue il [[Backoff Esponenziale]];\n\nPer ovviare al problema del terminale nascosto:\n\n- Introduco un meccanismo di ***prenotazione del canale***:\n\t- La sorgente (A) aspetta un DIFS e manda una ***Request To Send*** (***RTS***), con cui comunica alla destinazione (B) quanti dati vuole mandare e per quanto tempo serve prenotare il canale. Tale tempo è detto ***NAV*** (***Network Allocation Vector***);\n\t- Se B riceve RTS senza interferenze, attende un SIFS e manda a tutti un messaggio ***Clear To Send*** (***CTS***) con cui \n\t\t- avvisa la sorgente che può procedere a inviare;\n\t\t\t- Se A non riceve il CTS assume che il canale non sia libero, aggiorna il backoff esponenziale e riprova dopo un tempo estratto casualmente;\n\t\t- invita tutti gli altri (compresi gli hidden terminal C) a starsi zitti finché non finisce il NAV;\n\t\t\t- Se C sta già ricevendo qualcos'altro potrebbe non sentire il CTS;\n\t\t\t- Questo potrebbe bloccare anche comunicazioni che non avrebbero interferito con A e B (B urla a tutti di fare silenzio anche quando non è strettamente necessario);\n\t- Una volta che il canale è prenotato, A aspetta solo un SIFS piuttosto che un DIFS;\n\t- Questo meccanismo viene usato solo per pacchetti \"grandi\".\n","x":12899,"y":-6901,"width":760,"height":1000,"color":"4"},
		{"id":"d66b5203ff904bb6","type":"text","text":"# Rete Mobile\n\n\n\"c'è stata una spinta commerciale per la rete mobile vs la rete di casa\n\nLa copertura dall'antenna era detta cella (da cui cellulari?) in ogni punto arrivano più segnali, devo scegliere il più forte. prima c'erano addetti che misuravano, ma si può demandare ai singoli clienti della rete (misurano già in loco quanto forte vedono una certa antenna)\n\nin teoria ormai linea mobile ed internet hanno la stessa cella, in pratica c'è una virtualizzazione che rende il canale telefonico un po' più affidabile \n\nvedi GSM, VOIP, ...\n\nSe mi sposto tra diversi AP della rete mobile (***roaming***), questa deve essere in grado di non far crollare tutte le connessioni TCP che avevo.\n\n- H1 sente che il segnale da AP1 si affievolisce e avvia una scansione per un segnale più forte\n- H1 rileva AP2, si disassocia da AP1 e si associa a AP2, mantenendo lo stesso IP e sessioni TCP\n- AP2 invia un frame broadcast allo switch con indirizzo mittente H1 e lo switch capisce che H1 è ora nel BSS2","x":12965,"y":-8341,"width":628,"height":680},
		{"id":"c287d4aa7b5a27a1","type":"text","text":"# Protocolli di Accesso Multiplo (WLAN)\n\nDue AP possono scegliere canali troppo vicini, rischiando quindi di fare interferenza. Se succede, si torna al problema del canale condiviso. Lo standard ***802.11*** implementa un controllo detto ***Distributed Coordination Function*** (***DCF***), che si basa su ***CSMA/CA***.","x":12965,"y":-7521,"width":628,"height":180,"color":"6"},
		{"id":"e65e158ed9f2ecee","type":"text","text":"# Ma perché sta tutto a 2.4 GHz?\n\nEsistono bande di frequenza a pagamento, spesso gestite e assegnate dagli stati o dalle autorità di regolamentazione delle telecomunicazioni. Queste bande sono tipicamente utilizzate per applicazioni commerciali, come le comunicazioni mobili, le trasmissioni televisive e radiofoniche, e altri servizi wireless. Ecco un resoconto esaustivo delle principali bande di frequenza a pagamento e dei loro utilizzi:\n\n### Bande di Frequenza e i loro Utilizzi\n\n1. **Comunicazioni Mobili**\n   - **GSM (2G)**: 900 MHz e 1800 MHz\n   - **3G (UMTS)**: 2100 MHz\n   - **4G (LTE)**: Diverse bande, tra cui 700 MHz, 800 MHz, 1800 MHz, 2100 MHz, 2600 MHz\n   - **5G**: Bande sotto i 6 GHz (sub-6), come 700 MHz, 3.5 GHz e bande millimetriche (mmWave) come 24 GHz, 28 GHz, e 39 GHz\n\n2. **Trasmissioni Televisive e Radiofoniche**\n   - **TV Broadcast**: VHF (30 MHz - 300 MHz) e UHF (300 MHz - 3 GHz)\n   - **Radio AM**: 535 kHz - 1605 kHz\n   - **Radio FM**: 88 MHz - 108 MHz\n\n3. **Servizi Satellitari**\n   - **Satelliti di Comunicazione**: C-band (4 GHz - 8 GHz), Ku-band (12 GHz - 18 GHz), Ka-band (26 GHz - 40 GHz)\n   - **GPS**: 1.227 GHz e 1.575 GHz\n\n4. **Servizi Pubblici e di Sicurezza**\n   - **Bande per la Sicurezza Pubblica**: 700 MHz, 800 MHz\n   - **Servizi Aeronautici**: 108 MHz - 137 MHz (comunicazioni di aviazione civile)\n\n5. **Servizi per le Reti Wireless a Larga Banda**\n   - **WiMAX**: 2.3 GHz, 2.5 GHz, 3.5 GHz\n\n### Assegnazione e Regolamentazione delle Frequenze\n\n1. **Regolamentazione Nazionale**\n   - **FCC (Federal Communications Commission)** negli Stati Uniti\n   - **Ofcom** nel Regno Unito\n   - **ARCEP** in Francia\n   - **AGCOM** in Italia\n\n2. **Regolamentazione Internazionale**\n   - **ITU (International Telecommunication Union)**: Un'agenzia specializzata delle Nazioni Unite che coordina l'uso globale dello spettro radio e delle orbite satellitari.\n\n### Modalità di Assegnazione delle Frequenze\n\n1. **Aste di Spettro**\n   - Le bande di frequenza sono spesso vendute tramite aste in cui le compagnie di telecomunicazioni competono per ottenere licenze per l'uso di determinate bande di frequenza.\n\n2. **Licenze di Spettro**\n   - Le licenze possono essere assegnate tramite concessioni dirette o procedure competitive, e le aziende pagano per l'uso esclusivo delle bande assegnate per un determinato periodo.\n\n3. **Canoni di Utilizzo**\n   - Oltre al costo iniziale dell'assegnazione, le licenze possono comportare canoni annuali per l'uso continuo dello spettro.\n\n### Esempi di Bande di Frequenza a Pagamento e le loro Utilizzazioni Specifiche\n\n1. **700 MHz**\n   - Utilizzata per LTE e 5G.\n   - Favorita per la sua capacità di coprire grandi aree e penetrare edifici.\n\n2. **3.5 GHz**\n   - Una delle bande principali per il 5G, offrendo un buon equilibrio tra copertura e capacità.\n\n3. **24 GHz e 28 GHz (mmWave)**\n   - Utilizzate per il 5G per offrire velocità molto elevate, sebbene con una copertura limitata.\n\n### Bande di Frequenza Gratuita\n\n1. **Bande ISM**\n   - **2.4 GHz**: Utilizzata da Wi-Fi, Bluetooth, e altri dispositivi senza fili.\n   - **5 GHz**: Utilizzata da Wi-Fi (802.11a/n/ac/ax).\n   - **13.56 MHz**: Utilizzata da NFC.\n\n2. **Bande di Frequenza non Licenziate**\n   - Utilizzate per applicazioni come le reti wireless locali, i dispositivi a corto raggio, e le comunicazioni industriali.\n\n### Conclusione\n\nLe bande di frequenza a pagamento sono cruciali per molte applicazioni commerciali e pubbliche, e la loro assegnazione è rigorosamente regolamentata per garantire un uso efficiente e coordinato dello spettro. Le aste e le licenze di spettro permettono di gestire l'accesso a queste risorse preziose, assicurando che vengano utilizzate per servizi che portano valore economico e sociale.","x":10968,"y":-7809,"width":752,"height":760,"color":"#641e32"},
		{"id":"adcd49e79bfc238c","type":"text","text":"# Errori da Interferenza\n\nIl rumore esterno può distorcere il segnale che transita sul cavo, flippando i bit.\n\nGli errori da interferenza sono spesso ***bursty***: il segnale distorcente capita \"ogni tanto\" ed è \"lento\" rispetto alla velocità del segnale, quindi è più probabile avere un errore su tanti bit consecutivi (***finestra di interferenza***) piuttosto che su uno solo (e.g. se trasferisco a $1\\,Kbps$, un rumore che dura $1\\,ms$ influisce su $10\\,bit$).\n\nIn generale, per rilevare questi errori vengono aggiunti in coda al frame degli ***Error Detection and Correction bits*** (***EDC***). E cosa ci faccio?\n\n- ***Parity Checking*** - Aggiungo un solo EDC in coda, in modo che la somma tra esso e tutti i bit del messaggio sia pari. Se a destinazione non lo è, vuol dire che c'è stato un errore. Naturalmente questo ***non garantisce di individuare gli errori***:\n\t- Un numero pari di errori conserva la parità;\n\t- Se il check non torna posso solo dire che c'è stato un numero dispari di errori.\n\t- Non ho informazioni su dov'è l'errore, quindi non posso recuperarlo;\n- ***Parity Checking Bidimensionale*** - Metto i bit del frame su una matrice e faccio checksum su ogni riga e ogni colonna. Se so che c'è un solo errore lo trovo facilmente (sono sbagliati i checksum di una sola riga ed una sola colonna), ma restano i problemi del numero pari di errori. Ci si può divertire a ideare esempi in cui questo checksum funziona o meno;\n- ***Cyclic Redundancy Check*** (***CRC***) - Mittente e destinatario concordano una sequenza di bit detta **divisore** (o **generatore**, indicato con $G$) per generare una sorta di **digest hash** $R$ a partire dai bit del frame ($D$). Segue procedura:\n\t- Se $G$ consta di $n$ bit, aggiungo a $D$ $n-1$ zeri a destra creando $D'$; \n\t- Svolgo $D'\\,\\%\\,G = R$. Il resto della divisione intera modulo 2 ha un bit in meno del divisore, quindi $R$ ha $n-1$ bit;\n\t- Al posto degli $n-1$ zeri che ho aggiunto a $D$ per creare $D'$ metto gli $n-1$ bit di $R$, creando il messaggio $D''$ (in cui i bit di $R$ sono gli EDC);\n\t- A destinazione svolgo $D''\\,\\%\\,G$, che a questo punto deve darmi esattamente $0$, altrimenti sono certo di aver individuato un errore.\n\nCRC è ottimo se si vuole essere certi di identificare la presenza di un errore, ma non dice niente su dove si è verificato o su come recuperarlo.\n\n Per recuperare dagli errori (utile se ho un canale con altissima latenza come un satellite) si usano gli ***Error Correction Codes*** come ***Hamming***, ***Reed-Solomon***, ***BCH*** ed ***LDPC*** (sui quali non mi azzardo a dire altro se non che esistono).","x":10968,"y":-6901,"width":752,"height":1000,"color":"4"},
		{"id":"1402f82ddabdb007","type":"text","text":"# Switch\n\nReindirizza i frame tra IP della stessa LAN tramite una tabella che associa gli indirizzi MAC dei dispositivi ad esso connessi con la relativa porta fisica, e amplifica il segnale. È un elemento **trasparente** (gli host ignorano la sua presenza) che implementa tre azioni:\n\n- ***Learn*** - Riempire la propria ***Content Addressable Memory*** (***CAM***). Immaginiamola inizialmente vuota. Quando da una porta fisica arriva un frame questo contiene il MAC Address del mittente, permettendo allo switch di aggiungere l'associazione tra quel MAC e la porta da cui è arrivato come riga di una tabella di corrispondenze;\n\t- Nota che il frame potrebbe essere passato per altri switch, quindi non c'è la certezza che alla fine del proprio cavo ci sia proprio la NIC con quel MAC. La corrispondenza è un \"dove inoltrare per andare verso quel MAC\";\n- ***Flood*** - Se lo switch non conosce il MAC Address di destinazione si comporterà da ***hub***, inoltrando il frame in broadcast su tutte le altre porte. Solo il diretto interessato risponderà, di fatto passando per lo switch e facendogli imparare la sua associazione;\n- ***Forward*** - Se so già tutto, reindirizzo in scioltezza. Mentre il router legge l'header di rete e sostituisce l'header di link, lo switch si limita a reindirizzare.\n\nOpera all'interno delle reti locali, e comprende il compito di inoltrare i frame al gateway router, il quale poi se la vede con Internet.\n\nAnche lo switch ha un MAC e un IP, in caso serva configurarlo (e.g. con Telnet, o SSH). Fintantoché il traffico non è rivolto esattamente a lui, questi restano inutilizzati.\n\nRiassumendo, il compito dello switch è apprendere gli indirizzi MAC per reindirizzare correttamente i messaggi rivolti a quei MAC. Ma se non conosco il MAC?","x":10968,"y":-5261,"width":752,"height":696,"color":"4"},
		{"id":"04e2e59fbd2b386f","type":"text","text":"# Livello di Collegamento\n\nGestisce il ***trasferimento hop-to-hop*** dei frame.","x":11128,"y":-5661,"width":432,"height":100,"color":"6"},
		{"id":"0ea7ba1d2a860cba","type":"text","text":"# LAN","x":11283,"y":-5441,"width":123,"height":41,"color":"6"},
		{"id":"44d21c89cd07b8f4","type":"text","text":"# Glossario del Data Link Layer\n\n- ***Data Link Control (DLC)*** - protocollo che definisce la comunicazione hop-to-hop (unicast e non) sul canale condiviso da due host (e.g. incapsulamento, checksum);\n- ***Media Access Control (MAC)*** - protocollo che definisce la comunicazione broadcast;\n\t- Diverso è l'***indirizzo MAC***, che identifica univocamente una ***Network Interface Card*** (***NIC***, e.g. Ethernet, scheda Wi-Fi).\n- ***Flooding*** - Azione di uno switch. Inoltra un frame proveniente da una porta a tutte le altre porte;\n- ***Unicast*** - Un tipo di frame in cui il MAC di destinazione identifica un singolo host. Uno switch può eseguire un'azione di flooding se non conosce il MAC di destinazione;\n- ***Broadcast*** - Un tipo di frame in cui il MAC (i.e. `FF:FF:FF:FF:FF:FF`) indica allo switch di fare flooding. Un host che si vede recapitare un broadcast può decidere se accettarlo o meno, a seconda della configurazione;\n- Un ***canale di comunicazione*** (e.g. cavo Ethernet) può essere\n\t- ***Half-Duplex*** - Supporta trasmissione bidirezionale non contemporanea;\n\t- ***Full-Duplex*** - Supporta trasmissione bidirezionale contemporanea.\n- ***Network Interface Card (NIC)*** - Scheda di rete associata ad un canale di comunicazione ed identificata univocamente da un MAC Address. Collegata all'HW del computer attraverso il BUS, avente un firmware e gestita da un controller SW. Insomma, una periferica.","x":9985,"y":-6604,"width":791,"height":703,"color":"4"},
		{"id":"ea5e414eaee40f14","type":"text","text":"# Indirizzi MAC\n\nOgni scheda di rete (***Network Interface Card, NIC***) è identificata univocamente da un codice a $48\\,bit$, divisi in 6 gruppi da 8 e rappresentati ciascuno con due cifre esadecimali (e.g. `01:00:00:0F.A1.0A` corrisponde a `1:0:0:15:161:15`). Ogni numero decimale separato dai `:` va da `0` a `255`.\n\nIn cima alla catena alimentare dell'assegnazione dei MAC c'è la IEEE, che assegna ai produttori di NIC un ***Organizationally Unique Identifier*** (***OUI***). Questo codice a $24\\,bit$ diventerà l'incipit dei MAC Address prodotti da quel vendor. Ma non solo: si possono ricavare informazioni sul NIC a partire da alcuni bit di questo codice. Poniamo che sia  `xxxxxxBA:yyyyyyyy:zzzzzzzz`.\n\n- Se `A = 0` significa che il NIC è abilitato alle sole trasmissioni ***unicast***, ovvero i NIC che ricevono il frame confrontano il MAC di destinazione con il proprio e lo buttano se i due non coincidono (a meno di attivare la **promiscuous mode**). `A = 1`, viceversa, consente il ***multicast***. Il NIC ricevente (che pure deve avere `A = 1`) confronta il MAC di destinazione con un elenco di indirizzi multicast per decidere se accettare o meno il frame;\n- `B = 0` indica che l'indirizzo MAC è proprio quello assegnato dal vendor (***Universally Administrated***). Perché, ce ne possono essere altri? Già. Questo MAC è *hard-coded* dal vendor, ma io localmente posso scegliere di cambiarlo a patto di mettere `B = 1` (***Locally Administrated***). Quindi, ogni OUI ha `B = 0`;\n- Per altre informazioni prendi un MAC Address e mettilo su [questo sito](https://macaddress.io/mac-address-lookup/wkWqJz7E2K).\n\nOltre al MAC esistono altri formati per gli indirizzi fisici (e.g. **EUI**, **Extended Unique Identifier**), così come diverse lunghezze (e.g. 64 bit).","x":9985,"y":-5261,"width":791,"height":696,"color":"4"},
		{"id":"64182a68ba4bddda","type":"text","text":"# Robe utili dall'esame di Reti\n\nAlcune di queste cose sono caratteristiche del solo TCP/IP (i.e. Internet), ma possono comunque servire.","x":9120,"y":-5671,"width":501,"height":120,"color":"6"},
		{"id":"0e6f35441b30a9ce","type":"text","text":"# Binary Splitting Tree Slotted Aloha\n\nPartiamo con un BS classico. C'è un solo slot, quindi tutti i Tag rispondono insieme. ***BS*** allora li divide in due sottogruppi. Ciascun sottogruppo viene quindi gestito da ***TSA***, il che significa che potrebbero esserci slot del sottogruppo in cui un Tag viene identificato, ma possono ancora verificarsi collisioni. Se si verificano, ricado nel caso di BS e ricomincio.\n\nDal momento che ogni split divide i Tag in due gruppi circa uguali, sono anche sempre più in grado di stimare il numero totale di Tag via via che l'algoritmo procede.\n\n<span style=\"color:#FFA500\">Vogliamo scrivere come?!</span>","x":3532,"y":-3804,"width":759,"height":300,"color":"4"},
		{"id":"1e950c33e4268bb0","type":"file","file":"BSFSAComparison.png","x":4541,"y":-3908,"width":759,"height":508},
		{"id":"06c8dfc1835bdad9","type":"text","text":"# Aloha Based Protocols\n\nProtocolli in cui il tempo è discreto e la sua unità minima è detta ***slot***. Si possono poi eventualmente raggruppare più slot in un ***frame***.\n\nLa probabilità che due o più Tag rispondano entro lo stesso slot è un processo ***binomiale***.\n\nPer funzionare, protocolli come ***FSA*** e ***TSA*** hanno bisogno di sapere quanti Tag devono identificare. Essendo un'informazione in generale non nota a priori, ci interessa stimarla. Questo può essere fatto sia con approcci naive che con modelli più sofisticati:\n\n- Con un primo frame conto gli slot di collisione, stimando tramite un numero medio $k$ di collisioni attese per slot di collisione quanti possono essere i Tag totali;\n- Uso un protocollo meno sensibile a questa non-conoscenza, come ***BSTSA***.","x":3532,"y":-3105,"width":759,"height":372,"color":"6"},
		{"id":"58abf9d465bc3980","type":"text","text":"# Framed Slotted Aloha, EPC GEN 2\n\nSe in ***Slotted Aloha*** (***SA***) si assume che tutti i frame abbiano la stessa dimensione, in ***Framed Slotted Aloha*** (***FSA***) il reader ne decide la size volta per volta.\n\nAll'inizio di un frame che consta di $S$ slot, i Tag che sanno di dover essere ancora identificati devono sceglierne uno a caso per trasmettere.\n\nRispetto alla variante a frame fissato, qui posso gestirmela un po' meglio. Metterò un frame più grande all'inizio, quando il numero di potenziali collisioni è alto, e più piccolo alla fine, quando invece mancano pochi Tag e non ha senso sprecare banda. Nonostante tutto si trova comunque un'efficienza $\\text{SE}\\simeq37\\%$, come in SA classico, tuttavia all'atto pratico quando faccio le misure risulta più stabile e su valori più alti.\n\nSu FSA è basato il protocollo ***EPC GEN 2***, che introduce ottimizzazioni quali\n\n- Gli slot di silenzio (i.e. nei quali nessuno risponde) vengono accorciati rispetto agli altri;\n- La grandezza del frame è stabilita in modo dinamico rispetto al numero di collisioni osservate sperimentalmente;\n- Essendo tutto così dinamico, le performance sono valutate in relazione al tempo.","x":4542,"y":-3174,"width":759,"height":510,"color":"4"},
		{"id":"b56e6a2717144541","type":"text","text":"# Tree Slotted Aloha\n\nOgni slot in cui c'è collisione di due o più Tag genera un albero che si occupa di risolvere solo quei Tag che hanno risposto. I frame vengono quindi generati a partire dal numero di collisioni osservate sul singolo slot.\n\nAd esempio, se tra tutti Tag rispondono nel primo slot solo `0001`, `0101` e `1000`, il reader può decidere per un frame lungo `3` al quale parteciperanno solo i Tag sopracitati. Mettiamo che nel primo di questi tre `0001` viene correttamente identificato. Daje. Nel secondo invece gli altri due vanno in collisione. La storia si ripete finché non vengono tutti identificati.\n\nCalcolare la resa teorica di questo protocollo non è facilissimo, perché dipende molto dalla profondità dell'albero (i.e. quante collisioni si verificano). Inoltre, cambia molto tra\n\n- Ottimizzare $\\text{SE}$ - Devo scegliere abbastanza slot da evitare collisioni, ma se ne metto troppi creo degli altrettanto inefficaci idle slot. Se scelgo $N = n$ (i.e. numero di slot per frame pari al numero di Tag da identificare in quel frame) trovo un valore $\\text{SE}\\sim0.37$;\n- Ottimizzare $\\text{Time\\_SE}$ - Se gli idle slots pesano meno, posso permettermi di mettere più slot per frame. Una $\\text{Time\\_SE}$ ottimizzata può superare il $70\\%$ (sovrastimare il numero di slot necessari migliora i risultati, con un picco sperimentale di $N\\sim4.4\\cdot n$).","x":3532,"y":-2601,"width":759,"height":516,"color":"4"},
		{"id":"496569cc5d17f5be","type":"text","text":"# Protocolli RFID\n\nSe un reader richiede gli `ID` di un gruppo di Tag, questi rispondono simultaneamente.\n\nCiò in generale produce un gran numero di collisioni. Per via della semplicità dei Tag, non possono essere questi ultimi ad implementare un protocollo di collision avoidance, quindi tutto l'onere ricade sul coordinatore (i.e. il reader), il quale ha diverse possibilità.\n\n- ***Protocolli Sequenziali*** - Permetto la trasmissione di un tag alla volta (i.e. ***Collision Avoidance***, e.g. ***Binary Splitting*** e ***Slotted Aloha***);\n- ***Protocolli Concorrenti*** - Gestisco le collisioni, quando si verificano (e.g. ***Pure Aloha***).\n\t- Nota che questo NON è Collision Detection. Per realizzare quest'ultimo, tutti i dispositivi devono essere in grado di rendersi conto della collisione, cosa che vista la semplicità dei Tag risulta impossibile;\n\t- Questi protocolli sono utilizzati in RFID solo in condizioni di basso traffico, avendo come unico vantaggio la semplicità d'implementazione.","x":2331,"y":-3135,"width":759,"height":433,"color":"4"},
		{"id":"b088c8d184a0019a","type":"text","text":"# Semplici Reti Ancora Non Proprio SuperIntelligenti\n### Che possono però essere rese tali implementando nei nodi degli algoritmi di Reinforcement Learning\n\nSinceramente, non so che nome dare a questa parte introduttiva del corso.","x":2331,"y":272,"width":759,"height":205,"color":"6"},
		{"id":"cd0682544b4d7ae0","type":"text","text":"# HowTo Sensore di una WSN\n\nUn sensore è tipicamente composto dai seguenti elementi\n\n- Power Source, tipicamente una batteria;\n- CPU e Memoria per l'esecuzione di codice;\n- Sistema radio per la comunicazione con gli altri nodi;\n- Sensori vari.\n\nStoricamente, il più importante SO per un simile oggettino è stato ***TinyOS***, scritto in una variante depotenziata del C chiamata ***Stylized C***. Oggi si usa roba più moderna, tipo Zephyr, RTOS o RIOT, e linguaggi come C++, Rust e (incredibile) ***MicroPython***, che è una versione di Python3 non interpretata ma compilata (tipo funziona su RaspberryPi Pico).","x":5552,"y":196,"width":759,"height":357,"color":"4"},
		{"id":"fda930695389d493","type":"text","text":"# Routing in a WSN\n\nCi sono due principali tipologie di flussi di comunicazione in una WSN:\n\n- ***Broadcast*** - Il Sink fa da coordinatore e dissemina le informazioni di controllo a tutti;\n- ***Convergecast*** - Un gruppo di sensori comunica i propri dati al Sink.\n\nLa comunicazione è in generale ***multi-hop***, si assumono ***nodi fissi***. In questa circostanza posso usare i metodi classici. Se poi ho anche informazioni sulla topologia della rete (i.e. ho un'idea di dove si trova un certo nodo rispetto a me) posso usare Geographic Routing.\n\nTutto questo si rompe se i sensori si muovono e la topologia cambia (e.g. DRONET).","x":5552,"y":720,"width":759,"height":324,"color":"6"},
		{"id":"dfe3bfa74fb8b071","type":"text","text":"# Sleeping MAC (S-MAC)\n\nDal momento che il consumo energetico è davvero un bisogno primario, creo un protocollo MAC apposito per le reti di sensori.\n\nL'idea è imporre una schedule (***Duty Cycle***) al sensore in modo tale che resti in ibernazione per la maggior parte del tempo (consumando poca batteria) per poi attivarsi in una breve finestra utile a scambiare i dati (***Duty Time***), che in genere si attesta sul $10\\%$ del totale.\n\nQuesto step verso l'energy efficiency deve però al contempo garantire un buon throughput, una bassa latenza e una buona flessibilità (scalability, adaptability to changes).","x":5552,"y":-300,"width":759,"height":304,"color":"6"},
		{"id":"0daddd3434b67fe6","type":"text","text":"# Applicazioni Principali\n\n\n- ***Structural Health Monitoring*** (***SHM***) - Hai costruito un ponte e sai che ci sono alcuni punti deboli da tenere sotto controllo per conoscere lo stato di degrado dell'intera struttura? Magari sono anche difficili da raggiungere? Niente paura, ci pensa la WSN!\n- ***Healthcare*** - \"Mai lasciare un anziano da solo\", ma lavori tutto il giorno? Dotalo di *un botto* di sensori wireless. Battito cardiaco, gait, controllo di caduta. Evolve now!\n- ***Security*** - Quale migliore sistema di monitoraggio per persone e ambienti di una grossa ragnatela wireless autosufficiente?\n- Qualunque monitoraggio di eventi geotermico-climatici su larga scala.","x":4542,"y":-300,"width":759,"height":304,"color":"4"},
		{"id":"10eedec3831487f5","type":"text","text":"# Wireless Sensors Network (WSN)\n\nUna WSN è praticamente un sistema RFID in cui i Tag sono attivi e il reader si chiama ***Sink***.\n\nI sensori raccolgono dati in giro e li mandano al Sink, e sono in grado di implementare funzioni complesse come ascoltare attivamente il canale e fare comunicazione multi-hop.\n\nPertanto sulle WSN è possibile utilizzare ***CSMA/CA*** e in generale i protocolli ***MAC*** come ***Sleeping-MAC*** (***S-MAC***), attualmente stato-dell'-arte.\n\nLa bontà del segnale viene generalmente valutata con il ***Signal Noise Ratio*** (***SNR***).\n\nPer tutti questi argomenti, cfr. ***Wireless LAN (WLAN)*** in alto a destra.","x":4542,"y":196,"width":759,"height":355,"color":"6"},
		{"id":"5d63270df240ccdf","type":"text","text":"# Deployment\n\nSe i sensori sono fissi, è verosimile che questi vengano disposti sul territorio secondo un ***Regular Deployment*** che sfrutta simmetrie e simili.\n\nSe i sensori sono mobili, spesso si comincia con un ***Random Deployment*** che viene poi affinato in un Regular (il quale però resta dinamico, in attesa di ulteriori necessità).\n\nDiverse situazioni portano a diversi algoritmi di deployment, nonché a diverse features della rete che si forma. Se collego una rete secondo un algoritmo di ***Minimum Spanning Tree*** avrò più efficienza energetica ma meno robustezza rispetto ai guasti, e viceversa se la configuro con una ***backbone*** (cfr. Esame di ***Network Algorithms***).\n\n","x":4542,"y":720,"width":759,"height":324,"color":"4"},
		{"id":"8686dd285ea55e0b","type":"text","text":"# Collision Avoidance\n\nChiaro che, per quanto detto finora, quando i sensori si scambiano messaggi questi possono collidere.\n\nNiente di incredibile, mi pare. Usa la sequenza RTS/CTS/DATA/ACK come in CSMA/CA. Quando riceve un messaggio di coordinamento aggiorna il suo NAV e sa quanto tempo deve aspettare per proporsi a sua volta.\n\nPer facilitare tutto questo, nelle implementazioni il tempo viene diviso in \"mini-slots\" entro i quali mandare una `SYNC`, una `RTS` o qualsiasi messaggio di coordinamento.","x":6600,"y":-1191,"width":759,"height":300,"color":"4"},
		{"id":"6005a469cd64c6fb","type":"text","text":"# Sprechi Energetici e Duty Cycle\n\nGli sprechi energetici sono dati da un eccesso di pacchetti inviati, a causa di\n\n- ***collisioni*** (e quindi continue ritrasmissioni);\n- ***control packets overhead***, i.e. troppi messaggi di coordinamento perché la struttura di rete non è ottimale.\n\nma anche se resto (immotivatamente) in ascolto quando\n\n- i pacchetti sono destinati ad altri (***overhearing***);\n- non c'è nessun messaggio da ascoltare (***idle listening***).\n\n***S-MAC*** ha la pretesa di risolvere tutto questo con il ***Duty Cycle***, al costo di un po' di latenza in più. Definisco che entro un periodo c'è una finestra del $10\\%$ (o di quanto serve per la rete in questione) di tempo in cui il sensore ascolta il canale.\n\nQuesto permette di risparmiare una grande quantità di energia (l'idle listening è *un botto* costoso), ma introduce la necessità di ***sincronizzazione*** tra nodi (i.e. non posso mandarti un messaggio se stai dormendo). Come?\n\n- Definiamo un ***synchronization period*** come una certa finestra temporale entro la quale i nodi possono scambiarsi le informazioni di sincronizzazione, i.e. dei pacchetti `SYNC` che constano di due pezzi: `SENDER ID` e `NEXT SLEEP TIME`;\n- Tutti i nodi iniziano il protocollo ascoltando il canale per un tempo $T\\ge\\text{SYNC Period}$ casuale, in attesa appunto di messaggi `SYNC`. Possono succedere due cose:\n\t- Se il nodo non riceve nessun messaggio `SYNC`, al termine del tempo di ascolto $T$ sceglie in modo casuale il proprio Duty Cycle e fa broadcast della propria `SYNC`. L'idea è che i ***primi vicini*** di tale nodo si sincronizzino con lui (i.e. devono essere svegli quando anche lui è sveglio, per poter scambiare messaggi). Se ciò accade, il nodo in questione viene chiamato ***Syncronizer***;\n\t- Se il nodo riceve un messaggio `SYNC` prima di aver scelto il proprio Duty Cycle, allora si adatterà al Duty Cycle del nodo da cui ha ricevuto la `SYNC`, diventando un ***Follower***. A questo punto attende un tempo casuale e fa a sua volta broadcast.\n- Questo in generale crea dei ***cluster*** aventi stesso Duty Cycle. Non è quindi in generale garantito che tutta la rete segua lo stesso ritmo. Al contrario, è verosimile che si formino dei ***nodi di frontiera*** che ricevono `SYNC` indicanti Duty Cycle differenti (e che in generale vengono salvati in una ***tabella degli schedule***). Questi ultimi dovranno rispettare entrambi i ritmi per permettere ai due cluster di comunicare, il che li porterà ad avere maggiore consumo energetico rispetto al resto della rete.","x":5552,"y":-1531,"width":759,"height":981,"color":"4"},
		{"id":"4a483510ba6510d1","type":"text","text":"# Classic Routing\n\nPer mandare un pacchetto ad un nodo, al solito, devo sapere dov'è, i.e. devo averlo nella mia tabella di routing. Queste possono essere costruite in tre modi:\n\n- ***Proactive*** - Aggiorno continuamente le tabelle con tutti gli elementi della rete, anche se non mi servono costantemente tutti. Questo mi porta a rispondere ad ogni cambiamento della rete (e.g. un nodo che si sposta o un collegamento cade);\n\t- Pro: So sempre dove mandare un pacchetto; Contro: Overhead;\n\t- Per un esempio vedi ***Destination Sequence Distance Vector*** (***DSDV***). In pratica è  ***Bellman-Ford*** con un meccanismo di ***Aging*** che associa ad ogni entry delle Routing Tables un codice sequenziale. Questo permette sia di preferire quelle più recenti sia di evitare i loop.\n- ***Reactive*** - Mi impegno a trovare la via per A solo se devo mandargli un pacchetto. \n\t- Se sei particolarmente pigro non la trovi nemmeno, ti limiti a fare ***flooding***. Scelta caotica, ma delle $N$ copie del pacchetto sono certo che almeno una arriverà a destinazione in tempo ottimale, al costo di intasare un po' la rete;\n\t- Se oltre che pigro sei anche pazzo fai flooding, ma solo ad alcuni neighbors scelti a caso (si chiama ***gossiping***, e direi che il suo allineamento è chaotic evil);\n\t\t- Meme a parte, nonostante palesemente sub-ottimali, entrambi i metodi possono essere utilizzati sul serio in situazioni in cui ho ***bassa potenza*** computazionale, ci sono ***pochi nodi***, o ***la rete è stata appena lanciata*** e bisogna essere certi di diffondere a tutti le informazioni di configurazione.\n\t- ***Dynamic Source Routing*** (***DSR***, RFC 4728) - Quando `A` manda un pacchetto a `B`, questo tiene traccia dei nodi per i quali è passato. Quando `B` riceve il messaggio, conosce automaticamente la route inversa;\n\t\t- Chiaramente il primo nodo che invia un pacchetto deve fare necessariamente ***route discovery***. Questo in genere avviene con un messaggio broadcast di tipo `Route Request`, al quale ogni nodo aggiunge il proprio tag in sequenza. Un messaggio di `Route Reply` viene quindi rispedito al mittente dal target;\n\t\t- Questo ovviamente porta ogni nodo ad avere diversi path per raggiungere lo stesso nodo. Se ho abbastanza memoria, la ridondanza è una cosa buona: se una route cade, posso subito provarne un'altra senza rifare la discovery;\n\t\t- <span style=\"color:#FFA500\">Fai una gif delle slides 57-58, pacco 4</span>\n\t- ***Ad-hoc On-Demand Distance Vector*** (***AODV***) - Un nome complicatissimo per dire \"faccio Bellman-Ford, ma solo se serve\". In pratica, prendi DSR e tieni traccia solo del `Next Hop` per andare verso la destinazione (i.e. costruisce una classica RT invece di salvare l'intero path verso la destinazione). Ogni nodo intermedio impara di conseguenza il reverse path.\n- ***Hybrid*** - Ci sono implementazioni che mixano questi due paradigmi.","x":5552,"y":1140,"width":759,"height":1036,"color":"4"},
		{"id":"7aa49a133421d2fb","type":"text","text":"# Algoritmo di Bellman-Ford (Reti)\n\nNasce dall'idea che se i costi cambiano *poco* voglio eseguire *poco* codice.\n\nL'inizializzazione è identica a Dijkstra: supponiamo di essere il router $u$ e di avere una stima $D_u(w) = 5$, mentre ad esempio $x$ avrà una stima $D_x(w) = 3$.\n\nA questo punto tutti i router inviano ai primi vicini le proprie stime. In particolare, $x$ comunica la sua stima $D_x(w)$ ad $u$, il quale ricalcola $D_u(w)$ tramite l'***equazione di Bellman-Ford***\n\n$$D_u(w) = \\min\\limits_{i}(c_{u,i} + D_i(w)) = \\min\\limits_{i}(\\text{distanza}_{ui} + \\text{minima distanza}_{iw})$$\n\ndove $i$ sono tutti e soli i primi vicini. Quando $i = x$, $u$ si accorge di aver trovato una stima migliore e la comunica ai propri primi vicini. $v$ riceve questa nuova stima ma la sua vecchia $D_v(w) = 3$ è ancora la scelta più conveniente, quindi non la aggiorna e non la comunica ai primi vicini. Riassumendo, ogni router\n\n- ***Attende*** la modifica del costo di un link a cui è direttamente collegato, oppure un messaggio da un router vicino;\n\t- Algoritmo ***asincrono*** - non ha un un *refresh rate* fisso, ma aspetta un evento. **Se in qualche modo non cambiano i costi, il router non calcola niente**;\n- ***Ricalcola*** le proprie stime;\n- Se cambiano, ***avvisa*** i vicini.\n\t- In quanto algoritmo ***distribuito*** nessun nodo conosce il percorso globale, e spesso il cambiamento dei costi influisce solo su una piccola parte di rete.\n\nNotare che ***l'informazione si propaga a velocità finita***, quindi quando il singolo router calcola le proprie stime lo sta in realtà facendo con dati vecchi. In realtà la velocità di propagazione dell'informazione dipende dal tipo di notizia, e porta a due ***comportamenti patologici***:\n\n- Le buone notizie si propagano velocemente. Questo può portare rapidamente ad una situazione di ***black-holing***, in cui un router pubblicizza dei costi molto bassi, il traffico viene massicciamente spostato su di lui e si crea un bottleneck;\n- Le cattive notizie si propagano lentamente, in particolare se si rompe un cavo si verifica il ***conteggio all'infinito***.\n\n\n\n","x":4542,"y":1221,"width":759,"height":873,"color":"4"},
		{"id":"4aed78c2b6e37591","type":"text","text":"ma se sincronizzo le posizioni con le bussole? ogni coppia definisce una retta, le intersezioni potrebbero essere nodi (o no) indagare, sembra figo","x":7410,"y":872,"width":490,"height":148},
		{"id":"d26761e26328fff8","type":"text","text":"# Geographic Routing\n\n\"Se devo raggiungere un nodo a nord, che senso ha propagare l'informazione a sud?\".\n\nEd è proprio da questa domanda che realizzo di poter sfruttare una ***topologia nota*** della rete (o comunque una conoscenza approssimativa della mia posizione e di quella del nodo destinazione, e.g. tramite ***GPS***) per evitare trasmissioni inutili.\n\nE quindi a chi mando il pacchetto? Ho diverse alternative:\n\n- ***Most Forward within Range*** - Scelgo il nodo entro la mia gittata che più si avvicina alla zona che voglio raggiungere (i.e. il più lontano da me, ma anche il più vicino al target);\n- Nearest Node with Forward Progress - Voglio avvicinarmi al target ma non voglio neanche consumare troppa energia, quindi scelgo il più vicino nodo che mi garantisce progresso nella direzione che mi interessa;\n- ***Directional Routing*** - Scelgo il nodo con la minima deviazione angolare rispetto alla direzione del mio target;\n- ***Geocasting*** - Mando il pacchetto a tutti i nodi di una zona geografica (e.g. emergency alert per la popolazione).\n\nI problemi principali di una cosa del genere sono\n\n- ***Buchi di copertura*** - Non ci sono nodi entro il mio range nella direzione di interesse;\n- ***Dead End*** - Tra me e il mio \"nodo ottimale\" c'è un muro;\n- ***Loops*** - Alcune strategie possono portare a cicli infiniti.","x":6560,"y":570,"width":759,"height":625,"color":"4"},
		{"id":"9cd14b09c257782c","type":"text","text":"# Who won? Who's next? You decide!\n\nManco a dirlo, la scelta dell'algoritmo migliore dipende dalla situazione.\n\n- I metodi proactive sono veloci ma causano un botto di overhead;\n- I metodi reactive sono efficienti ma ci mettono più tempo;\n- I metodi ibridi sono probabilmente quelli più utilizzati;\n- Geographic Routing permette di risparmiare energia, ma tocca conoscere la rete.","x":6560,"y":1538,"width":759,"height":241,"color":"4"},
		{"id":"7377628de440c4ef","type":"text","text":"flat network = no node is more powerful than the others","x":7660,"y":1639,"width":250,"height":140},
		{"id":"0c134d0d526830b1","type":"text","text":"# Slides 05 to gpt\n\nLe slide trattano il tema delle reti autonome di droni (UAV), includendo vari aspetti tecnici ed applicativi. Ecco una sintesi dettagliata:\n\n1. **UAV (Unmanned Aerial Vehicles)**: Droni che operano senza pilota umano a bordo. Possono essere controllati da remoto o autonomamente da un computer di bordo. Le caratteristiche variano ampiamente, con droni che pesano da 0.5 g a 15.000 kg e velocità massime fino a 11.265 km/h.\n\n2. **Motivi per l'uso di UAV**: Utilizzati in scenari critici come disastri naturali, operazioni di soccorso e consegne mediche in aree inaccessibili. Possono anche essere impiegati per monitoraggio del traffico, stime del vento, rilevamento incendi e operazioni militari.\n\n3. **Reti di Droni (DRONET)**: Più UAV vengono coordinati per missioni specifiche, come monitoraggio di ampie aree. Le sfide includono la comunicazione tra droni e la stazione di controllo e la necessità di trasferire grandi quantità di dati in ambienti difficili.\n\n4. **Problemi Principali**:\n   - Garantire comunicazione in assenza di infrastrutture di rete.\n   - Ottimizzare l'assegnazione dei compiti e la pianificazione delle traiettorie.\n   - Offload di dati continuo in aree vaste e complesse.\n   \n5. **DANGER**: Un esempio di rete drone utilizzata in operazioni di emergenza, dove i droni fungono da stazioni base volanti o nodi di relay per supportare le reti terrestri esistenti.\n\n6. **Routing nelle reti UAV**: Il protocollo di routing deve affrontare mobilità elevata, topologia fluida e consumo energetico, con lo scopo di ridurre ritardi, aumentare il tasso di consegna e risparmiare energia.\n\n7. **Protocolli di Routing**:\n   - **Proattivi**: Mantengono tabelle aggiornate della rete (es. OLSR, DSDV), ma non sono sempre adatti per reti di droni data la mobilità elevata.\n   - **Reattivi**: Trovano percorsi solo quando necessario (es. DSR, AODV), offrendo maggiore scalabilità.\n   - **Ibridi**: Combinano approcci reattivi e proattivi, bilanciando latenza e overhead (es. ZRP, TORA).\n   \n8. **B.A.T.M.A.N.**: Protocollo di routing proattivo sviluppato per reti mesh mobili, con gestione decentralizzata e multipli percorsi per destinazione. Ottimizza la trasmissione in scenari complessi come quelli delle reti di droni.\n\nQuesto riassume i principali temi delle slide, enfatizzando le sfide tecniche e le soluzioni proposte per gestire le reti di droni.","x":4412,"y":2999,"width":1020,"height":813},
		{"id":"11bd063ee8d2baf4","type":"text","text":"Il file caricato esplora diversi aspetti delle reti autonome di droni (UAV), la gestione delle reti mesh, e i protocolli di routing utilizzati in questi scenari. Di seguito una spiegazione dettagliata ma sintetica, come richiesto.\n\n### 1. **Reti Mesh e B.A.T.M.A.N.**\n   - **Rete Mesh**: Ogni nodo può agire come router, inoltrando dati agli altri nodi. Questo permette di avere più percorsi possibili tra i nodi, migliorando la robustezza della rete【11†source】.\n   - **B.A.T.M.A.N. (Better Approach to Mobile Adhoc Networking)**: Un protocollo di routing proattivo per le reti ad-hoc mobili e mesh. È decentralizzato, con ogni nodo che conosce solo il miglior vicino per raggiungere una destinazione. Le decisioni si basano sulla qualità del link【11†source】.\n\n### 2. **Funzionamento di B.A.T.M.A.N.**\n   - Ogni nodo invia periodicamente **Originator Messages (OGM)** per annunciare la propria presenza. Questi messaggi vengono inoltrati dai vicini, propagando le informazioni nella rete. Ogni nodo valuta la qualità del link basandosi su quanti OGM riceve dai vicini【11†source】.\n   - **Problema dei Link Asimmetrici**: In alcuni casi, i pacchetti inviati da un nodo (es. A) raggiungono il nodo B, ma B non riesce a inviare pacchetti ad A. Questo può portare a stime errate della qualità del collegamento. Per risolvere, viene usato l'algoritmo **Transmit Quality (TQ)**【11†source】【11†source】.\n\n### 3. **Protocolli di Routing Geografico**\n   - **Routing Geografico**: Basato sulla posizione dei nodi (es. GPS), riduce l'overhead poiché non richiede tabelle di routing o la scoperta dei percorsi. Solo le informazioni sui nodi vicini e sulla destinazione sono necessarie【11†source】.\n   - **GDSTR-3D**: Un esempio di protocollo geografico che seleziona il nodo più vicino alla destinazione come relay. Un problema può essere il **dead end**, dove un pacchetto non trova un nodo più vicino alla destinazione【11†source】.\n\n### 4. **Sfide e Algoritmi per l'Offloading dei Dati**\n   - In aree difficili, come le missioni di sorveglianza in zone vaste, i droni devono periodicamente scaricare i dati raccolti. Questo comporta la necessità di formare una topologia di rete efficiente, minimizzando il tempo e la distanza percorsa【11†source】.\n   - **Algoritmo DGA (Distributed Gathering Algorithm)**: Durante la fase di costruzione della topologia, un drone si ferma se è nel raggio di comunicazione del deposito o di un altro drone connesso. Altrimenti, si muove verso un punto di incontro più vicino【11†source】.\n\n### 5. **Valutazione delle Performance**\n   - Sono state effettuate simulazioni per valutare l'efficacia dell'algoritmo di offloading in un'area di 2.25 km² con velocità di 8 m/s e un raggio di trasmissione di 100 m. Le simulazioni durano circa 37 minuti e mirano a ottimizzare la connettività e la sincronizzazione dei droni【11†source】.\n\nIn sintesi, il documento esplora l'uso di protocolli di routing come B.A.T.M.A.N. per reti mesh, protocolli geografici per droni, e sfide tecniche legate all'offloading dei dati in reti UAV, con un focus sulle soluzioni distribuite.","x":4412,"y":3934,"width":1020,"height":1220},
		{"id":"9c36d33a9486dbca","type":"text","text":"# Protocolli MAC per DRONETs\n\n... non ci sono.\n\nTipicamente, i droni si basano su teconlogie già esistenti come il classico ***Wi-Fi*** (o varianti della famiglia ***802.11*** ) e la rete cellulare ***5G*** (ampia copertura, tramite l'implementazione delle ***slicing networks*** permette di dedicare ai droni bassa latenza e alta affidabilità).","x":3311,"y":1556,"width":759,"height":205,"color":"4"},
		{"id":"68e6c3596ea5dc88","type":"text","text":"# Routing in Ambiente Dinamico\n\nDal momento che parliamo di una rete ad-hoc, questa si auto-organizza dinamicamente al rapido variare delle posizioni dei nodi (in $\\tD$). Anche qui, diverse scelte come in WSN:\n\n- ***Proactive*** - Un esempio di protocollo di routing per UAVNETs è ***B.A.T.M.A.N.*** (***Better Approach To Mobile Ad-hoc Network***): ogni nodo agisce da router, tenendo in memoria solo l'hop successivo per la comunicazione. Il protocollo prevede un ***heartbeat*** detto ***Originator Message*** (***OGM***, sì, gli autori sono simpatici), che ogni nodo manda ai suoi vicini (i quali poi lo inoltrano ai propri, e così via). Ogni nodo può così valutare la ***qualità*** di ciascun canale di comunicazione dalla frequenza degli OGM ricevuti. Ora, questo potrebbe in linea di principio portare un nodo a sbagliare la stima di qualità del canale se questo è ***asimmetrico*** (e.g. `B` riceve tutti gli OGM da `A`, ma a ne riceve solo il $10\\%$. `B` pensa che il canale funziona bene, ma non è così). Questa cosa viene risolta dall'algoritmo di ***Transmit Quality***, che valuta il rapporto$$T_Q=E_Q/R_Q$$dove $E_Q$ è la ***Echo Quality*** (i.e. `A` si fa ritrasmettere i propri OGM e li conta) ed $R_Q$ è la ***Receive Quality*** (i.e. `A` conta semplicemente gli OGM di `B`). In questo modo ogni nodo è in grado di rendersi conto se il canale è asimmetrico;\n\t- Come nelle WSN, usano le RT e sono in genere ***troppo lenti*** rispetto a cambiamenti di topologia della rete, che invece accadono di frequente.\n- ***Reactive*** - ***DSR*** e ***AODV*** come nelle WSN, ma non credo siano molto utilizzati;\n- ***Hybrid*** - Protocolli con poco overhead e buona scalability (prendono il best of both worlds), ma sono spesso di difficile implementazione. Esempi sono ***ZRP*** e ***TORA***;\n- ***Geographic Routing*** - C'è sempre il problema del dead end, ma qui la questione si fa più interessante, perché è più verosimile che i droni abbiano il GPS. Tre tipi:\n\t- ***Greedy Forwarding*** - Il classico \"tra i nodi che posso raggiungere, scelgo quello più vicino al target secondo la distanza euclidea o qualsiasi cosa sia\";\n\t- ***Store-Carry-Forward*** - Se non ho modo di raggiungere il mio target node con una comunicazione multi-hop, mi tengo il messaggio e mi muovo nella direzione del target finché non incontro un altro nodo o il nodo target stesso;\n\t- ***Prediction*** - Se conosco posizione e velocità di un nodo, magari non serve che mi muovo io. Magari il mio target node viene verso di me, magari un altro nodo lontano sta andando verso il target node.\n\t\t- Se funziona è in teoria il più efficiente, in quanto \"***intelligente***\".","x":2331,"y":2094,"width":759,"height":931,"color":"4"},
		{"id":"63fd59600df38671","type":"text","text":"# Unmanned Aerial Vehicles (UAVs, i.e. Droni)\n\nGli UAV (o droni) sono oggetti mobili senza pilota, i cui obiettivi e dimensioni spaziano da semplici reti di sensori a bombardieri da guerra, spesso utilizzati in contesti pericolosi.\n\nUna UAVNET (o DRONET) è una rete di droni che cooperano per raggiungere un obiettivo, spesso scambiando un'enorme mole di dati.\n\nCi sono 4 problemi principali da risolvere in una DRONET:\n\n1. Come comunicare senza un'infrastruttura fissa (e.g. 5G)? Necessario se la DRONET è utilizzata in situazioni di emergenza;\n2. Come selezionare le traiettorie ottimali? Un problema multi-drone multi-depot con minimizzazione dei consumi energetici o del tempo di volo è più complesso di un semplice multi-TSP (cfr. esame di ***Network Algorithms***);\n3. Come scambiare informazioni in real-time tra tutti i membri della rete? Bisogna implementare un protocollo di ***Routing***;\n4. Come fare un periodic offload dei dati? Un esempio è l'algoritmo ***Step&Route***.","x":2331,"y":1424,"width":759,"height":469,"color":"6"},
		{"id":"560eac5d2c69c1d2","type":"text","text":"# Stop & Route\n#### A Gathering Algorithm for Periodic Data Offloading\n\nUna roba pubblicata da Maselli, Bartolini e compagni di merende per ottimizzare il data offloading di una rete di droni verso un depot che periodicamente manda degli heartbeat.\n\nDiscretizzo lo spazio e controllo chi ho in range.\n\n- Se c'è qualcuno più vicino al depot rispetto a me, questo diventa il mio ***leader*** (e io di conseguenza divento un ***follower***). Mi limito a seguire il leader;\n- Se c'è qualcuno che può raggiungere il depot (il quale, da protocollo, quando se ne rende conto si ferma), gli mollo i dati e ci pensa lui;\n- Se non c'è nessuno dei precedenti, mi muovo verso il depot.\n\nRisultati sperimentali: `Sì, sta roba funziona bene`.","x":1240,"y":1452,"width":759,"height":413,"color":"4"},
		{"id":"d91339e82a54fbfa","type":"text","text":"# Wireless Sensor Network (WSN)\n\nsensori che mandano dati al sink (cervellone centrale). can sense the channel and spontaneously send data to anyone. also can run protocols.\nlimited transmission rate -> multi-hop.\n\nle applicazioni sono senza fine, quello che puoi immaginare in qualche modo lo puoi anche realizzare\n\ntre elementi fondamentali:\n\n- sensori che raccolgono dati dall'ambiente\n- sink che li raccolgono dai sensori ed eventualmente ci fanno cose\n- actuators che fanno cose sulla base dei dati elaborati dai sink o chi per loro\n\ncome piazzo i sensori in giro? ... dipende dalle necessità. a volte una geometria regolare è comoda. alcuni li posso anche muovere in corso d'opera (tipo i droni).\n\n- scalability - le performance non calano al crescere dei nodi\n- poca potenza a disposizione e poca energia -> serve efficienza\n- asymmetric flow of info sensore->sink (e non posso mandare segnali da un controller? o avere un drone controller in posizione strategica?)\n- lifetime - se muore un critical node ciao ciao network\n- re-programmability - quello che dicevo prima\n- deve adattarsi ai cambiamenti (anche con RL) tipo clima che cambia o un nuovo sensore nella rete\n- data centric networking non mi piace, è limitante ma forse è utile in qualche situazione specifica (semplifica i protocolli probabilmente, li rende efficienti)\n- locality è per evitare overhead di messaggi in giro per la rete (che di nuovo rende i protocolli inefficienti)\n","x":8440,"y":-671,"width":680,"height":867},
		{"id":"b15d348eb6b0ef51","type":"text","text":"# Roba da IoT\n\nSeguono esperimenti in cui hanno realizzato un controller da gioco (SapyJoy) ed un mouse battery-free. Il reaction time misurato è simile a (se non migliore di) quelli a batteria.\n\nSi possono addirittura creare controller dallo spessore di un foglio di carta (JoyPaper).\n\nBello, ma un conto è misurare le performance di un unico Tag RFID isolato, altro conto è se ce ne sono altri. Cosa succede in quel caso?\n\n... non ho capito, si è solo posta la domanda?\n\n\n\n\nMooTag, EPC Global Standard (EPC Gen 2 Class 1), USRP.","x":4542,"y":-1386,"width":759,"height":686,"color":"3"},
		{"id":"35df43790e0bcb33","type":"text","text":"# Internet of Things (IoT)\n\nUn piatto a base di RFID e WSN che unisce il concetto di Tag (i.e. back-scattering) e di sensore per dire che in fondo qualsiasi oggetto può interagire EM (ergo informatico).\n\nIl risultato è una sorta di internet in cui i nodi sono oggetti di qualsiasi tipo (da cui il nome) in grado di essere ***identificabili*** (i.e. ogni nodo ha almeno un nome ed un indirizzo fisico), di ***comunicare*** tra loro e di ***interagire*** con l'ambiente (sia con ***sensors***, i.e. una WSN, che con ***actuators***, i.e. una ***SANET***, Sensors and Actuators Network).\n\nLa bassa potenza non consente di implementare complesse stack protocollari, ma tali nodi devono al contempo fornire minime garanzie di localizzazione, auto-organizzazione in reti mesh e sicurezza (soprattutto nel senso della privacy).\n\nIl back-scattering può essere ottenuto in due modi:\n\n- ***Ambient*** - Se devo scambiare pochi dati e poco importanti, posso sperare di trovare l'energia che mi serve un po' a caso dall'ambiente circostante;\n- ***RFID*** - C'è un reader che mi fornisce esplicitamente l'energia necessaria\n\t- Accelerometro e camera di un telefono funzionano esattamente così;\n\t- Pare abbiano realizzato un controller e un mouse che risultano così battery-free.\n\nDividiamo infine le reti in\n\n- ***Infrastructure-Based*** - Rete mobile tradizionale, Wi-Fi. Ci sono delle antenne centrali alle quali sono connessi i dispositivi, muoversi significa cambiare cella;\n- ***Infrastructureless-Based*** - Ne è un esempio la car-to-car communication. In assenza di una central authority, i partecipanti devono auto-regolamentarsi.","x":3532,"y":-1386,"width":759,"height":686,"color":"6"},
		{"id":"8849ff2d9d118604","type":"text","text":"# Slides 06 to gpt\nLe slide trattano principalmente l'Internet of Things (IoT) e l'idea di dispositivi IoT senza batteria. Ecco una spiegazione sintetica ma dettagliata:\n\n### 1. **Internet of Things (IoT)**\n   - **Oggetti Smart**: Sono oggetti fisici con elettronica integrata, che permettono loro di comunicare e interagire. Questi includono smartwatch, smart TV, ma anche auto, case e città intelligenti【17†source】.\n   - **Definizione di IoT**: Si riferisce a:\n     1. La rete globale che connette oggetti intelligenti tramite tecnologie internet estese.\n     2. Le tecnologie di supporto necessarie per realizzare questa visione.\n     3. Le applicazioni e i servizi che sfruttano queste tecnologie per creare nuove opportunità di business【17†source】.\n\n### 2. **Pilastri dell'IoT**\n   - Gli oggetti intelligenti devono:\n     1. Essere identificabili.\n     2. Comunicare.\n     3. Interagire tra loro o con utenti ed entità nella rete【17†source】.\n\n### 3. **Caratteristiche di un Oggetto Smart**\n   - Un oggetto smart ha un corpo fisico, capacità di comunicazione, è associato a un nome e un indirizzo, ha capacità di calcolo, e può percepire fenomeni fisici (es. temperatura, movimento) o agire sull'ambiente【17†source】.\n\n### 4. **Dispositivi Chiave nell'IoT**\n   - L'IoT include dispositivi con capacità di comunicazione e calcolo molto limitate, come quelli studiati nelle reti RFID e WSN (reti di sensori senza fili). Questi dispositivi agiscono come fornitori o consumatori di dati legati al mondo fisico【17†source】.\n\n### 5. **Caratteristiche Richieste per l'IoT**\n   - **Eterogeneità dei dispositivi**: Capacità di gestire dispositivi con diverse capacità di calcolo e comunicazione.\n   - **Scalabilità**: Riguarda la gestione dei nomi, la comunicazione, la rete, e la fornitura di servizi.\n   - **Ottimizzazione energetica**: Cruciale per dispositivi con capacità limitate【17†source】.\n   - **Sicurezza e privacy**: Deve essere integrata per garantire accettazione e adozione【17†source】.\n\n### 6. **Tecnologie Abilitanti**\n   - Tecnologie chiave come le reti di sensori wireless e RFID sono essenziali per identificare e abilitare l'interazione degli oggetti smart con l'ambiente【17†source】.\n\n### 7. **Dispositivi senza Batteria**\n   - **Backscattering**: Tecnologia che permette ai dispositivi di funzionare senza batterie, riflettendo i segnali radio esistenti per alimentarsi【17†source】.\n\nIn sintesi, queste slide esplorano il concetto di IoT, le sue tecnologie abilitanti, le sfide come l'efficienza energetica e la sicurezza, e introducono nuove soluzioni come il backscattering per dispositivi senza batteria.\n\n\nEcco una spiegazione dettagliata ma concisa delle slide che hai fornito:\n\n### 1. **Nuovo tipo di dispositivo: oggetti smart senza batteria**\n   - Si propone di riprogettare gli oggetti intelligenti in modo che non abbiano bisogno di batterie. La soluzione a questo è la **retrodiffusione** (backscattering), che riflette i segnali da cui provengono.\n   - Questi dispositivi utilizzano i segnali a radiofrequenza (RF) come fonte di energia per svolgere attività di rilevamento, calcolo e trasmissione dati.\n\n### 2. **Tipologie di retrodiffusione**\n   - **Ambientale**: sfrutta segnali RF già presenti nell’ambiente, come TV o Wi-Fi, senza necessità di un dispositivo di emissione dedicato.\n     - Svantaggi: bassa velocità di trasmissione dati e limitata disponibilità di segnali, soprattutto in ambienti interni.\n   - **RFID**: utilizza un lettore RFID per alimentare dispositivi senza batteria, permettendo loro di inviare informazioni attraverso la riflessione del segnale.\n\n### 3. **Tag RFID con sensori integrati**\n   - I tag RFID possono essere potenziati con sensori come PIR, fotocamere o accelerometri per rilevare eventi (ad esempio movimento), con applicazioni in scenari come case smart.\n   - Svantaggi: potenza limitata, raggio d'azione breve e capacità di memoria ridotta.\n\n### 4. **Casa smart senza batteria**\n   - Viene presentata una possibile architettura per una casa intelligente basata su dispositivi RFID senza batteria. Questi possono monitorare vari aspetti dell’ambiente, come la temperatura, comunicando con applicazioni su smartphone o server.\n   - Un nuovo protocollo MAC, chiamato **APT-MAC**, è stato sviluppato per gestire i tempi di risposta e ridurre la perdita di dati, permettendo al sistema di adattarsi automaticamente ai requisiti di trasmissione dei dispositivi.\n\n### 5. **Dispositivi realizzati**\n   - Vengono descritti vari dispositivi senza batteria, come un joystick per videogiochi, un interruttore per luci, e un telecomando per un bollitore. Questi dispositivi utilizzano la retrodiffusione RFID per funzionare senza necessità di ricarica.\n\n### 6. **Esperimenti e prestazioni**\n   - Gli esperimenti mostrano che questi dispositivi possono avere tempi di reazione accettabili, anche paragonabili ai dispositivi alimentati a batteria. Ad esempio, il controller per videogiochi ha un tempo di reazione di circa 92 ms, comparabile a quello di un mouse o controller commerciale.\n\n### 7. **Problemi di interoperabilità**\n   - Quando più dispositivi senza batteria operano contemporaneamente, il tempo di reazione aumenta, rendendo la gestione della comunicazione una sfida. Il protocollo deve essere in grado di assegnare le risorse di canale in modo efficiente per soddisfare le esigenze diverse dei dispositivi.\n\nIn sintesi, queste slide trattano l'uso della tecnologia RFID e della retrodiffusione per creare oggetti smart senza batteria, evidenziando i vantaggi e le sfide, in particolare l'interoperabilità e la gestione delle risorse di comunicazione in ambienti multi-dispositivo.","x":6877,"y":-4160,"width":1067,"height":2757},
		{"id":"2795cbd69099d104","type":"text","text":"# Autonomous Network (AN)\n\nQuand'è che una rete è ***autonoma***?\n\n- Una volta configurata, ***non servono indicazioni o risorse aggiuntive***;\n\t- i.e. ***self-governance*** e ***self-sufficiency***.\n - È \"intelligente\", nei limiti dell'AI (i.e. si adatta ai cambiamenti ambientali e/o li prevede), usando il ***reinforcement learning***.\n\t - i.e. l'***Embedded Intelligence*** deve essere in grado di fornire una ***Proactive Response*** a ciò che accade nelle sue vicinanze, possibilmente imparando dall'ambiente se le condizioni non sono quelle che si aspetta fin da subito.\n","x":-330,"y":212,"width":759,"height":318,"color":"6"},
		{"id":"241a50c4268e0c2e","type":"text","text":"# Reinforcement Learning (RL)\n\nIl Reinforcement Learning è un processo ***trial-and-error*** che tenta di apprendere una buona sequenza di decisioni ***in tempo reale*** basandosi sui feedback dell'ambiente circostante.\n\nSe la sequenza di azioni è buona, dopo un certo periodo di tempo ci saranno dei \"premi\" (***delayed rewards***) sotto forma di punteggi, che indicano in generale quanto bene si sta comportando l'agente nel processo di apprendimento. E il delay? La sequenza può avere effetti a lungo termine, pertanto il vero beneficio potrebbe emergere solo in seguito.\n\nLa logica di scelta delle azioni da prendere è quindi provare a massimizzare i reward futuri. È quindi un processo ***unsupervised*** e ***senza training*** (che avviene appunto \"online\").","x":-3920,"y":212,"width":759,"height":318,"color":"6"},
		{"id":"81ade21fad6371fb","type":"text","text":"# Battery-Free Smart Home\n\nIl punto di sta roba è il seguente: ho una smart home con un botto di dispositivi che devono scambiarsi dati. Alcuni li producono in modo ***bursty*** (e.g. il mouse, i.e. solo se lo sposto, e se lo faccio ne produce un botto), altri sono ***Tag RFID passivi*** e hanno bisogno di un reader che oltre ad essere efficiente con i Tag non deve scontrarsi con gli altri dispositivi (che, nota, in generale potrebbero essere anche droni per portare le medicine a letto al nonno, per quanto ne sappiamo. I quali oltretutto si spostano!).\n\nDisegnare un protocollo MAC per un simile environment è follia. Allora uso il RL.\n\nCostruiamo i rewards nel seguente modo:\n\n- ***++*** se lo scheduler fa parlare un device che ha nuovi dati da scaricare;\n- ***- -*** se al contrario il device non ha nulla da dire.\n\n\n\n... e basta?????","x":-4929,"y":-997,"width":759,"height":792,"color":"3"},
		{"id":"ec91651bdd90f0d5","type":"text","text":"# Un piccolo dilemma\n\nSe vado a mangiare sempre nello stesso ristorante, sono sicuro di cascare bene, ma potenzialmente mi perdo posti ancora migliori. Se provo sempre nuovi posti, è verosimile che cascherò male diverse volte. Devo bilanciare queste due cose.\n\nUna Agent di RL ha questo stesso problema: se sfrutta le buone conclusioni che ha tratto finora otterrà dei reward, ma è anche il caso di esplorare altre possibilità alla ricerca di opzioni ancora migliori. Tutta sta pippa si chiama ***exploration-exploitation dilemma***.","x":-2911,"y":880,"width":759,"height":259,"color":"4"},
		{"id":"c3c700746f35cbed","type":"file","file":"RL_Scheme.png","x":-3740,"y":-1520,"width":400,"height":391},
		{"id":"dec5f256d7b4cce1","type":"text","text":"# Rapido Glossario\n\nAd ogni tempo $t$ possiamo così schematizzare l'interazione tra Agent ed Environment:\n\n- L'Environment fornisce all'Agent due tipi di dati:\n\t- Il suo stato (parziale), che per l'agent costituisce un'***osservazione*** $O_t$;\n\t- Un ***reward*** $R_t$ che rappresenta la conseguenza di tutte le azioni passate.\n- Sulla base di questo, l'Agent produce un'***Azione*** $A_t$.\n\nDefiniamo quindi\n\n- ***History*** - Lo storico $H_t$ di tutte le sequenze $\\{O_i,R_i, A_i\\}$ fino al tempo $t$;\n\t- Possiamo interpretarla come l'***esperienza*** dell'Agent.\n- ***Stato*** - Una funzione $S_t=f(H_t)$ utile ad evidenziare le informazioni più rilevanti.\n\t- Possiamo definire entrambe queste grandezze sia per l'Environment ($S^E_t$) sia per l'Agent ($S_t^A$). Idealmente, i.e. in condizioni di ***piena osservabilità***, l'Agent conosce perfettamente lo stato dell'Environment, i.e. $S^A_t=S^E_t$. Più comunemente, l'Agent ne conosce solo una parte (i.e. ***parziale osservabilità***, $S^A_t\\ne S^E_t$);\n\t- Lo stato costituisce l'***esperienza pesata con l'importanza*** degli eventi accaduti, e serve quindi a predire quello che potrebbe succedere in futuro.\n\nQuando mi trovo in uno stato e ricevo dall'Environment un'informazione di osservazione $O_t$ ed un reward $R_t$, quello che resta da fare è prendere una decisione (i.e. eseguire un'azione $A_t$). Vorrei in generale muovermi verso uno stato migliore di quello che lascio, il che significa che mi serve una misura di quanto è \"buono\" uno stato. Questo dipende dalla mia ***policy*** $\\pi$. Se ad esempio vogliamo massimizzare i reward futuri dando via via meno peso a ciò che accade nel futuro più lontano possiamo usare una ***Value Function*** così definita:$$V_\\pi(s)=\\E_\\pi\\bigg[\\sum_{i=1}\\g^{i-1} R_{t+i}\\,\\,\\bigg|\\,\\,S_t=s\\bigg]$$dove $\\g<1$ è detto ***discount factor***.","x":-3920,"y":-997,"width":759,"height":792,"color":"4"},
		{"id":"b05056eaa2e4856d","type":"text","text":"# RL At Glance\n\nL'Agent non sa a priori in che modo le azioni che prenderà influiranno sull'ambiente che lo circonda. Deve quindi ***apprendere empiricamente*** le buone sequenze dall'***esperienza***.\n\nIl tempo per un RL Agent è un po' come per noi: una volta presa una decisione prima o poi ne vedremo i risultati, e non sappiamo cosa sarebbe invece successo se avessimo preso un'altra decisione. Questo divide la vita in due macro-periodi che si alternano:\n\n- ***Planning*** - Scegliamo cosa fare ragionando sia sul breve che sul lungo termine;\n- ***Learning*** - Quando facciamo i conti con quello che abbiamo raccolto, non sempre è chiaro a quale azione è dovuto un risultato positivo o negativo.\n\nIl risultato di questo alternarsi è la creazione di una ***policy*** $\\pi$, i.e. un modo di tradurre la propria esperienza in azioni \"ottimali\" da prendere. Visto il grosso punto interrogativo che troneggia sul futuro del mondo, è da folli scrivere una policy pre-programmata.\n\nLa generalizzabilità del processo di apprendimento passa per l'ammissione che non possiamo conoscere in anticipo tutte le situazioni che si possono presentare, ma possiamo avere un'idea di come affrontarne di nuove basandoci su ciò che abbiamo già fatto. Si può al più eventualmente partire da un ***modello*** atteso di Environment che verrà poi però in ogni caso integrato con l'esperienza: \n\nPossiamo quindi valutare il modello in base a\n\n- ***Robustness*** - Quanto l'agent è in grado di performare bene in ambienti sconosciuti, evitando al contempo di essere troppo sensibile a piccole variazioni;\n- ***Risk Sensitivity*** - Come il modello gestisce l'incertezza. Spesso si preferiscono strategie che minimizzano i rischi.\n\nTutto ciò si applica in campi quali guida autonoma, healthcare, social media (Meta ha sviluppato un algoritmo di RL, Horizon, per ottimizzare i contenuti offerti all'utente), gaming, NLP, robotica e insomma qualsiasi cosa ok basta.","x":-2910,"y":-997,"width":759,"height":792,"color":"4"},
		{"id":"b3834f78c48047d1","type":"text","text":"# $K$-Armed Bandit Problem, Greedy Solutions\n\nL'Agent può scegliere tra $K$ diverse azioni, ognuna delle quali ha un reward casuale (i.e. distribuito in modo ignoto). Il problema dell'Agent è quindi provare a ricostruire la pdf dei reward per capire cosa è meglio fare, i.e. scegliere al meglio tra $K$ possibili azioni.\n\nPartiamo quindi cercando un valore atteso. L'***Action Value*** $q$ associato all'azione $a$ è definito come il valore atteso del reward che arriverà se scegliamo di mettere in atto $a$, i.e.$$q(a):=\\E[R_t\\,|\\,A_t=a]$$\nIn mezzo a $K$ scelte questo si traduce nel trovare sperimentalmente la quantità$$Q_t(a):={{\\text{sum of rewards after choosing }a}\\over \\text{how many times I chose }a}={\\sum_kR_i\\,\\d(A_k=a)\\over\\sum_k\\d(A_k=a)}$$i.e. per ogni azione $k$ a qualsiasi istante posso valutare $Q$ come$$Q^k={1\\over N^k}\\sum_{i=1}^{N^k}R_i^k$$\nQuesta grandezza, detta ***Q-Value***, approssima sempre meglio il valore atteso man mano che procedo con l'esplorazione (cfr. Legge dei Grandi Numeri). Però oltre ad esplorare devo anche sfruttare i buoni risultati che trovo, quindi non è mai ovvio qual è il modo migliore per scegliere la prossima azione, anche se ho abbastanza dati per estrarre alcune probabilità. Vediamone allora un paio.\n\n- ***Random*** - Old but gold, anche se più vado avanti più diventa un criterio sciocco;\n- ***Greedy*** - Scelgo l'azione con il più alto $Q$. Ovviamente problematico, perché potrei finire molto rapidamente in un \"minimo locale\", scegliendo sempre la stessa azione;\n- $\\e$***-Greedy*** - Come prima, ma con un piccola probabilità $\\e$ invece di fare la scelta ottimale fanne una random tra tutte le azioni possibili (anche quella ottimale...!).\n\nIn alternativa, posso aggiornare dinamicamente (o ***incrementalmente***) la stima di $Q$ come$$Q_{n+1}={1\\over n}\\sum_iR_i=[...]=Q_n+{1\\over n}\\bigg[R_n-Q_n\\bigg]$$Questo mi permette di fare un'osservazione. Tutto questo discorso va bene per ***problemi stazionari***, i.e. le pdf non cambiano nel tempo. Ma le $\\text{pdf}$ possono in generale essere delle $\\text{pdf}(t)$ (***problemi non-stazionari***). E allora che faccio? Mi rendo conto che quel termine ${1\\over n}$\nfa in modo che le correzioni alla mia stima attuale siano sempre più piccole. Ma se $Q$ può cambiare voglio che i nuovi rewards pesino di più. Allora ridefinisco$$Q_{n+1}=Q_n+\\a\\bigg[R_n-Q_n\\bigg]$$dove $\\a$ è una costante detta ***step size***, che definisce quanto pesa l'ultimo feedback che ho ricevuto. In pratica significa$$\\text{New Estimate}\\leftarrow \\text{Old Estimate}+\\text{Step Size}\\bigg[\\text{Reward} - \\text{Old Estimate}\\bigg]$$","x":-3920,"y":880,"width":759,"height":1154,"color":"4"},
		{"id":"0a27aebf7145e0bf","type":"text","text":"# Optimistic Initial Values\n\nCome $\\e$-greedy, ma partiamo da un'efficacia prevista del $100\\%$ per tutte le azioni. Dal momento che sono tutte ottimali, l'Agent inizia scegliendo a caso finché una non fallisce. A quel punto l'Agent, visibilmente offeso, inizia a scegliere solo tra le altre. E via dicendo.\n\nQuesto permette una buona esplorazione e al contempo una frequente exploitation delle scelte migliori.","x":-2911,"y":1343,"width":759,"height":229,"color":"4"},
		{"id":"af010e14b89df601","type":"file","file":"GreedyPerformance.png","x":-2911,"y":2160,"width":759,"height":342},
		{"id":"7f463e2b6fea84e0","type":"text","text":"# Upper Confidence Bound (UCB)\n\nFin qui abbiamo parlato di pdf, ma abbiamo calcolato solo valori attesi. È il momento di introdurre nella discussione la ***deviazione standard***. E come la uso?\n\nSe la $\\s$ della pdf di un'azione è alta, significa che è importante approfondire i suoi effetti: potrebbe rivelarsi la migliore. O meno, naturalmente, il punto è che mi serve più certezza.\n\nIl principio di \"***ottimismo di fronte all'incertezza***\" ci dice sostanzialmente di buttarci a testa bassa verso le azioni con la $\\s$ più alta. In particolare, posso scegliere di seguire la logica dell'***Upper Confidence Bound*** (***UCB***): non guardo al $Q$-value più alto, ma a quello che diventa il più alto se gli sommo la sua $\\s$. Questo si traduce nel dire che$$A_t=\\text{argmax}\\bigg[Q_t(a)+C\\sqrt{{\\ln t\\over N_t(a)}}\\bigg]$$dove quella radice non è propriamente una deviazione standard, piuttosto un suo ***proxy*** (i.e. un modo *fancy* per dire che è una sua approssimazione), essendo $t$ il numero totale di scelte effettuate ed $N_t(a)\\le t$ il numero di volte che è stata scelta l'azione $a$.\n\nSta roba ***è più intelligente di quanto sembra***. Se $a$ viene scelta spesso, la frazione sotto radice decresce rapidamente, lasciando possibilmente spazio alle altre azioni. Se tuttavia $a$ non viene scelta da un po' (perché magari ho trovato un'altra azione $b$ il cui valore medio è maggiore dell'upper bound di $a$), la frazione, seppur lentamente, riallargherà l'incertezza, riportando l'upper bound in alto. Questo farà dire al modello una roba tipo `ah aspe, c'era anche questa possibilità che non provo da un po', fammi vedere come va...`. Non sorprende quindi che i nomi di quei due termini siano$$A_t=\\text{argmax}\\bigg[\\text{Exploitation}+\\text{Exploration}\\bigg]$$e che la costante $C$ sia detta ***exploration-exploitation trade-off coefficient***, per gli amici ***exploration coefficient***: alti valori di $C$ danno più importanza all'esplorazione, e viceversa.\n\nTutto ciò è molto bello ma è un po' ***lento ad adattarsi a problemi non-stazionari***.","x":-3920,"y":2160,"width":759,"height":817,"color":"4"},
		{"id":"1b960a10645a8931","type":"text","text":"# Performance Evaluation\n\nFissando il numero di possibili azioni a $K=10$, i risultati sperimentali mostrano in che modo il modello trova le distribuzioni per ciascuna delle $10$ azioni. I risultati mostrano che\n\n- $\\e$-Greedy performa meglio nel setup classico di $Q$-value come media statistica che parte da $0$, ma le performance dipendono fortemente dalla scelta di $\\e$;\n- Simple Greedy performa ancora di meglio di $\\e$-Greedy se lo si accoppia ad Optimistic Initial Values, ma non è adatto a situazioni dinamiche in cui le pdf sono $\\text{pdf}(t)$ perché l'esplorazione avviene tendenzialmente all'inizio.","x":-2911,"y":1744,"width":759,"height":290,"color":"4"},
		{"id":"ce567157a24941d9","type":"file","file":"Starting10ArmsDistributions.png","x":-2004,"y":1744,"width":437,"height":290},
		{"id":"21c067b9f8222074","type":"file","file":"10ArmsDistributions.png","x":-1913,"y":1744,"width":437,"height":290},
		{"id":"61c71f856f65004b","type":"text","text":"# RL\n\nC'è un agent che ha diverse azioni da poter compiere. Ogni azione ha un reward casuale distribuito in modo ignoto. L'agent prova a ricostruire la pdf dei reward per capire cosa fare. Il $Q$ value di R è una probabilità statistica che R sia la scelta giusta (la valuto facendo, e.g., tante prove random e vedendo che succede).\n\nMa poi, come scelgo l'azione una volta che ho le probabilità?\n\n- random\n- highest Q (greedy action) - potrebbe essere problematico, perché potrei finire a scegliere sempre la stessa azione. Oltre ad exploitare (quella che so essere la buona scelta) dovrei anche esplorare le altre possibilità.\n\t- $\\e$-greedy - sii greedy, ma con piccola probabilità $\\e$ scegli random tra tutte le scelta (anche quella ottimale...!)\n\n$$Q^k={1\\over N^k}\\sum_{i=1}^{N^k}R_i^k$$sull'azione k. Se al generico step ottengo un reward 2 per l'azione k che aveva già ottenuto i reward 2 e 1, abbiamo $Q^k=5/3$.\n\nalternative al Q-value? rearranging quaa robba sopra trovo che\n\n$$Q_{n+1}={1\\over n}\\sum_iR_i=[...]=Q_n+{1\\over n}\\bigg[R_n-Q_n\\bigg]$$che in pratica significa$$\\text{New Estimate}\\leftarrow \\text{Old Estimate}+\\text{Step Size}\\bigg[?\\bigg]$$\ntutta sta roba si chiama bandit. le $pdf$ sono $pdf(t)$, ma l'agent non lo sa. e che fa? campiona. Ora, potrei cambiare lo step size e renderlo una costante $\\a$ (tipo $0.5$). Questo permette di modellizzare stationary problems? Non ho capito\n\n$$Q_n+\\alpha[R_n-Q_n]=[...]=(1-\\a)^nQ_1+\\sum\\a(1-\\a)^{n-i}R_i$$","x":-2815,"y":3220,"width":567,"height":1028},
		{"id":"3276e8832bd5b673","type":"file","file":"UCBPerformance.png","x":-2911,"y":2604,"width":759,"height":373},
		{"id":"86dd9248d0795405","type":"file","file":"OptimisticGreedyPerformance.png","x":-1900,"y":1278,"width":800,"height":360},
		{"id":"d1f5251fd2d62f35","type":"text","text":"# Markov Reward Processes (MRP)\n\nOgni mossa in una CdM determina non solo un reward (la freccia per raggiungere lo stato in sé), ma anche i possibili reward futuri (gli stati da lì accessibili, e così via). Vediamo quindi che il $K$-Armed Bandit è una CdM con un solo stato le cui azioni disponibili corrispondono a diverse frecce di loop. La generalizzazione è dunque$$q(a)\\to q(s,a)$$dove l'azione $a$ deve essere accessibile dallo stato $s$. Per tutte le proprietà delle CdM, cfr. esame di ***Computer Network Performance***.\n\nSe aggiungiamo un ***reward*** al raggiungimento di ogni stato possiamo calcolare il reward cumulativo di ogni possibile percorso come media pesata sulle probabilità. Spesso a tutto questo si aggiunge il ***discount factor*** $\\g$, in modo tale che il ***return value*** sia dato da$$G_t=R_{t+1}+\\g R_{t+2}+...=\\sum_{k=0}^\\infty\\g^kR_{t+k+1}$$dove ovviamente valori prossimi a $0$ fanno concentrare il modello sul breve termine e valori prossimi a $1$ tendono a pesare in modo uniforme i reward futuri. Questo ha come obiettivo quello di far convergere la serie (ovviamente), il che si traduce nell'evitare percorsi ciclici.\n\nPossiamo quindi definire una ***funzione di stato*** per i ***Markov Reward Processes*** (***MRP***):$$V_s=\\E\\bigg[G_t\\,\\bigg|\\,S_t=s\\bigg]=R_s+\\sum_{s'}\\calP(s\\to s')V(s')$$dove $\\calP$ è la ***matrice di transizione*** in un solo step, e di conseguenza i vari $s'$ diventano tutti gli stati raggiungibili in un solo step da $s$. Questa roba si chiama ***Bellman Equation***, e fa un po' le veci della probabilità stazionaria (nel senso che è la nostra unica certezza in mezzo alla complessità di una CdM). $V_s$ rappresenta una misura di quanto è mediamente \"buono\" lo stato $s$ indipendentemente da quando ci sono finito.\n\nNota che in tutto questo ***i reward vengono assegnati DOPO aver lasciato lo stato***, e che quindi $R_{t+1}$ è il reward associato allo stato in cui ero al tempo $t$. Questo significa che se $\\g=0$ allora la misura $V_s$ di bontà dello stato $s$ è data unicamente dal suo reward.","x":-4929,"y":1032,"width":759,"height":850,"color":"4"},
		{"id":"a22235297696c98b","type":"file","file":"MRP.png","x":-4929,"y":2011,"width":334,"height":299},
		{"id":"43974ae3fb552c0f","type":"file","file":"MRP_StateValuesGamma1.png","x":-4504,"y":2011,"width":334,"height":299},
		{"id":"cb16818f4911f671","type":"text","text":"# Bellman Equation\n\nIn sto corso c'è letteralmente una sola dimostrazione. Facciamola.\n\nPartiamo dalla definizione di ***Value Function*** come valore atteso del ***Return Value***$$V_s=\\E\\bigg[G_t\\,\\bigg|\\,S_t=s\\bigg]=\\E\\bigg[R_{t+1}+\\g R_{t+2}+\\g^2R_{t+3}+...\\,\\bigg|\\,S_t=s\\bigg]$$Raccogliamo $\\g$ e notiamo che$$V_s=\\E\\bigg[R_{t+1}+\\g\\big(R_{t+2}+\\g R_{t+3}+...\\big)\\,\\bigg|\\,S_t=s\\bigg]=\\E\\bigg[R_{t+1}+\\g \\,G_{t+1}\\,\\bigg|\\,S_t=s\\bigg]$$A questo punto sappiamo chi sono i due valori attesi:\n\n- Quello di $R_{t+1}$ è banalmente $R_s$;\n- Quello di $G_{t+1}$ è $V_{s+1}$, i.e. è la Value Function dello stato $s'=s+1$ che raggiungo in un solo step a partire da $s$. Questo in generale avviene con probabilità $\\calP(s\\to s')$.\n\nMettendo insieme tutte queste belle storielle abbiamo che$$V_s=R_s+\\g\\sum_{s'}\\calP(s\\to s')V(s')\\qquad\\text{i.e.}\\qquad V=\\calR+\\g\\calP V$$Questa roba si risolve in genere come problema di calcolo matriciale secondo$$V=(\\I-\\g \\calP)^{-1}\\calR$$il che è $O(n^3)$ ed è quindi verosimilmente risolvibile solo per piccole CdM. Per grandi CdM si usano robe come Dynamic Programming (qualsiasi cosa sia, non mi va di cercarlo), Monte Carlo e Temporal Difference Learning (same).","x":-5899,"y":1109,"width":759,"height":697,"color":"4"},
		{"id":"ce48b54473bd82a5","type":"text","text":"# Markov Decision Process (MDP) & Policies\n\nSostituiamo le probabilità con le ***azioni*** e abbiamo trasformato un MRP in un MDP.\n\nVisto che non abbiamo più le probabilità ci serve una logica per scegliere i nostri movimenti. Definiamo allora una ***policy*** che associa ad ogni azione una probabilità (sì, di nuovo...)$$\\pi(a|s)=\\P\\big[A_t=a\\,\\big|\\,S_t=s\\big]$$i.e. è la definizione formale per dire \"dato lo stato in cui mi trovo adesso, qual è la pdf delle varie azioni che posso prendere?\". Ed è per questo che la Value Function dipende da $\\pi$:$$V_\\pi(s)=\\E_\\pi\\big[G_t\\,\\big|\\,S_t=s\\big]\\qquad\\text{and}\\qquad q_\\pi(a|s)=\\E_\\pi\\big[G_t\\,\\big|\\,S_t=s,\\,A_t=a\\big]$$\nIn pratica, $V_\\pi$ valuta ancora lo stato e $q_\\pi$ valuta l'azione dato lo stato.\n\nOra, è chiaro che se guardo la Bellman Equation di prima questa non va più bene, perché non ho più direttamente delle probabilità come in una CdM ma ho una policy che assegna delle probabilità alle azioni dato lo stato. In pratica abbiamo le seguenti modifiche:\n\n- $R_s$ scompare, perché il reward è sull'azione che scelgo e non più sullo stato in cui sono;\n- $\\calP$ viene sostituita dalla policy $\\pi$;\n- $V(s')$ viene sostituito da $q_\\pi(s, a)$ perché, ancora, il reward è sull'azione e non sullo stato.\n\nSe $A_s$ è l'insieme delle azioni accessibili dallo stato $s$ abbiamo allora che$$V_\\pi=\\sum_{a\\in A_s}\\pi(a|s)\\,q_\\pi(s,a)$$Ma non è tutto: chi è $q_\\pi(s,a)$? Certamente è il reward $\\calR_s^a$ dell'azione $a$ presa nello stato $s$, ma non solo. Devo considerare a quale stato e a quali altre azioni mi porterà. Quindi$$q_\\pi(s,a)=\\calR_s^a+\\g\\sum_{s'}\\calP^a(s\\to s')\\,V_\\pi(s')$$dove il simpatico termine $\\calP^a(s\\to s')$ significa che se scelgo una certa azione $a$ non è detto che sono certo dello stato $s'$ in cui finirò. Questo si traduce, ad esempio, nello scegliere l'azione `Pub` nell'esempio dello studente volenteroso.\n\nInfine, se metto tutto insieme (i.e. le vorrei anche risolvere, queste equazioni) abbiamo$$V_\\pi=\\sum_{a\\in A_s}\\pi(a|s)\\bigg(\\calR_s^a+\\g\\sum_{s'}\\calP^a(s\\to s')\\,V_\\pi(s')\\bigg)$$e$$\nq_\\pi(s,a)=\\calR_s^a+\\g\\sum_{s'}\\calP^a(s\\to s')\\sum_{a'\\in A_s}\\pi(a'|s)\\,q_\\pi(s,a')\n$$","x":-4929,"y":2420,"width":759,"height":1029,"color":"4"},
		{"id":"7c93d0ff811275c6","type":"file","file":"MDP_Student.png","x":-5800,"y":2706,"width":561,"height":458},
		{"id":"81b117e207e0f933","type":"text","text":"# RL II\n\nriassunto parte 1 delle slides: ad ogni stato della markov chain associo un reward. ogni path ha un reward totale associato pari alla somma pesata del reward attuale e di tutti quelli che possono venire dopo pesati con la rispettiva probabilità e con un fattore $\\gamma$ che aggiusto per decidere se dare più o meno peso al lungo termine.\n\nriassunto parte 2: come prendo le decisioni? ci stanno le policies.\ndato uno stato in cui sono, la policy sceglie quale azione prendere (e.g. study o pub). altro discorso è poi che se prendo l'azione pub questa mi porta con diverse probabilità a diversi stati.\n\nin pratica la policy diventa un peso (o un parametro? in qualche modo cambia il risultato di q insomma). forse dipende da cosa sto calcolando ","x":-5806,"y":2011,"width":567,"height":550},
		{"id":"9909fc4cf33945d0","type":"text","text":"# Optimal Policy\n\nLe performance di un MDP dipendono dalla policy. Ma come trovo quella ottimale?\n","x":-4929,"y":3760,"width":759,"height":200,"color":"6"},
		{"id":"1ef815baa057d8c0","type":"text","text":"# Bellman's Optimality Equations\n\nDefiniamo $V^*(s)=\\max_\\pi V_\\pi(s)$, i.e. il massimo valore di uno stato rispetto a tutte le possibili politiche, ed analogo $Q^*(s,a)$. Quest'ultimo significa che data un'azione $a$ in uno stato $s$, esiste una politica tale che il $Q$-value di tale azione è massimo. Infine, definiamo un ordine parziale tra tutte le possibili policies dicendo che$$V_\\pi(s)\\ge V_{\\pi'}(s)\\,\\,\\forall s\\so \\pi\\ge\\pi'$$\n\n`Teorema` - Per ogni MDP esiste una policy ottimale $\\pi^*$ tale che $\\pi^*\\ge \\pi_i \\,\\forall i$.\n\nDetto tutto questo, costruiamo la policy ottimale come$$\\pi^*(a|s)\\begin{cases}1\\quad \\text{if }a=\\arg\\max_{a'}Q^*(s,a')\\\\0\\quad\\text{otherwise}\\end{cases}$$che in pratica significa \"per ogni stato, trova la migliore azione possibile su tutte le possibili policies e rendila parte della policy ottimale\". Ora, tutto questo può sembrare uno strano \"taglia e cuci\" in cui arbitrariamente prendiamo azioni \"buone\" secondo policies diverse per poi forzatamente metterle insieme in un'unica policy.\n\nSe così fosse, non sarebbe molto coerente. Questa roba invece funziona perché $Q^*(s,a)$ è calcolato tenendo già conto ricorsivamente di tutti gli altri $Q^*(s',a')$ ottimali. Come? Ma ovviamente tramite le ***Bellman's Optimality Equations***.$$V^*(s) = \\max_a Q^*(s,a)\\qquad Q^*(s,a)=\\calR_s^a+\\g\\sum_{s'\\in\\calS}\\calP^a(s\\to s')V^*(s')$$da cui seguono$$V^*(s) = \\max_a\\bigg[\\calR_s^a+\\g\\sum_{s'\\in\\calS}\\calP^a(s\\to s')V^*(s')\\bigg]$$e$$Q^*(s,a)=\\calR_s^a+\\g\\sum_{s'\\in\\calS}\\calP^a(s\\to s')\\max_a Q^*(s,a)$$Sta roba è non lineare e non ha in generale una soluzione analitica. Servono quindi metodi numerici iterativi di ***Temporal Difference Learning***, e.g. ***Q-Learning***, Sarsa.","x":-4929,"y":4080,"width":759,"height":868,"color":"4"},
		{"id":"91f40e79bcda272c","type":"text","text":"# Q-Learning\n\nIl ***Q-Learning*** è un algoritmo di apprendimento ***model-free*** (i.e. non è necessario avere idea di com'è fatto l'ambiente in cui mi muovo), che permette di approssimare $Q^*(s,a)$ direttamente con l’esperienza. Non serve quindi\n\n- conoscere le probabilità di transizione $\\calP(s\\to s')$;\n- una policy iniziale da cui partire, si aggiorna direttamente la funzione $Q$.\n\nL'idea è la seguente:\n\n- Inizializzo la funzione $Q$ con valori arbitrari. Questo significa che dato uno stato le probabilità associate alle varie azioni non sono ancora ottimizzate;\n- Prendo una scelta secondo una strategia esplorativa predefinita (e.g. $\\e$***-greedy***);\n- Osservo i risultati di quello che ho fatto. Ottenendo un reward $r_t$ sono finito in un nuovo stato avente azione ottimale $\\max_aQ(s_{t+1},a_{t+1})$, il che significa che se la mia stima precedente della bontà dell'azione era $Q(s_t,a_t)$ ora posso calcolare la differenza$$\\text{TD}(s_t,a_t)=r_t+\\g\\max_aQ(s_{t+1},a_{t+1})\\,-\\,Q(s_t,a_t)$$\n- Aggiusto la mia vecchia stima secondo$$Q^{\\text{new}}(s_t,a_t) = Q^{\\text{old}}(s_t,a_t)+\\a\\,\\text{TD}(s_t,a_t)$$\n\nEvidentemente, questo algoritmo può apprendere una politica ottimale anche mentre ne segue una non ottimale (i.e. è detto ***off-policy***: non è vincolato alla policy che sta seguendo al momento).\n\nPer la cronaca, tutto ciò è molto bello ma ha diversi problemi. Se ci sono troppi stati o se lo spazio degli eventi è continuo non riesce a costruire la tabella. Nel 2015 DeepMind ha introdotto le reti neurali per l'approssimazione della funzione $Q$ (***Deep Q-Networks***, ***DQN***), ma ad oggi non è più stato-dell'-arte (ci sono tecniche ancora migliori.)","x":-3920,"y":4080,"width":759,"height":868,"color":"4"},
		{"id":"4ffa6f5f80df423d","type":"text","text":"# Temporal Difference Learning (TDL)\n\nPer TDL si intende una ***famiglia di algoritmi*** che aggiornano il valore stimato di un valore basandosi su esperienze parziali, senza quindi attendere un'osservazione \"completa\".\n\nL'idea è la seguente: dato uno stato ho una stima del suo valore, dopodiché però posso osservare le conseguenze delle mie azioni e confrontarle con ciò che mi aspettavo, aggiornando in modo dinamico la mia stima secondo il ***TD Error***$$\\d_t=\\calR_t+\\g V(s_{t+1})-V(s_t)$$Se $\\d_t$ supera una certa threshold, allora aggiorno la stima $V(s_t)$.\n\nIl ***Q-Learning*** è un caso specifico di TDL.","x":-5938,"y":4339,"width":759,"height":351,"color":"4"},
		{"id":"cc2e203d8407499d","type":"text","text":"# Papers","x":-330,"y":6440,"width":759,"height":229,"color":"6"},
		{"id":"5c9a173d23378970","type":"text","text":"# Questo Corso\n\nDato un networking problem (MAC o routing), devi essere in grado di decidere se sia o meno il caso di formularlo come problema di reinforcement learning.\n\nIn caso affermativo, devi definirlo formalmente (in termini di state space, action space, dynamics e reward model), stabilire quale tra gli algoritmi visti a lezione è più adatto per il problema e argomentare per quale motivo lo è.\n","x":-330,"y":-715,"width":759,"height":229,"color":"3"},
		{"id":"6ae7f80816be5460","type":"text","text":"# Aloha-Q (2015)\n\nProtocollo MAC per WSN che usa il $Q$***-Learning*** per ottimizzare la scelta degli slot in Aloha.\n\nConosciamo già i problemi di Aloha classico: collisioni, ritrasmissioni (quindi overhead), idle listening e overhearing (i.e. manca una coordinazione). Ci sono già protocolli che migliorano l'efficienza energetica (i.e. S-MAC, Z-MAC), ma questi introducono più complessità ed overhead. \n\n- Ogni nodo mantiene ","x":-1840,"y":6335,"width":759,"height":440},
		{"id":"a9710cd0cf1a0dfb","x":-1010,"y":7401,"width":250,"height":60,"type":"text","text":""},
		{"id":"021d1cc671feb903","x":-72,"y":7490,"width":250,"height":60,"type":"text","text":""},
		{"id":"0073c9a1077332fd","x":849,"y":7463,"width":250,"height":60,"type":"text","text":""},
		{"id":"93e5b042945237b3","x":1014,"y":6521,"width":250,"height":60,"type":"text","text":""}
	],
	"edges":[
		{"id":"ba08de2f1f873a71","fromNode":"4b21c821ca9a99a5","fromSide":"top","toNode":"496569cc5d17f5be","toSide":"bottom"},
		{"id":"96913fe00cd61de5","fromNode":"496569cc5d17f5be","fromSide":"right","toNode":"06c8dfc1835bdad9","toSide":"left"},
		{"id":"29150fdcb1548b51","fromNode":"496569cc5d17f5be","fromSide":"left","toNode":"b34074a3a43e8d58","toSide":"right"},
		{"id":"00709dd159fa99e6","fromNode":"b34074a3a43e8d58","fromSide":"top","toNode":"07860fbdac8f9f5e","toSide":"bottom"},
		{"id":"01affd8767b69ee5","fromNode":"b34074a3a43e8d58","fromSide":"left","toNode":"e9efc94fac1f44e4","toSide":"right"},
		{"id":"3dd19a2bc37f3d5f","fromNode":"496569cc5d17f5be","fromSide":"top","toNode":"67138e840671f086","toSide":"bottom"},
		{"id":"2947d46836431621","fromNode":"d66b5203ff904bb6","fromSide":"right","toNode":"8c0119c21d2aab9f","toSide":"top"},
		{"id":"474e411ab8553c85","fromNode":"4b4c321762d3e679","fromSide":"right","toNode":"d66b5203ff904bb6","toSide":"left"},
		{"id":"ff10b6be69a2310e","fromNode":"4b4c321762d3e679","fromSide":"right","toNode":"c287d4aa7b5a27a1","toSide":"left"},
		{"id":"e23485d028abe209","fromNode":"840636eb4f2d40f4","fromSide":"top","toNode":"4b4c321762d3e679","toSide":"bottom"},
		{"id":"0d6fa802c8ae240e","fromNode":"c287d4aa7b5a27a1","fromSide":"bottom","toNode":"df043301b08dc4bc","toSide":"top","label":"Accesso Casuale"},
		{"id":"386ddb30df089803","fromNode":"c287d4aa7b5a27a1","fromSide":"right","toNode":"895bc3f1bf8fd64a","toSide":"top","label":"Partizionamento del Canale"},
		{"id":"3ae39d8ffd513bf1","fromNode":"840636eb4f2d40f4","fromSide":"right","toNode":"df043301b08dc4bc","toSide":"left"},
		{"id":"2fc54700d04e8845","fromNode":"840636eb4f2d40f4","fromSide":"top","toNode":"e65e158ed9f2ecee","toSide":"bottom"},
		{"id":"ef0500313fb877c3","fromNode":"04e2e59fbd2b386f","fromSide":"right","toNode":"840636eb4f2d40f4","toSide":"bottom"},
		{"id":"9c0107675e1dc7be","fromNode":"df043301b08dc4bc","fromSide":"right","toNode":"3f6df1e0812fdc42","toSide":"left"},
		{"id":"3ca2058c81a93542","fromNode":"df043301b08dc4bc","fromSide":"right","toNode":"85f2794d386784c8","toSide":"left"},
		{"id":"780daa0899c004fa","fromNode":"f7bb59d2b607b321","fromSide":"right","toNode":"57643829e285a0ee","toSide":"left"},
		{"id":"461cf23f5e223a6d","fromNode":"f7bb59d2b607b321","fromSide":"right","toNode":"7553697f9878b2c6","toSide":"left"},
		{"id":"32d5477cbeab3840","fromNode":"f7bb59d2b607b321","fromSide":"bottom","toNode":"3babb9c1abd49799","toSide":"top"},
		{"id":"37a3126b7594c86e","fromNode":"0ea7ba1d2a860cba","fromSide":"right","toNode":"f7bb59d2b607b321","toSide":"top"},
		{"id":"314989ed6f70281e","fromNode":"1402f82ddabdb007","fromSide":"right","toNode":"f7bb59d2b607b321","toSide":"left"},
		{"id":"3671cce9b3bfda58","fromNode":"0ea7ba1d2a860cba","fromSide":"left","toNode":"ea5e414eaee40f14","toSide":"top"},
		{"id":"728792761e586a70","fromNode":"ea5e414eaee40f14","fromSide":"right","toNode":"1402f82ddabdb007","toSide":"left"},
		{"id":"7f17e05281a78325","fromNode":"ea5e414eaee40f14","fromSide":"right","toNode":"332c0e8ffc8d1968","toSide":"left"},
		{"id":"2892630a933c5b64","fromNode":"1402f82ddabdb007","fromSide":"bottom","toNode":"332c0e8ffc8d1968","toSide":"top"},
		{"id":"bfac845af5668888","fromNode":"04e2e59fbd2b386f","fromSide":"bottom","toNode":"1402f82ddabdb007","toSide":"top"},
		{"id":"0fb23c2256327ee7","fromNode":"332c0e8ffc8d1968","fromSide":"bottom","toNode":"93d339019972442f","toSide":"top"},
		{"id":"6a5ec1eb169f17da","fromNode":"04e2e59fbd2b386f","fromSide":"top","toNode":"adcd49e79bfc238c","toSide":"bottom"},
		{"id":"c0b8d447d02389f1","fromNode":"04e2e59fbd2b386f","fromSide":"left","toNode":"44d21c89cd07b8f4","toSide":"bottom"},
		{"id":"932ab6b775602a74","fromNode":"04e2e59fbd2b386f","fromSide":"right","toNode":"34ea13703634e6c8","toSide":"left"},
		{"id":"2653abefb7ddba77","fromNode":"8c0119c21d2aab9f","fromSide":"top","toNode":"f19b3a4fa73ba9e8","toSide":"bottom"},
		{"id":"88a67fbd65beeffc","fromNode":"8c0119c21d2aab9f","fromSide":"top","toNode":"895bc3f1bf8fd64a","toSide":"bottom"},
		{"id":"697484167276192c","fromNode":"34ea13703634e6c8","fromSide":"top","toNode":"8c0119c21d2aab9f","toSide":"bottom"},
		{"id":"7189fdbfe08b6fcb","fromNode":"c0bea95135c9c558","fromSide":"top","toNode":"7453c854124ec469","toSide":"bottom"},
		{"id":"1bbb117dac8d2233","fromNode":"c0bea95135c9c558","fromSide":"right","toNode":"faa6429103579d88","toSide":"left"},
		{"id":"b9c868ae60ca8e13","fromNode":"c0bea95135c9c558","fromSide":"right","toNode":"cf066ff07b9dcf69","toSide":"left"},
		{"id":"c34bd2b721ee25eb","fromNode":"c934a9e7d90eb7cc","fromSide":"top","toNode":"c0bea95135c9c558","toSide":"bottom"},
		{"id":"34ca7aeaf092eb73","fromNode":"c934a9e7d90eb7cc","fromSide":"bottom","toNode":"30928e3765ea01bf","toSide":"top"},
		{"id":"130c12c4a7e30349","fromNode":"c934a9e7d90eb7cc","fromSide":"right","toNode":"80a40c0953bfe923","toSide":"left"},
		{"id":"39284feb790e514a","fromNode":"34ea13703634e6c8","fromSide":"right","toNode":"c934a9e7d90eb7cc","toSide":"left"},
		{"id":"467aeca0bc85ea60","fromNode":"34ea13703634e6c8","fromSide":"bottom","toNode":"63119a3b9909af65","toSide":"top"},
		{"id":"56f4a84ebfcc56ab","fromNode":"63119a3b9909af65","fromSide":"bottom","toNode":"825165ad441d79f9","toSide":"left"},
		{"id":"d1375a5d71569287","fromNode":"63119a3b9909af65","fromSide":"bottom","toNode":"affb87dd75497bd6","toSide":"right"},
		{"id":"0bd099586616b6b4","fromNode":"63119a3b9909af65","fromSide":"bottom","toNode":"5e772fe2702b3d44","toSide":"right"},
		{"id":"f5c50ed07c883beb","fromNode":"63119a3b9909af65","fromSide":"bottom","toNode":"bd33a66a27f4e32d","toSide":"left"},
		{"id":"6efaf533006d07cf","fromNode":"bd33a66a27f4e32d","fromSide":"bottom","toNode":"8ae579769d34655f","toSide":"top"},
		{"id":"dd33eaad0d9b2a90","fromNode":"bd33a66a27f4e32d","fromSide":"right","toNode":"93588f5566f63388","toSide":"left","label":"Circa"},
		{"id":"2cb32bc57ecac963","fromNode":"30928e3765ea01bf","fromSide":"bottom","toNode":"a984965221233e7a","toSide":"top"},
		{"id":"eda65dcb510a66d2","fromNode":"faa6429103579d88","fromSide":"right","toNode":"ed1a9855d26a488d","toSide":"left"},
		{"id":"05ad2286d94db188","fromNode":"affb87dd75497bd6","fromSide":"bottom","toNode":"5e772fe2702b3d44","toSide":"top"},
		{"id":"87da0453586b71d1","fromNode":"5e772fe2702b3d44","fromSide":"bottom","toNode":"733d37bec4794264","toSide":"top"},
		{"id":"c7b198dc932ae0be","fromNode":"85f2794d386784c8","fromSide":"right","toNode":"9761cb49699f7d24","toSide":"left"},
		{"id":"af2cc619ecf34a69","fromNode":"06c8dfc1835bdad9","fromSide":"right","toNode":"58abf9d465bc3980","toSide":"left"},
		{"id":"677371e311bac074","fromNode":"06c8dfc1835bdad9","fromSide":"bottom","toNode":"b56e6a2717144541","toSide":"top"},
		{"id":"9bf6787bec612ad5","fromNode":"4b21c821ca9a99a5","fromSide":"left","toNode":"39bd0d24bf3d18c1","toSide":"right"},
		{"id":"958ba262ee3b5ff1","fromNode":"b56e6a2717144541","fromSide":"right","toNode":"2d2a1ead3f62559a","toSide":"left"},
		{"id":"0b9f31f3f51fc1c6","fromNode":"06c8dfc1835bdad9","fromSide":"top","toNode":"0e6f35441b30a9ce","toSide":"bottom"},
		{"id":"30194f92bd6527d1","fromNode":"64182a68ba4bddda","fromSide":"right","toNode":"04e2e59fbd2b386f","toSide":"left"},
		{"id":"02acaa45aa8e8095","fromNode":"0e6f35441b30a9ce","fromSide":"right","toNode":"1e950c33e4268bb0","toSide":"left"},
		{"id":"e5859ae734acf4ab","fromNode":"b088c8d184a0019a","fromSide":"top","toNode":"4b21c821ca9a99a5","toSide":"bottom"},
		{"id":"48f0ef61f6f58e2b","fromNode":"b088c8d184a0019a","fromSide":"right","toNode":"10eedec3831487f5","toSide":"left"},
		{"id":"c9a993f052a0edea","fromNode":"10eedec3831487f5","fromSide":"top","toNode":"0daddd3434b67fe6","toSide":"bottom"},
		{"id":"c41b55b10feabd97","fromNode":"10eedec3831487f5","fromSide":"bottom","toNode":"5d63270df240ccdf","toSide":"top"},
		{"id":"a4d8775573b9f5db","fromNode":"2795cbd69099d104","fromSide":"right","toNode":"b088c8d184a0019a","toSide":"left"},
		{"id":"333fb0d0eaae5d7a","fromNode":"10eedec3831487f5","fromSide":"right","toNode":"cd0682544b4d7ae0","toSide":"left"},
		{"id":"f334b54578c249c3","fromNode":"10eedec3831487f5","fromSide":"right","toNode":"dfe3bfa74fb8b071","toSide":"left"},
		{"id":"3807675986bc24b8","fromNode":"10eedec3831487f5","fromSide":"right","toNode":"fda930695389d493","toSide":"left"},
		{"id":"e7ff8158dbbecbe9","fromNode":"dfe3bfa74fb8b071","fromSide":"top","toNode":"6005a469cd64c6fb","toSide":"bottom"},
		{"id":"ce081f12cdafdb7a","fromNode":"dfe3bfa74fb8b071","fromSide":"right","toNode":"8686dd285ea55e0b","toSide":"bottom"},
		{"id":"281798a3bbdbe402","fromNode":"6005a469cd64c6fb","fromSide":"right","toNode":"8686dd285ea55e0b","toSide":"left"},
		{"id":"3c36eb6d8911539f","fromNode":"4a483510ba6510d1","fromSide":"left","toNode":"7aa49a133421d2fb","toSide":"right"},
		{"id":"2c23dc430fd0dc24","fromNode":"fda930695389d493","fromSide":"bottom","toNode":"4a483510ba6510d1","toSide":"top"},
		{"id":"07d42756ac153fbb","fromNode":"4a483510ba6510d1","fromSide":"right","toNode":"9cd14b09c257782c","toSide":"left"},
		{"id":"5b71882e5b26bd65","fromNode":"d26761e26328fff8","fromSide":"bottom","toNode":"9cd14b09c257782c","toSide":"top"},
		{"id":"930c3b31b61f7284","fromNode":"fda930695389d493","fromSide":"right","toNode":"d26761e26328fff8","toSide":"left"},
		{"id":"f9a18eb7024cb38b","fromNode":"0c134d0d526830b1","fromSide":"bottom","toNode":"11bd063ee8d2baf4","toSide":"top"},
		{"id":"91c35e31a132f241","fromNode":"b088c8d184a0019a","fromSide":"bottom","toNode":"63fd59600df38671","toSide":"top"},
		{"id":"1d8b82ff39a5d3e4","fromNode":"63fd59600df38671","fromSide":"right","toNode":"9c36d33a9486dbca","toSide":"left"},
		{"id":"a2d5f083826bb913","fromNode":"63fd59600df38671","fromSide":"bottom","toNode":"68e6c3596ea5dc88","toSide":"top","label":"3"},
		{"id":"de38a15972d19905","fromNode":"63fd59600df38671","fromSide":"left","toNode":"560eac5d2c69c1d2","toSide":"right","label":"4"},
		{"id":"0fc1befa40392851","fromNode":"4b21c821ca9a99a5","fromSide":"right","toNode":"35df43790e0bcb33","toSide":"top"},
		{"id":"501ec8a5ff9ed6fe","fromNode":"10eedec3831487f5","fromSide":"left","toNode":"35df43790e0bcb33","toSide":"bottom"},
		{"id":"c2366e7b0fd9c8a5","fromNode":"35df43790e0bcb33","fromSide":"right","toNode":"b15d348eb6b0ef51","toSide":"left"},
		{"id":"be264c49bbb81a71","fromNode":"2795cbd69099d104","fromSide":"left","toNode":"241a50c4268e0c2e","toSide":"right"},
		{"id":"1acfae72d1d9d981","fromNode":"241a50c4268e0c2e","fromSide":"top","toNode":"b05056eaa2e4856d","toSide":"bottom"},
		{"id":"7a6dff3405d64ff0","fromNode":"241a50c4268e0c2e","fromSide":"top","toNode":"81ade21fad6371fb","toSide":"bottom"},
		{"id":"b4ea278a24d0b573","fromNode":"241a50c4268e0c2e","fromSide":"top","toNode":"dec5f256d7b4cce1","toSide":"bottom"},
		{"id":"5697d207ba7c31d4","fromNode":"b05056eaa2e4856d","fromSide":"left","toNode":"dec5f256d7b4cce1","toSide":"right"},
		{"id":"57a987b8d944665d","fromNode":"241a50c4268e0c2e","fromSide":"bottom","toNode":"ec91651bdd90f0d5","toSide":"top"},
		{"id":"93d0425b14e212ed","fromNode":"241a50c4268e0c2e","fromSide":"bottom","toNode":"b3834f78c48047d1","toSide":"top","label":"Simple\nSingle-Action\nOptimization"},
		{"id":"8e0be69e19de81a0","fromNode":"b3834f78c48047d1","fromSide":"right","toNode":"0a27aebf7145e0bf","toSide":"left"},
		{"id":"f23f82768d4ab0b8","fromNode":"ec91651bdd90f0d5","fromSide":"left","toNode":"b3834f78c48047d1","toSide":"right"},
		{"id":"04d34defcaacf05b","fromNode":"ec91651bdd90f0d5","fromSide":"bottom","toNode":"0a27aebf7145e0bf","toSide":"top"},
		{"id":"eb2658f8c764e4ef","fromNode":"b3834f78c48047d1","fromSide":"right","toNode":"1b960a10645a8931","toSide":"left"},
		{"id":"791a542fbf619b6e","fromNode":"0a27aebf7145e0bf","fromSide":"bottom","toNode":"1b960a10645a8931","toSide":"top"},
		{"id":"0c93e4f343fbdb43","fromNode":"1b960a10645a8931","fromSide":"bottom","toNode":"af010e14b89df601","toSide":"top"},
		{"id":"e828658105150e35","fromNode":"1b960a10645a8931","fromSide":"right","toNode":"86dd9248d0795405","toSide":"left"},
		{"id":"98257116f1ff3aa2","fromNode":"0a27aebf7145e0bf","fromSide":"right","toNode":"86dd9248d0795405","toSide":"left"},
		{"id":"28fd61e1469d1c75","fromNode":"ce567157a24941d9","fromSide":"right","toNode":"21c067b9f8222074","toSide":"left"},
		{"id":"3f0c62d41089a232","fromNode":"1b960a10645a8931","fromSide":"right","toNode":"ce567157a24941d9","toSide":"left"},
		{"id":"83abb1d3649a4c36","fromNode":"b3834f78c48047d1","fromSide":"bottom","toNode":"7f463e2b6fea84e0","toSide":"top"},
		{"id":"9401c9cd3e9fb64e","fromNode":"7f463e2b6fea84e0","fromSide":"right","toNode":"3276e8832bd5b673","toSide":"left"},
		{"id":"1a265a109d92489b","fromNode":"af010e14b89df601","fromSide":"bottom","toNode":"3276e8832bd5b673","toSide":"top"},
		{"id":"95dfb797b13adf99","fromNode":"241a50c4268e0c2e","fromSide":"bottom","toNode":"d1f5251fd2d62f35","toSide":"top","label":"Multiple-Actions\nOptimization"},
		{"id":"62ca6973f69fee2e","fromNode":"d1f5251fd2d62f35","fromSide":"bottom","toNode":"a22235297696c98b","toSide":"top"},
		{"id":"21ad17bcd8278b46","fromNode":"d1f5251fd2d62f35","fromSide":"bottom","toNode":"43974ae3fb552c0f","toSide":"top"},
		{"id":"43a1f2017e792ce8","fromNode":"d1f5251fd2d62f35","fromSide":"left","toNode":"cb16818f4911f671","toSide":"right"},
		{"id":"a133b84a00b08d4d","fromNode":"d1f5251fd2d62f35","fromSide":"bottom","toNode":"ce48b54473bd82a5","toSide":"top"},
		{"id":"60bd9595889c14a1","fromNode":"2795cbd69099d104","fromSide":"top","toNode":"5c9a173d23378970","toSide":"bottom"},
		{"id":"537de4b05f12e6be","fromNode":"ce48b54473bd82a5","fromSide":"bottom","toNode":"9909fc4cf33945d0","toSide":"top"},
		{"id":"8510b0ae4efa139c","fromNode":"9909fc4cf33945d0","fromSide":"right","toNode":"91f40e79bcda272c","toSide":"top"},
		{"id":"7dff173738be23ce","fromNode":"9909fc4cf33945d0","fromSide":"bottom","toNode":"1ef815baa057d8c0","toSide":"top"},
		{"id":"4203b6b1366dd753","fromNode":"1ef815baa057d8c0","fromSide":"right","toNode":"91f40e79bcda272c","toSide":"left"},
		{"id":"60a52a434dd267ff","fromNode":"1ef815baa057d8c0","fromSide":"left","toNode":"4ffa6f5f80df423d","toSide":"right"},
		{"id":"8158c1e1c26aabe2","fromNode":"2795cbd69099d104","fromSide":"bottom","toNode":"cc2e203d8407499d","toSide":"top"},
		{"id":"bde3eb639a93427d","fromNode":"cc2e203d8407499d","fromSide":"left","toNode":"6ae7f80816be5460","toSide":"right"},
		{"id":"5e23db2ab26de288","fromNode":"cc2e203d8407499d","fromSide":"bottom","toNode":"a9710cd0cf1a0dfb","toSide":"top"},
		{"id":"fa00ade586e344b2","fromNode":"cc2e203d8407499d","fromSide":"bottom","toNode":"021d1cc671feb903","toSide":"top"},
		{"id":"12a832791ca02b68","fromNode":"cc2e203d8407499d","fromSide":"bottom","toNode":"0073c9a1077332fd","toSide":"top"},
		{"id":"4d8968edaf06638b","fromNode":"cc2e203d8407499d","fromSide":"right","toNode":"93e5b042945237b3","toSide":"left"}
	]
}