{
	"nodes":[
		{"id":"2795cbd69099d104","type":"text","text":"# Autonomous Network (AN)\n\nQuand'è che una rete è ***autonoma***?\n\n- Una volta configurata, ***non servono indicazioni o risorse aggiuntive***;\n- È \"intelligente\", nei limiti dell'AI (i.e. si adatta ai cambiamenti ambientali e/o li prevede), usando il ***reinforcement learning***.\n\n","x":-83,"y":20,"width":626,"height":208,"color":"6"},
		{"id":"4b21c821ca9a99a5","type":"text","text":"# Radio Frequency Identification (RFID)\n\nÈ un sistema che consta di tre componenti:\n\n- ***Tag*** - Circuiti molto semplici, al punto che spesso sono integrati in uno sticker. Identificati da un codice univoco tipicamente a 96 bit, possono essere alimentati (attivi) e non (passivi). Il loro ruolo è rispondere ad uno stimolo EM esterno;\n- ***Reader*** - Dispositivi che emettendo un segnale EM forniscono ai Tag la potenza necessaria a rispondere;\n- ***Server*** - Riceve e processa i dati ricevuti dal Reader.\n\nI Tag passivi sono spesso utilizzati per l'identificazione (e.g. come alternativa al codice a barre), in quanto sono low cost, battery free e non necessitano line of sight.\n\nQuando un'antenna richiede gli ID di un gruppo di Tag, questi rispondono simultaneamente. Serve un protocollo semplice per evitare le collisioni, e viene rispolverato ***Aloha*** in versione un po' più semplice: il reader dice a tutti `generate un numero casuale da 1 a N, a ogni slot temporale decrementatelo e rispondete quando arriva a 0`. L'efficienza di questa roba è $\\sim 37\\%$, altrimenti c'è la sua variante ***Tree Slotted Aloha***: ogni slot in cui c'è collisione di $N$ Tag diventa la radice di un albero che iterativamente si occupa di risolvere solo quegli $N$ Tag (più facile a farsi che a dirsi).","x":1320,"y":-1240,"width":581,"height":637,"color":"4"},
		{"id":"3c75d95894ed422c","type":"file","file":"SlottedAloha.png","x":2099,"y":-1183,"width":700,"height":181},
		{"id":"5b6eb8218c9cdbcf","type":"file","file":"PureAloha.png","x":2099,"y":-944,"width":700,"height":181},
		{"id":"40cc347011752646","type":"file","file":"RFID.png","x":1411,"y":-1640,"width":400,"height":301},
		{"id":"b00aab8306e43b32","type":"text","text":"# Aggiunte RFID\n\nquesti protocolli evitano le collisioni, e sono detti sequenziali. ci sono anche quelli che le gestiscono, detti concorrenti.\n\nbinary splitting divide i tag in due gruppi ricorsivamente. Come? Inizio con tutti i tag con counter 0. rispondono alla query solo chi ha 0, quindi all'inizio tutti e c'è collisione. Ogni tag genera un bit casuale che somma al counter. Così in media stamo 50 e 50. slides\n\nslide 28, il formulone è una binomiale ricorsiva\ntutta la megaparentesi è una roba ricorsiva, la prima riga è il caso base.\n\ntutto questo è comandato dal controller, mentre se uso aloha è distribuito (credo, controlla)\n\nl'efficienza misurata come query riuscite su totali ha senso se ogni query prende lo stesso tempo, altrimenti devo tenerlo in considerazione.\n\nsul grafico di pag 42 c'è un picco: when I overstimate the number of slots I get best results. better have much more idle slot (last much less than a collision slot, that's $\\beta$ from some slide before)\n\nin TSA i tag devono ricordare la collisione precedente (so she said, siamo sicuri?). la performance è 43% circa.","x":543,"y":-1224,"width":620,"height":621},
		{"id":"844cabf1eaf0fa7b","type":"text","text":"# Protocolli MAC però questi sono per WSN!!\n\nUna AN è anzitutto una rete wireless (sempre?)","x":-83,"y":-400,"width":626,"height":140},
		{"id":"a45e4313d00ec084","type":"text","text":"segue CSMA CD e CA, copia da Reti ed eventualmente aggiungi\n\nmi pare di capire che in contesti AN e IoT si tende a preferire TDM, ma spesso si implementano protocolli misti.","x":-440,"y":-790,"width":467,"height":340},
		{"id":"d91339e82a54fbfa","type":"text","text":"# Wireless Sensor Network (WSN)\n\nsensori che mandano dati al sink (cervellone centrale). can sense the channel and spontaneously send data to anyone. also can run protocols.\nlimited transmission rate -> multi-hop.\n\nle applicazioni sono senza fine, quello che puoi immaginare in qualche modo lo puoi anche realizzare\n\ntre elementi fondamentali:\n\n- sensori che raccolgono dati dall'ambiente\n- sink che li raccolgono dai sensori ed eventualmente ci fanno cose\n- actuators che fanno cose sulla base dei dati elaborati dai sink o chi per loro\n\ncome piazzo i sensori in giro? ... dipende dalle necessità. a volte una geometria regolare è comoda. alcuni li posso anche muovere in corso d'opera (tipo i droni).\n\n- scalability - le performance non calano al crescere dei nodi\n- poca potenza a disposizione e poca energia -> serve efficienza\n- asymmetric flow of info sensore->sink (e non posso mandare segnali da un controller? o avere un drone controller in posizione strategica?)\n- lifetime - se muore un critical node ciao ciao network\n- re-programmability - quello che dicevo prima\n- deve adattarsi ai cambiamenti (anche con RL) tipo clima che cambia o un nuovo sensore nella rete\n- data centric networking non mi piace, è limitante ma forse è utile in qualche situazione specifica (semplifica i protocolli probabilmente, li rende efficienti)\n- locality è per evitare overhead di messaggi in giro per la rete (che di nuovo rende i protocolli inefficienti)\n- poi vabbè dice l'ovvio, sono ponte tra mondo fisico e virtuale\n- raspberry\n- TinyOS, stylized C (?), NesC\n- slides per vedere i sensori disponibili nel magnifico negozio della vita\n\n","x":-1520,"y":-1036,"width":680,"height":867},
		{"id":"88aeb7f35a9f1438","type":"text","text":"a drownet is a network of drows.\n\n","x":-400,"y":-160,"width":250,"height":60},
		{"id":"ac2c1079b491ceec","type":"text","text":"# Tipi di AN\n\nWSN, SANET, Infrastructure(less)-Based WN?, UAV (droni),","x":-920,"y":94,"width":330,"height":134},
		{"id":"72bb0a3bb98b57ab","type":"text","text":"# Reinforcement Learning","x":10,"y":420,"width":441,"height":141},
		{"id":"c176c2da581453b1","type":"text","text":"# Sleeping-MAC (S-MAC)\n\nprova a minimizzare il consumo energetico a spese della latenza.\ni nodi hanno finestre divise in sleeping time e sensing time (il loro rapporto è definito dalla ratio sensing/finestra = duty time in genere $\\sim10\\%$). e se qualcuno vuole mandare pacchetti? Sincronizziamo cluster di nodi in modo che siano attivi nello stesso momento. Quando mando SYN aggiungo info sulla mia sleep schedule, in modo che tutti possano farsi una tabella degli schedule. e tra cluster diversi? divido i nodi tra synchronizer e follower, in cui S coordina gruppi di F. Se S collega due gruppi di F con schedule diversi, sarà attivo durante entrambi i waking time. Quando parlano, RTS/CTS.","x":880,"y":-400,"width":600,"height":380},
		{"id":"7377628de440c4ef","type":"text","text":"flat network = no node is more powerful than the others","x":1651,"y":-160,"width":250,"height":140},
		{"id":"4a483510ba6510d1","type":"text","text":"# Routing?\n\ntre approcci:\n\n- aggiorno continuamente le tabelle di routing (proactive) anche se non mi serve\n\t- rispondo ad ogni cambio della rete (e.g. un nodo si sposta, o un collegamento cade)\n\t- la cosa buona è che so sempre dove mandare un pacchetto, quella cattiva è l'overhead\n\t- DSDV bellman-ford + aging (tiene traccia di quanto le info nelle RT sono vecchie, preferendo quelle fresh)\n- mi impegno a trovare la route per A solo quando devo mandargli un pacchetto (reactive).\n\t- se sei particolarmente pigro non la trovi nemmeno, fai flooding e sticazzi, prima o poi arriverà (chaotic evil) inutile dire quanto poco ottimizzata sia sta roba\n\t- se oltre che pigro sei anche pazzo scegli a caso alcuni neighbors (non tutti come nel flooding) e ciao (gossiping, il che è ancora più che chaotic evil)\n\t- DSR (RFC 4728) - dalle slides è molto ovvio, fai una gif. tipicamente esce fuori la scelta migliore, ma in generale il sistema è asincrono. you can improve this protocol by keeping some info\n\t- AODV - we just keep next hop, not whole path as in DSR. mantains tables, not source. è la versione enhanced di DSDV. intermediate nodes learn reverse path. in pratica riempio le tabelle solo quando serve\n- hybrid\n\nnoiose considerazioni finali su cosa è meglio","x":880,"y":40,"width":600,"height":806},
		{"id":"49a949b25dfe30de","type":"text","text":"# DSR\n\n","x":1651,"y":40,"width":469,"height":90},
		{"id":"d26761e26328fff8","type":"text","text":"# Geographic Routing\n\nse devo raggiungere un nodo che so essere a nord, che senso ha propagare l'informazione a sud?\n- most forward - scelgo il primo vicino più a nord;\n- directional routing ???\n\nil grosso problema sono i dead end, perché ho solo info sugli hop (no conoscenza globale)\n\nma se sincronizzo le posizioni con le bussole? ogni coppia definisce una retta, le intersezioni potrebbero essere nodi (o no) indagare, sembra figo","x":880,"y":920,"width":600,"height":371},
		{"id":"51049abcb69c56a1","type":"text","text":"Problema di questi algoritmi di routing: e se i nodi si spostano?","x":960,"y":1395,"width":493,"height":165}
	],
	"edges":[
		{"id":"496e20920231146c","fromNode":"4b21c821ca9a99a5","fromSide":"right","toNode":"3c75d95894ed422c","toSide":"left","label":"Circa"},
		{"id":"719086c4817931dd","fromNode":"4b21c821ca9a99a5","fromSide":"top","toNode":"40cc347011752646","toSide":"bottom"},
		{"id":"58e21454f19faeae","fromNode":"2795cbd69099d104","fromSide":"top","toNode":"844cabf1eaf0fa7b","toSide":"bottom"},
		{"id":"5dfc04739aa6c83e","fromNode":"2795cbd69099d104","fromSide":"left","toNode":"ac2c1079b491ceec","toSide":"right"},
		{"id":"9dee13e1ebae3aa1","fromNode":"2795cbd69099d104","fromSide":"bottom","toNode":"72bb0a3bb98b57ab","toSide":"top"},
		{"id":"ba9b772f029d870c","fromNode":"844cabf1eaf0fa7b","fromSide":"right","toNode":"c176c2da581453b1","toSide":"left"},
		{"id":"11bd67804bc3ea6c","fromNode":"4a483510ba6510d1","fromSide":"right","toNode":"49a949b25dfe30de","toSide":"left"}
	]
}