{
	"nodes":[
		{"id":"b34074a3a43e8d58","type":"text","text":"# Tree Based Protocols\n\nSia ***Binary Splitting*** (***BS***) che ***Query Tree*** (***QT***) tendono ad avere una struttura simile.\n\nPer BS è un po' più facile ricavare il valore asintotico (i.e. per $N\\to\\infty$) della $\\text{SE}$, che si attesta sul $38\\%$. Valori simili si trovano in genere per QT, ma dipende dalla lunghezza degli `ID` (nonché dalla loro omogeneità tra Tag diversi).\n\nTipicamente, questi valori teorici risultano essere delle ***sottostime*** dell'efficienza, in quanto non tengono conto di problemi pratici che tipicamente occorrono (e.g. interferenze).","x":1218,"y":-3058,"width":759,"height":276,"color":"6"},
		{"id":"e9efc94fac1f44e4","type":"text","text":"# Query Tree Protocol\n\nL'idea è implementare una roba gerarchica basata sull'`ID`.\n\n- Inizio chiedendo di rispondere a `tutti gli ID che iniziano per 0`;\n- Probabilmente mi risponderanno in tanti (statisticamente il $50\\%$), allora la richiesta successiva sarà indirizzata a `tutti gli ID che iniziano per 00`;\n- Ad un certo punto troverò un unico Tag con quel dato prefisso (e.g. `000`);\n- Lo step successivo è provare `001`;\n- Una volta esaurito il sotto-albero `00`, riprendo da `01`.\n\nSegue che la complessità computazionale è $O(N\\cdot L)$. dove $L$ è la lunghezza dell'`ID`.\n\nQuesto algoritmo è generalmente il preferito per un numero medio di Tag aventi `ID` di media lunghezza.","x":150,"y":-3135,"width":759,"height":430,"color":"4"},
		{"id":"67138e840671f086","type":"text","text":"# HowTo Performance Evaluation\n\nLa valutazione di un protocollo di lettura degli `ID` avviene tramite la ***System Efficiency***$$\\text{SE}={n\\over q}$$dove\n\n- $n$ è il numero di Tag identificati (i.e. $n\\le N$ numero totale di Tag);\n- $q$ è il numero totale di query inviate dal reader.\n\nOvviamente, come ogni misura di efficienza, all'atto pratico abbiamo $\\text{SE}<1$, tipicamente tra $0.3$ e $0.5$. Spesso inoltre (e di nuovo, ovviamente) il suo valore misurato (i.e. l'unico che conta veramente) è minore del suo valore teorico.\n\nQuesto assumendo che ogni richiesta del reader richieda sempre lo stesso tempo. Se così non è (e.g. **EPC GEN 2**) può essere utile definire la $\\text{Time\\_SE}$ come$$\\text{Time\\_SE}={R_{\\text{id}}\\over\\b R_{\\text{idle}}+R_{\\text{id}}+R_{\\text{c}}}$$dove\n- $R_{\\text{id}}$ è il numero di slot utilizzati per identificare un singolo Tag;\n- $R_{\\text{idle}}$ è il numero di slot in cui nessuno ha risposto:\n\t- Nei protocolli dinamici, gli slot $\\text{idle}$ durano una frazione $\\b<1$ rispetto agli slot di identificazione e di collisione (è a questo che servono i protocolli dinamici!).\n- $R_{\\text{C}}$ è il numero di slot in cui due i più Tag hanno risposto (collisione).\n\nÈ evidente che senza $\\b$ avremmo $R_{\\text{id}}+R_{\\text{idle}}+R_{\\text{C}}=N$. Questa nuova normalizzazione $<N$ ci sta dicendo che nei protocolli che usano tali accorgimenti $\\text{Time\\_SE}>\\text{SE}$.","x":2331,"y":-4020,"width":759,"height":738,"color":"4"},
		{"id":"07860fbdac8f9f5e","type":"text","text":"# Binary Splitting\n\nL'idea è dividere ricorsivamente i Tag in due gruppi finché non ne resta uno solo.\n\nTutti implementano un counter, e rispondono solo se questo è pari a `0`.\n\n- Tutti i Tag iniziano con counter `0`, quindi alla prima richiesta ho $N$ collisioni;\n- Ogni Tag che ha risposto genera un bit casuale che somma al counter. Chi ha ottenuto `1` si autoesclude dalle successive risposte, fino a nuovo ordine;\n\t- In media abbiamo uno split $50$ e $50$;\n- Alla seconda richiesta ho mediamente $N/2$ collisioni, e si ripete il gioco;\n- Ad un certo punto ne risponderà solo uno. Il reader sarà quindi in grado di rispondere con un `ACK` rivolto esplicitamente a lui, il quale si autoescluderà dal processo di identificazione in modo permanente;\n- Alla prossima richiesta, nessuno risponderà. Il reader allora manda una sorta di `OK, ricominciamo` con cui dice a tutti di rimettere il contatore a `0`.\n\t- Questa roba è un po' inefficiente se $N$ di partenza è molto grande, dato che ricomincia ogni volta da $N-1$;\n\t- Questi ultimi due step si possono fare insieme, ma in generale ciò aumenta la complessità dell'HW del Tag (quindi in pratica non si fa).\n\nSegue che la complessità computazionale è $O(N\\log N)$.","x":1218,"y":-3941,"width":759,"height":574,"color":"4"},
		{"id":"b00aab8306e43b32","type":"text","text":"# Aggiunte RFID\n\n\nin TSA i tag devono ricordare la collisione precedente (so she said, siamo sicuri?). la performance è 43% circa.","x":4760,"y":-4320,"width":620,"height":180},
		{"id":"4b21c821ca9a99a5","type":"text","text":"# Radio Frequency Identification (RFID)\n\nÈ un sistema che consta di tre componenti:\n\n- ***Tag*** - Circuiti molto semplici, al punto che spesso sono integrati in uno sticker. Identificati da un codice univoco tipicamente a `96 bit`, possono essere alimentati (attivi) e non (passivi). Il loro ruolo è rispondere ad uno stimolo EM esterno;\n- ***Reader*** - Dispositivi che emettendo un segnale EM forniscono ai Tag la potenza necessaria a rispondere (i.e. i Tag trasmettono per ***back-scattering***);\n- ***Server*** - Riceve e processa i dati ricevuti dal Reader.\n\nI Tag passivi sono spesso utilizzati per l'identificazione (e.g. come alternativa al codice a barre), in quanto sono low cost, battery free e non necessitano line of sight.\n","x":2331,"y":-2522,"width":759,"height":355,"color":"6"},
		{"id":"39bd0d24bf3d18c1","type":"file","file":"Reti di Elaboratori/RFID.png","x":1362,"y":-2522,"width":472,"height":355},
		{"id":"2d2a1ead3f62559a","type":"file","file":"TSA_Efficiency.png","x":4622,"y":-2555,"width":598,"height":423},
		{"id":"affb87dd75497bd6","type":"text","text":"# Partizionamento del Canale\n\nUn protocollo del genere divide il canale in slot più piccoli, dando l'esclusiva ad un solo host per ogni slot.\n\n- **Time Division Multiple Access** (***TDMA***) è un Time Division Multiplexing;\n- **Frequency Division Multiple Access** (***FDMA***) è un Frequency Division Multiplexing;\n\nSi possono usare in combinazione con i protocolli ad accesso casuale ad esempio riservare alcuni slot ad un certo NIC con TDMA lasciando uno Slotted Aloha sugli altri (e.g. DOCSIS, che non credo funzioni esattamente così ma idgaf).","x":13785,"y":-5122,"width":581,"height":412,"color":"4"},
		{"id":"5e772fe2702b3d44","type":"text","text":"# Bluetooth\n\nBluetooth (***IEEE 802.15***) è una rete a corto raggio ($10\\,\\text{m}$) che trasmette a velocità moderate ($1\\text{Mbps}$). Definisce due tipi di reti:\n\n- ***Piconet***, in cui vi possono essere 8 dispositivi al massimo, di cui uno primario (e.g. smartphone) e 7 secondari (e.g. cuffie, tastiera);\n- ***Scatternet***, in cui un dispositivo secondario di una Piconet diventa il primario di un'altra.\n\nUsa anch'esso la banda $2.4\\,\\text{GHz}$ (come Wi-Fi), ma la divide in 79 canali da $1\\,\\text{MHz}$ ciascuno. Questo significa che il protocollo deve evitare interferenze con 802.11b. E cosa fa il bimbo speciale? Si inventa un complesso sistema di specchi e leve che usa ***TDMA***.\n\nAnzitutto slottizza il tempo ($625 \\mu s$), alternando i ruoli di mittente e destinatario tra dispositivo primario e secondario (**half-duplex**). Ma ad ogni slot cambia anche frequenza, tra le 79 disponibili. Poco male se qualcuna di queste non funziona perché forse c'è anche il Wi-Fi, ne abbiamo altre! Inoltre, se ci sono più device connessi spetta al primario dire a chi tocca nel prossimo slot.\n\nCome se non bastasse, definisce una propria stack protocollare della quale non mi azzardo a parlare.","x":13785,"y":-4638,"width":581,"height":637,"color":"4"},
		{"id":"733d37bec4794264","type":"file","file":"Reti di Elaboratori/Bluetooth.png","x":13876,"y":-3960,"width":400,"height":164},
		{"id":"63119a3b9909af65","type":"text","text":"# Protocolli \"Semplici\"\n\nQuando l'HW si fa semplice, i protocolli efficienti smettono di giocare.\n\nSe ho un HW semplice non posso implementare algoritmi complessi.","x":14204,"y":-5321,"width":624,"height":150,"color":"6"},
		{"id":"80a40c0953bfe923","type":"text","text":"# Persistenza\n\nI protocolli di accesso multiplo si possono dividere in tre categorie, a seconda del tipo di comportamento.\n\n- ***Non-Persistente*** - **CSMA** senza CD:\n\t- Se trova il canale libero trasmette subito;\n\t- Se trova il canale occupato desiste (riprova ad ascoltare dopo un tempo casuale);\n- ***p-Persistente*** - Se trova il canale occupato resta in ascolto (*persiste*) in attesa che si liberi. Quando il canale è libero trasmette con probabilità $p$ (e.g. **Slotted Aloha**);\n\t- ***1-Persistente*** - Un sottocaso di *p-persistenza* in cui $p = 1$, cioè se trova il canale libero trasmette subito (e.g. **Ethernet CSMA/CD**).\n\n\n","x":16198,"y":-5820,"width":535,"height":419,"color":"4"},
		{"id":"cf066ff07b9dcf69","type":"file","file":"Reti di Elaboratori/CSMA_CD.png","x":16312,"y":-6164,"width":306,"height":263},
		{"id":"faa6429103579d88","type":"text","text":"# Ethernet CSMA/CD\n\nProtocollo per regolamentare il \"vecchio\" Ethernet a cavo condiviso (adesso è punto-punto, si collega direttamente ad una porta fisica dello switch o del router.\n\nSi articola in diversi passaggi, in cui la scheda di rete (NIC)\n\n1. riceve il datagramma dal livello di rete e crea il frame;\n2. ascolta (*sense*) il canale:\n\t- se è inattivo avvia la trasmissione;\n\t- se è occupato attende che si liberi, quindi trasmette (1-persistente);\n3. trasmette il frame, restando in ascolto per eventuali collisioni;\n\t- Se non avvengono collisioni, tutto ok;\n\t- Altrimenti, interrompe la trasmissione e invia un segnale di `jam` ($48\\,bit$, avvisa tutti gli altri NIC);\n\t\t- Dopo questa comunicazione, il NIC entra in fase di ***backoff binario***:\n\t\t\t- dopo l'$n$-esima collisione, il NIC estrae a caso un valore $k$ nell'intervallo $[0, 2^n-1]$, attende $k$ slot ($\\Rightarrow$ tempo per tramettere un frame di $512\\,bit$) e torna al punto 2;\n\t\t\t- più collisioni allungano l'intervallo di backoff;\n\t\t\t- I tempi si aggiornano in modo un po' caotico, non è ovvio prevederne il comportamento a livello teorico.\n\nEmpiricamente, l'efficienza di questo algoritmo in condizioni ragionevoli è $\\simeq 50\\%$. Facendo probabilmente dei calcoli che non mi va di fare si può arrivare all'espressione$$\\eta = \\frac{1}{1 + 5\\frac{t_{P}}{t_{T}}}$$","x":16785,"y":-6641,"width":700,"height":740,"color":"4"},
		{"id":"ed1a9855d26a488d","type":"text","text":"# Ethernet\n\nSe in origine la tecnologia Ethernet usava un cavo condiviso o un ***hub*** (che prendeva più cavi e li rendeva di fatto un cavo condiviso), oggi è sostanzialmente sempre punto-punto (**full-duplex**) con l'ausilio degli ***switch***.\n\nUn frame Ethernet si suddivide nel seguente modo:\n\n- ***Preambolo*** - Serve a sincronizzare la frequenza di invio dei dati con quella di lettura. A sua volta diviso in due parti:\n\t- i primi 7 byte (`10101010`) servono a dare il tempo a chi ascolta di adattarsi alla frequenza;\n\t- l'ultimo, detto **Start Frame Delimiter** (**SFD**, `10101011`) segna l'inizio del messaggio;\n- **Indirizzi di destinazione e sorgente**;\n- ***Type*** - Identificativo del protocollo di rete da usare per demultiplexare (tipicamente è IP);\n- ***Dati*** - C'è una ***lunghezza minima*** (**46 byte**) che insieme alla lunghezza massima del cavo garantisce che CSMA/CD sia in grado di identificare le collisioni. Se non li raggiungo faccio ***padding***;\n- ***CRC*** - Controllo degli errori.\n\nEsistono diverse implementazioni di Ethernet per adattarsi al tipo di canale (i.e. full-duplex o half-duplex) e al tipo di mezzo (e.g. doppino intrecciato, fibra ottica).","x":17673,"y":-6641,"width":612,"height":740,"color":"4"},
		{"id":"f19b3a4fa73ba9e8","type":"text","text":"# Non sapevo di essere in fase\n\nProssimamente, su DMAX.\n\nNo, seriamente: come faccio a sapere di essere in fase? Perché se non sono tutti perfettamente sincronizzati CDMA esplode malamente, e ho evitato ogni commento a riguardo.\n\nPare che esistano dei codici che restano ortogonali a tutti gli altri anche se sono sfasati (sprecando un po' di bit). Non entrerò nel dettaglio finché non finirò a lavorarci.","x":14685,"y":-7614,"width":535,"height":303,"color":"4"},
		{"id":"8c0119c21d2aab9f","type":"text","text":"# CDMA\n\n***Code Division Multiple Access*** (***CDMA***) è un metodo per consentire la trasmissione simultanea di diverse sorgenti su un singolo canale, utilizzando dei ***codici personali per demultiplexare le informazioni***.\n\nI codici sono sequenze ortogonali (***chip***) tali che\n- $\\langle i|j\\rangle$ = $\\delta_{ij}$\n- $|i|^2 = N$, dove N è il numero di stazioni che comunicano sul canale condiviso;\n\t- Per come vengono generati i codici ortogonali (tabelle di Walsh), ne escono fuori sempre $2^n$. Scegliere $N = 2^n$ significa ottimizzare il numero di stazioni che sfruttano quei codici (sicuramente deve essere $N\\leq2^n$);\n\nQuesti chip si accompagnano ad ogni bit inviato. `1` resta `1`, mentre `0` ***viene mappato nel segnale*** `-1`. Questo perché il silenzio (`0`) non è un segnale!\n\nCDMA viene usato nella telefonia mobile. I codici vengono assegnati agli host dalla cella, che\n\n- è l'unica a conoscerli tutti;\n- deve usare codici ortogonali alle celle vicine.\n\nIn realtà ci sono dei codici hard-coded nel telefono, il quale li testa per trovare il match migliore con la cella più veloce.\n\nIn passato CDMA è stato usato anche come codice di crittografia, ma i segnali non sono veramente casuali e un attaccante bravo può risalire al messaggio.","x":14685,"y":-6898,"width":535,"height":997,"color":"4"},
		{"id":"7453c854124ec469","type":"text","text":"## ... e il principio di sovrapposizione?!\n\nSe la collisione non avviene a destinazione, che mi importa? Vale il principio di sovrapposizione, per cui due onde dopo aver fatto interferenza tornano esattamente come prima, no?\n\n... no. Siamo in un cavo, non nel vuoto. La propagazione sfrutta le proprietà elettriche del mezzo, motivo per cui una sovrapposizione può indurre fenomeni non lineari o interferenze distruttive che non propagano il segnale.","x":15445,"y":-7031,"width":700,"height":260,"color":"4"},
		{"id":"c0bea95135c9c558","type":"text","text":"# CSMA/CD\n\n***Carrier Sense Multiple Access*** (***CSMA***) stabilisce delle regole per evitare che ci siano collisioni:\n\n- Se il canale è libero, invia l'intero frame;\n- Se il canale è occupato riprova più tardi.\n\nQuesto però non evita di per sé le collisioni: dal momento che la velocità di propagazione del segnale è finita, mentre A osserva che il canale è libero ed inizia a trasmettere, dall'altro lato del cavo B può aver già iniziato la trasmissione. Questo significa che da quando B inizia a trasmettere c'è un ***tempo di vulnerabilità*** pari ad un tempo di propagazione $t_P$ entro il quale A non dovrebbe mandare messaggi, pena la loro sovrapposizione.\n\nE se li manda lo stesso? Nel momento in cui rilevo una collisione (ovvero, mi rendo conto che arrivano dati mentre io sto trasmettendo) introduco un meccanismo di ***Collision Detection*** (***CD***) che interrompe la mia trasmissione.\n\nLa cosa importante, insomma, è essere in grado di rilevare la collisione. La chiave sta nella dimensione minima del frame che viene inviato. Perché il CD funzioni, il mittente deve poter rilevare la trasmissione in ingresso mentre sta trasmettendo, ovvero prima di inviare l’ultimo bit del proprio frame. Il caso peggiore è quello in cui B inizia a trasmettere un attimo prima di ricevere i primi bit da A, per cui prima che A si renda conto di questa collisione passerà $\\sim 2t_P$. \n\nQuindi è sufficiente porre per ogni frame un ***tempo di trasmissione minimo di ***$2t_P$.","x":15445,"y":-6641,"width":700,"height":740,"color":"4"},
		{"id":"c934a9e7d90eb7cc","type":"text","text":"# Accesso Casuale\n\nSi basano su due possibili approcci:\n\n- Cerco di impedire le collisioni (e.g. ***CSMA/CD***);\n- Cerco di recuperare dalle collisioni (e.g. ***Aloha***)","x":15568,"y":-5699,"width":455,"height":177,"color":"6"},
		{"id":"825165ad441d79f9","type":"text","text":"# Rotazione\n\nRound Robin con i dispositivi che devono trasmettere. Due modi principali di implementarlo:\n\n- ***Polling*** - Un ***nodo master*** invita a turno (con un messaggio di `poll`) i ***nodi slave*** a trasmettere. Tipicamente usato se questi nodi slave non hanno un HW/SW in grado di gestire protocolli complessi. Creare e inviare ogni volta il `poll` crea overhead, aspettarlo per inviare crea latenza, e infine c'è un unico *point-of-failure* (il nodo master);\n- ***Token Passing*** - Ci si mette in cerchio e si gioca a passarsi un ***token di controllo***. Chi ha il token trasmette. E se si perde il token? Non possiamo più giocare!","x":14666,"y":-5122,"width":581,"height":412,"color":"4"},
		{"id":"bd33a66a27f4e32d","type":"text","text":"# Radio Frequency Identification (RFID)\n\nÈ un sistema che consta di tre componenti:\n\n- ***Tag*** - Circuiti molto semplici, al punto che spesso sono integrati in uno sticker. Identificati da un codice univoco tipicamente a 96 bit, possono essere alimentati (attivi) e non (passivi). Il loro ruolo è rispondere ad uno stimolo EM esterno;\n- ***Reader*** - Dispositivi che emettendo un segnale EM forniscono ai Tag la potenza necessaria a rispondere;\n- ***Server*** - Riceve e processa i dati ricevuti dal Reader.\n\nI Tag passivi sono spesso utilizzati per l'identificazione (e.g. come alternativa al codice a barre), in quanto sono low cost, battery free e non necessitano line of sight.\n\nQuando un'antenna richiede gli ID di un gruppo di Tag, questi rispondono simultaneamente. Serve un protocollo semplice per evitare le collisioni, e viene rispolverato ***Aloha*** in versione un po' più semplice: il reader dice a tutti `generate un numero casuale da 1 a N, a ogni slot temporale decrementatelo e rispondete quando arriva a 0`. L'efficienza di questa roba è $\\sim 37\\%$, altrimenti c'è la sua variante ***Tree Slotted Aloha***: ogni slot in cui c'è collisione di $N$ Tag diventa la radice di un albero che iterativamente si occupa di risolvere solo quegli $N$ Tag (più facile a farsi che a dirsi).","x":14666,"y":-4638,"width":581,"height":637,"color":"4"},
		{"id":"8ae579769d34655f","type":"file","file":"Reti di Elaboratori/RFID.png","x":14757,"y":-3946,"width":400,"height":301},
		{"id":"30928e3765ea01bf","type":"text","text":"# Aloha\n\nInvia subito il frame, dopodiché se c'è stata una collisione aspetta un tempo estratto casualmente e riprova. Questo **assume che tutti i nodi siano in grado di rilevare le collisioni**. Ci sono due possibili implementazioni:\n\n- ***Slotted Aloha*** - Il più usato. Divide il tempo in slot, assumendo che tutti i frame abbiano la stessa dimensione e che tutti i nodi siano sincronizzati. Se avviene una collisione, a partire dallo slot successivo ogni nodo ha una probabilità $p$ di ritrasmettere. $p$ è estratta casualmente, altrimenti sarebbe molto probabile generare altre collisioni;\n\t- Abbastanza semplice: l'unica sincronizzazione è sugli slot;\n\t- Se c'è un solo nodo a trasmettere, può usare tutta la banda;\n\t- Per $N \\to \\infty$ nodi, la binomiale restituisce un'efficienza massima $1/e \\simeq 37\\%$;\n\t- Di contro, a seguito di collisioni potrebbero esserci slot inutilizzati;\n- ***Pure Aloha*** - Più semplice, ma meno efficiente. Non richiede nemmeno quel minimo di sincronizzazione degli slot, ma di contro aumenta la probabilità di collisione;\n\t- Ogni frame ha un ***tempo di vulnerabilità*** di $2\\,t_T$ (tempo di trasmissione), perché può fare overlap con un altro frame\n\t\t- che è partito fino a $1\\,t_T$ prima di lui;\n\t\t- che parte prima che sia stato trasmesso completamente ($1\\,t_T$);\n\t- Efficienza misurata $\\simeq 18\\%$.","x":15445,"y":-5261,"width":700,"height":623,"color":"4"},
		{"id":"93588f5566f63388","type":"file","file":"Reti di Elaboratori/SlottedAloha.png","x":15445,"y":-4581,"width":700,"height":181},
		{"id":"a984965221233e7a","type":"file","file":"Reti di Elaboratori/PureAloha.png","x":15445,"y":-4342,"width":700,"height":181},
		{"id":"895bc3f1bf8fd64a","type":"text","text":"## CDMA vs FDMA\n\nConcettualmente CDMA è simile a FDMA (volendo, sono gli 11 canali del Wi-Fi), nel senso che entrambi permettono l'accesso senza latenza al canale condiviso.\n\n- CDMA richiede hardware e software dedicato, ma può essere modificato più velocemente per adattarsi al numero di nodi nella rete (basta generare e assegnare nuovi codici);\n- FDMA può richiedere hardware costoso per gestire i filtri per gestire le diverse bande.","x":13785,"y":-7263,"width":780,"height":232,"color":"4"},
		{"id":"3f6df1e0812fdc42","type":"text","text":"# Tipi di frame 802.11\n\nLe informazioni sul tipo di messaggio sono contenute nei primi $2\\,byte$ dell'header 802.11.\n\nIn particolare si hanno\n\n- Due bit che identificano la categoria del messaggio (e.g. `00` è un frame di gestione, `10` un frame di dati);\n- Quattro bit che specificano un tipo entro la categoria. Entro i frame di controllo `01` troviamo RTS (`1011`), CTS (`1100`) e ACK (`1101`);\n- Due bit (`To DS` e `From DS`) che spiegano come leggere i quattro indirizzi MAC che seguono all'interno dell'header, ovvero\n\t- `00` - Comunicazione ad-hoc (p2p);\n\t- `01`, `10` - Voglio parlare ad un altro nodo tramite AP (come comunicare in LAN tramite uno switch);\n\t- `11` - Devo passare per diversi AP per raggiungere la mia destinazione (e.g. in aeroporto ci sono tanti AP diversi ma con lo stesso SSID che comunicano tra loro)\n\nIl formato del frame 802.11 è convertibile in Ethernet in modo semplice.","x":13785,"y":-6901,"width":780,"height":540,"color":"4"},
		{"id":"85f2794d386784c8","type":"file","file":"Reti di Elaboratori/CSMA_CA.png","x":13785,"y":-6301,"width":332,"height":400},
		{"id":"9761cb49699f7d24","type":"file","file":"Reti di Elaboratori/PrenotazioneCanale.png","x":14165,"y":-6240,"width":400,"height":279},
		{"id":"34ea13703634e6c8","type":"text","text":"# Protocolli di Accesso Multiplo (LAN)\n\nSu canale ***half-duplex***, due host non possono parlare insieme.\n\nSe un nodo ascolta più segnali contemporaneamente si verifica una ***collisione***.\n\nI protocolli provano ad impedire o a recuperare dalle collisioni sapendo che non esiste un canale di controllo out-of-band e cercando di garantire **fairness** sulla banda pro-capite.","x":14204,"y":-5750,"width":624,"height":279,"color":"6"},
		{"id":"332c0e8ffc8d1968","type":"text","text":"# Protocollo ARP\n\nPer comunicare il LAN devo conoscere l'indirizzo MAC del destinatario. Assumiamo di conoscerne già l'IP. Verifico prima di tutto che sia dentro la LAN (altrimenti devo passare dal router). Come? Confrontando il mio IP col suo attraverso la subnet mask.\n\n- Se l'IP che voglio raggiungere è in locale ma non so il suo MAC Address mando broadcast una ***richiesta ARP*** (RFC 826), includendo la mia coppia (IP, MAC) (una cosa del tipo `se hai IP 192.168.1.10, manda il tuo MAC alla coppia IP = 192.168.1.20 e MAC = AB:AD:DE:AD:CA:FE`. Chi non ha questo IP semplicemente ignora il messaggio). L'interessato riceve la richiesta, si segna la mia coppia (IP, MAC) nella ***cache ARP*** (associando un `TTL` tipicamente e procede a rispondermi unicast (perché a questo punto sa il mio MAC) con la sua coppia;\n- Se l'IP che voglio raggiungere NON è in locale devo passare dal gateway router. Faccio ARP sul gateway router (il cui IP è impostato di default come parametro di connessione), dopodiché se la vede lui con le proprie tabelle di routing. Questo ovviamente avviene solo la prima volta. Preso il MAC del gateway, se la vede lui.\n\t- Nota che alla stessa porta possono corrispondere diversi MAC. La porta fisica è \"dove andare per raggiungere questo MAC\", non \"SOLO questo MAC\"!","x":10968,"y":-4508,"width":752,"height":510,"color":"4"},
		{"id":"93d339019972442f","type":"text","text":"# Quindi cosa serve per comunicare?\n\nSe voglio comunicare ***in locale***, mi bastano due informazioni:\n\n- il mio ***IP***;\n- la ***maschera di sottorete***.\n\nAl resto pensa ARP.\n\nSe voglio comunicare ***al di fuori della mia sottorete***, mi servono ***anche***\n- ***IP del router*** (default gateway)\n- ***IP di un server DNS***.\n\nTutto questo viene configurato automaticamente al momento della creazione della connessione dal DHCP.","x":10968,"y":-3920,"width":752,"height":408,"color":"4"},
		{"id":"f7bb59d2b607b321","type":"text","text":"# VLAN (Virtual LAN)\n\nSe volessi dividere una rete in due sottoreti? Posso mettere un router e creare una nuova LAN, certo, ma introduco complessità (nonché il livello di Rete, qua stiamo in DLL!).\n\nPosso invece dividere le porte di un singolo switch fisico in due gruppi distinti, e costruire le tabelle MAC come se ogni gruppo fosse uno switch fisico separato dall'altro. Proprio come fossero fisicamente separati, questi ***switch virtuali*** così costruiti sono indipendenti l'uno dall'altro, e ad ognuno di essi corrisponde una ***LAN Virtuale*** (***VLAN***).\n\nSi sa, virtualizzare apre sempre le porte alle magie perché introduce il SW. Inoltre, la topologia virtuale non è vincolata alla topologia fisica.\n\nPosso assegnare ad ogni VLAN un codice identificativo (***VLAN Tag***) e collegare la `VLAN 10` di uno switch fisico con la `VLAN 10` di un altro tramite cavo (***Access***), creando un singolo switch virtuale fisicamente delocalizzato.\n\nSe voglio collegare diverse VLAN di uno switch fisico ad un altro switch fisico devo usare un cavo Access per ciascuna? No, esistono cavi che collegano in blocco più VLAN (detti ***Trunk***). C'è un campo dell'header per il VLAN Tag (`ID`, impostato dallo switch quando invia il frame su un Trunk) che serve allo switch fisico di destinazione per demultiplexare.\n\n- E se mi arriva un frame senza VLAN Tag? Definisco una ***Native VLAN*** a cui indirizzare di default i frame senza Tag.\n\t- Non serve solo a questo! Ipotizziamo la Native sia `ID = 10`. Se arriva una frame da un Access della VLAN `30`, lo switch controlla se `30` è la Native. Non lo è, allora mette il tag `30` e invia. Se invece arriva un frame da un Access della Native (`10` in questo esempio), lo switch non mette alcun tag!\n\t- I ***Trunk*** sono connessi alle ***Tagged Ports***, gli ***Access*** alle ***Untagged Ports***. La Native VLAN è l'unica che attraversa un Tagged Link senza Tag.\n- ***802.1q*** è la variante del protocollo Ethernet che include i VLAN Tag;","x":11925,"y":-5261,"width":780,"height":769,"color":"4"},
		{"id":"3babb9c1abd49799","type":"file","file":"Reti di Elaboratori/Confronto_VLAN_Header.png","x":11940,"y":-4093,"width":750,"height":173},
		{"id":"57643829e285a0ee","type":"file","file":"Reti di Elaboratori/VLAN_1.png","x":12819,"y":-5165,"width":400,"height":223},
		{"id":"7553697f9878b2c6","type":"file","file":"Reti di Elaboratori/VLAN_2.png","x":12819,"y":-4781,"width":400,"height":142},
		{"id":"fbefd18df3a53c86","type":"file","file":"Reti di Elaboratori/802.1q.png","x":12033,"y":-4400,"width":564,"height":220},
		{"id":"f87237b7fec09ab2","type":"text","text":"# Dataflow\n\nComplessivamente, tutto il traffico di Internet è interamente determinato da tre oggetti:\n\n- MAC Address Table - Mappa gli indirizzi MAC in porte fisiche (switchports);\n- ARP Table/Cache - Mappa gli indirizzi IP in indirizzi MAC;\n- Routing Table - Indirizza i datagrammi (contenenti gli indirizzi IP) al prossimo router.\n\nPercHé avvenga il flusso di informazioni, se uso la RT poi userò anche la ARP.","x":9400,"y":-3548,"width":619,"height":358},
		{"id":"895e1ffe72619a28","type":"text","text":"# Aggiunte ARP\n\n\"chi ha questo IP mi dica il suo MAC\"\nse arrivano due risposte?\ndipende dall'implementazione, alcune tengono solo la risposta più recente, altre restituiscono un errore (ARP conflict)\nesistono attacchi ARP spoofing in cui mi fingo un'altra interfaccia, ma poco interessante perché dovrei già trovarmi sulla LAN.\n\nswitch in cascata funzionano esattamente come un singolo switch\n\n","x":10267,"y":-3435,"width":600,"height":287},
		{"id":"4b4c321762d3e679","type":"text","text":"# Connettersi ad un AP\n\nLo standard 802.11 assegna dei range di frequenze per il protocollo ***Wireless Fidelity*** (***Wi-Fi***).\n\nLo spettro di frequenze $[2.4, 2.485]\\,GHz$  è diviso in 11 canali parzialmente sovrapposti numerati da $1$ a $11$. Spetta all'admin scegliere quali usare, tenendo conto che segnali distanti $3$ o meno canali possono fare interferenza tra loro. A questo punto:\n\n- L'AP invia segnali periodici, detti ***beacon***, che includono il suo identificatore univoco (Service Set Identifier, SSID) ed indirizzo MAC sui propri canali attivi;\n- I dispositivi in ascolto fanno un check su tutti i canali, intercettando eventuali beacon;\n\t- Inizialmente richiedeva minuti perché l'HW era lento;\n- Ogni dispositivo sceglie uno ed un solo AP, inviando una ***richiesta di associazione***;\n\t- Nel caso delle celle telefoniche, sceglierà l'AP il cui segnale è più forte;\n- L'AP risponde con una ***risposta di associazione*** che permette al dispositivo di effettuare la richiesta DHCP e tornare sostanzialmente al caso di LAN cablata.\n\nTutto questo vale su un singolo AP. Se ce ne sono diversi in contrasto con protocolli diversi, magari uno è molto più aggressivo degli altri e domina\n\n\n\"se sono sintonizzato su una frequenza, tutto il resto è rumore\"\n","x":11925,"y":-7809,"width":780,"height":760,"color":"3"},
		{"id":"840636eb4f2d40f4","type":"text","text":"# Wireless LAN (WLAN)\n\nSi basa sulla presenza di ripetitori (***base station*** per i dati mobili, ***access point*** per le WLAN domestiche) collegati alla rete cablata che propagano onde sferiche. È una trasmissione ***broadcast*** in cui il mezzo condiviso è l'aria.\n\nEsiste anche un paradigma non centralizzato in cui ogni host può comunicare direttamente con ogni altro (***rete ad-hoc*** o ***standalone***, protocolli ***WiFi Direct***) in cui il routing non è centralizzato (***rete mesh***).\n\nSembra semplice: arrivano onde EM e le ricevo. In realtà ci sono tre problemi principali:\n\n- ***Propagazione multi-path*** - quando il segnale sbatte contro una parete, questo viene in gran parte riflesso. Questo significa che l'host riceve una fauna di onde casualmente sfasate da tutte le direzioni (la distribuzione del segnale data dalle pareti di una stanza è un sistema caotico). Quando arrivano segnali sfasati in teoria ci sarebbero i battimenti (disastro a livello di segnale), ma gli access point sono intelligenti. Hanno più antenne e sono abbastanza in grado di ***ricostruire l'informazione di partenza***, a volte anche a potenziarla sommando in fase le due onde;\n\t- Quindi all'esterno questo problema non c'è? Purtroppo c'è, parte del segnale su grandi distanze rimbalza sulla ionosfera, ma un cellulare può ricostruire il segnale a partire da questi rimbalzi;\n- ***Attenuazione del segnale*** - La potenza si conserva sulla sfera, quindi cala come $1/r^2$;\n\t- Come conseguenza, è difficile rilevare una collisione come previsto da CSMA/CD, perché quando parlo la mia voce è molto più forte del segnale che ricevo (lo chiameremo simpaticamente ***problema dell'uomo sulla montagna***);\n\t\t- Le soluzioni richiedono o troppo effort energetico o HW troppo complicato;\n\t\t- Anche se fosse, A che parla con B può sottrarre il proprio rumore ma non può sottrarre il rumore di terminali che non conosce, ad esempio C, mentre quest'ultimo nemmeno se ne accorge (***hidden terminal problem***);\n\t- Se il segnale si attenua troppo può confondersi col ***rumore***, per cui si definisce un ***Signal to Noise Ratio*** (***SNR***);\n- ***Interferenze*** - Più ripetitori che usano le stesse frequenze possono interferire a destinazione. Anche il multi-path è considerabile un'interferenza\n\nLa IEEE stabilisce come standard ***802.11*** (cui segue una lettera ad indicare le specifiche tecniche, come frequenze utilizzate e larghezza di banda). L'equivalente di una LAN in cui l'access point fa le veci di uno switch è detto ***Basic Service Set*** (***BSS***). Più BSS organizzati in modo gerarchico formano un ***Extended Service Set*** (***ESS***).","x":11925,"y":-6901,"width":780,"height":1000,"color":"4"},
		{"id":"1dbf5273a42e5229","type":"file","file":"Reti di Elaboratori/ProtocolliWireless.png","x":12115,"y":-8159,"width":400,"height":214},
		{"id":"df043301b08dc4bc","type":"text","text":"# CSMA/CA\n\nIn virtù del **problema dell'uomo sulla montagna** e dell'**hidden terminal problem** non posso usare Collision Detection. Allora implemento una ***Collision Avoidance*** (***CA***), cioè evito a priori che si possano mai verificare collisioni. Come?\n\nPer ovviare al problema dell'uomo sulla montagna:\n\n- Introduco degli intervalli tra un frame e l'altro, detti ***InterFrame Space*** (***IFS***);\n\t- Il mittente ascolta il canale per un tempo ***DIFS*** (***Distributed IFS***). Se Carrier Sense non rileva segnali in ingresso, al termine del DIFS manda il frame;\n\t- Se il destinatario riceve il frame senza interferenze, aspetta un tempo ***SIFS*** (***Short IFS***, di durata $SIFS < DIFS$) e manda un ***ACK*** di conferma;\n- Introduco una ***finestra di contesa*** per stabilire la durata del DIFS;\n\t- La grandezza della finestra segue il [[Backoff Esponenziale]];\n\nPer ovviare al problema del terminale nascosto:\n\n- Introduco un meccanismo di ***prenotazione del canale***:\n\t- La sorgente (A) aspetta un DIFS e manda una ***Request To Send*** (***RTS***), con cui comunica alla destinazione (B) quanti dati vuole mandare e per quanto tempo serve prenotare il canale. Tale tempo è detto ***NAV*** (***Network Allocation Vector***);\n\t- Se B riceve RTS senza interferenze, attende un SIFS e manda a tutti un messaggio ***Clear To Send*** (***CTS***) con cui \n\t\t- avvisa la sorgente che può procedere a inviare;\n\t\t\t- Se A non riceve il CTS assume che il canale non sia libero, aggiorna il backoff esponenziale e riprova dopo un tempo estratto casualmente;\n\t\t- invita tutti gli altri (compresi gli hidden terminal C) a starsi zitti finché non finisce il NAV;\n\t\t\t- Se C sta già ricevendo qualcos'altro potrebbe non sentire il CTS;\n\t\t\t- Questo potrebbe bloccare anche comunicazioni che non avrebbero interferito con A e B (B urla a tutti di fare silenzio anche quando non è strettamente necessario);\n\t- Una volta che il canale è prenotato, A aspetta solo un SIFS piuttosto che un DIFS;\n\t- Questo meccanismo viene usato solo per pacchetti \"grandi\".\n","x":12899,"y":-6901,"width":760,"height":1000,"color":"4"},
		{"id":"d66b5203ff904bb6","type":"text","text":"# Rete Mobile\n\n\n\"c'è stata una spinta commerciale per la rete mobile vs la rete di casa\n\nLa copertura dall'antenna era detta cella (da cui cellulari?) in ogni punto arrivano più segnali, devo scegliere il più forte. prima c'erano addetti che misuravano, ma si può demandare ai singoli clienti della rete (misurano già in loco quanto forte vedono una certa antenna)\n\nin teoria ormai linea mobile ed internet hanno la stessa cella, in pratica c'è una virtualizzazione che rende il canale telefonico un po' più affidabile \n\nvedi GSM, VOIP, ...\n\nSe mi sposto tra diversi AP della rete mobile (***roaming***), questa deve essere in grado di non far crollare tutte le connessioni TCP che avevo.\n\n- H1 sente che il segnale da AP1 si affievolisce e avvia una scansione per un segnale più forte\n- H1 rileva AP2, si disassocia da AP1 e si associa a AP2, mantenendo lo stesso IP e sessioni TCP\n- AP2 invia un frame broadcast allo switch con indirizzo mittente H1 e lo switch capisce che H1 è ora nel BSS2","x":12965,"y":-8341,"width":628,"height":680},
		{"id":"c287d4aa7b5a27a1","type":"text","text":"# Protocolli di Accesso Multiplo (WLAN)\n\nDue AP possono scegliere canali troppo vicini, rischiando quindi di fare interferenza. Se succede, si torna al problema del canale condiviso. Lo standard ***802.11*** implementa un controllo detto ***Distributed Coordination Function*** (***DCF***), che si basa su ***CSMA/CA***.","x":12965,"y":-7521,"width":628,"height":180,"color":"6"},
		{"id":"e65e158ed9f2ecee","type":"text","text":"# Ma perché sta tutto a 2.4 GHz?\n\nEsistono bande di frequenza a pagamento, spesso gestite e assegnate dagli stati o dalle autorità di regolamentazione delle telecomunicazioni. Queste bande sono tipicamente utilizzate per applicazioni commerciali, come le comunicazioni mobili, le trasmissioni televisive e radiofoniche, e altri servizi wireless. Ecco un resoconto esaustivo delle principali bande di frequenza a pagamento e dei loro utilizzi:\n\n### Bande di Frequenza e i loro Utilizzi\n\n1. **Comunicazioni Mobili**\n   - **GSM (2G)**: 900 MHz e 1800 MHz\n   - **3G (UMTS)**: 2100 MHz\n   - **4G (LTE)**: Diverse bande, tra cui 700 MHz, 800 MHz, 1800 MHz, 2100 MHz, 2600 MHz\n   - **5G**: Bande sotto i 6 GHz (sub-6), come 700 MHz, 3.5 GHz e bande millimetriche (mmWave) come 24 GHz, 28 GHz, e 39 GHz\n\n2. **Trasmissioni Televisive e Radiofoniche**\n   - **TV Broadcast**: VHF (30 MHz - 300 MHz) e UHF (300 MHz - 3 GHz)\n   - **Radio AM**: 535 kHz - 1605 kHz\n   - **Radio FM**: 88 MHz - 108 MHz\n\n3. **Servizi Satellitari**\n   - **Satelliti di Comunicazione**: C-band (4 GHz - 8 GHz), Ku-band (12 GHz - 18 GHz), Ka-band (26 GHz - 40 GHz)\n   - **GPS**: 1.227 GHz e 1.575 GHz\n\n4. **Servizi Pubblici e di Sicurezza**\n   - **Bande per la Sicurezza Pubblica**: 700 MHz, 800 MHz\n   - **Servizi Aeronautici**: 108 MHz - 137 MHz (comunicazioni di aviazione civile)\n\n5. **Servizi per le Reti Wireless a Larga Banda**\n   - **WiMAX**: 2.3 GHz, 2.5 GHz, 3.5 GHz\n\n### Assegnazione e Regolamentazione delle Frequenze\n\n1. **Regolamentazione Nazionale**\n   - **FCC (Federal Communications Commission)** negli Stati Uniti\n   - **Ofcom** nel Regno Unito\n   - **ARCEP** in Francia\n   - **AGCOM** in Italia\n\n2. **Regolamentazione Internazionale**\n   - **ITU (International Telecommunication Union)**: Un'agenzia specializzata delle Nazioni Unite che coordina l'uso globale dello spettro radio e delle orbite satellitari.\n\n### Modalità di Assegnazione delle Frequenze\n\n1. **Aste di Spettro**\n   - Le bande di frequenza sono spesso vendute tramite aste in cui le compagnie di telecomunicazioni competono per ottenere licenze per l'uso di determinate bande di frequenza.\n\n2. **Licenze di Spettro**\n   - Le licenze possono essere assegnate tramite concessioni dirette o procedure competitive, e le aziende pagano per l'uso esclusivo delle bande assegnate per un determinato periodo.\n\n3. **Canoni di Utilizzo**\n   - Oltre al costo iniziale dell'assegnazione, le licenze possono comportare canoni annuali per l'uso continuo dello spettro.\n\n### Esempi di Bande di Frequenza a Pagamento e le loro Utilizzazioni Specifiche\n\n1. **700 MHz**\n   - Utilizzata per LTE e 5G.\n   - Favorita per la sua capacità di coprire grandi aree e penetrare edifici.\n\n2. **3.5 GHz**\n   - Una delle bande principali per il 5G, offrendo un buon equilibrio tra copertura e capacità.\n\n3. **24 GHz e 28 GHz (mmWave)**\n   - Utilizzate per il 5G per offrire velocità molto elevate, sebbene con una copertura limitata.\n\n### Bande di Frequenza Gratuita\n\n1. **Bande ISM**\n   - **2.4 GHz**: Utilizzata da Wi-Fi, Bluetooth, e altri dispositivi senza fili.\n   - **5 GHz**: Utilizzata da Wi-Fi (802.11a/n/ac/ax).\n   - **13.56 MHz**: Utilizzata da NFC.\n\n2. **Bande di Frequenza non Licenziate**\n   - Utilizzate per applicazioni come le reti wireless locali, i dispositivi a corto raggio, e le comunicazioni industriali.\n\n### Conclusione\n\nLe bande di frequenza a pagamento sono cruciali per molte applicazioni commerciali e pubbliche, e la loro assegnazione è rigorosamente regolamentata per garantire un uso efficiente e coordinato dello spettro. Le aste e le licenze di spettro permettono di gestire l'accesso a queste risorse preziose, assicurando che vengano utilizzate per servizi che portano valore economico e sociale.","x":10968,"y":-7809,"width":752,"height":760,"color":"#641e32"},
		{"id":"adcd49e79bfc238c","type":"text","text":"# Errori da Interferenza\n\nIl rumore esterno può distorcere il segnale che transita sul cavo, flippando i bit.\n\nGli errori da interferenza sono spesso ***bursty***: il segnale distorcente capita \"ogni tanto\" ed è \"lento\" rispetto alla velocità del segnale, quindi è più probabile avere un errore su tanti bit consecutivi (***finestra di interferenza***) piuttosto che su uno solo (e.g. se trasferisco a $1\\,Kbps$, un rumore che dura $1\\,ms$ influisce su $10\\,bit$).\n\nIn generale, per rilevare questi errori vengono aggiunti in coda al frame degli ***Error Detection and Correction bits*** (***EDC***). E cosa ci faccio?\n\n- ***Parity Checking*** - Aggiungo un solo EDC in coda, in modo che la somma tra esso e tutti i bit del messaggio sia pari. Se a destinazione non lo è, vuol dire che c'è stato un errore. Naturalmente questo ***non garantisce di individuare gli errori***:\n\t- Un numero pari di errori conserva la parità;\n\t- Se il check non torna posso solo dire che c'è stato un numero dispari di errori.\n\t- Non ho informazioni su dov'è l'errore, quindi non posso recuperarlo;\n- ***Parity Checking Bidimensionale*** - Metto i bit del frame su una matrice e faccio checksum su ogni riga e ogni colonna. Se so che c'è un solo errore lo trovo facilmente (sono sbagliati i checksum di una sola riga ed una sola colonna), ma restano i problemi del numero pari di errori. Ci si può divertire a ideare esempi in cui questo checksum funziona o meno;\n- ***Cyclic Redundancy Check*** (***CRC***) - Mittente e destinatario concordano una sequenza di bit detta **divisore** (o **generatore**, indicato con $G$) per generare una sorta di **digest hash** $R$ a partire dai bit del frame ($D$). Segue procedura:\n\t- Se $G$ consta di $n$ bit, aggiungo a $D$ $n-1$ zeri a destra creando $D'$; \n\t- Svolgo $D'\\,\\%\\,G = R$. Il resto della divisione intera modulo 2 ha un bit in meno del divisore, quindi $R$ ha $n-1$ bit;\n\t- Al posto degli $n-1$ zeri che ho aggiunto a $D$ per creare $D'$ metto gli $n-1$ bit di $R$, creando il messaggio $D''$ (in cui i bit di $R$ sono gli EDC);\n\t- A destinazione svolgo $D''\\,\\%\\,G$, che a questo punto deve darmi esattamente $0$, altrimenti sono certo di aver individuato un errore.\n\nCRC è ottimo se si vuole essere certi di identificare la presenza di un errore, ma non dice niente su dove si è verificato o su come recuperarlo.\n\n Per recuperare dagli errori (utile se ho un canale con altissima latenza come un satellite) si usano gli ***Error Correction Codes*** come ***Hamming***, ***Reed-Solomon***, ***BCH*** ed ***LDPC*** (sui quali non mi azzardo a dire altro se non che esistono).","x":10968,"y":-6901,"width":752,"height":1000,"color":"4"},
		{"id":"1402f82ddabdb007","type":"text","text":"# Switch\n\nReindirizza i frame tra IP della stessa LAN tramite una tabella che associa gli indirizzi MAC dei dispositivi ad esso connessi con la relativa porta fisica, e amplifica il segnale. È un elemento **trasparente** (gli host ignorano la sua presenza) che implementa tre azioni:\n\n- ***Learn*** - Riempire la propria ***Content Addressable Memory*** (***CAM***). Immaginiamola inizialmente vuota. Quando da una porta fisica arriva un frame questo contiene il MAC Address del mittente, permettendo allo switch di aggiungere l'associazione tra quel MAC e la porta da cui è arrivato come riga di una tabella di corrispondenze;\n\t- Nota che il frame potrebbe essere passato per altri switch, quindi non c'è la certezza che alla fine del proprio cavo ci sia proprio la NIC con quel MAC. La corrispondenza è un \"dove inoltrare per andare verso quel MAC\";\n- ***Flood*** - Se lo switch non conosce il MAC Address di destinazione si comporterà da ***hub***, inoltrando il frame in broadcast su tutte le altre porte. Solo il diretto interessato risponderà, di fatto passando per lo switch e facendogli imparare la sua associazione;\n- ***Forward*** - Se so già tutto, reindirizzo in scioltezza. Mentre il router legge l'header di rete e sostituisce l'header di link, lo switch si limita a reindirizzare.\n\nOpera all'interno delle reti locali, e comprende il compito di inoltrare i frame al gateway router, il quale poi se la vede con Internet.\n\nAnche lo switch ha un MAC e un IP, in caso serva configurarlo (e.g. con Telnet, o SSH). Fintantoché il traffico non è rivolto esattamente a lui, questi restano inutilizzati.\n\nRiassumendo, il compito dello switch è apprendere gli indirizzi MAC per reindirizzare correttamente i messaggi rivolti a quei MAC. Ma se non conosco il MAC?","x":10968,"y":-5261,"width":752,"height":696,"color":"4"},
		{"id":"04e2e59fbd2b386f","type":"text","text":"# Livello di Collegamento\n\nGestisce il ***trasferimento hop-to-hop*** dei frame.","x":11128,"y":-5661,"width":432,"height":100,"color":"6"},
		{"id":"0ea7ba1d2a860cba","type":"text","text":"# LAN","x":11283,"y":-5441,"width":123,"height":41,"color":"6"},
		{"id":"44d21c89cd07b8f4","type":"text","text":"# Glossario del Data Link Layer\n\n- ***Data Link Control (DLC)*** - protocollo che definisce la comunicazione hop-to-hop (unicast e non) sul canale condiviso da due host (e.g. incapsulamento, checksum);\n- ***Media Access Control (MAC)*** - protocollo che definisce la comunicazione broadcast;\n\t- Diverso è l'***indirizzo MAC***, che identifica univocamente una ***Network Interface Card*** (***NIC***, e.g. Ethernet, scheda Wi-Fi).\n- ***Flooding*** - Azione di uno switch. Inoltra un frame proveniente da una porta a tutte le altre porte;\n- ***Unicast*** - Un tipo di frame in cui il MAC di destinazione identifica un singolo host. Uno switch può eseguire un'azione di flooding se non conosce il MAC di destinazione;\n- ***Broadcast*** - Un tipo di frame in cui il MAC (i.e. `FF:FF:FF:FF:FF:FF`) indica allo switch di fare flooding. Un host che si vede recapitare un broadcast può decidere se accettarlo o meno, a seconda della configurazione;\n- Un ***canale di comunicazione*** (e.g. cavo Ethernet) può essere\n\t- ***Half-Duplex*** - Supporta trasmissione bidirezionale non contemporanea;\n\t- ***Full-Duplex*** - Supporta trasmissione bidirezionale contemporanea.\n- ***Network Interface Card (NIC)*** - Scheda di rete associata ad un canale di comunicazione ed identificata univocamente da un MAC Address. Collegata all'HW del computer attraverso il BUS, avente un firmware e gestita da un controller SW. Insomma, una periferica.","x":9985,"y":-6604,"width":791,"height":703,"color":"4"},
		{"id":"ea5e414eaee40f14","type":"text","text":"# Indirizzi MAC\n\nOgni scheda di rete (***Network Interface Card, NIC***) è identificata univocamente da un codice a $48\\,bit$, divisi in 6 gruppi da 8 e rappresentati ciascuno con due cifre esadecimali (e.g. `01:00:00:0F.A1.0A` corrisponde a `1:0:0:15:161:15`). Ogni numero decimale separato dai `:` va da `0` a `255`.\n\nIn cima alla catena alimentare dell'assegnazione dei MAC c'è la IEEE, che assegna ai produttori di NIC un ***Organizationally Unique Identifier*** (***OUI***). Questo codice a $24\\,bit$ diventerà l'incipit dei MAC Address prodotti da quel vendor. Ma non solo: si possono ricavare informazioni sul NIC a partire da alcuni bit di questo codice. Poniamo che sia  `xxxxxxBA:yyyyyyyy:zzzzzzzz`.\n\n- Se `A = 0` significa che il NIC è abilitato alle sole trasmissioni ***unicast***, ovvero i NIC che ricevono il frame confrontano il MAC di destinazione con il proprio e lo buttano se i due non coincidono (a meno di attivare la **promiscuous mode**). `A = 1`, viceversa, consente il ***multicast***. Il NIC ricevente (che pure deve avere `A = 1`) confronta il MAC di destinazione con un elenco di indirizzi multicast per decidere se accettare o meno il frame;\n- `B = 0` indica che l'indirizzo MAC è proprio quello assegnato dal vendor (***Universally Administrated***). Perché, ce ne possono essere altri? Già. Questo MAC è *hard-coded* dal vendor, ma io localmente posso scegliere di cambiarlo a patto di mettere `B = 1` (***Locally Administrated***). Quindi, ogni OUI ha `B = 0`;\n- Per altre informazioni prendi un MAC Address e mettilo su [questo sito](https://macaddress.io/mac-address-lookup/wkWqJz7E2K).\n\nOltre al MAC esistono altri formati per gli indirizzi fisici (e.g. **EUI**, **Extended Unique Identifier**), così come diverse lunghezze (e.g. 64 bit).","x":9985,"y":-5261,"width":791,"height":696,"color":"4"},
		{"id":"64182a68ba4bddda","type":"text","text":"# Robe utili dall'esame di Reti\n\nAlcune di queste cose sono caratteristiche del solo TCP/IP (i.e. Internet), ma possono comunque servire.","x":9120,"y":-5671,"width":501,"height":120,"color":"6"},
		{"id":"0e6f35441b30a9ce","type":"text","text":"# Binary Splitting Tree Slotted Aloha\n\nPartiamo con un BS classico. C'è un solo slot, quindi tutti i Tag rispondono insieme. ***BS*** allora li divide in due sottogruppi. Ciascun sottogruppo viene quindi gestito da ***TSA***, il che significa che potrebbero esserci slot del sottogruppo in cui un Tag viene identificato, ma possono ancora verificarsi collisioni. Se si verificano, ricado nel caso di BS e ricomincio.\n\nDal momento che ogni split divide i Tag in due gruppi circa uguali, sono anche sempre più in grado di stimare il numero totale di Tag via via che l'algoritmo procede.\n\n<span style=\"color:#FFA500\">Vogliamo scrivere come?!</span>","x":3532,"y":-3804,"width":759,"height":300,"color":"4"},
		{"id":"1e950c33e4268bb0","type":"file","file":"BSFSAComparison.png","x":4541,"y":-3908,"width":759,"height":508},
		{"id":"06c8dfc1835bdad9","type":"text","text":"# Aloha Based Protocols\n\nProtocolli in cui il tempo è discreto e la sua unità minima è detta ***slot***. Si possono poi eventualmente raggruppare più slot in un ***frame***.\n\nLa probabilità che due o più Tag rispondano entro lo stesso slot è un processo ***binomiale***.\n\nPer funzionare, protocolli come ***FSA*** e ***TSA*** hanno bisogno di sapere quanti Tag devono identificare. Essendo un'informazione in generale non nota a priori, ci interessa stimarla. Questo può essere fatto sia con approcci naive che con modelli più sofisticati:\n\n- Con un primo frame conto gli slot di collisione, stimando tramite un numero medio $k$ di collisioni attese per slot di collisione quanti possono essere i Tag totali;\n- Uso un protocollo meno sensibile a questa non-conoscenza, come ***BSTSA***.","x":3532,"y":-3105,"width":759,"height":372,"color":"6"},
		{"id":"58abf9d465bc3980","type":"text","text":"# Framed Slotted Aloha, EPC GEN 2\n\nSe in ***Slotted Aloha*** (***SA***) si assume che tutti i frame abbiano la stessa dimensione, in ***Framed Slotted Aloha*** (***FSA***) il reader ne decide la size volta per volta.\n\nAll'inizio di un frame che consta di $S$ slot, i Tag che sanno di dover essere ancora identificati devono sceglierne uno a caso per trasmettere.\n\nRispetto alla variante a frame fissato, qui posso gestirmela un po' meglio. Metterò un frame più grande all'inizio, quando il numero di potenziali collisioni è alto, e più piccolo alla fine, quando invece mancano pochi Tag e non ha senso sprecare banda. Nonostante tutto si trova comunque un'efficienza $\\text{SE}\\simeq37\\%$, come in SA classico, tuttavia all'atto pratico quando faccio le misure risulta più stabile e su valori più alti.\n\nSu FSA è basato il protocollo ***EPC GEN 2***, che introduce ottimizzazioni quali\n\n- Gli slot di silenzio (i.e. nei quali nessuno risponde) vengono accorciati rispetto agli altri;\n- La grandezza del frame è stabilita in modo dinamico rispetto al numero di collisioni osservate sperimentalmente;\n- Essendo tutto così dinamico, le performance sono valutate in relazione al tempo.","x":4542,"y":-3174,"width":759,"height":510,"color":"4"},
		{"id":"b56e6a2717144541","type":"text","text":"# Tree Slotted Aloha\n\nOgni slot in cui c'è collisione di due o più Tag genera un albero che si occupa di risolvere solo quei Tag che hanno risposto. I frame vengono quindi generati a partire dal numero di collisioni osservate sul singolo slot.\n\nAd esempio, se tra tutti Tag rispondono nel primo slot solo `0001`, `0101` e `1000`, il reader può decidere per un frame lungo `3` al quale parteciperanno solo i Tag sopracitati. Mettiamo che nel primo di questi tre `0001` viene correttamente identificato. Daje. Nel secondo invece gli altri due vanno in collisione. La storia si ripete finché non vengono tutti identificati.\n\nCalcolare la resa teorica di questo protocollo non è facilissimo, perché dipende molto dalla profondità dell'albero (i.e. quante collisioni si verificano). Inoltre, cambia molto tra\n\n- Ottimizzare $\\text{SE}$ - Devo scegliere abbastanza slot da evitare collisioni, ma se ne metto troppi creo degli altrettanto inefficaci idle slot. Se scelgo $N = n$ (i.e. numero di slot per frame pari al numero di Tag da identificare in quel frame) trovo un valore $\\text{SE}\\sim0.37$;\n- Ottimizzare $\\text{Time\\_SE}$ - Se gli idle slots pesano meno, posso permettermi di mettere più slot per frame. Una $\\text{Time\\_SE}$ ottimizzata può superare il $70\\%$ (sovrastimare il numero di slot necessari migliora i risultati, con un picco sperimentale di $N\\sim4.4\\cdot n$).","x":3532,"y":-2601,"width":759,"height":516,"color":"4"},
		{"id":"496569cc5d17f5be","type":"text","text":"# Protocolli RFID\n\nSe un reader richiede gli `ID` di un gruppo di Tag, questi rispondono simultaneamente.\n\nCiò in generale produce un gran numero di collisioni. Per via della semplicità dei Tag, non possono essere questi ultimi ad implementare un protocollo di collision avoidance, quindi tutto l'onere ricade sul coordinatore (i.e. il reader), il quale ha diverse possibilità.\n\n- ***Protocolli Sequenziali*** - Permetto la trasmissione di un tag alla volta (i.e. ***Collision Avoidance***, e.g. ***Binary Splitting*** e ***Slotted Aloha***);\n- ***Protocolli Concorrenti*** - Gestisco le collisioni, quando si verificano (e.g. ***Pure Aloha***).\n\t- Nota che questo NON è Collision Detection. Per realizzare quest'ultimo, tutti i dispositivi devono essere in grado di rendersi conto della collisione, cosa che vista la semplicità dei Tag risulta impossibile;\n\t- Questi protocolli sono utilizzati in RFID solo in condizioni di basso traffico, avendo come unico vantaggio la semplicità d'implementazione.","x":2331,"y":-3135,"width":759,"height":433,"color":"4"},
		{"id":"10eedec3831487f5","type":"text","text":"# Wireless Sensors Network (WSN)\n\nUna WSN è praticamente un sistema RFID in cui i Tag sono attivi e il reader si chiama ***Sink***.\n\nI sensori raccolgono dati in giro e li mandano al Sink, e sono in grado di implementare funzioni complesse come ascoltare attivamente il canale e fare comunicazione multi-hop.\n\nPertanto sulle WSN è possibile utilizzare ***CSMA/CA*** e in generale i protocolli ***MAC***.\n\nLa bontà del segnale viene generalmente valutata con il ***Signal Noise Ratio*** (***SNR***).\n\nPer tutti questi argomenti, cfr. ***Wireless LAN (WLAN)*** in alto a destra.","x":3532,"y":-524,"width":759,"height":355,"color":"6"},
		{"id":"0daddd3434b67fe6","type":"text","text":"# Applicazioni Principali\n\n\n- ***Structural Health Monitoring*** (***SHM***) - Hai costruito un ponte e sai che ci sono alcuni punti deboli da tenere sotto controllo per conoscere lo stato di degrado dell'intera struttura? Magari sono anche difficili da raggiungere? Niente paura, ci pensa la WSN!\n- ***Healthcare*** - \"Mai lasciare un anziano da solo\", ma lavori tutto il giorno? Dotalo di *un botto* di sensori wireless. Battito cardiaco, gait, controllo di caduta. Evolve now!\n- ***Security*** - Quale migliore sistema di monitoraggio per persone e ambienti di una grossa ragnatela wireless autosufficiente?\n- Qualunque monitoraggio di eventi geotermico-climatici su larga scala.","x":3532,"y":-1020,"width":759,"height":304,"color":"4"},
		{"id":"5d63270df240ccdf","type":"text","text":"# Deployment\n\nSe i sensori sono fissi, è verosimile che questi vengano disposti sul territorio secondo un ***Regular Deployment*** che sfrutta simmetrie e simili.\n\nSe i sensori sono mobili, spesso si comincia con un ***Random Deployment*** che viene poi affinato in un Regular (il quale però resta dinamico, in attesa di ulteriori necessità).\n\nDiverse situazioni portano a diversi algoritmi di deployment, nonché a diverse features della rete che si forma. Se collego una rete secondo un algoritmo di ***Minimum Spanning Tree*** avrò più efficienza energetica ma meno robustezza rispetto ai guasti, e viceversa se la configuro con una ***backbone*** (cfr. Esame di ***Network Algorithms***).\n\n","x":3532,"y":0,"width":759,"height":324,"color":"4"},
		{"id":"cd0682544b4d7ae0","type":"text","text":"# HowTo Sensore di una WSN\n\nUn sensore è tipicamente composto dai seguenti elementi\n\n- Power Source, tipicamente una batteria;\n- CPU e Memoria per l'esecuzione di codice;\n- Sistema radio per la comunicazione con gli altri nodi;\n- Sensori vari.\n\nStoricamente, il più importante SO per un simile oggettino è stato ***TinyOS***, scritto in una variante depotenziata del C chiamata ***Stylized C***. Oggi si usa roba più moderna, tipo Zephyr, RTOS o RIOT, e linguaggi come C++, Rust e (incredibile) ***MicroPython***, che è una versione di Python3 non interpretata ma compilata (tipo funziona su RaspberryPi Pico).","x":4542,"y":-524,"width":759,"height":357,"color":"4"},
		{"id":"dfe3bfa74fb8b071","type":"text","text":"# Sleeping MAC\n\nDal momento che il consumo energetico è davvero un bisogno primario, creo un protocollo MAC apposito per le reti di sensori.\n\nL'idea è imporre una schedule (***Duty Cycle***) al sensore in modo tale che resti in ibernazione per la maggior parte del tempo (consumando poca batteria) per poi attivarsi in una breve finestra utile a scambiare i dati (***Duty Time***), che in genere si attesta sul $10\\%$ del totale.\n\n","x":4542,"y":-1020,"width":759,"height":304,"color":"6"},
		{"id":"fda930695389d493","type":"text","text":"# Routing in a WSN","x":4542,"y":0,"width":759,"height":324,"color":"6"},
		{"id":"c176c2da581453b1","type":"text","text":"# Sleeping-MAC (S-MAC)\n\nprova a minimizzare il consumo energetico a spese della latenza.\ni nodi hanno finestre divise in sleeping time e sensing time (il loro rapporto è definito dalla ratio sensing/finestra = duty time in genere $\\sim10\\%$). e se qualcuno vuole mandare pacchetti? Sincronizziamo cluster di nodi in modo che siano attivi nello stesso momento. Quando mando SYN aggiungo info sulla mia sleep schedule, in modo che tutti possano farsi una tabella degli schedule. e tra cluster diversi? divido i nodi tra synchronizer e follower, in cui S coordina gruppi di F. Se S collega due gruppi di F con schedule diversi, sarà attivo durante entrambi i waking time. Quando parlano, RTS/CTS.","x":5400,"y":-1058,"width":600,"height":380},
		{"id":"4a483510ba6510d1","type":"text","text":"# Routing?\n\ntre approcci:\n\n- aggiorno continuamente le tabelle di routing (proactive) anche se non mi serve\n\t- rispondo ad ogni cambio della rete (e.g. un nodo si sposta, o un collegamento cade)\n\t- la cosa buona è che so sempre dove mandare un pacchetto, quella cattiva è l'overhead\n\t- DSDV bellman-ford + aging (tiene traccia di quanto le info nelle RT sono vecchie, preferendo quelle fresh)\n- mi impegno a trovare la route per A solo quando devo mandargli un pacchetto (reactive).\n\t- se sei particolarmente pigro non la trovi nemmeno, fai flooding e sticazzi, prima o poi arriverà (chaotic evil) inutile dire quanto poco ottimizzata sia sta roba\n\t- se oltre che pigro sei anche pazzo scegli a caso alcuni neighbors (non tutti come nel flooding) e ciao (gossiping, il che è ancora più che chaotic evil)\n\t- DSR (RFC 4728) - dalle slides è molto ovvio, fai una gif. tipicamente esce fuori la scelta migliore, ma in generale il sistema è asincrono. you can improve this protocol by keeping some info\n\t- AODV - we just keep next hop, not whole path as in DSR. mantains tables, not source. è la versione enhanced di DSDV. intermediate nodes learn reverse path. in pratica riempio le tabelle solo quando serve\n- hybrid\n\nnoiose considerazioni finali su cosa è meglio","x":5502,"y":297,"width":600,"height":806},
		{"id":"49a949b25dfe30de","type":"text","text":"# DSR\n\n","x":6202,"y":655,"width":469,"height":90},
		{"id":"d26761e26328fff8","type":"text","text":"# Geographic Routing\n\nse devo raggiungere un nodo che so essere a nord, che senso ha propagare l'informazione a sud?\n- most forward - scelgo il primo vicino più a nord;\n- directional routing ???\n\nil grosso problema sono i dead end, perché ho solo info sugli hop (no conoscenza globale)\n\nma se sincronizzo le posizioni con le bussole? ogni coppia definisce una retta, le intersezioni potrebbero essere nodi (o no) indagare, sembra figo","x":5502,"y":1177,"width":600,"height":371},
		{"id":"51049abcb69c56a1","type":"text","text":"Problema di questi algoritmi di routing: e se i nodi si spostano?","x":5507,"y":1661,"width":493,"height":165},
		{"id":"7377628de440c4ef","type":"text","text":"flat network = no node is more powerful than the others","x":6312,"y":458,"width":250,"height":140},
		{"id":"ac2c1079b491ceec","type":"text","text":"# Tipi di AN\n\nWSN, SANET, Infrastructure(less)-Based WN?, UAV (droni),","x":-1420,"y":-313,"width":330,"height":134},
		{"id":"b088c8d184a0019a","type":"text","text":"# Semplici Reti Ancora Non Proprio SuperIntelligenti\n### Che tuttavia potrebbero ancora essere utili, perché costituiscono la base di tutto quello che viene dopo.\n\nSinceramente, non so che nome dare a questa parte introduttiva del corso.","x":2331,"y":-448,"width":759,"height":205,"color":"6"},
		{"id":"2795cbd69099d104","type":"text","text":"# Autonomous Network (AN)\n\nQuand'è che una rete è ***autonoma***?\n\n- Una volta configurata, ***non servono indicazioni o risorse aggiuntive***;\n- È \"intelligente\", nei limiti dell'AI (i.e. si adatta ai cambiamenti ambientali e/o li prevede), usando il ***reinforcement learning***.\n\n","x":216,"y":-451,"width":626,"height":205,"color":"6"},
		{"id":"515ac4435ccb6301","type":"text","text":"# Tutto quello che trovo\n\nL'obiettivo è quello di realizzare una rete in grado di prendere decisioni (Self-Governance) e gestire le proprie risorse (Self-Sufficiency) in modo autonomo, senza intervento umano.\n\nPer farlo, ha bisogno di una Embedded Intelligence in grado di fornire una Proactive Response a ciò che accade nelle sue vicinanze, possibilmente imparando dall'ambiente se le condizioni non sono precisamente quelle che si aspetta fin da subito. Tutto questo viene fatto da algoritmi di Reinforcement Learning (How an intelligent agent can learn to make a good sequence of decisions).\n\n","x":1061,"y":-143,"width":586,"height":431},
		{"id":"5c9a173d23378970","type":"text","text":"# Questo Corso\n\nGiven a networking problem (MAC or\nrouting) decide if it should be formulated as a\nRL problem if yes be able to define it formally (in\nterms of state space, action space,\ndynamics and reward model)\nstate what algorithm (from class) is\nbest suited to addressing it and\njustify your answer","x":941,"y":348,"width":468,"height":373},
		{"id":"2fb6e914f4d53590","type":"text","text":"# Slides 05 to gpt\n\nLe slide trattano il tema delle reti autonome di droni (UAV), includendo vari aspetti tecnici ed applicativi. Ecco una sintesi dettagliata:\n\n1. **UAV (Unmanned Aerial Vehicles)**: Droni che operano senza pilota umano a bordo. Possono essere controllati da remoto o autonomamente da un computer di bordo. Le caratteristiche variano ampiamente, con droni che pesano da 0.5 g a 15.000 kg e velocità massime fino a 11.265 km/h.\n\n2. **Motivi per l'uso di UAV**: Utilizzati in scenari critici come disastri naturali, operazioni di soccorso e consegne mediche in aree inaccessibili. Possono anche essere impiegati per monitoraggio del traffico, stime del vento, rilevamento incendi e operazioni militari.\n\n3. **Reti di Droni (DRONET)**: Più UAV vengono coordinati per missioni specifiche, come monitoraggio di ampie aree. Le sfide includono la comunicazione tra droni e la stazione di controllo e la necessità di trasferire grandi quantità di dati in ambienti difficili.\n\n4. **Problemi Principali**:\n   - Garantire comunicazione in assenza di infrastrutture di rete.\n   - Ottimizzare l'assegnazione dei compiti e la pianificazione delle traiettorie.\n   - Offload di dati continuo in aree vaste e complesse.\n   \n5. **DANGER**: Un esempio di rete drone utilizzata in operazioni di emergenza, dove i droni fungono da stazioni base volanti o nodi di relay per supportare le reti terrestri esistenti.\n\n6. **Routing nelle reti UAV**: Il protocollo di routing deve affrontare mobilità elevata, topologia fluida e consumo energetico, con lo scopo di ridurre ritardi, aumentare il tasso di consegna e risparmiare energia.\n\n7. **Protocolli di Routing**:\n   - **Proattivi**: Mantengono tabelle aggiornate della rete (es. OLSR, DSDV), ma non sono sempre adatti per reti di droni data la mobilità elevata.\n   - **Reattivi**: Trovano percorsi solo quando necessario (es. DSR, AODV), offrendo maggiore scalabilità.\n   - **Ibridi**: Combinano approcci reattivi e proattivi, bilanciando latenza e overhead (es. ZRP, TORA).\n   \n8. **B.A.T.M.A.N.**: Protocollo di routing proattivo sviluppato per reti mesh mobili, con gestione decentralizzata e multipli percorsi per destinazione. Ottimizza la trasmissione in scenari complessi come quelli delle reti di droni.\n\nQuesto riassume i principali temi delle slide, enfatizzando le sfide tecniche e le soluzioni proposte per gestire le reti di droni.","x":-5988,"y":-3121,"width":1020,"height":813},
		{"id":"64d5f9d2d9437be5","type":"text","text":"Il file caricato esplora diversi aspetti delle reti autonome di droni (UAV), la gestione delle reti mesh, e i protocolli di routing utilizzati in questi scenari. Di seguito una spiegazione dettagliata ma sintetica, come richiesto.\n\n### 1. **Reti Mesh e B.A.T.M.A.N.**\n   - **Rete Mesh**: Ogni nodo può agire come router, inoltrando dati agli altri nodi. Questo permette di avere più percorsi possibili tra i nodi, migliorando la robustezza della rete【11†source】.\n   - **B.A.T.M.A.N. (Better Approach to Mobile Adhoc Networking)**: Un protocollo di routing proattivo per le reti ad-hoc mobili e mesh. È decentralizzato, con ogni nodo che conosce solo il miglior vicino per raggiungere una destinazione. Le decisioni si basano sulla qualità del link【11†source】.\n\n### 2. **Funzionamento di B.A.T.M.A.N.**\n   - Ogni nodo invia periodicamente **Originator Messages (OGM)** per annunciare la propria presenza. Questi messaggi vengono inoltrati dai vicini, propagando le informazioni nella rete. Ogni nodo valuta la qualità del link basandosi su quanti OGM riceve dai vicini【11†source】.\n   - **Problema dei Link Asimmetrici**: In alcuni casi, i pacchetti inviati da un nodo (es. A) raggiungono il nodo B, ma B non riesce a inviare pacchetti ad A. Questo può portare a stime errate della qualità del collegamento. Per risolvere, viene usato l'algoritmo **Transmit Quality (TQ)**【11†source】【11†source】.\n\n### 3. **Protocolli di Routing Geografico**\n   - **Routing Geografico**: Basato sulla posizione dei nodi (es. GPS), riduce l'overhead poiché non richiede tabelle di routing o la scoperta dei percorsi. Solo le informazioni sui nodi vicini e sulla destinazione sono necessarie【11†source】.\n   - **GDSTR-3D**: Un esempio di protocollo geografico che seleziona il nodo più vicino alla destinazione come relay. Un problema può essere il **dead end**, dove un pacchetto non trova un nodo più vicino alla destinazione【11†source】.\n\n### 4. **Sfide e Algoritmi per l'Offloading dei Dati**\n   - In aree difficili, come le missioni di sorveglianza in zone vaste, i droni devono periodicamente scaricare i dati raccolti. Questo comporta la necessità di formare una topologia di rete efficiente, minimizzando il tempo e la distanza percorsa【11†source】.\n   - **Algoritmo DGA (Distributed Gathering Algorithm)**: Durante la fase di costruzione della topologia, un drone si ferma se è nel raggio di comunicazione del deposito o di un altro drone connesso. Altrimenti, si muove verso un punto di incontro più vicino【11†source】.\n\n### 5. **Valutazione delle Performance**\n   - Sono state effettuate simulazioni per valutare l'efficacia dell'algoritmo di offloading in un'area di 2.25 km² con velocità di 8 m/s e un raggio di trasmissione di 100 m. Le simulazioni durano circa 37 minuti e mirano a ottimizzare la connettività e la sincronizzazione dei droni【11†source】.\n\nIn sintesi, il documento esplora l'uso di protocolli di routing come B.A.T.M.A.N. per reti mesh, protocolli geografici per droni, e sfide tecniche legate all'offloading dei dati in reti UAV, con un focus sulle soluzioni distribuite.","x":-5988,"y":-2254,"width":1020,"height":1220},
		{"id":"6a6fbf04f53e9fac","type":"text","text":"# 05","x":-4430,"y":-1126,"width":250,"height":60,"color":"1"},
		{"id":"8849ff2d9d118604","type":"text","text":"# Slides 06 to gpt\nLe slide trattano principalmente l'Internet of Things (IoT) e l'idea di dispositivi IoT senza batteria. Ecco una spiegazione sintetica ma dettagliata:\n\n### 1. **Internet of Things (IoT)**\n   - **Oggetti Smart**: Sono oggetti fisici con elettronica integrata, che permettono loro di comunicare e interagire. Questi includono smartwatch, smart TV, ma anche auto, case e città intelligenti【17†source】.\n   - **Definizione di IoT**: Si riferisce a:\n     1. La rete globale che connette oggetti intelligenti tramite tecnologie internet estese.\n     2. Le tecnologie di supporto necessarie per realizzare questa visione.\n     3. Le applicazioni e i servizi che sfruttano queste tecnologie per creare nuove opportunità di business【17†source】.\n\n### 2. **Pilastri dell'IoT**\n   - Gli oggetti intelligenti devono:\n     1. Essere identificabili.\n     2. Comunicare.\n     3. Interagire tra loro o con utenti ed entità nella rete【17†source】.\n\n### 3. **Caratteristiche di un Oggetto Smart**\n   - Un oggetto smart ha un corpo fisico, capacità di comunicazione, è associato a un nome e un indirizzo, ha capacità di calcolo, e può percepire fenomeni fisici (es. temperatura, movimento) o agire sull'ambiente【17†source】.\n\n### 4. **Dispositivi Chiave nell'IoT**\n   - L'IoT include dispositivi con capacità di comunicazione e calcolo molto limitate, come quelli studiati nelle reti RFID e WSN (reti di sensori senza fili). Questi dispositivi agiscono come fornitori o consumatori di dati legati al mondo fisico【17†source】.\n\n### 5. **Caratteristiche Richieste per l'IoT**\n   - **Eterogeneità dei dispositivi**: Capacità di gestire dispositivi con diverse capacità di calcolo e comunicazione.\n   - **Scalabilità**: Riguarda la gestione dei nomi, la comunicazione, la rete, e la fornitura di servizi.\n   - **Ottimizzazione energetica**: Cruciale per dispositivi con capacità limitate【17†source】.\n   - **Sicurezza e privacy**: Deve essere integrata per garantire accettazione e adozione【17†source】.\n\n### 6. **Tecnologie Abilitanti**\n   - Tecnologie chiave come le reti di sensori wireless e RFID sono essenziali per identificare e abilitare l'interazione degli oggetti smart con l'ambiente【17†source】.\n\n### 7. **Dispositivi senza Batteria**\n   - **Backscattering**: Tecnologia che permette ai dispositivi di funzionare senza batterie, riflettendo i segnali radio esistenti per alimentarsi【17†source】.\n\nIn sintesi, queste slide esplorano il concetto di IoT, le sue tecnologie abilitanti, le sfide come l'efficienza energetica e la sicurezza, e introducono nuove soluzioni come il backscattering per dispositivi senza batteria.\n\n\nEcco una spiegazione dettagliata ma concisa delle slide che hai fornito:\n\n### 1. **Nuovo tipo di dispositivo: oggetti smart senza batteria**\n   - Si propone di riprogettare gli oggetti intelligenti in modo che non abbiano bisogno di batterie. La soluzione a questo è la **retrodiffusione** (backscattering), che riflette i segnali da cui provengono.\n   - Questi dispositivi utilizzano i segnali a radiofrequenza (RF) come fonte di energia per svolgere attività di rilevamento, calcolo e trasmissione dati.\n\n### 2. **Tipologie di retrodiffusione**\n   - **Ambientale**: sfrutta segnali RF già presenti nell’ambiente, come TV o Wi-Fi, senza necessità di un dispositivo di emissione dedicato.\n     - Svantaggi: bassa velocità di trasmissione dati e limitata disponibilità di segnali, soprattutto in ambienti interni.\n   - **RFID**: utilizza un lettore RFID per alimentare dispositivi senza batteria, permettendo loro di inviare informazioni attraverso la riflessione del segnale.\n\n### 3. **Tag RFID con sensori integrati**\n   - I tag RFID possono essere potenziati con sensori come PIR, fotocamere o accelerometri per rilevare eventi (ad esempio movimento), con applicazioni in scenari come case smart.\n   - Svantaggi: potenza limitata, raggio d'azione breve e capacità di memoria ridotta.\n\n### 4. **Casa smart senza batteria**\n   - Viene presentata una possibile architettura per una casa intelligente basata su dispositivi RFID senza batteria. Questi possono monitorare vari aspetti dell’ambiente, come la temperatura, comunicando con applicazioni su smartphone o server.\n   - Un nuovo protocollo MAC, chiamato **APT-MAC**, è stato sviluppato per gestire i tempi di risposta e ridurre la perdita di dati, permettendo al sistema di adattarsi automaticamente ai requisiti di trasmissione dei dispositivi.\n\n### 5. **Dispositivi realizzati**\n   - Vengono descritti vari dispositivi senza batteria, come un joystick per videogiochi, un interruttore per luci, e un telecomando per un bollitore. Questi dispositivi utilizzano la retrodiffusione RFID per funzionare senza necessità di ricarica.\n\n### 6. **Esperimenti e prestazioni**\n   - Gli esperimenti mostrano che questi dispositivi possono avere tempi di reazione accettabili, anche paragonabili ai dispositivi alimentati a batteria. Ad esempio, il controller per videogiochi ha un tempo di reazione di circa 92 ms, comparabile a quello di un mouse o controller commerciale.\n\n### 7. **Problemi di interoperabilità**\n   - Quando più dispositivi senza batteria operano contemporaneamente, il tempo di reazione aumenta, rendendo la gestione della comunicazione una sfida. Il protocollo deve essere in grado di assegnare le risorse di canale in modo efficiente per soddisfare le esigenze diverse dei dispositivi.\n\nIn sintesi, queste slide trattano l'uso della tecnologia RFID e della retrodiffusione per creare oggetti smart senza batteria, evidenziando i vantaggi e le sfide, in particolare l'interoperabilità e la gestione delle risorse di comunicazione in ambienti multi-dispositivo.","x":-4148,"y":-708,"width":1067,"height":2757},
		{"id":"d91339e82a54fbfa","type":"text","text":"# Wireless Sensor Network (WSN)\n\nsensori che mandano dati al sink (cervellone centrale). can sense the channel and spontaneously send data to anyone. also can run protocols.\nlimited transmission rate -> multi-hop.\n\nle applicazioni sono senza fine, quello che puoi immaginare in qualche modo lo puoi anche realizzare\n\ntre elementi fondamentali:\n\n- sensori che raccolgono dati dall'ambiente\n- sink che li raccolgono dai sensori ed eventualmente ci fanno cose\n- actuators che fanno cose sulla base dei dati elaborati dai sink o chi per loro\n\ncome piazzo i sensori in giro? ... dipende dalle necessità. a volte una geometria regolare è comoda. alcuni li posso anche muovere in corso d'opera (tipo i droni).\n\n- scalability - le performance non calano al crescere dei nodi\n- poca potenza a disposizione e poca energia -> serve efficienza\n- asymmetric flow of info sensore->sink (e non posso mandare segnali da un controller? o avere un drone controller in posizione strategica?)\n- lifetime - se muore un critical node ciao ciao network\n- re-programmability - quello che dicevo prima\n- deve adattarsi ai cambiamenti (anche con RL) tipo clima che cambia o un nuovo sensore nella rete\n- data centric networking non mi piace, è limitante ma forse è utile in qualche situazione specifica (semplifica i protocolli probabilmente, li rende efficienti)\n- locality è per evitare overhead di messaggi in giro per la rete (che di nuovo rende i protocolli inefficienti)\n- poi vabbè dice l'ovvio, sono ponte tra mondo fisico e virtuale\n- raspberry\n- TinyOS, stylized C (?), NesC\n- slides per vedere i sensori disponibili nel magnifico negozio della vita\n\n","x":-3568,"y":-2274,"width":680,"height":867},
		{"id":"a45e4313d00ec084","type":"text","text":"segue CSMA CD e CA, copia da Reti ed eventualmente aggiungi\n\nmi pare di capire che in contesti AN e IoT si tende a preferire TDM, ma spesso si implementano protocolli misti.","x":-3462,"y":-2780,"width":467,"height":340},
		{"id":"5ec1513a31b16dd5","type":"text","text":"# 06","x":-2826,"y":-480,"width":250,"height":60,"color":"1"},
		{"id":"e8490028b0db5076","type":"text","text":"# Slides 03 to gpt\n\nEcco una spiegazione dettagliata e concisa delle slide che hai caricato:\n\n### **Wireless Sensor Networks (WSN)**\n\n1. **Definizione**: Le reti di sensori wireless (WSN) sono composte da dispositivi distribuiti che monitorano condizioni ambientali e inviano i dati a un nodo centrale per l'elaborazione. Sono fondamentali per applicazioni come il monitoraggio ambientale e industriale.\n\n2. **Componenti principali**:\n   - **Sensori**: Rilevano fenomeni fisici (es. temperatura, umidità).\n   - **Processore e memoria**: Elaborano i dati raccolti dai sensori.\n   - **Transceiver**: Trasmette e riceve dati dai nodi circostanti.\n   - **Unità di alimentazione**: Spesso basata su batterie, la cui gestione dell'energia è cruciale per la durata della rete.\n\n3. **Topologia di comunicazione**:\n   - Le reti di sensori possono operare in modalità **multi-hop**, dove i dati vengono trasmessi attraverso diversi nodi prima di raggiungere il nodo centrale (sink).\n   - Il **WSN** è autonomo e raccoglie dati in tempo reale, permettendo una rapida risposta ai cambiamenti ambientali.\n\n---\n\n### **Applicazioni delle WSN**\n- **Controllo Industriale**: Ottimizzazione dei processi industriali tramite il monitoraggio costante.\n- **Monitoraggio Ambientale**: Utilizzate in agricoltura per monitorare l'umidità del suolo e prevenire incendi boschivi.\n- **Salute Strutturale (SHM)**: Monitoraggio di strutture come ponti e edifici per rilevare danni o degrado nel tempo.\n- **Sanità**: Monitoraggio dei pazienti tramite sensori medici per parametri vitali come la temperatura e la pressione sanguigna.\n\n---\n\n### **Monitoraggio Strutturale (SHM)**\n- Viene utilizzato per monitorare le condizioni di strutture come ponti, tunnel e edifici storici. L’obiettivo è rilevare deterioramenti o rischi di collasso, come nel caso dello **studio del Golden Gate Bridge**, che monitora le vibrazioni causate dal vento e dai terremoti senza interrompere il normale utilizzo della struttura.\n\n---\n\n### **Caratteristiche delle WSN**\n1. **Efficienza energetica**: Le reti di sensori sono spesso alimentate da batterie, e la loro sostituzione può essere costosa e difficile. La comunicazione a bassa potenza è cruciale per prolungare la durata della rete.\n2. **Scalabilità**: Le WSN devono essere in grado di gestire un grande numero di nodi senza compromettere le prestazioni.\n3. **Tolleranza ai guasti**: I nodi devono essere resistenti ai guasti, e la rete deve continuare a funzionare anche in caso di malfunzionamento di alcuni nodi.\n\n---\n\n### **Problemi di comunicazione e risparmio energetico**\n- **Collisioni**: Quando più nodi trasmettono contemporaneamente, i pacchetti possono collidere, richiedendo ritrasmissioni che consumano energia.\n- **Overhearing**: I nodi ricevono pacchetti destinati ad altri nodi, sprecando energia.\n- **Idle listening**: I nodi ascoltano costantemente il canale in attesa di pacchetti, consumando inutilmente energia.\n\n---\n\n### **Protocolli MAC per WSN**\n1. **CSMA/CA** (Carrier Sense Multiple Access with Collision Avoidance): Utilizzato per evitare collisioni nel canale di trasmissione. I nodi verificano se il canale è libero prima di trasmettere, ma in reti dense la probabilità di collisione aumenta.\n2. **RTS/CTS** (Request to Send / Clear to Send): Risolve i problemi di **nodo nascosto** e **nodo esposto** riservando il canale prima della trasmissione effettiva, riducendo le collisioni.\n\n---\n\nIn sintesi, le slide coprono il funzionamento delle reti di sensori wireless, le loro applicazioni e i protocolli di comunicazione che ottimizzano l'uso dell'energia e riducono i problemi di trasmissione in reti dense e distribuite. Le WSN sono essenziali per il monitoraggio ambientale, la sicurezza strutturale e la sanità, tra le altre aree.","x":-2741,"y":-3400,"width":1000,"height":1920},
		{"id":"7ddeee8420c760e7","type":"text","text":"# 03","x":-2308,"y":-1274,"width":250,"height":60,"color":"1"},
		{"id":"6a822436662accf4","type":"text","text":"# 07","x":-400,"y":1104,"width":250,"height":60,"color":"1"},
		{"id":"61c71f856f65004b","type":"text","text":"# RL\n\nC'è un agent che ha diverse azioni da poter compiere. Ogni azione ha un reward casuale distribuito in modo ignoto. L'agent prova a ricostruire la pdf dei reward per capire cosa fare. Il $Q$ value di R è una probabilità statistica che R sia la scelta giusta (la valuto facendo, e.g., tante prove random e vedendo che succede).\n\nMa poi, come scelgo l'azione una volta che ho le probabilità?\n\n- random\n- highest Q (greedy action) - potrebbe essere problematico, perché potrei finire a scegliere sempre la stessa azione. Oltre ad exploitare (quella che so essere la buona scelta) dovrei anche esplorare le altre possibilità.\n\t- $\\e$-greedy - sii greedy, ma con piccola probabilità $\\e$ scegli random tra tutte le scelta (anche quella ottimale...!)\n\n$$Q^k={1\\over N^k}\\sum_{i=1}^{N^k}R_i^k$$sull'azione k. Se al generico step ottengo un reward 2 per l'azione k che aveva già ottenuto i reward 2 e 1, abbiamo $Q^k=5/3$.\n\nalternative al Q-value? rearranging quaa robba sopra trovo che\n\n$$Q_{n+1}={1\\over n}\\sum_iR_i=[...]=Q_n+{1\\over n}\\bigg[R_n-Q_n\\bigg]$$che in pratica significa$$\\text{New Estimate}\\leftarrow \\text{Old Estimate}+\\text{Step Size}\\bigg[?\\bigg]$$\ntutta sta roba si chiama bandit. le $pdf$ sono $pdf(t)$, ma l'agent non lo sa. e che fa? campiona. Ora, potrei cambiare lo step size e renderlo una costante $\\a$ (tipo $0.5$). Questo permette di modellizzare stationary problems? Non ho capito\n\n$$Q_n+\\alpha[R_n-Q_n]=[...]=(1-\\a)^nQ_1+\\sum\\a(1-\\a)^{n-i}R_i$$","x":-3,"y":1732,"width":567,"height":1028},
		{"id":"b05056eaa2e4856d","type":"text","text":"# RL copypaste\n\nLearning : The agent does not know in\nadvance how its decisions\nare going to affect the world\n¡ What decisions might be\nassociated with good\noutcomes\n¡ The agent has to acquire this\ninformation through\nexperience\n\nWhen planning: decisions involve\nreasoning about not just\nimmediate benefit of a decision\nbut also its longer term\nramifications\nWhen learning: temporal credit\nassignment is hard (what caused\nlater high or low rewards?)\n\nLearning about the world by making decisions\n¡ Learn to ride a bike by trying (and falling)\n¡ Censored data (you only get to learn about what you try to do)\n¡ Only get a reward for decision made\n¡ Don’t know what would have happened if we had taken a different\ndecision\n¡ Each choice is made at a particular time\n\nPolicy is mapping from past experience to action (defines the actions an\nagent should take based on its past experiences)\nWhy not just pre-program a policy?\nWe can have a huge number of states, thus we need generalization\nEven if we run into a particular state we have never seen before our agent\nstill know what to do (Generalization allows an RL agent to handle situations\nit has never encountered before by applying knowledge from similar past\nexperiences.)\n\nExplore the world\nUse experience (rewards) to guide\nfuture decisions\n\n- Where do rewards come from? And what happens if we get it wrong?\n- Robusteness/risk sensitivity:Robustness refers to the agent's ability to perform well in different, often unseen situations, without being too sensitive to slight changes in the environment Risk sensitivity involves how the agentmanages uncertainty, often opting for strategies that minimize risky outcomes\n","x":13,"y":2872,"width":588,"height":1600},
		{"id":"72bb0a3bb98b57ab","type":"text","text":"# Reinforcement Learning","x":291,"y":1292,"width":441,"height":141,"color":"6"},
		{"id":"182dc1d2e895b562","type":"text","text":"# 08\n\nnon ha ancora messo le slides (ma sono diverse da quelle che ha presentato a lezione???)","x":785,"y":2206,"width":276,"height":180,"color":"1"},
		{"id":"e6369fabd45b3008","type":"text","text":"# Slides 07 to gpt\n\nEcco una spiegazione sintetica e chiara delle slide che hai caricato, concentrandoci sui concetti chiave:\n\n### **Reti autonome (Autonomous Networking)**\n1. **Definizione**: Una rete autonoma opera senza intervento umano, come un organismo indipendente. Implica intelligenza e capacità di apprendere dall'ambiente, reagendo di conseguenza.\n\n2. **Obiettivo**: Applicare l'autonomia a livello di rete (comunicazione e instradamento), ad esempio per reti di droni o dispositivi IoT, principalmente in contesti wireless.\n\n---\n\n### **Primo caso di studio: Casa intelligente senza batteria**\n- Dispositivi come sensori di presenza, termostati, telecomandi e controller per videogiochi operano senza batterie, utilizzando la tecnologia RFID per raccogliere energia dai segnali di lettori RFID.\n  \n- **Problema**: Come ottimizzare la comunicazione tra il lettore RFID e i dispositivi, assicurando che vengano interrogati solo quando hanno nuovi dati, evitando perdite o interrogazioni ridondanti.\n\n---\n\n### **Soluzione proposta: Reinforcement Learning (RL)**\n1. **Cos'è il Reinforcement Learning?**\n   - RL riguarda il processo decisionale sequenziale: un agente impara a prendere buone decisioni attraverso l'interazione con l'ambiente, massimizzando una ricompensa nel lungo termine.\n\n2. **Caratteristiche principali del RL**:\n   - **Trial-and-error**: L'agente non sa in anticipo quali azioni siano migliori, deve scoprirlo sperimentando.\n   - **Ricompensa ritardata**: Le azioni possono avere effetti a lungo termine, e il vero beneficio potrebbe emergere solo in seguito.\n\n3. **Differenze rispetto ad altri approcci di apprendimento**:\n   - Non c'è supervisione diretta; si lavora con un segnale di ricompensa che può essere ritardato e influenzato da decisioni precedenti.\n   - L'agente impara online, migliorando costantemente mentre interagisce con un ambiente dinamico.\n\n---\n\n### **Applicazioni reali del RL**\n- **Veicoli a guida autonoma**: Ottimizzazione della traiettoria e della pianificazione del percorso.\n- **Automazione industriale**: Robot che eseguono compiti pericolosi per gli esseri umani.\n- **Sanità**: RL può ottimizzare i trattamenti medici basandosi su esperienze passate, senza bisogno di modelli matematici complessi.\n\n---\n\n### **Il dilemma esplorazione-sfruttamento**\n- Un agente deve bilanciare l'esplorazione di nuove azioni con lo sfruttamento di quelle già note per massimizzare la ricompensa a lungo termine.\n  \n---\n\n### **Applicazione del RL alla casa intelligente**\n- **Problema di comunicazione**: In una casa intelligente con dispositivi eterogenei, come decidere l'ordine in cui interrogare i dispositivi per evitare perdite di dati e interrogazioni ridondanti?\n- **Formulazione RL**: Il problema può essere modellato come un problema RL, dove il lettore RFID è l'agente, le interrogazioni ai dispositivi sono le azioni, e la disponibilità di nuovi dati è la ricompensa.\n\n---\n\nIn sintesi, le slide illustrano l'importanza del Reinforcement Learning per sviluppare reti autonome in contesti come case smart senza batterie, ottimizzando le comunicazioni attraverso un processo di apprendimento basato sull'interazione con l'ambiente.","x":-1759,"y":1572,"width":1203,"height":1527},
		{"id":"7c28717c0d6159ad","type":"text","text":"# 09?\n\n","x":1612,"y":2410,"width":250,"height":60,"color":"1"},
		{"id":"87f413d5de7b78dc","type":"text","text":"# RL II\n\nriassunto parte 1 delle slides: ad ogni stato della markov chain associo un reward. ogni path ha un reward totale associato pari alla somma pesata del reward attuale e di tutti quelli che possono venire dopo pesati con la rispettiva probabilità e con un fattore $\\gamma$ che aggiusto per decidere se dare più o meno peso al lungo termine.\n\nriassunto parte 2: come prendo le decisioni? ci stanno le policies.\ndato uno stato in cui sono, la policy sceglie quale azione prendere (e.g. study o pub). altro discorso è poi che se prendo l'azione pub questa mi porta con diverse probabilità a diversi stati.\n\nin pratica la policy diventa un peso (o un parametro? in qualche modo cambia il risultato di q insomma). forse dipende da cosa sto calcolando ","x":1454,"y":2549,"width":567,"height":550}
	],
	"edges":[
		{"id":"5dfc04739aa6c83e","fromNode":"2795cbd69099d104","fromSide":"left","toNode":"ac2c1079b491ceec","toSide":"right"},
		{"id":"9dee13e1ebae3aa1","fromNode":"2795cbd69099d104","fromSide":"bottom","toNode":"72bb0a3bb98b57ab","toSide":"top"},
		{"id":"11bd67804bc3ea6c","fromNode":"4a483510ba6510d1","fromSide":"right","toNode":"49a949b25dfe30de","toSide":"left"},
		{"id":"10058852c36c37d6","fromNode":"2fb6e914f4d53590","fromSide":"bottom","toNode":"64d5f9d2d9437be5","toSide":"top"},
		{"id":"74097e514927d6ef","fromNode":"6a822436662accf4","fromSide":"right","toNode":"72bb0a3bb98b57ab","toSide":"left"},
		{"id":"922a5e0db107f9c5","fromNode":"ac2c1079b491ceec","fromSide":"top","toNode":"7ddeee8420c760e7","toSide":"bottom"},
		{"id":"847d4908512864e3","fromNode":"7ddeee8420c760e7","fromSide":"top","toNode":"e8490028b0db5076","toSide":"bottom"},
		{"id":"f2e1f3e851eaf1b6","fromNode":"7ddeee8420c760e7","fromSide":"left","toNode":"d91339e82a54fbfa","toSide":"bottom"},
		{"id":"b35891f582a86e61","fromNode":"ac2c1079b491ceec","fromSide":"left","toNode":"5ec1513a31b16dd5","toSide":"top"},
		{"id":"bbc2fd756c7e22e6","fromNode":"5ec1513a31b16dd5","fromSide":"left","toNode":"8849ff2d9d118604","toSide":"right"},
		{"id":"b0a0b8d28eb1cd8e","fromNode":"7ddeee8420c760e7","fromSide":"bottom","toNode":"5ec1513a31b16dd5","toSide":"top","label":"nel senso che IoT e robe senza batteria sono tutte wsn?"},
		{"id":"ae7cb2cdcf01252d","fromNode":"7ddeee8420c760e7","fromSide":"left","toNode":"6a6fbf04f53e9fac","toSide":"right","label":"Nel senso che i droni sono una wsn?"},
		{"id":"db3ec91d66f0b2f0","fromNode":"6a6fbf04f53e9fac","fromSide":"left","toNode":"2fb6e914f4d53590","toSide":"right"},
		{"id":"2aaa34cb51ad0b85","fromNode":"6a822436662accf4","fromSide":"left","toNode":"e6369fabd45b3008","toSide":"top"},
		{"id":"046df6fb7082568c","fromNode":"182dc1d2e895b562","fromSide":"left","toNode":"61c71f856f65004b","toSide":"right"},
		{"id":"8f134dca82add816","fromNode":"72bb0a3bb98b57ab","fromSide":"bottom","toNode":"182dc1d2e895b562","toSide":"top"},
		{"id":"f039c7daf7e357bc","fromNode":"72bb0a3bb98b57ab","fromSide":"bottom","toNode":"7c28717c0d6159ad","toSide":"top"},
		{"id":"e6834a64663d3524","fromNode":"7c28717c0d6159ad","fromSide":"bottom","toNode":"87f413d5de7b78dc","toSide":"top"},
		{"id":"ba08de2f1f873a71","fromNode":"4b21c821ca9a99a5","fromSide":"top","toNode":"496569cc5d17f5be","toSide":"bottom"},
		{"id":"96913fe00cd61de5","fromNode":"496569cc5d17f5be","fromSide":"right","toNode":"06c8dfc1835bdad9","toSide":"left"},
		{"id":"29150fdcb1548b51","fromNode":"496569cc5d17f5be","fromSide":"left","toNode":"b34074a3a43e8d58","toSide":"right"},
		{"id":"00709dd159fa99e6","fromNode":"b34074a3a43e8d58","fromSide":"top","toNode":"07860fbdac8f9f5e","toSide":"bottom"},
		{"id":"01affd8767b69ee5","fromNode":"b34074a3a43e8d58","fromSide":"left","toNode":"e9efc94fac1f44e4","toSide":"right"},
		{"id":"3dd19a2bc37f3d5f","fromNode":"496569cc5d17f5be","fromSide":"top","toNode":"67138e840671f086","toSide":"bottom"},
		{"id":"2947d46836431621","fromNode":"d66b5203ff904bb6","fromSide":"right","toNode":"8c0119c21d2aab9f","toSide":"top"},
		{"id":"474e411ab8553c85","fromNode":"4b4c321762d3e679","fromSide":"right","toNode":"d66b5203ff904bb6","toSide":"left"},
		{"id":"ff10b6be69a2310e","fromNode":"4b4c321762d3e679","fromSide":"right","toNode":"c287d4aa7b5a27a1","toSide":"left"},
		{"id":"e23485d028abe209","fromNode":"840636eb4f2d40f4","fromSide":"top","toNode":"4b4c321762d3e679","toSide":"bottom"},
		{"id":"0d6fa802c8ae240e","fromNode":"c287d4aa7b5a27a1","fromSide":"bottom","toNode":"df043301b08dc4bc","toSide":"top","label":"Accesso Casuale"},
		{"id":"386ddb30df089803","fromNode":"c287d4aa7b5a27a1","fromSide":"right","toNode":"895bc3f1bf8fd64a","toSide":"top","label":"Partizionamento del Canale"},
		{"id":"3ae39d8ffd513bf1","fromNode":"840636eb4f2d40f4","fromSide":"right","toNode":"df043301b08dc4bc","toSide":"left"},
		{"id":"2fc54700d04e8845","fromNode":"840636eb4f2d40f4","fromSide":"top","toNode":"e65e158ed9f2ecee","toSide":"bottom"},
		{"id":"ef0500313fb877c3","fromNode":"04e2e59fbd2b386f","fromSide":"right","toNode":"840636eb4f2d40f4","toSide":"bottom"},
		{"id":"9c0107675e1dc7be","fromNode":"df043301b08dc4bc","fromSide":"right","toNode":"3f6df1e0812fdc42","toSide":"left"},
		{"id":"3ca2058c81a93542","fromNode":"df043301b08dc4bc","fromSide":"right","toNode":"85f2794d386784c8","toSide":"left"},
		{"id":"780daa0899c004fa","fromNode":"f7bb59d2b607b321","fromSide":"right","toNode":"57643829e285a0ee","toSide":"left"},
		{"id":"461cf23f5e223a6d","fromNode":"f7bb59d2b607b321","fromSide":"right","toNode":"7553697f9878b2c6","toSide":"left"},
		{"id":"32d5477cbeab3840","fromNode":"f7bb59d2b607b321","fromSide":"bottom","toNode":"3babb9c1abd49799","toSide":"top"},
		{"id":"37a3126b7594c86e","fromNode":"0ea7ba1d2a860cba","fromSide":"right","toNode":"f7bb59d2b607b321","toSide":"top"},
		{"id":"314989ed6f70281e","fromNode":"1402f82ddabdb007","fromSide":"right","toNode":"f7bb59d2b607b321","toSide":"left"},
		{"id":"3671cce9b3bfda58","fromNode":"0ea7ba1d2a860cba","fromSide":"left","toNode":"ea5e414eaee40f14","toSide":"top"},
		{"id":"728792761e586a70","fromNode":"ea5e414eaee40f14","fromSide":"right","toNode":"1402f82ddabdb007","toSide":"left"},
		{"id":"7f17e05281a78325","fromNode":"ea5e414eaee40f14","fromSide":"right","toNode":"332c0e8ffc8d1968","toSide":"left"},
		{"id":"2892630a933c5b64","fromNode":"1402f82ddabdb007","fromSide":"bottom","toNode":"332c0e8ffc8d1968","toSide":"top"},
		{"id":"bfac845af5668888","fromNode":"04e2e59fbd2b386f","fromSide":"bottom","toNode":"1402f82ddabdb007","toSide":"top"},
		{"id":"0fb23c2256327ee7","fromNode":"332c0e8ffc8d1968","fromSide":"bottom","toNode":"93d339019972442f","toSide":"top"},
		{"id":"6a5ec1eb169f17da","fromNode":"04e2e59fbd2b386f","fromSide":"top","toNode":"adcd49e79bfc238c","toSide":"bottom"},
		{"id":"c0b8d447d02389f1","fromNode":"04e2e59fbd2b386f","fromSide":"left","toNode":"44d21c89cd07b8f4","toSide":"bottom"},
		{"id":"932ab6b775602a74","fromNode":"04e2e59fbd2b386f","fromSide":"right","toNode":"34ea13703634e6c8","toSide":"left"},
		{"id":"2653abefb7ddba77","fromNode":"8c0119c21d2aab9f","fromSide":"top","toNode":"f19b3a4fa73ba9e8","toSide":"bottom"},
		{"id":"88a67fbd65beeffc","fromNode":"8c0119c21d2aab9f","fromSide":"top","toNode":"895bc3f1bf8fd64a","toSide":"bottom"},
		{"id":"697484167276192c","fromNode":"34ea13703634e6c8","fromSide":"top","toNode":"8c0119c21d2aab9f","toSide":"bottom"},
		{"id":"7189fdbfe08b6fcb","fromNode":"c0bea95135c9c558","fromSide":"top","toNode":"7453c854124ec469","toSide":"bottom"},
		{"id":"1bbb117dac8d2233","fromNode":"c0bea95135c9c558","fromSide":"right","toNode":"faa6429103579d88","toSide":"left"},
		{"id":"b9c868ae60ca8e13","fromNode":"c0bea95135c9c558","fromSide":"right","toNode":"cf066ff07b9dcf69","toSide":"left"},
		{"id":"c34bd2b721ee25eb","fromNode":"c934a9e7d90eb7cc","fromSide":"top","toNode":"c0bea95135c9c558","toSide":"bottom"},
		{"id":"34ca7aeaf092eb73","fromNode":"c934a9e7d90eb7cc","fromSide":"bottom","toNode":"30928e3765ea01bf","toSide":"top"},
		{"id":"130c12c4a7e30349","fromNode":"c934a9e7d90eb7cc","fromSide":"right","toNode":"80a40c0953bfe923","toSide":"left"},
		{"id":"39284feb790e514a","fromNode":"34ea13703634e6c8","fromSide":"right","toNode":"c934a9e7d90eb7cc","toSide":"left"},
		{"id":"467aeca0bc85ea60","fromNode":"34ea13703634e6c8","fromSide":"bottom","toNode":"63119a3b9909af65","toSide":"top"},
		{"id":"56f4a84ebfcc56ab","fromNode":"63119a3b9909af65","fromSide":"bottom","toNode":"825165ad441d79f9","toSide":"left"},
		{"id":"d1375a5d71569287","fromNode":"63119a3b9909af65","fromSide":"bottom","toNode":"affb87dd75497bd6","toSide":"right"},
		{"id":"0bd099586616b6b4","fromNode":"63119a3b9909af65","fromSide":"bottom","toNode":"5e772fe2702b3d44","toSide":"right"},
		{"id":"f5c50ed07c883beb","fromNode":"63119a3b9909af65","fromSide":"bottom","toNode":"bd33a66a27f4e32d","toSide":"left"},
		{"id":"6efaf533006d07cf","fromNode":"bd33a66a27f4e32d","fromSide":"bottom","toNode":"8ae579769d34655f","toSide":"top"},
		{"id":"dd33eaad0d9b2a90","fromNode":"bd33a66a27f4e32d","fromSide":"right","toNode":"93588f5566f63388","toSide":"left","label":"Circa"},
		{"id":"2cb32bc57ecac963","fromNode":"30928e3765ea01bf","fromSide":"bottom","toNode":"a984965221233e7a","toSide":"top"},
		{"id":"eda65dcb510a66d2","fromNode":"faa6429103579d88","fromSide":"right","toNode":"ed1a9855d26a488d","toSide":"left"},
		{"id":"05ad2286d94db188","fromNode":"affb87dd75497bd6","fromSide":"bottom","toNode":"5e772fe2702b3d44","toSide":"top"},
		{"id":"87da0453586b71d1","fromNode":"5e772fe2702b3d44","fromSide":"bottom","toNode":"733d37bec4794264","toSide":"top"},
		{"id":"c7b198dc932ae0be","fromNode":"85f2794d386784c8","fromSide":"right","toNode":"9761cb49699f7d24","toSide":"left"},
		{"id":"af2cc619ecf34a69","fromNode":"06c8dfc1835bdad9","fromSide":"right","toNode":"58abf9d465bc3980","toSide":"left"},
		{"id":"677371e311bac074","fromNode":"06c8dfc1835bdad9","fromSide":"bottom","toNode":"b56e6a2717144541","toSide":"top"},
		{"id":"9bf6787bec612ad5","fromNode":"4b21c821ca9a99a5","fromSide":"left","toNode":"39bd0d24bf3d18c1","toSide":"right"},
		{"id":"958ba262ee3b5ff1","fromNode":"b56e6a2717144541","fromSide":"right","toNode":"2d2a1ead3f62559a","toSide":"left"},
		{"id":"0b9f31f3f51fc1c6","fromNode":"06c8dfc1835bdad9","fromSide":"top","toNode":"0e6f35441b30a9ce","toSide":"bottom"},
		{"id":"30194f92bd6527d1","fromNode":"64182a68ba4bddda","fromSide":"right","toNode":"04e2e59fbd2b386f","toSide":"left"},
		{"id":"02acaa45aa8e8095","fromNode":"0e6f35441b30a9ce","fromSide":"right","toNode":"1e950c33e4268bb0","toSide":"left"},
		{"id":"e5859ae734acf4ab","fromNode":"b088c8d184a0019a","fromSide":"top","toNode":"4b21c821ca9a99a5","toSide":"bottom"},
		{"id":"48f0ef61f6f58e2b","fromNode":"b088c8d184a0019a","fromSide":"right","toNode":"10eedec3831487f5","toSide":"left"},
		{"id":"c9a993f052a0edea","fromNode":"10eedec3831487f5","fromSide":"top","toNode":"0daddd3434b67fe6","toSide":"bottom"},
		{"id":"c41b55b10feabd97","fromNode":"10eedec3831487f5","fromSide":"bottom","toNode":"5d63270df240ccdf","toSide":"top"},
		{"id":"a4d8775573b9f5db","fromNode":"2795cbd69099d104","fromSide":"right","toNode":"b088c8d184a0019a","toSide":"left"},
		{"id":"333fb0d0eaae5d7a","fromNode":"10eedec3831487f5","fromSide":"right","toNode":"cd0682544b4d7ae0","toSide":"left"},
		{"id":"f334b54578c249c3","fromNode":"10eedec3831487f5","fromSide":"right","toNode":"dfe3bfa74fb8b071","toSide":"left"},
		{"id":"3807675986bc24b8","fromNode":"10eedec3831487f5","fromSide":"right","toNode":"fda930695389d493","toSide":"left"}
	]
}