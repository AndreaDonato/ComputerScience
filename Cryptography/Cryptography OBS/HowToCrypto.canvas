{
	"nodes":[
		{"id":"7cb40482ce744e2d","type":"text","text":"# Cryptography\n\n- (Un)conditional proofs - algoritmi (in)efficienti facendo (zero) assunzioni\n\t- aggiungere ipotesi ragionevoli\n- Schema tipico del corso: Teorema dimostrazione del tipo\n\t- THM - Cryptosystem X is \"secure\" if factoring is $\\NPH$;\n\t- PROOF - Assume X is note secure, i.e. exists efficient machine B che \"rompe\" X, trova la contraddizione.\n\n","x":-220,"y":60,"width":759,"height":320},
		{"id":"7fdd088ea436cf44","type":"text","text":"# Premesse\n\nSia $m$ un messaggio in chiaro scelto tra tutti i possibili messaggi $\\calM$. Chiamiamo $M$ la generica distribuzione secondo la quale estraggo $m$ dal set $\\calM$. Stessa cosa con la chiave $k$ tra tutte le chiavi $\\calK$ estratta con distribuzione $K$ e con il ciphertext $c$ tra tutti i $\\calC$ ottenuti con distribuzione $C$.\n\nUno schema crittografico a chiave segreta (***Secret Key Encryption***, ***SKE***) è definito da una coppia di funzioni di ***encryption*** e ***decryption***, i.e.$$\\Pi = (\\text{Enc}, \\text{Dec)}\\quad\\text{t.c.}\\quad C=\\Enc(k, M)$$\nQuesta cosa vale sia per le distribuzioni $(C, M)$ che per gli elementi $(c, m)$ estratti secondo esse. In modo analogo si definisce la funzione inversa $\\Dec$.\n\nIl pilastro che definisce la crittografia come scienza lo mette ***Shannon*** nel 1950: una SKE è ***sicura*** se rispetta la condizione matematica di ***Perfect Secrecy*** (***PS***)$$\\P[M=m] = \\P[M=m\\mid C=c]$$i.e. conoscere il ciphertext $c$ non modifica in alcun modo la probabilità a priori del messaggio $m$. In altre parole, una SKE è sicura se guardare $c$ non permette di inferire nulla su $m$, tolto ovviamente quello che già sapevamo già prima di guardare $c$. Possiamo definire la PS in modo equivalente:$$\\text{PS}\\iff M\\text{ and }C\\text{ independent}\\iff \\forall m,m'\\in\\calM, \\,\\,\\forall c\\in\\calC \\,\\,\\P[\\Enc(K,m)=c]=\\P[\\Enc(K,m')=c]$$\nNella terza formulazione $\\P$ è una distribuzione su $K$ e $K$ è una distribuzione su $\\calK$. Queste definizioni sono generali: non c'è nessuna ***assunzione*** su un eventuale attaccante, pertanto la chiamiamo ***unconditional***. Le proposizioni di questo tipo sono appunto più generali, ma di norma sono difficili da realizzare nella pratica. La PS è talmente difficile da realizzare che il ***teorema di Shannon*** ci dice che data una qualsiasi SKE $\\Pi$ si ha che$$|\\calK|\\ge|\\calM|$$\nQuesto disastroso risultato ci dice che la SKE minimale ha $|\\calK| = |\\calM|$. Si chiama ***One Time Pad*** (***OTP***), e nonostante sia mostruosamente inefficiente viene ancora oggi utilizzato in alcune situazioni. Tutti gli altri SKE che utilizziamo hanno $|\\calK| < |\\calM|$, e pertanto non sono PS: il ciphertext $c$ rivelerà ***sempre*** qualcosa sul messaggio in chiaro $m$.","x":-220,"y":440,"width":759,"height":880,"color":"4"},
		{"id":"c0588c81531cd312","x":-1240,"y":440,"width":759,"height":880,"type":"text","text":"# One Time Pad (OTP)\n\nÈ un esempio di cifrario PS minimale, in cui $|\\calK| = |\\calM|$. Poniamo$$\\calK=\\calM=\\calC=\\{0,1\\}^n$$\ne stabiliamo come schema $\\Pi$ $$\\Enc(k, m)=k\\oplus m \\quad\\so\\quad \\Dec(k,c)=k\\oplus c$$\ndove $\\oplus$ è l'operatore di $\\text{bitwise XOR}$. È facile verificare la *correctness* di questo SKE, visto che$$\\Dec(\\Enc(k,m))=\\Dec(k\\oplus m) = k\\oplus(k\\oplus m) = m \\quad(\\text{since }k\\oplus k = 1)$$\nProviamo ad usare la terza definizione equivalente di PS.$$\\P[\\Enc(k,m)=c] = \\P[k\\oplus m = c] = \\P[k=m\\oplus c]=2^{-n}$$\nQuesto perché $m\\oplus c$ è una delle $2^n$ stringhe $\\{0,1\\}^n$, in modo equiprobabile."},
		{"id":"9209fd8b71149fc4","type":"text","text":"# Dimostrazioni PS & Shannon\n\nPS (TO DO)\n\nShannon - ","x":840,"y":440,"width":759,"height":880}
	],
	"edges":[
		{"id":"92deadaae90f983c","fromNode":"7fdd088ea436cf44","fromSide":"left","toNode":"c0588c81531cd312","toSide":"right"}
	]
}