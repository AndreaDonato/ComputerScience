{
	"nodes":[
		{"id":"7cb40482ce744e2d","type":"text","text":"# Cryptography\n\n- (Un)conditional proofs - algoritmi (in)efficienti facendo (zero) assunzioni\n\t- aggiungere ipotesi ragionevoli\n- Schema tipico del corso: Teorema dimostrazione del tipo\n\t- THM - Cryptosystem X is \"secure\" if factoring is $\\NPH$;\n\t- PROOF - Assume X is note secure, i.e. exists efficient machine B che \"rompe\" X, trova la contraddizione.\n\n","x":-220,"y":60,"width":759,"height":320},
		{"id":"7fdd088ea436cf44","type":"text","text":"# Premesse\n\nSia $m$ un messaggio in chiaro scelto tra tutti i possibili messaggi $\\calM$. Chiamiamo $M$ la generica distribuzione secondo la quale estraggo $m$ dal set $\\calM$. Stessa cosa con la chiave $k$ tra tutte le chiavi $\\calK$ estratta con distribuzione $K$ e con il ciphertext $c$ tra tutti i $\\calC$ ottenuti con distribuzione $C$.\n\nUno schema crittografico a chiave segreta (***Secret Key Encryption***, ***SKE***) è definito da una coppia di funzioni di ***encryption*** e ***decryption***, i.e.$$\\Pi = (\\text{Enc}, \\text{Dec)}\\quad\\text{t.c.}\\quad C=\\Enc(k, M)$$\nQuesta cosa vale sia per le distribuzioni $(C, M)$ che per gli elementi $(c, m)$ estratti secondo esse. In modo analogo si definisce la funzione inversa $\\Dec$.\n\nIl pilastro che definisce la crittografia come scienza lo mette ***Shannon*** nel 1950: una SKE è ***sicura*** se rispetta la condizione matematica di ***Perfect Secrecy*** (***PS***)$$\\P[M=m] = \\P[M=m\\mid C=c]$$i.e. conoscere il ciphertext $c$ non modifica in alcun modo la probabilità a priori del messaggio $m$. In altre parole, una SKE è sicura se guardare $c$ non permette di inferire nulla su $m$, tolto ovviamente quello che già sapevamo già prima di guardare $c$. Possiamo definire la PS in modo equivalente:$$\\text{PS}\\iff M\\text{ and }C\\text{ independent}\\iff \\forall m,m'\\in\\calM, \\,\\,\\forall c\\in\\calC \\,\\,\\P[\\Enc(K,m)=c]=\\P[\\Enc(K,m')=c]$$\nNella terza formulazione $\\P$ è una distribuzione su $K$ e $K$ è una distribuzione su $\\calK$. Queste definizioni sono generali: non c'è nessuna ***assunzione*** su un eventuale attaccante, pertanto la chiamiamo ***unconditional***. Le proposizioni di questo tipo sono appunto più generali, ma di norma sono difficili da realizzare nella pratica. La PS è talmente difficile da realizzare che il ***teorema di Shannon*** ci dice che data una qualsiasi SKE $\\Pi$ si ha che$$|\\calK|\\ge|\\calM|$$\nQuesto disastroso risultato ci dice che la SKE minimale ha $|\\calK| = |\\calM|$. Si chiama ***One Time Pad*** (***OTP***), e nonostante sia mostruosamente inefficiente viene ancora oggi utilizzato in alcune situazioni. Tutti gli altri SKE che utilizziamo hanno $|\\calK| < |\\calM|$, e pertanto non sono PS: il ciphertext $c$ rivelerà ***sempre*** qualcosa sul messaggio in chiaro $m$.","x":-220,"y":440,"width":759,"height":880,"color":"4"},
		{"id":"c0588c81531cd312","type":"text","text":"# One Time Pad (OTP)\n\nÈ un esempio di cifrario PS minimale, in cui $|\\calK| = |\\calM|$. Poniamo$$\\calK=\\calM=\\calC=\\{0,1\\}^n$$\ne stabiliamo come schema $\\Pi$ $$\\Enc(k, m)=k\\oplus m \\quad\\so\\quad \\Dec(k,c)=k\\oplus c$$\ndove $\\oplus$ è l'operatore di $\\text{bitwise XOR}$. È facile verificare la *correctness* di questo SKE, visto che$$\\Dec(\\Enc(k,m))=\\Dec(k\\oplus m) = k\\oplus(k\\oplus m) = m \\quad(\\text{since }k\\oplus k = 1)$$\nProviamo ad usare la terza definizione equivalente di PS.$$\\P[\\Enc(k,m)=c] = \\P[k\\oplus m = c] = \\P[k=m\\oplus c]=2^{-n}$$\nQuesto perché $m\\oplus c$ è una delle $2^n$ stringhe $\\{0,1\\}^n$, in modo equiprobabile.\n\n","x":-1240,"y":440,"width":759,"height":880},
		{"id":"9209fd8b71149fc4","type":"text","text":"# Dimostrazioni Shannon\n\nPer assurdo, prendiamo $M$ uniforme e un qualsiasi $c$ tale che $\\P[C=c]>0$, i.e. posso ottenere $c$ come $\\Enc(k,m)$ per una qualche scelta di $k$ ed $m$, ed assumiamo $|\\calK|<|\\calM|$. Definiamo$$\\calM'=\\bigg\\{\\Dec(k,c)\\,\\text{ t.c. }\\,k\\in\\calK\\bigg\\}$$i.e. l'insieme di tutti i messaggi ricostruibili a partire da una chiave $k\\in\\calK$. È chiaro che $|\\calM'|\\le|\\calK|$: a parità di $c$, non posso ricostruire più messaggi $m'$ di quante sono le chiavi $k$. Segue che $$|\\calM'|\\le|\\calK|<|\\calM| \\quad\\so\\quad |\\calM'|<|\\calM|$$Essendo strettamente minore, deve esistere un messaggio $\\in\\calM$ ma $\\notin\\calM'$. Per tale $m$ abbiamo$$\\P\\big[M=m\\big]={1\\over|\\calM|}$$in quanto $\\in\\calM$, ma anche $$\\P\\big[M=m\\mid C=c\\big]=0$$\nin quanto $\\notin \\calM'$. Essendo queste due $\\P$ diverse non vale la condizione di PS, quindi non esiste un SKE tale che $|\\calK|<|\\calM|$.","x":840,"y":440,"width":759,"height":880,"color":"4"},
		{"id":"a82c1a10ade4a3e5","x":-220,"y":1432,"width":759,"height":1688,"type":"text","text":"# Lec 26/10\n\nproof del lemma che dimostra equivalenza definizioni\n\n- 1 $\\so$ 2 : Prendi per buona la definizione di PS, usi Bayes$$P(M=m)={}$$ (appunti in negativo + suoi online)\n\n\nsecrecy was goal n 1, then integrity. let's see integrity\n\n### Message Authentication Codes\n\nmessage can be public, don't care about secrecy. mi interessa solo che non venga modificato. Alice dà il messaggio m in pasto ad un algoritmo detto Tag che usa una chiave per far uscire un tag $\\t$ tc. $|\\t|<|m|$. Alice manda sia m che tau. dice una roba sul fatto che sta roba è unconditional\n\nbob riceve $m,\\t$, prende m e calcola il tag ottenendo $\\t'$, quindi controlla se $\\t=\\t'$. Se lo è, daje, sennò c'è qualcosa che non va. Tutto il punto del corso è capire cosa voglio garantire con questa funzione di tag, come la costruisco e sotto quali condizioni è sicura.\n\nmentre PS è perfetta (da capire meglio questo), un adversary potrebbe con probabilità molto bassa  guessare la giusta modifica in grado di non modificare l'hash. \"correctness is implicit as long as Tag function is deterministic\". Non ha senso farla non deterministica, no? \"a volte ha senso\".\n\n\"completeness = correctness\"\n\nunforgeability = should be hard to forge valid tag $\\t'$ on message $m'$ (se non conosco la chiave è difficile guessare il giusto hash, il che mi fa pensare che prima ho capito male qualcosa). E se conosco già un'associazione messaggio/tag? E se ne raccolgo un tot? Posso risalire alla chiave?\nma poi ovviamente ad ogni messaggio aggiungo un timestamp in modo da non fare mai due messaggi uguali, quindi per forza devo trovare la chiave, è difficile fare tipo \"prendo un pezzetto da una parte e uno dall'altra, tipo che il messaggio abc ha hash 65 e afg ha 69 e associo 6 ad a (tipo)\". \"AES non è un encryption scheme, ha proprietà diverse, poi certo, lo puoi usare per la secirity o per l'hashing\". ok unforgeability ti fa essere sicuro che eve non può scrivere messaggi e asociare un valid tag convincendo bob che il mess venga da alice.\n\ndef (statistical secure mac) - say $\\Pi =$ tag (perché di nuovo pi???). pi ha una $\\e$-statistical security (unforgeability) se $$\\forall\\,m,m'\\text{ t.c. }m\\ne m'\\quad \\forall\\,\\t,\\t'\\in\\calT\\so \\P[tag(K,m')=\\t'\\mid tag(K,m)]=\\t\\le\\e$$\nex: impossible to get \\e=0 (credo perché con probabilità $1\\over|\\calK|$ posso comunque guessare la chiave, lui dice meglio che con probabilità $1\\over|\\calT|$ posso guessare il giusto \\t che forgia). nota che però qua non c'è l'adversary, quindi ancora unconditional. questa def parla solo di un messaggio: se vedo un'associazione posso guessare un'altra giusta associazione con prob al più \\e. Se già i messaggi sono due non dice più nulla. \"alice, puoi taggare in sicurezza un solo messaggio, se ne tagghi due io me ne tiro fuori\". è una ONE-TIME definition. Si può anche scrivere la TWO-TIME definition ma non credo ci interessi. ok forging is ab\n\n- the notion is achievable\n- it's unefficient - thm: any t-time $\\l$-statistically secure tag has a key of length (i.e. al tempo t, una funzione che si propone di essere $\\l$-SS deve avere una chiave lunga almeno $(t+1)\\l$)\n\ndef pairwise independence\n\n\"sha has no key, it is public. pw independent hanno una chiave\"\nany family of hash functions \"prendo una chiave a caso, critto due messaggi a caso, questi cosi sono indipendenti. già non vale per più messaggi\"."}
	],
	"edges":[
		{"id":"92deadaae90f983c","fromNode":"7fdd088ea436cf44","fromSide":"left","toNode":"c0588c81531cd312","toSide":"right"}
	]
}