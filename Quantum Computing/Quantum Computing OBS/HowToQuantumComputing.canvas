{
	"nodes":[
		{"id":"2acc7bcd96aff60e","type":"text","text":"# Versione Generale\n\nGli stati quantistici sono rappresentati dalle ***density matrices***","x":802,"y":689,"width":759,"height":310},
		{"id":"133cd6df233bcfec","type":"text","text":"# Quantum Information Theory\n\nLa teoria classica dell'Informazione è un caso particolare (i.e. limite classico?) della versione semplificata della QIT, che a sua volta è un caso particolare della generale.","x":-207,"y":689,"width":759,"height":310},
		{"id":"51ba04bfd72f3571","type":"text","text":"# Versione Semplificata\n\nGli stati quantistici sono ***vettori*** e le operazioni sono ***matrici unitarie***.","x":-207,"y":1234,"width":759,"height":310},
		{"id":"743ef9a469fb22bb","type":"text","text":"# Quantum Computing\n\nLa grande premessa a questi appunti è che chi li ha redatti ha un background in Meccanica Quantistica. Potrebbero comparire di botto termini complessi non precedentemente introdotti per bene o concetti complessi accennati o liquidati con un \"ovviamente\".","x":-207,"y":-246,"width":759,"height":310},
		{"id":"866747bff074fdd2","type":"text","text":"# SPACING","x":-207,"y":-716,"width":250,"height":235,"color":"5"},
		{"id":"2cedddbf856edcb5","type":"text","text":"# SPACING","x":-800,"y":-326,"width":250,"height":235,"color":"5"},
		{"id":"e6c41c8e2e350d7c","type":"text","text":"# Basi di Meccanica Quantistica","x":-207,"y":-1181,"width":759,"height":310},
		{"id":"e2db50131cd84590","type":"text","text":"# Classical Information Theory\n\n","x":-2225,"y":300,"width":759,"height":1089},
		{"id":"e6e020dbb57ef986","type":"text","text":"# Classical Information Theory (Qiskit)\n\nChiamiamo X un sistema chiuso in una scatola che può trovarsi in un numero finito di ***stati classici*** (i.e. stati che possono essere descritti in modo non ambiguo, senza incertezze o errori), i.e. un set $\\Sigma$ costituito da tutti i possibili outcome di una misura dello stato del sistema (e.g. $\\{1, 2\\}$ per una moneta, o `bit fisico`, $\\{1, 2, 3, 4, 5, 6\\}$ per un dado a sei facce).\n\nPrima di fare una misura, il sistema si trova in uno ***stato probabilistico*** (e.g. quando lancio una moneta non truccata la probabilità che esca testa è uguale a quella che esca croce, e sono entrambe pari a $0.5$). Uno stato probabilistico può essere espresso come\n$$\n\\P(X=0) = 0.7,\\quad \\P(X=1)=0.3 \\quad\\iff \\begin{pmatrix}0.7\\\\0.3\\end{pmatrix}\n$$\nAbbiamo così introdotto il ***probability vector*** (PV), che nel caso classico ha una entry per ogni possibile stato classico del sistema. Introduciamo in notazione di Dirac il ket $\\ket{\\a}$ per indicare un vettore di stato avente $1$ in corrispondenza dello stato $\\a$ e $0$ altrimenti (i.e. scriviamo una base ortonormale usando gli stati del sistema, nella quale quindi il PV risulta scritto). Effettuare una misura sullo stato probabilistico classico e trovare come risultato $\\a$ equivale a far collassare (dal nostro punto di vista) il PV nel ket di base $\\ket{\\a}$.\n\nTutto questo sembra corrispondere ad un ***collasso informativo***, piuttosto che fisico. Il sistema classico era probabilmente già in uno stato ben preciso, noi abbiamo solo guardato. Ovviamente, dal punto di vista di una persona che non osserva il risultato restano valide le probabilità di partenza: diversi osservatori possono avere un diverso grado di conoscenza dello stesso sistema.\n\n","x":-2225,"y":1624,"width":759,"height":637,"color":"4"},
		{"id":"765ef5312171995a","type":"text","text":"# Aggiungi Teoria dell'Informazione dall'esame di IoT","x":-3360,"y":684,"width":768,"height":322,"color":"1"},
		{"id":"8f7ea773adcc0343","type":"text","text":"# Operatori Classici\n\nPossiamo vedere l'atto di misura come una funzione che modifica il PV:\n$$\nf:\\,\\S\\to\\S\\quad\\text{tale che}\\quad \\calM|\\a\\ket=|f(a)\\ket\\quad\\text{dove}\\quad\\calM(i,j)=\n\\begin{cases}\n1\\text{ se }i = f(j)\\\\\n0\\text{ se }i \\ne f(j)\\\\\n\\end{cases}\n$$\n\nOgni funzione $f$ di questo tipo rappresenta un'***operazione deterministica***, scrivibile come $\\ketbra{a}{b}$. Se usiamo i vettori di base, questa è una matrice avente $\\calM(a,b) = 1$ e ogni altro elemento $=0$. Segue che dalla definizione precedente che\n$$\n\n\\calM=\\sum_{b\\in\\S}\\ketbra{f(b)}{b}$$\nAbbiamo più in generale le ***operazioni probabilistiche*** (e.g. flippa il `bit` con probabilità $p$), di cui le deterministiche sono quel sottocaso in cui non introduco incertezze. $\\calM$ diventa una ***matrice stocastica*** (elementi non-negativi, ogni colonna somma ad $1$). Per leggere una matrice stocastica in modo intuitivo: se applichiamo questo operatore al ket di base $\\ket{j}$, la colonna $j$ della matrice ci fornisce la *pdf* degli stati in cui questo può trasformarsi.\n\nSi possono sempre pensare le operazioni deterministiche come random choice tra outcome dati da operazioni deterministiche, e.g.\n$$\n\\begin{pmatrix}1&1/2\\\\0&1/2\\end{pmatrix}={1\\over2}\\begin{pmatrix}1&1\\\\0&0\\end{pmatrix}+{1\\over2}\\begin{pmatrix}1&0\\\\0&1\\end{pmatrix}\n$$\nInfine, essendo il prodotto di matrici associativo, $\\calM_2(\\calM_1 v)=(\\calM_2\\calM_1)v$. È anche chiuso, quindi $\\calM_2\\calM_1$ è ancora una matrice stocastica.","x":-2225,"y":2497,"width":759,"height":640,"color":"4"},
		{"id":"1ba94a12349094a8","type":"text","text":"# Operatori Classici Notevoli\n\n$$\nf_1:\\begin{cases}0\\to0\\\\1\\to0\\end{cases}\\quad \\so\\quad \\calM=\\bigg(\\begin{matrix}1&1\\\\0&0\\end{matrix}\\bigg)\\quad\\so\\quad\\text{0 Gate}\n$$\n$$\nf_2:\\begin{cases}0\\to0\\\\1\\to1\\end{cases}\\quad \\so\\quad \\calM=\\bigg(\\begin{matrix}1&0\\\\0&1\\end{matrix}\\bigg)\\quad\\so\\quad\\text{AND Gate}\n$$\n$$\nf_3:\\begin{cases}0\\to1\\\\1\\to0\\end{cases}\\quad \\so\\quad \\calM=\\bigg(\\begin{matrix}0&1\\\\1&0\\end{matrix}\\bigg)\\quad\\so\\quad\\text{NOT Gate}\n$$\n$$\nf_4:\\begin{cases}0\\to1\\\\1\\to1\\end{cases}\\quad \\so\\quad \\calM=\\bigg(\\begin{matrix}0&0\\\\1&1\\end{matrix}\\bigg)\\quad\\so\\quad\\text{1 Gate}\n$$","x":-2225,"y":3372,"width":759,"height":577,"color":"3"},
		{"id":"bc0719120cb286b0","type":"text","text":"# SPACING","x":-1466,"y":2497,"width":250,"height":235,"color":"5"},
		{"id":"121c1b6063127d40","type":"text","text":"# Operatori Quantistici\n\nSe le operazioni nella teoria classica sono rappresentate da matrici stocastiche, nella controparte quantistica abbiamo ***matrici unitarie***, i.e. matrici quadrate tali che\n$$\n\\calU^\\dagger\\calU = \\I = \\calU\\calU^\\dagger \\quad\\iff\\quad \\calU^{-1} = \\calU^\\dagger\n$$\nLa cosa simpatica di queste matrici è che non modificano la norma euclidea:\n$$\n||\\calU v|| = ||v||\n$$\nÈ ovvio che ciò sia necessario: la norma euclidea fa le veci del teorema della probabilità totale, non possiamo cambiarla come ci pare. Inoltre, ovviamente, se $v$ è un quantum state vector allora anche $w=\\calU v$ sarà un quantum state vector.\n\n","x":-1216,"y":2497,"width":759,"height":640,"color":"4"},
		{"id":"29ff74ab90c94bca","type":"text","text":"la definizione dello stato quantistico determina una differente informazione quantistica (?)","x":716,"y":1820,"width":604,"height":200},
		{"id":"4a4c03afbff3bf2a","type":"text","text":"# Operatori Quantistici Notevoli\n\n- Le ***matrici di Pauli***, che sono anche ***hermitiane*** (i.e. $\\calU=\\calU^\\dagger$): $$\\I=\\begin{pmatrix}1&0\\\\0&1\\end{pmatrix}\\qquad\\s_x=\\begin{pmatrix}0&1\\\\1&0\\end{pmatrix}\\qquad\\s_y=\\begin{pmatrix}0&-i\\\\i&0\\end{pmatrix}\\qquad\\s_z=\\begin{pmatrix}1&0\\\\0&-1\\end{pmatrix}\\qquad$$\n\t- Nota che $\\s_x=f_3$ per come definita nel caso classico: si comporta come una porta `NOT` (i.e. esegue un `bit flip`). $\\s_z$ è invece un'operazione di `phase flip`, i.e. applicata a $\\ku$ restituisce $-\\ku$.\n- La matrice di ***Hadamard*** definita come$$\\calH={1\\over\\sqrt2}\\begin{pmatrix}1&1\\\\1&-1\\end{pmatrix}$$\n\t- La sua azione è definita da $\\calH \\kz = \\kp,\\,\\calH \\ku = \\km$ , e viceversa ($\\calH \\kp = \\kz$). Utile per capire se lo stato che sto osservando è $\\kp$ o $\\km$ (i.e. prima di applicare $\\calH$ allo stato quantistico ottengo $\\kz$ e $\\ku$ al $50\\%$, senza informazioni sulla fase. Dopo, ottengo solo $\\kz$ o $\\ku$ a seconda che lo stato originale fosse $\\kp$ o $\\km$);\n\t- Utile anche nella pratica a portare i ket di base $\\kz$ e $\\ku$ ad una loro sovrapposizione.\n- Le ***phase operations*** definite come$$\\calP_\\f=\\begin{pmatrix}1&0\\\\0&e^{i\\f}\\end{pmatrix}\\quad\\text{e.g.}\\quad\\calP_{\\pi/2}=\\calS=\\begin{pmatrix}1&0\\\\0&i\\end{pmatrix}\\quad\\text{e}\\quad\\calP_{\\pi/4}=\\calT = \\gateT$$","x":-1216,"y":3372,"width":759,"height":577,"color":"4"},
		{"id":"c4a9dc0e9aabfad3","type":"text","text":"# Quantum States\n\nUno stato quantistico è rappresentato da un ket i cui indici corrispondono agli stati classici in cui il sistema può trovarsi quando viene effettuata una misura. La differenza è che qui gli elementi sono $\\in\\C$ (prima erano $\\in\\R^+$) e che non è la semplice somma a fare $1$, ma la somma dei moduli quadri (in parte è ovvio, perché i valori da cui partiamo sono $\\in\\C$ e la probabilità deve essere $\\in R^+$, per le motivazioni più profonde sarebbe utile seguire il corso di Meccanica Quantistica a Fisica, lui stesso non entra in dettaglio ovviamente).\n\nSe usiamo la norma euclidea\n$$\n||v||=\\sqrt{\\sum_{k=1}^n|\\a_k|^2}\n$$\npossiamo dire che i ***quantum states*** sono ***vettori unitari*** rispetto ad essa. Da qui in poi posso giocare a creare nuovi vettori di base come $\\kp$ e $\\km$ o generici stati quantistici.\n\nIn questo contesto, effettuare una misura nei vettori di base significa estrarre informazione classica dallo stato quantistico. Il collasso della funzione d'onda pone un limite alla quantità di informazione classica che può essere estratta da uno stato quantistico (cfr. una lezione successiva).","x":-207,"y":1624,"width":759,"height":637},
		{"id":"7b8f68b752cc0f58","type":"text","text":"# SPACING","x":-707,"y":3949,"width":250,"height":235,"color":"5"},
		{"id":"d93e311c7132bf29","type":"text","text":"# Square Root of `NOT`\n\nQui iniziamo a vedere gli effetti quantistici. Consideriamo l'operatore dato dall'applicazione in sequenza di una porta Hadamard, un S-gate ed un'altra Hadamard.\n$$\n\\calH\\calS\\calH=\\hadamard\\gateS\\hadamard = \\begin{pmatrix}{1+i\\over2}&{1-i\\over2}\\\\{1-i\\over2}&{1+i\\over2}\\end{pmatrix}\n$$\n... e quindi? A questo punto potremmo notare che\n$$\n\\big(\\calH\\calS\\calH\\big)^2 = \\paulix = \\s_x\n$$\nDi fatto, abbiamo costruito una porta `NOT` applicando due volte in sequenza la stessa operazione. Questa roba non ha un equivalente classico!","x":-1216,"y":4184,"width":759,"height":373,"color":"4"},
		{"id":"567a94228b10bd4f","type":"text","text":"# Riprendi da [qui](https://www.youtube.com/watch?v=DfZZS8Spe7U&list=PLOFEBzvs-VvqKKMXX4vbi4EB1uaErFMSO&index=5&ab_channel=Qiskit)","x":-8,"y":3396,"width":408,"height":164,"color":"1"},
		{"id":"03baf5c82939af36","type":"text","text":"# Algoritmi!\n\nintanto dice che, come avviene con il clock in un computer classico, la computazione quantistica è ben definita solo a certi step temporali. Sarebbe, shroedinger fa evolvere lo stato ma ti serve fotografarlo al momento giusto per avere quello che vuoi.\n\ntoffoli gate \"when both controls a, b are 1 invert the output\". è una base completa per la computazione classica (basta notare che fissare c=1 significa ottenere un NAND, che a sua volta è base completa, sia per reversible che per irreversible).\n\n##### oracle algorithms\n\nQuantum Oracle - hai una non reversible boolean function. quale?? quella che segue è reversibile?\n\n$$U_f:(x,y)\\to(x,y\\oplus f(x))\\quad\\so\\quad U_f(x,0)=(x,f(x)) \\quad U_f(x,1)=(x,NOT(f(x)))$$\npassare dai bit ai qubit significa mettere un prodotto tensore al posto delle virgole.\n\n$$U_f:(x\\otimes y)\\to(x\\otimes (y\\oplus f(x)))\\quad\\so\\quad U_f(x\\otimes 0)=(x\\otimes f(x)) \\quad U_f(x\\otimes 1)=(x\\otimes NOT(f(x)))$$\ne che cambia? Mettiamoci dentro i qubit veri, e.g.\n\n$$U_f\\AT{1\\over\\sqrt2}\\at\\kz+\\ku\\ct\\otimes\\kz\\CT={1\\over\\sqrt2}\\AT\\mid0\\otimes f(0)\\ket + \\mid1\\otimes f(1)\\ket\\CT$$\n\"f(0) ed f(1) sono calcolate in parallelo\".\n","x":4720,"y":9802,"width":894,"height":593},
		{"id":"56a070e72950f083","type":"text","text":"# Quantum-Deterministic Algorithms\n#### Deutsch (1985)\n\nclassicamente se ho $f(0)\\oplus f(1)$ devo per forza calcolare prima f(0) e poi f(1). Due volte, insomma. Deutsch usa una sola chiamata all'Oracle descritto sopra. In pratica, dimezza il numero di volte che devo valutare f. Schema slides 6 p 13, restituisce 0 se $f(0)=f(1)$ e 1 altrimenti. Vediamo come.\n\n- Se parto con $\\ket{01}$ applico Hadamard a entrambi ottenendo $${1\\over2}\\at\\kz+\\ku \\ct\\otimes\\at\\kz-\\ku\\ct={1\\over2}\\AQ\\kz\\otimes\\AT\\kz-\\ku\\CT+\\ku\\otimes\\AT\\kz-\\ku\\CT\\CQ$$\n- Possiamo scrivere l'azione di $U_f$ sul un oggetto come quello come $$U_f|a\\ket\\otimes\\AT{\\kz-\\ku\\over\\sqrt2}\\CT=(-1)^{f(a)}\\,\\,|a\\ket\\otimes\\AT{\\kz-\\ku\\over\\sqrt2}\\CT$$\n\t- Si chiama ***Phase Flipping***\n- A seconda che $f(a)$ sia $1$ o $0$ otteniamo\n\t- $\\pm\\kp$ \n\n\n#### Deutsch-Jozsa Problem (21/10)\n\nPossiamo generalizzare Deutsch a N qubits? Non è banale. $f:\\B^n\\to\\B$ è costante se f(x)=0 (o 1) per ogni input, ed è ***balanced*** se$$\\sum_{x\\in\\calB}f(x)=2^{n-1}$$Ci sono solo due f costanti ma N bilanciate (quante?). Che ce famo? Ammettiamo di avere una funzione o costante o bilanciata (non entrambe insieme, ovviamente. detto \"promise problem\"). Il problema è decidere se f è costante o bilanciata. Classicamente devo avere $2^{n+1}+1$ evaluations of $f$, nel caso quantistico ne basta una.\n \nIl circuito è come Deutsch normale ma con N qubits di input, tutti in $\\kz$ ($\\so\\ket{0^n}$, e allo stesso modo una Hadamard su $n$ qubits diventa $\\calH^{\\otimes n}$ ). Se riotteniamo $\\ket{0^n}$ allora è costante, altrimenti è bilanciata. unica valutazione di f in $U_f$.\n\nAzione Hadamard su più qubit:$$H\\ka={1\\over\\sqrt2}\\sum_b(-1)^{ab}\\kb\\quad\\so\\quad\\AT H\\otimes H\\CT\\kx\\otimes\\ky = ...= {1\\over2}\\sum_{a,b}(-1)^{xa+yb}\\ket{ab}={1\\over2}\\sum_{a\\in\\calB^2}(-1)^{xy\\cdot a}\\ket{ab}$$\nGeneralizzando ad N abbiamo$$\\calH^{\\otimes n}\\kx={1\\over\\sqrt{2^n}}\\sum_{a\\in\\calB^n}(-1)^{x\\cdot a}\\ka$$Nota che\n- se $x=0^n$ ottengo una combinazione omogenea di tutti i vettori della base canonica.\n- se $x=0^n\\otimes1$ vedi slides per tutti i calcoli\n\nil punto qui è che sta roba restituisce probabilità 1 per uno stato o per l'altro. Nessun \"with high probability\", siamo certi di quello che stiamo ottenendo. Da qui in poi non sarà più così.\n","x":5880,"y":9440,"width":1001,"height":1318},
		{"id":"bdfa0971534eb41a","type":"text","text":"# Quantum-Probabilistic Algorithms","x":4720,"y":11150,"width":894,"height":481},
		{"id":"17eb5ea6c2fb740c","type":"text","text":"# Grover","x":3240,"y":11150,"width":783,"height":481},
		{"id":"28d7a388df752e23","type":"text","text":"# Shor\n","x":7080,"y":11150,"width":645,"height":481},
		{"id":"396fd1bf9e36e927","type":"text","text":"# DFT & QFT\n\nPer farlo ci serve la Discrete Fourier Transform, che tendenzialmente serve a moltiplicare due polinomi con molti termini;$$\\AQ p(x)=\\sum_{i=0} ^{n-1}a_ix^i\\CQ\\times\\AQ q(x) = \\sum_{j=0}^{n-1} b_jx^j\\CQ=\\sum_i\\sum_ja_ib_jx^{i+j}=\\sum_{k=0}^{2n-2}x^k\\AT\\sum_j^{k}a_jb_{k-j}\\CT := \\sum_{k=0}^{2n-1}x^kc_k$$dove se $j<0$ o $j \\ge n$ abbiamo $a_j=b_j=0$. Ora, dati due vettori a e b definiamo la convoluzione come$$a\\convolution b=(c_0, ..., c_{2n-1})$$\nora passa a definire gli anelli (commutativi?) come (dominio prodotto somma elementoneutro unità). $w$ is a ***principal*** n-th (n lo fisso io come parametro) root of unity if\n\n1. $w\\ne1$\n2. $w^n=1$\n3. $\\sum_{j=0}^{n-1}w^{j\\cdot p}=0$ where $p=1, ..., n-1$\n\nrispetto ad un vettore colonna di size n, una DFT è una matrice $A_{ij}=w^{i\\cdot j}$ : $\\text{DFT}(a)=Aa$ . L'inversa è $A^{-1}_{ij}={1\\over n} w^{-ij}$ . L'i-esimo elemento di DFT(a) è $$\\sum_k a_k w^{ik}=\\sum_k a_k (w^i)^k:=p(w^i)$$ in pratica è come riscrivere il polinomio in $w^i$.\n\nConvolution Theorem: se prendo $a=(a_0, ..., a_{n-1}, 0, ..., 0)\\in\\R^{2n}$ e $b=(b_0, ..., b_{n-1}, 0, ..., 0)\\in\\R^{2n}$ allora $$a \\convolution b = DFT^{-1}\\AT DFT(a)\\cdot DFT(b)\\CT$$ cove $\\cdot$ indica una component-wise multiplication.  Perché posso farlo? dopo che faccio DFT sono in una rappresentazione $w^i$ (... e quindiii??).\n\nComputing A is O(n^2). E quindi è inutile, no? No, perché se $n=2^k$ esiste un modo più veloce $O(n\\log n)$ per calcolare la matrice (Fast FT). è un risultato ottimale, non puoi fare meglio di così (è un teorema? vedi algoritmi)\n\n###### Quantum DFT\n\nAbbiamo $N$ ket di base, ci basta definire l'azione su di essi (poi per linearità si estende a tutto):$$\\ket{j}\\to{1\\over\\sqrt N}\\sum_{k=0}^{N-1} e^{2\\pi ijk\\over N}\\ket{k}$$la normalizzazione serve a rendere la QFT unitaria. \"it's a kind of CNOT\", dice parlando della delta di kroneker (?)\n\nImplementazione circuito: assumiamo $N=2^n$. \"You might think it has an efficient implementations in terms of qubits, but...\" no, niente ma. Sono prodotti tensore, ce l'ha e basta. R sono controlled rotations.","x":8560,"y":10854,"width":1080,"height":1074},
		{"id":"bea8002766d6b597","type":"text","text":"# Howard Shor's algorithm\n\n$$n=pq+r$$\n\nOrder Finding Problem \"it's a number theory thing\"  GDC = greater common divisor\n\nprendi due numeri $x<N$ coprimi ($GDC(x,N)=1$)\n\nThe order of x modulo N is the least integer r such that $x^r = 1$ mod N. Find $r$.\n\nintroduction to the theory of numbers (libro)\n\n\n###### 7/11\n(in realtà continua order finding)\nGli autovalori di un operatore unitario si possono scrivere $e^{2\\pi i \\f}$, e quantum phase estimation si ripropone di trovare $\\f$. Qui ci interessano quelli dell'operatore$$U_x\\ky=\\ket{xy\\mod N}\\qquad y\\le N$$\"last time we proved it to be unitary for any x\". Esiste newer version delle slides in cui qua ci sta qualcosa in più. Mo troviamo autovalori e autovettori. Claim: for any $s$ t.c. $0\\le s\\le r-1$ $$\\ket{u_s}={1\\over\\sqrt r}\\sum$$segue proof. Nota solo che nelle slides passando dal ket con la parentesi a quello senza usa la integer division, una roba tipo$$x\\times x^k=x(qN+r) \\so x^{k+1}xqN+xr$$dove $r=x^k\\mod N$. C'è un passaggio intermedio in cui $x(x^k\\mod N)\\to (x^{k+1}\\mod N)\\mod N\\to x^{k+1}\\mod N$.\n\nCostruire un circuito che fa questo servono $O(L^3)$ gates (upper bound, ci sono stime migliori fino a quasi $L^2$, ed è il bottleneck dell'algoritmo di Shor), dove L è il numero di bit necessari a encodare l'input N ($L=\\ceil{\\log N}$).\n\nAl posto di $\\ket{u}$ potrei dare una superposition di eigenvectors e sarebbe tutto uguale (per linearità). La cosa figa è che$$\\ku = {1\\over\\sqrt r}\\sum_r\\ket{u_s}$$quindi sappiamo come costruire $\\ket{u_s}$. proof sulle slides.\n\nRECAP (credo):\n\n- Abbiamo il problema della fattorizzazione col modulo, definiamo un operatore quantistico unitario che la effettua su un ket;\n- Facciamo un po' di giri e riusciamo a mettere quello che ci serve nella fase di un autovalore di questo operatore;\n- Con la Quantum Phase Estimation tramite la Quantum Fourier Transform siamo in grado di ricostruire con una certa accuracy questa fase;\n- Metti tutto insieme e ottieni Shor.\n\nIn tutto questo ripete più volte che i bottleneck sono nei pezzi classici dell'algoritmo (e.g. stimare r a partire da s/r con le frazioni continue, details in Nielsen Chuang).\n\nDi fatto shor usa solo una piccola sub-routine quantistica in tutto l'algoritmo, tutto il resto è classico. Ciò è possibile in virtù di due teoremi:\n\n1. Trovare una soluzione non banale per $x^2=1\\mod N$ (quindi non 1 o -1) è equivalente a trovare $x$ come fattore primo di $N$;\n2. Posso trovare una soluzione non banale con probabilità $\\ge 50\\%$ (i.e. $\\ge 1-2^{-m}$ dove $m$ è il numero di fattori primi di $N$. \n\nSegue algoritmo di Shor (ultima slide). Unico pezzo quantum: riga 8.\n\nServono centinaia di good qubits (nel senso, non quelli fuzzy che abbiamo oggi). \"we need at least 10 years to break rsa\".","x":6916,"y":12191,"width":974,"height":1509},
		{"id":"0230e96a480e47fb","type":"text","text":"# Quantum Phase Estimation (QPE)\n\nero distratto\n\nl'idea è trovare la fase dell'autoket d iun operatore unitario. si fa applicando l'operatore C, poi $QFT^{-1}$ e  trovo le fasi (?). Lo faccio con probabilità 1 se $\\f=0.\\f_1...\\f_t$ (binary fraction) una sorta di oracle algorithm, \"non posso trovare una complessità\" (?)\n\ne sa la fase è un numero generico (non una binary fraction)? Devo definire i bit di precisione e una probabilità $1-\\e$ \n\nl'output sono t bits che approssimano la fase (si capisce meglio il motivo per cui se la fase contiene solo 0 e 1 la stimo con prob=1). Prima dell'output c'è la QFT^-1, che richiede quadratic complexity nell'input.","x":10080,"y":11167,"width":793,"height":447},
		{"id":"cbbfa8244737d93c","type":"text","text":"questa roba si può fare in qiskit\n\n\"è come cucinare un soufflé, devi fermarti esattamente al tempo giusto\", perché l'idea generale è applicare rotazioni ad $\\ka$ fino ad arrivare a $\\kb$, ma rischio di scavallarlo. la versione migliorata non rischia di scavallarlo, ma rischia di diventare troppo lenta.\n\nR_s ed R_t sono unitari (proof? o intuizione?)","x":500,"y":11150,"width":671,"height":573},
		{"id":"73649c6cd8fdf5d3","type":"text","text":"# proof e altre cose\n\n$$\\bigg|\\bra{t}UR_sU^\\dagger R_tU\\ket{s}\\bigg|^2 = 1-\\e^3$$\ndimostrazione con azione su $\\ket{s}$:$$UR_sU^\\dagger R_tU\\ket{s}=U\\ket{s}\\AQ e^{i\\th}+ |U_{ts}|^2\\at e^{i\\th-1})^2+\\ket{t}U_{ts}\\at e^{i\\th-1}\\ct\\CQ$$(questa stessa espressione va dimostrata... lo fa dopo, ma concettualmente è lo step 1) poi fa conti (step 2)... è scritto sulle slides, e se non lo è boh, ti arrangi. sta indicando con $U_{ts}=\\bra{t}U\\ket{s}$. A na certa esce\n\n$$\\bigg|\\bigg|\\ket{t}U_{ts}\\AQ2e^{i\\th}-1+|U_{ts}|^2(e^{i\\th}-1)^2\\CQ\\bigg|\\bigg|^2=|U_{ts}|^2\\bigg| -{1\\over2}\\bigg|U_{ts}\\bigg|^2+{\\sqrt3\\over2}\\at2-|U_{ts}|^2\\ct\\bigg|^2$$\na na certa devi usare $\\th=\\pi/3$, ma solo alla fine (ho palesemente sbagliato a scrivere, vedi slides).\n\nle chiamate ricorsive per costruire $U_m$ lo rendono poco pratico da implementare. si può anche far vedere che$$|\\bra{t}U_m\\ket{s}|^2= \\e^{2q_m-1}$$ dove ci sono $q_m$ chiamate all'oracolo all'iterazione $m$. Quel fattore viene dal fatto che R_t viene raddoppiato ad ogni iterazione.\n\nlavoro successivo con Chuang (quello del libro) migliorano sta roba dando un $\\th$ variabile invece di $\\pi/3$ fisso.\n\nricorda che $\\ba U^\\dagger\\kb = \\bb U \\ka^*$ ","x":1400,"y":12927,"width":894,"height":879},
		{"id":"771af3f492f38981","type":"text","text":"# QC Roma3 16/09/25\n\nG7 parlano di QC?\nQuantum Europe Strategy\nBequantum\nAmplitude Amplification (soluzione solo con alta probabilità!!)\nNo cloning implica che non posso fare a=b nel senso di assegnazione di variabile\nDecoerenza limita il tempo utile a disposizione del calcolo\nError correction (le risposte sono probabilistiche) non si può fare con ridondanza (no cloning). Quindi problema scalabilità.\nSe i qc hanno pochi qubit -> algoritmi distribuiti (orchestratori). Ma allora servono protocolli per scambiare qubit su una rete!\nProof of concept (?)\n\nStrategia Italiana per le Tecnologie Quantistiche\nEuropean Declaration of Q technologies\nMimit?\nMinistero università pubblica a febbraio documento per mappare ricerca scientifica quantum in industrie\nFinanziamenti quantum sono pnrr, quindi… perseguibilità progetti? Tocca affrontare il problema.\nStanno (vogliono…) stimolando investimenti privati e collaborazione pubblico-privato\nSe ho capito bene vogliono sfruttare qc per attrarre “talenti e capitale”. Ci puntano? Capire.\nPrevisto “quantum europe act” entro fine anno\n\nL’europa è indietro nel trasferire la teoria all’industria. L’italia prima manco aveva una strategia. “Però dai oh, se stamo a da na mossa”. \nCitano diverse volte il timore per la sicurezza nazionale (quelli dei ministeri)\nSensing-comunicazione (quantistici? Non ho capito)\nA parole dice che puntano su QC per far tornare i talenti. Sarà vero? E in caso, funzionerà?\n“A fronte di offerta che cresce, manca la domanda”, dicono le imprese.\n“Le tecnologie quantistiche non si possono affrontare a livello d’italia, ma d’europa” (i.e. non ce la facciamo da soli)\n\nCineca: HPC alla portata di tutti, ed è così che approcciano il QC. QPU (Quantum Processing Unit)\nCome oggi i pc hanno codice che gira sulle gpu, deve accadere per le qpu. Pasqal. Loro stanno scrivendo le librerie per far programmare un po’ tutti, da 7 anni.\nL’italia non ha startup per la costruzione di QC (in europa e nel mondo ci sono). \nAl momento in europa una dozzina di computer quantistici, diversi (ioni, spin, … Non sappiamo quale sia meglio ad oggi! Test in corso. Diversi hw potrebbero essere ottimizzati per diversi task).\nE comunque l’idea è appunto fare sistemi ibridi HPC-QC (tipo gpu affianco alla cpu)\nCineca sta installando due QC. Uno a bologna (superconductive, IQM, 54qbits) e uno “simulatore analogico” (nel senso che non viene programmato con i gate? Sembra più sul fisico che sull’informatico, la qpu è ad “atomi freddi”, vedi proprio l’evoluzione temporale del sistema, orion beta)\n\nFederico Mattei (IBM Quantum)\nC’è il dipartimento di QC, nel 2016 esce il primo QC. M vogliamo farlo usare a tutti. Due fronti aperti: HW funzionante e algoritmi (ne conosciamo pochi!). Oggi siamo lontani (ma non lontanissimi) da un QC fault-tolerant (error correction perfetto), ma abbiamo meccanismi di error mitigation accettabili (fanno meglio dei computer classici). Obiettivi: dimostrare il quantum advantage (i.e. HPC+QC fanno meglio di HPC da solo su certi problemi, previsto 2026) e realizzare QC fault-tolerant (2029). Hanno fatto una roadmap.\nQiskit sviluppato da ibm ma reso open source.\n10 minuti di computazione al mese gratis per studenti. “Noi da soli non ce la facciamo”. Qistkit functions una specie di app store, chiunque può realizzare app e metterle a disposizione (e.g algorithmic). Stanno installando QC per conto di varie nazioni nel mondo.\n“Quando girerà shor? Qualcuno dice 2030, altri 2035, vedremo”. Se succede rompe tutto. Come si risolve? Entanglement, post quantum crypto (problemi NP anche per QC)\nIl problema serio di post quantum non è tanto trovare gli algoritmi, ma la migrazione dalla vecchia crypto alla nuova (vai a capire quali pezzi di hw e sw contengono rsa). Infatti per questo vorremmo d’ora in poi fare le cose più trasparenti e modulari per poter cambiare algoritmi in modo semplice. Vorremmo far migrare le cose importanti entro il 2030. \n“Noi cercheremo di tenerlo open source, dopodiché IBM è USA e se ci dicono di secretare tutto per vincere la gara quantum contro la Cina…”\n\n\nCorbelletto (Intesa San Paolo)\nBanche si interessano perché settore con valore altissimo e si sta iniziando ad investire. (Parla anche lui di quantum sensing e communication)\nSi stima che entro il 2040 un quarto di circa due trilioni di dollari di valore prodotto da QC impatterà sulla finanza.\nChiede che la BCE regolamenti QC prima che questi diventino operativi (il contrario di quello che è successo con l’AI).\nCash pooling? Lo cita come problema di ottimizzazione? Me sa de si\nBanca fa continuamente monte carlo per indicatori di rischio, pricing strumenti finanziari, stress test scenarios. Banalmente il QC qui serve come generatore di numeri casuali (sì?)\nQuantum ML\nÈ top 3 a livello mondiale per applicazioni quantum alla finanza (seconda solo a JPMorgan)\nClassiq\nQuantum singular value transformation (gli è servita per mitigare gli errori?)\nIl PNRR è in scadenza\nTransizione per loro entro 2030 (consigliata) e 2035 (obbligatoria). Il problema non è tanto l’algoritmo, di nuovo. Magari facciamo quantumcybersec as a sservice, quindi evitiamo di cambiare tutto lhw\n\nGiancarlo sudano Microsoft\nGennaio: chip Majorana 1. Microsoft unica azienda (a parte università) a portare avanti i qubit topologici. L’idea è che la decoerenza è difficilissima da evitare. Da qui cerco l’error correction sw, questo è hw. Se funziona è 2-4 ordini di grandezza più stabile.\nNelle implementazioni attuali l’informazione è molto localizzata, e anche solo un neutrino che passa riesce ad estrala. Se uso la topologia, l’informazione è distribuita (ie quanti buchi ha una superficie necessita di esplorare tutto) per cui un’interferenza passa ma non riesce ad estrarre informazione. Quindi, sfruttiamo il famoso fermione di Majorana (ne abbiamo visto gli effetti in modo indiretto tipo, informati, 2018-2023). Long story short, hanno dimostrato che si possono sfruttare per le computazioni. Questa roba dovrebbe scalare molto bene, al momento il chip ha 8 qbit ed èproof of concept. Hanno creato un nuovo stato della materia, ma non riescono a controllarlo. Vedi se trovi le sue slides e trovare il tetron. I punti rossi sono stati che rispondono alla statistica non abeliana. La computazione avviene tramite braiding ie un intreccio di topologie (ad ogni pattern grafico corrisponde un quantum gate). Questo realizza feult tolerance sull’hw. Pensano sia scalabile, ottimisticamente parla di nuova legge di moore.\nParla di articolo in cui si dimostra che il boost deve essere più che quadratico, sennò non vale la pena. Tante cose non valgono la pena, restano buone chimica e scienza dei materiali (tipo, Quantum ML richiede troppo I/O  rispetto a hw crio). Tipo, ferrodoxina per fare la fotosintesi ancora non sappiamo usarla, o anche quella per fare fertilizzanti. Sono progetti a 20 anni per saltare avanti di 250.\n\nMezzo milione di qubit per fare chimica, uno per rompere rsa 2048\n\n\nCatalina Curceanu INFN\nBiologia quantistica per studiare il cervello (“potrei parlarne per ore”)\n\nPolitecnico di Milano\nGià, ma in Italia oggi? \nICSC finanziato con PNRR fino a 2025. Fanno PhD e post doc, Sapienza è socio, ma anche aziende. Spoke10 (coordinato da Milano, Padova) è QC.\nAlleanza Quantistica Italiana nata luglio 2025\nQuantum Computing Communication Observatory, ingegneri gestionali del PoliMI.\n“Su AI e Cloud l’europa ha perso, so tutti americani, qui se ce la giochiamo bene magari possiamo vincere”\n\n\nFrancesco Tafuri Federico II\nHanno realizzato il primo quantum processor. Oggi basse temperature non sono troppo un problema. Tutta la struttura è un frigorifero che viene chiuso e messo sottovuoto. Se lo sono costruito da soli, “sappiamo fare tutto il processo, quindi siamo anche indipendenti”)\nGiunzione Josephson rende la quantistica macroscopica. Trasmone. (Solo per i superconduttivi?). L’effetto macroscopico èsulla fase, e con essa scrivo l’algoritmo quantistico.\nCioè hadamard ti da 50/50, ma questo in teoria. In pratica va calibrato.\nFerrotransmone\nIn italia non riusciamo a fare un intero processore, tocca appoggiarsi all’estero\nShading a IBM “il nostro funziona meglio”, giustamente ottimizzano tutto e non usano qbit a caso in giro. Se conosco la confusion matrix delle porte posso correggere meglio gli errori (credo)\nMegaride-Cineca\n\n\nMarco Barbieri Roma3\nqt.eu (vedi questo sito)\nE in teoria esiste la registrazione, sarebbe interessante questa roba che dice ma sono un po’ stanco (mixare misurazione e crittografia)\n“Le nuove frontiere sono a metà tra la fisica e la teoria dell’informazione”\n\n\nPoliTo\nHanno comprato un QC industriale qualche mese fa (primo industriale in italia). 5 qbit. 1 secondo di calcolo IBM costa 1,6$, loro stanno a 15 ore di utilizzo. Nel complesso 2,4Milioni €\nCamera bianca\nMette a disposizione degli studenti con Colab \nPer accedere in modo autenticato al QC devo ottenere un token (sia IBM che PoliTo fanno così). \n\nCollevecchio CDTI\nLegge le slides in modo anche un po’ imbarazzante \n\nMomento dottorandi\n\nDario Denora- veldhorst (sei palese di foggia zi)\nCon cosa si fa quantum computing?\nNegli ultimi 2 anni molti investimenti HW e molte innovazioni. \nParametri: Fedeltà (i.e. quanti errori faccio), connettività (i.e. architettura), clock, scalabilità, modularità (per ottenere milioni di qbit toccherà mettere insieme tanti chip e coordinarli). Diverse implementazioni hanno diversi pro e contro rispetto a queste metriche. Seguono implementazioni:\n\t⁃\tSuperconducting qubits\n\t⁃\tTrapped ions\n\t⁃\tNeutral atoms\n\t⁃\tIntegrated Photonic (che ovviamente non posso intrappolare, quindi veloci ma grandissime perdite\nDiversi HW probabilmente diverse cose ottimizzate\n\nMa perché così tante? Se ce ne fosse uno solo migliore? … non possiamo saperlo, abbiamo al più 1000 qubit, gli algoritmi seri ne richiedono milioni.\nCi piacciono molto però gli spin (o anche holes) qubits. \n\nAnche gli algoritmi più noti sono ancora oggi molto discussi.\nQuantum Supremacy\n\t⁃\tshor rompe rsa\n\t⁃\tGrover cerca meglio nei DB (vantaggio quadratico, ricorda che prima il tizio diceva che dobbiamo averne uno più che quadratico!!)\n\t⁃\tChimica e materiali (simulazioni, ma non è un algoritmo…)\n\t⁃\tFinanza (qui per tanti punti dice “not clear” sui potenziali vantaggi… da cui la domanda: vale la pena?)\n\t⁃\tML\n\nQuasi nessun programmatore quantistico conosce l’HW sottostante, mandano gli algoritmi a quelli che fanno HW e bon, sanno loro cosa farci\n\nStruttura ordinata nello spazio = cristallo\nStruttura ordinata nel tempo = cristallo temporale (con molta fantasia) e.g sistema quantistico fuori dall’equilibrio, difficile da simulare. E perché lo scrivo? Perché è un esempio di sinergia tra HPC e QC\n\nRosati (Roma3) - Quantum Internet\nGià oggi usiamo fibra e satelliti per trasportare qubits. QKD.\nI nodi di una fibra sono oggetti che rompono info quantistica (diventa classica) e poi la “rigenerano” (ma scusa, e il no cloning?)\nBlind quantum computing: collego diversi QC e faccio un sistema distribuito, ma con una sorta di federated learning in cui non condivido davvero i miei dati ma collaboro.\nProposto anche gps quantistico.\nComunque, servono protocolli per precisione, privacy e correttezza (nonché sicurezza rispetto ad attacchi anche potenti).\nBit commitment?\nI fotoni sono molto belli per fare ste cose, dice lui\n\n\nUltima relatrice (grazie a dio)\nSmartHPC-QC è un progrtto europeo in cui ogni paese si è preso un HW diverso e ha iniziato a giocare per capire quale HW è ottimizzato per quale task.\nQEC4QEA progetto per creare centri specialistici in europa. \n\nQuantum Annealer?","x":2937,"y":-5920,"width":1771,"height":3485},
		{"id":"93d0eb6efe630b00","type":"text","text":"# lec 23/09\n\nnielsen chuang come Sciarrino\n\nqiskit funziona sicuramente su QC di IBM, poi dipende (però stanno provando a renderlo più portabile no?)\nSiamo ancora allo stato in cui tocca conoscere l HW per programmare. Siamo in \"pre-assembly\"\n\nfattorizzazione e in generale problemi NP resi efficienti da QC ad oggi non sono $\\NPC$. sono pochi e spesso artificiali (non si incontrano davvero nella vita reale)\n\nerrori su una porta classica $\\sim$ uno ogni $10^{20}$ operazioni, su quantum gate è ogni $10^3$. \n\n\"se vuoi vedere errori su un pc classico lo porti in alta quota (radiazioni maggiori) e lo metti a calcolare roba per un bel po'\". In grandi DB le RAM sono error-corrected\n\nun quantum programming language è banalmente una descrizione del circuito. Non abbiamo ancora le astrazioni.\n\nVon Neumann ha dimostrato equivalenza tra le due formulazioni (fdo e matrici heisenberg) nel libro che dice lui\n\nQC - reversible turing machine?? vabbè tipo che finché non collassa tutto puoi recuperare le info\n\ngoogle 2019 \"dimostra\" quantum supremacy (trovano un problema artificiale NP adatto a un QC e ottengono risposta in poco, ma non verificano la soluzione perché ci metterebbe troppo su classico)\n\ndistinzione physical-logical qubits (dimostrano 800% improv ma con postselection)\n\nentangling zone \\sim CPU","x":4720,"y":2947,"width":894,"height":940},
		{"id":"ba27a18cb7f60fcf","type":"text","text":"# Lec 24/09\n\nIntroduzione sui numeri complessi partendo dall'estensione dei naturali agli interi, dagli interi ecc...\npoi vettori, matrici e roba simile.\n\n# Qubits\n\nFissato un input, un QC restituisce il risultato $i$ con probabilità $p_i$. In generale, a priori non è noto il set di probabilità $\\{p_i\\}$. Multiple run a parità di input permettono di ricostruire la pdf dei risultati.\nAlso, qualsiasi random number generator usa funzioni deterministiche. Sono robe difficilissime da calcolare, quindi ci sembrano casuali, ma in realtà sono pseudocasuali (ci sono un tot di test statistici per valutare la bontà della randomicità del generatore pseudorandom). Il collasso della fdo è random nel senso più puro del termine (as far as we know, poi vabbe bisognerebbe prendere una fdo con tutti i coefficienti uguali...).\n\nper dire che esce $\\ku$ \"con probabilità tot\" scrive $\\ku @$ tot\n\ndice che dopo il collasso a rigore non esce $\\ku$ ma $\\l\\ku$ e che a rigore c'è la fase che sì, non si osserva, ma in teoria c'è.\n\nla porta NOT si implementa come matrice di pauli $\\s_x$\n$$\\paulix$$","x":4720,"y":4067,"width":894,"height":640},
		{"id":"80eef76e4b93f0bf","type":"text","text":"# Lec 30/09\n\nrappresentazione in coordinate polari della sfera di bloch (serve a qualcosa???)\n$$\n\\kps = \\a\\kz+\\b\\ku=\\cos{\\th\\over2}+e^{i\\f}\\sin{\\th\\over2}\\qquad\\th\\in[0,\\pi],\\quad\\f\\in[0,2\\pi]\n$$\n\n$(\\a_0\\quad\\a_1) \\otimes (\\b_0\\quad\\b_1) = \\at\\a_0\\b_0\\quad \\a_0\\b_1\\quad \\a_1\\b_0\\quad \\a_1\\b_1\\ct$ \n\n\ntipo 1/2 (00 01 10 11) lo fai con hadamard su entrambi (separati? ma l'entanglement?)\n\nlui dice che in uno stato entangled misurare un qubit \"cambia\" lo stato dell'altro. non so se sono d'accordo, mi puzza di variabili nascoste...\n\nl'informazione è non-locale, i.e. a t fissato ha una distribuzione non-puntiforme nello spaziotempo. cioè lo spaziotempo e l'informazione sono la stessa cosa?\n\n# Lec 1/10\n\nper rendere invertibile CNOT dovrei aggiungere $a$ all'output, però no-cloning? no ok si può fare senza misure costruendo direttamente l'operatore. unitarity $\\so$ linearity\n\nsi può ottenere una coppia entangled con una hadamard + una cnot:\n\n- prendi $\\kz$ e gli applichi hadamard, andando in ${1\\over\\sqrt2}(\\kz+\\ku)=\\kp$;\n- prendi questo output insieme a un $\\ku$ e gli applichi CNOT, ottenendo (algebra) ${1\\over\\sqrt2}(\\ket{01}+\\ket{10})$\n\nl'autostato di CNOT è ${1\\over2}(\\ket{00}+\\ket{01}+\\ket{10}+\\ket{11})$\n\nscriviti un riquadro per verifica entaglement (generico stato a 2 qubit, forse eviterei di andare oltre) cioè se ho $\\a_{00}$ posso trasformarlo in $\\a_0\\b_0$ ecc tali che $|\\a_0|^2+|\\b|^2=1$ (e analogo con $_2$)\n\ndi norma i QC partono con tutti i qubits =$\\kz$ (tanto poi posso fare NOT)\n\ninvece di considerare due singole operazioni unitarie (gates) su due diversi qubit, posso considerarne l'effetto sullo stato prodotto tensore eseguendo il prodotto tensore dei gates. Esempio: partiamo da $\\kz$ e $\\kz$, applichiamo H e otteniamo $\\kp$ e $\\kp$, che fatti a prodotto tensore sarebbe $\\kp\\kp$. ora vogliamo costruire un operatore che applicato a $\\kz\\kz$ restituisca direttamente $\\kp\\kp$. Basta fare il prodotto tensore degli operatori H. long story short, la roba alla fine delle slides multiple qubits.$$H\\otimes H=ecc$$\nobv le dimensioni dello stato prodotto tensore crescono come $2^n$, quindi gli operatori $2^{2n}$.\n\n\ndimostra no cloning definendo $\\exists y\\forall x\\quad CP(X\\otimes Y)=X\\otimes X$ e trovando che CP non è lineare (contraddizione, deve essere unitario quindi lineare).\n\nquantum repeaters fanno imperfect cloning, ma come? dal collasso di un singolo qubit non ricavi un solo bit di informazione??\n\nsegue implementazione del teletrasporto con i quantum circuits\n\nqiskit\n\n- transpile è una sorta di compilatore\n- shots sono le run (è sempre tutto probabilistico)\n- l'unità immaginaria la indica con $j$ (maledetti ingegneri)\n\n\"try to implement teleportation without looking at my code\"\n\n::: BUCO ::: (Grande ripassone di matematica)\n\n# L 15/10\n\nla parte delle proprietà dei prodotti tensore guardatela, probabilmente i circuiti quantistici richiedono molta manipolazione algebrica co sta roba.","x":4720,"y":4854,"width":894,"height":1793},
		{"id":"517359f852524057","type":"text","text":"# Una roba pazzesca\n\nPresa da Quantum Computing Since Democritus\n\nSe lancio una moneta, ci sono solo due eventi possibili: o esce testa o esce croce. Che sia bilanciata o meno, posso assegnare delle probabilità, diciamo p e 1-p. Perché sono contento di questa affermazione? Perché da teorema della probabilità totale sappiamo che la somma delle probabilità deve fare 1 (i.e. dare il 100%). Da questo generalizziamo ai vettori di probabilità i cui numeri sommano a 1, e costruiamo tutta una teoria per la quale tali vettori sono chiusi rispetto a particolari operazioni, rappresentate da matrici stocastiche.\n\nOra, basterebbe poco per cambiare tutto. Se definissimo un vettore di probabilità i cui moduli quadri sommano a 1? Visto che le probabilità classiche sono positive, di fatto quella di prima è una norma-1. E se usassimo la norma-2? Troveremmo che i vettori possono avere coefficienti complessi, e che sono chiusi rispetto a operazioni rappresentate da matrici unitarie (una matrice unitaria che ha solo elementi reali si chiama ortogonale). Ci ricorda qualcosa?\n\n***Prendere la teoria classica della probabilità e sostituire la 1-norma con la 2-norma per scrivere la condizione di chiusura restituisce la meccanica quantistica.***\n\nQuesta roba è fuori di testa, e seguono mie speculazioni.\n\nSiamo abituati a pensare al mondo reale, proprio nel senso di $\\R$, ed è in questo senso che siamo abituati a pensare agli osservabili fisici, che infatti sono operatori hermitiani (autovalori reali). I quantum gates, l'evoluzione temporale hamiltoniana, le misure di bell... sono tutti operatori unitari, i.e. autovalori complessi. Questi ultimi non fanno collassare la fdo (i.e. perdita d'informazione quantistica), mentre gli hermitiani sì. Non è ovvio? L'hermitiano proietta l'informazione complesse sul sottospazio dell'informazione reale. L'unitario parla la stessa lingua dell'informazione quantistica: $\\C$. e poi sì ok non cambia la norma, ma non credo sia quello il punto. Il punto è un altro:","x":6057,"y":3137,"width":824,"height":840},
		{"id":"c6b38e6488c8dfb0","type":"text","text":"Quantum mechanics is a beautiful generalization of the laws of\nprobability: a generalization based on the 2-norm rather than the\n1-norm, and on complex numbers rather than nonnegative real\nnumbers. It can be studied completely separately from its appli-\ncations to physics (and indeed, doing so provides a good starting\npoint for learning the physical applications later). This general-\nized probability theory leads naturally to a new model of compu-\ntation – the quantum computing model – that challenges ideas\nabout computation once considered a priori, and that theoretical\ncomputer scientists might have been driven to invent for their\nown purposes, even if there were no relation to physics. In short,\nwhile quantum mechanics was invented a century ago to solve\ntechnical problems in physics, today it can be fruitfully explained\nfrom an extremely different perspective: as part of the history of\nideas, in math, logic, computation, and philosophy, about the\nlimits of the knowable.\n\nquantum mechanics is the\noperating system that other physical theories run on as application\nsoftware (with the exception of general relativity, which hasn’t yet\nbeen successfully ported to this particular OS). There’s even a word\nfor taking a physical theory and porting it to this OS: “to quantize.”","x":6057,"y":4057,"width":824,"height":825},
		{"id":"8f87c8780cb1599e","type":"text","text":"# Dizionario degli Operatori","x":3480,"y":4387,"width":718,"height":762},
		{"id":"1e496a5d9be311e3","type":"text","text":"# Quantum Crypto\n\nQKD slides 12 + fine slides 13","x":8560,"y":5537,"width":791,"height":428},
		{"id":"ee63e9dbb3cb9eb6","type":"text","text":"\n\n#### Finding a needle in a haystack (1996)\n\nricerca di un elemento in array non ordinato, classicamente $O(N)$ (o per essere precisi $O({N\\over M})$ se ci sono $M$ soluzioni), diventa $O(\\sqrt{N\\over M})$. (parentesi, forse il tipo che alla conferenza diceva che ci serve uno speedup più che quadratico intendeva che l'error correction si mangia tutto lo speedup quadratico? o cosa?)\n\nDefiniamo una funzione sul dominio degli elementi dell'array ad un bit:$$f:\\{0,.., N-1\\}\\to\\calB\\quad:\\quad f(x)=1 \\text{ sse } A[x] \\text{ è soluzione, 0 altrimenti}$$\nDobbiamo costruire un oracle in questo modo:$$U_f\\kx\\otimes\\ky=\\kx\\otimes\\ket{y\\oplus f(x)}$$\ndove $x\\in\\calB^n$ e $y\\in\\calB$ come con Deutsch(-Jozsa?), e nello stesso modo valutiamo$$U_f\\kx\\otimes\\AT{\\kz-\\ku\\over\\sqrt2}\\CT=(-1)^{f(x)}\\,\\,\\kx\\otimes\\AT{\\kz-\\ku\\over\\sqrt2}\\CT$$\nVisto che non ha effetto su (questo?) $y$ ci riduciamo a$$O_f\\kx=(-1)^{f(x)}\\,\\,\\kx$$\nCircuito sulle slides, con G in cascata. Serve un secondo input, che chiamiamo ancilla (sta cosa c'era pure in computer science classica ve?). Sputa un array N-dimensionale in cui ho evidenziato le soluzioni con alta probabilità. ... in che senso? Scomponiamo il generico stato $\\psi$ nei suoi vettori di base $\\kx$ e definiamo roba di statistica:$$\\psi=\\sum\\a_x\\kx\\quad \\braket{a}= {1\\over N}\\sum\\a_x\\quad W\\kx = (-\\a_x+2\\braket{a})\\kx$$\nA questo punto definiamo $G=W\\cdot O_f$ (ma \\cdot è un \\otimes???) , dove sia W che G sono unitari. Non è sempre semplice implementare tutti questi operatori (se lo fosse, risolveremmo P=NP, dice lui). Quindi, usciti da H^n abbiamo\n\n$$\\calH^{\\otimes n}\\kx={1\\over\\sqrt{2^n}}\\sum_{a\\in\\calB^n}(-1)^{x\\cdot a}\\ka$$\nL'idea è fare phase flip delle soluzioni e poi aumentare l'ampiezza delle sole soluzioni (quelle con fase flippata).\n- La media $<\\a>$ è $1\\over \\sqrt N$;\n- Applico $O_f$ e flippo la fase, che ora ha un segno meno;\n- La media si abbassa\n- Applico $W$ che alza l'ampiezza dello stato flippato e abbassa gli altri;\n- Nel complesso ho applicato G, posso farlo quante volte voglio e continuare ad evidenziare le ampiezze degli stati soluzione.\n\nPosso farlo ad libitum? non proprio. Conviene farlo $O(\\sqrt{N\\over M})$ volte, poi inizio a decrementare la probabilità di soluzione (perché???).\n\nPer capire meglio come funziona dobbiamo cambiare base. Ipotizziamo set $S$ non-vuoto degli indici soluzione. Sia $|S|=M$. La nuova base è prevedibilmente scissa tra stati soluzione e stati non soluzione:$$\\ka={1\\over\\sqrt{N-M}}\\sum_{x\\in\\overline{S}}\\kx\\qquad\\kb={1\\over\\sqrt{M}}\\sum_{x\\in S}\\kx$$\nQuindi posso scrivere il generico stato a N qubit come combinazione di questi due stati:\n\n$${1\\over\\sqrt N}\\sum_{x\\in\\calB^N}\\kx={\\sqrt{N-M\\over N}}\\ka+{\\sqrt{M\\over N}}\\kb$$\na questo punto l'oracle flippa la fase delle sole soluzioni:$$O_f\\kps = O_f\\AT\\l_a\\ka+\\l_b\\kb\\CT=\\l_a\\ka-\\l_b\\kb$$\ne ovviamente se lo riapplico torno indietro. quel commento di prima che non trovo su P=NP: stiamo valutando la complessità solo in numero di accessi, non stiamo dicendo nulla su quanto è difficile implementare l'oracle.\n\n\"il set S non è dato, la soluzione è implementata nella funzione f(x) dell'oracle\"\n\npossiamo scrivere l'azione di W come (verifica)$$W=2\\calP_\\psi-\\calI=2\\ketbra{\\psi}{\\psi} - \\calI$$e definire $\\calG$ come$$\\calG=\\calW\\cdot\\calO_f$$\nOra, nello spazio $\\ka$ vs $\\kb$ il vettore di $\\psi$ sarà molto vicino a $\\ka$ (i.e. tutti i coefficienti pesano uguale e ci sono più non-soluzioni che soluzioni). L'obiettivo è ruotare $\\kps$ verso $\\kb$. Come? Posso scrivere $\\calI$ come $\\calP_\\psi+\\calP_\\psi^\\perp$ so$$W=\\calP_\\psi-\\calP_\\psi^\\perp$$che è una anti-clockwise rotation. Se lo facciamo troppo, scavalliamo $\\kb$ e iniziamo a tornare indietro. Qual è il limite? Troviamo l'angolo di ogni rotazione. Chiamiamo quello di partenza, i.e. l'angolo inizialmente tra $\\kps$ e $\\ka$, come $\\th/2$, quindi$$\\cos\\th/2=\\sqrt{N-M\\over N} \\quad \\sin\\th/2=\\sqrt{M\\over N}\\quad\\so\\quad\\kps=\\cos\\th/2\\ka+\\sin\\th/2\\kb$$\nVisto che la fase flippa, G ruota di un angolo $\\th$. Segue che$$G\\kps=\\cos3\\th/2\\ka+\\sin3\\th/2\\kb\\quad\\so\\quad G^k\\kps=\\cos(2k+1)\\th/2\\ka+\\sin(2k+1)\\th/2\\kb$$\n\"it's like cooking a souffle, you have to know where to stop\". Quindi dove$$\\sin(2k+1)\\th/2\\sim1\\so(2k+1)\\th/2=\\pi/2\\so k={{\\pi\\over\\th}-1\\over2}\\sim$$\n\ntroviamo le soluzioni con almeno il 50% con $k=\\floor{(cos^-1\\sqrt{M/N}))}$, (that's what grover did) ma possiamo fare meglio. Se assumiamo $M\\le N/2$.... conti sulle slides. we get rid of this condition by adding 1 qubit (doubles $\\a$ parameters of wavefunction)\n\nnota che per calcolare $<\\a>$ avrei bisogno di misurare tutte le ampiezze. esiste un modo di farlo senza misure con una stack of hadamards. Classically non è per niente efficient, perché devi misurare tutto (numero exp di coefficienti)\n\n\nPartiamo da $\\ket{00}$, applichiamo $H\\otimes H$ e otteniamo tutti i ket di base con prob omogenea 1/2. $O_f$ mi flippa solo il coefficiente di $\\ket{11}$ e W mi restituisce {0,0,0,1}. Quindi trovo soluzione con prob 1. Se riapplico $O_f$ ora la media è -1/4 e ottengo -1/2{1,1,1,-1}. Sono (quasi) tornato al punto di partenza: i moduli quadri sono tutti uguali. Cosa l'ha detto a fare? non ho capito\n\nsunto: se conosci M puoi cercare quadratically faster \n#### Versione un po' migliorata in cui ogni iterazione tende asintoticamente a $\\kb$ (2005)\n\nFixed-Point Quantum Search\n\n$$R_s=\\calI-[1-e^{i\\th}]\\ketbra{s}{s}\\quad  R_t=\\calI-[1-e^{i\\th}]\\ketbra{t}{t}$$phase shift operators dove poniamo $\\th=\\pi/3$ perché.... sì. Dai calcoli risulta comodo. Dato un qualsiasi operatore unitario $U$ che soddisfa $\\big|\\scalar{t}{U_s}\\big|=1-\\e$ dove per $U_s$ si intende U applicato ad S (i.e. l'azione di U su s è renderlo arbitariamente vicino a $\\ket{t}$). My claim is that for such U we have $U R_s U^\\dagger R_t U \\ket{s}$ is $(1-\\e^3)$-close to $t$.\n\nCome applichiamo tutto ciò a Grover? Costruiamo ricorsivamente\n$$U_0=U\\quad...\\quad U_{m+1}=U_mR_sU_m^\\dagger R_tU_m$$ogni iterazione mi avvicino di un fattore cubico. $U_m\\ket{s}$ is $(1-\\e^{3m})$-close to t.\n\nSto comunque chiamando l'oracle applicando R_s ed R_t. Il punto però è che mi avvicino monotono alla soluzione perfetta facendo un gran numero di chiamate all'oracle, il che mi fa perdere lo speedup quadratico. Nel 2014 dei tizi hanno modificato sta roba per non perdere questo speedup quadratico (\"ma non l'ho ancora letto invero, è moolto più complicato).","x":1400,"y":10001,"width":894,"height":2780},
		{"id":"e5c36828b7ed4e4b","type":"text","text":"# oracle algorithms\n\nare classical!!! Devi capire come funzionano","x":6007,"y":8080,"width":718,"height":593},
		{"id":"d58a31e40457558d","type":"text","text":"Qiskit\n\ncreate an environment in anaconda\n\nibm quantum platform (free trial?)\n\nquando arrivo alla variabile \"isa_circuit\" è dove entrano le differenze HW (?)\n\nin simSampler simula in locale\nin qSampler si connette a runtime del QC IBM e gli escono picchi 11 00 ancora più alti (non dovrebbero proprio esserci, sono rumore).\n\n\"un vero qc è molto più noisy. qui non c'è error correction, le macchine vanno ricalibrate ogni paio d'ore, soprattutto con tempeste (campi elettrici più forti)\"","x":6165,"y":8809,"width":431,"height":460},
		{"id":"9a818c9d0af1bf6a","type":"text","text":"# Protocolli Entanglement & Non-Locality\n\n- non-locality slides 13 (che iniziano con delle considerazioni sulla misura, non so bene quale sia il nesso con Bell)\n$$H\\kz=\\kp\\qquad H\\ku=\\km\\qquad\\text{ Hadamard è una riflessione rispetto alla retta m=}\\pi/8$$\n\nassumiamo che la fdo dello stato entangled sia $\\psi$.\n\n$$\\E[QS]=\\scalar{\\psi}{QS\\psi}$$\nDefinizioni di S, T come funzioni di Z, X: questa violazione si ha solo per quella determinata scelta di osservabili? forse sì ma va bene\n\nPoi dimostra che quei valori attesi vengono $1/\\sqrt2$  ma c'è qualcosa che non mi torna. Abbiamo definito X e Z??\n\ntype systems?? Askell?\n\nSILQ linguaggio di più alto livello, fastest simulator for QC. cerca roba a riguardo.\n\n- type system using annotation. eh? puoi avere types per altre cose oltre che per i data type (int, float, ...). `C` lo fa ma in modo abbastanza free  (in che senso? guarda che si lamenta se sbagli il tipo...). Ok, di base è quello che fai in `C` con `typedef`, e fa il controllo su quello che definisci. Anche le funzioni sono trattate come oggetti con un tipo. Qiskit non lo fa (\"there's only one type there, and it's quantum wire...\")\n- automatic un-computation of classical subroutines - eh? tipo Grover ha un oracle che dato un indice ti dice se l'elemento contenuto a quell'indice è soluzione o no. $$O_f\\kx=(-1)^{f(x)}\\,\\,\\kx$$dove $f(x)$ è una roba classica che si deve comportare in modo unitario. Il punto è che i calcoli possono produrre entanglement non richiesti. dopo che ho usato f(x) posso un-computarla (i.e. fare il gate al contrario). Che ci faccio? ... non ho capito!","x":2040,"y":5330,"width":824,"height":841},
		{"id":"1a71e8cdf224bc63","x":500,"y":10001,"width":671,"height":899,"type":"text","text":"# 19/11\n\nAggiunte a grover\n\nprima cosa: dovrei conoscere M per sapere quante iterazioni fare. Secondo: e se M=0?\n\nDevo intanto contare le soluzioni, che è un po' come fare l'integrale.\n\nDice che si può fare con i seguenti step logici: G contiene dentro \\theta il valore M, posso fare phase estimation per risalire a M.\n\n- Ma scusa come fai a definire G se non sai M?? G è definito a partire dall'oracolo, che però assume di sapere M.\n\n"}
	],
	"edges":[
		{"id":"61bd5634454aac56","fromNode":"743ef9a469fb22bb","fromSide":"top","toNode":"e6c41c8e2e350d7c","toSide":"bottom"},
		{"id":"0d39e1eeaf8ec001","fromNode":"743ef9a469fb22bb","fromSide":"bottom","toNode":"133cd6df233bcfec","toSide":"top"},
		{"id":"c5048beece8c6f92","fromNode":"e2db50131cd84590","fromSide":"right","toNode":"133cd6df233bcfec","toSide":"left"},
		{"id":"de6d61ec626fd032","fromNode":"133cd6df233bcfec","fromSide":"bottom","toNode":"51ba04bfd72f3571","toSide":"top"},
		{"id":"9543499a7322a61a","fromNode":"133cd6df233bcfec","fromSide":"right","toNode":"2acc7bcd96aff60e","toSide":"left"},
		{"id":"6413f7e3b0f0389b","fromNode":"e2db50131cd84590","fromSide":"bottom","toNode":"e6e020dbb57ef986","toSide":"top"},
		{"id":"48aba5cb3adeb952","fromNode":"8f7ea773adcc0343","fromSide":"bottom","toNode":"1ba94a12349094a8","toSide":"top"},
		{"id":"a9b8ed9e9afa76bd","fromNode":"e2db50131cd84590","fromSide":"left","toNode":"765ef5312171995a","toSide":"right"},
		{"id":"f8fd16edb102a301","fromNode":"e6e020dbb57ef986","fromSide":"bottom","toNode":"8f7ea773adcc0343","toSide":"top"},
		{"id":"799010b15902d27f","fromNode":"8f7ea773adcc0343","fromSide":"right","toNode":"121c1b6063127d40","toSide":"left"},
		{"id":"92b09889672012cf","fromNode":"1ba94a12349094a8","fromSide":"right","toNode":"4a4c03afbff3bf2a","toSide":"left"},
		{"id":"a2bc34477c81eba3","fromNode":"121c1b6063127d40","fromSide":"bottom","toNode":"4a4c03afbff3bf2a","toSide":"top"},
		{"id":"86fa7d978ac99ace","fromNode":"c4a9dc0e9aabfad3","fromSide":"left","toNode":"121c1b6063127d40","toSide":"top"},
		{"id":"7ddac251f4b1a158","fromNode":"4a4c03afbff3bf2a","fromSide":"bottom","toNode":"d93e311c7132bf29","toSide":"top"},
		{"id":"fd53b4ac8842d60d","fromNode":"80eef76e4b93f0bf","fromSide":"bottom","toNode":"03baf5c82939af36","toSide":"top"},
		{"id":"6ffe0b33cbce8d44","fromNode":"03baf5c82939af36","fromSide":"right","toNode":"56a070e72950f083","toSide":"left"},
		{"id":"f42933d4a3497768","fromNode":"ee63e9dbb3cb9eb6","fromSide":"left","toNode":"cbbfa8244737d93c","toSide":"right"},
		{"id":"ab9a286250de1564","fromNode":"ee63e9dbb3cb9eb6","fromSide":"bottom","toNode":"73649c6cd8fdf5d3","toSide":"top"},
		{"id":"acecb70906584427","fromNode":"03baf5c82939af36","fromSide":"bottom","toNode":"bdfa0971534eb41a","toSide":"top"},
		{"id":"911bd284b46d70fc","fromNode":"bdfa0971534eb41a","fromSide":"right","toNode":"28d7a388df752e23","toSide":"left"},
		{"id":"d33757288b4ed310","fromNode":"bdfa0971534eb41a","fromSide":"left","toNode":"17eb5ea6c2fb740c","toSide":"right"},
		{"id":"ae7b4c9a7019b22d","fromNode":"17eb5ea6c2fb740c","fromSide":"left","toNode":"ee63e9dbb3cb9eb6","toSide":"right"},
		{"id":"12feb9b02f099cb4","fromNode":"28d7a388df752e23","fromSide":"right","toNode":"396fd1bf9e36e927","toSide":"left"},
		{"id":"a5621d27aa4df846","fromNode":"396fd1bf9e36e927","fromSide":"bottom","toNode":"bea8002766d6b597","toSide":"top"},
		{"id":"0276561b26bdfe94","fromNode":"396fd1bf9e36e927","fromSide":"right","toNode":"0230e96a480e47fb","toSide":"left"},
		{"id":"6a08c28e5ead3c77","fromNode":"80eef76e4b93f0bf","fromSide":"right","toNode":"1e496a5d9be311e3","toSide":"left"},
		{"id":"3341268b5bca0b7f","fromNode":"80eef76e4b93f0bf","fromSide":"left","toNode":"9a818c9d0af1bf6a","toSide":"right"},
		{"id":"9e1e82de419f1619","fromNode":"28d7a388df752e23","fromSide":"bottom","toNode":"bea8002766d6b597","toSide":"top"},
		{"id":"b0ed646c42794364","fromNode":"03baf5c82939af36","fromSide":"top","toNode":"e5c36828b7ed4e4b","toSide":"left"},
		{"id":"a7cf7f12b5f39f78","fromNode":"ee63e9dbb3cb9eb6","fromSide":"left","toNode":"1a71e8cdf224bc63","toSide":"right"}
	]
}