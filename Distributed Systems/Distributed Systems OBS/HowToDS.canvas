{
	"nodes":[
		{"id":"fbc1ef28f3589012","x":-440,"y":-380,"width":640,"height":460,"type":"text","text":"Definizioni:\n\n- h_i history of process i = tutti gli eventi sulla sua timeline.\n- H = collezione delle storie\n- prefix of h_i sono i primi k eventi di h_i\n- local state = dopo k eventi, il processo i si trova nello stato $\\sigma_i^k$.\n- global state = collezione dei local states al tempo k\n- run k' = reordering of events such that internal order of every process il preserved. sono diverse sequenze di computazione.\n- Cut C is collection of prefix of every process. so it's a set of events. a process may not have events before the cut, it's alright\n\t- it is also a global state. for every C there is a GS\n- consistent cut = se e avviene prima di e' ed e' $\\in C$ allora $e\\in C$.\n\t- da cui segue la definizione di consistent run, ovvero una run in cui qualsiasi C è consistente"},
		{"id":"e6fd42bc1097166e","x":-940,"y":-380,"width":430,"height":540,"type":"text","text":"exam\n\nmidterm 3 esercizi (+ altro?)\n\nesempio ex\n\n$C_1$ e $C_2$ sono due CC. Show that $C_1\\cap C_2$ is consistent.\n\n$C_1\\cap C_2 \\subseteq C_1$, which is consistent.\n\ndevi usare la definizione per cui un consistent cut è \"se e precede e', ovvero $e \\to e'$ ecc...\n\nanche l'unione è consistente."},
		{"id":"eead1953cd38ffd8","x":-440,"y":140,"width":640,"height":1180,"type":"text","text":"# Lamport\n\nMettiamo processi da 0 a 3. Ogni volta che su un processo da 1 a 3 avviene un e, questo lo notifica a $p_0$, il quale può ricostruire la run (è un osservatore). visto che non so quanto ci mettono i singoli messaggi ad arrivare a p_o, potrei avere delle inconsistenze! Non solo potrebbe non essere consistente, ma potrebbe non essere nemmeno una run!! come risolvo? Con un canale FIFO! weak assumption, very easy to implement. ma questo canale è per ogni coppia $(i;0)$ non mi dice niente sull'ordine dei diversi processi. Quindi così è una run, ma non necessariamente consistente. what if i give you a global clock (aka Real Clock RC), assume every process can use it. very strong assumption, cause no god gives us a clock, but i can use it to build a consistent run.\n\ndiciamo che $\\delta$ è un upper bound per il tempo impiegato da ogni canale per deliverare il messaggio a p_0. Ogni messaggio ha un timestamp, e p_0 ha una finestra di osservazione larga $\\delta$. entro questa finestra ha un buffer in cui aspetta di essere sicuro di ricevere tutti i messaggi di quella finestra.\n\n(what if I let p_0 put things in timeline in whatever order and run a sorting algorithm on the window $\\delta$?   -A)\n\n$e\\to e' \\Rightarrow RC(e)<RC(e')$. **Clock condition**. Non serve RC, basta qualsiasi clock con questa proprietà. LA freccia non è al contrario! $e\\to e'$ implica una necessità di ordine, che non è necessaria per **eventi concorrenti** (segnati con una freccia sul grafico, i singoli punti sono eventi indipendenti)\n\nDefiniamo un sapienza clock SC local to every p. se $e_1^1\\to e_2^1$ e il primo ha timestamp 1, il secondo deve avere timestamp maggiore, quindi sarà 2. dopodiché procedo con gli eventi in ordine, finché 7 sulla linea 2 non manda un messaggio alla linea 1. a qualsiasi numero sono arrivato sulla linea 1, ricevere un messaggio da 2 deve avere timestamp maggiore sia della linea 2 che di quella 1.\n\n- se 1 era arrivata a 5, il massimo +1 è 8;\n- se era a 12, è 13.\n\nQuesta roba è il **Lamport (or logical) Clock**\n\nora, sul singolo canale FIFO sono sicuro di avere i timestamp in ordine. ma prima di aggiungere $e_2^3$ devo aspettare tutti gli eventi precedenti? Non proprio, solo quelli che precedono logicamente. vedi grafico. e come entra $\\delta$ in tutto questo? se ricevo $e_2^3$ con timestamp 4, allora devo aspettare tutti gli eventi degli altri processi con timestamp fino a 4. this might make me wait. e se p_3 non ha nessun evento per un bel po'? ...boh si è dimenticato?...\n\n"},
		{"id":"941a38f0264b5e2e","x":328,"y":140,"width":572,"height":923,"type":"text","text":"# Lamport vettoriale (vector clock)\n\nse ci sono eventi concorrenti (quindi non c'è un ordine tra loro). i loro timestamp non possono essere numeri. allora posso modificare un po' la definizione dei timestamp, e renderli non numeri ma con la loro history. in questo modo$$e\\to e' \\Leftrightarrow TS(e)\\subseteq TS(e')$$\nin questo modo due eventi senza freccia sono semplicemente due eventi le cui storie non sono una un sottoinsieme dell'altra. ma la history di tutta la run! è un vettore. ad esempio, la timestamp di $e_2^3$ è $[1,4,2]$, ovvero il vettore dei lamport clock di ogni processo, così non pesa 5 terabyte dopo un'ora.\n\nvedi secondo grafico.\n\np_0 riceve $[141]$, quindi sa che deve ricevere prima una notifica da 1, 3 da 2 (ma di questo sono sicuro, perché il singolo canale è FIFO) e 1 da 3. nota che così non serve $\\delta$.\n\nvector clock usato nei DB distribuiti. così vediamo anche i deadlock (how?)"}
	],
	"edges":[
		{"id":"40550efc7af07698","fromNode":"fbc1ef28f3589012","fromSide":"bottom","toNode":"eead1953cd38ffd8","toSide":"top"},
		{"id":"e0e074485452ef04","fromNode":"eead1953cd38ffd8","fromSide":"right","toNode":"941a38f0264b5e2e","toSide":"left"}
	]
}