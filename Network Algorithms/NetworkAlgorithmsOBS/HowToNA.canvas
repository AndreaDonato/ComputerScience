{
	"nodes":[
		{"id":"d2544beca5412320","type":"text","text":"# Cabled Networks Algorithms\n\nUn algoritmo su rete cablata ***assume di conoscere i nodi e le relative interconnessioni***. Questo è tendenzialmente vero, ma non è un dogma.\n\n- Se lavoro con una ***rete Internet*** è possibile che un link si rompa o che un nodo vada offline;\n\t- Con \"rete Internet\" sto intendendo tutte quelle reti in cui i nodi sono router o computer e i link sono cavi Ethernet, quindi anche LAN e DB distribuiti;\n\t- È in questo caso che ci poniamo il ***routing problem*** e il ***minimum vertex cover problem***.\n- Se lavoro con una ***Network-on-Chip*** (***NoC***, i.e. un circuito stampato), il grafo è immutabile.\n\t- Diventa interessante studiare l'***interconnection topology*** più adatta al caso in esame.\n\nIl modello è ***store-and-forward*** + ***packet-switching***, in cui i dati sono divisi in pacchetti che vengono elaborati e poi inoltrati dal nodo, ed ***eventualmente*** messi in attesa in una ***queue***.\n\nEsistono modelli alternativi che rilassano la prima condizione (e.g. ***cut-through-switching***, in cui il nodo non attende l'intero pacchetto prima di inoltrarlo) o la seconda (e.g. ***circuit-switching***).","x":-490,"y":-3280,"width":840,"height":451,"color":"6"},
		{"id":"320fe254853146fb","type":"text","text":"# Layouts\n\nDefiniamo ***layout*** una ***orthogonal grid drawing*** di un grafo ***che prova a minimizzare l'area***, e più in generale che rispetta le condizioni del modello di Thompson.\n\nNella vasta letteratura sul disegno ortogonale dei grafi esistono algoritmi in grado di costruire una rappresentazione che rispetta il modello di Thompson dato un generico grafo in input. Questo modo di procedere ***non è ottimizzato***, in quanto non sfrutta le simmetrie delle IT note.\n\nViceversa, i ***layout algorithms*** si basano su una specifica IT, permettendo di sfruttarne le proprietà di simmetria. In questo contesto, infatti, i miglioramenti anche di \"solo\" un fattore costante sono significativi: dimezzare l'area significa dimezzare il costo.","x":-6800,"y":-2051,"width":820,"height":351,"color":"6"},
		{"id":"a357e03f7f1a5b24","type":"text","text":"# Network Algorithms (NA)\n\nI grafi i cui nodi sono dispositivi elettronici che scambiano informazioni mediante gli archi sono detti ***interconnection networks*** (***IN***).\n\nTrovare uno specifico nodo all'interno della rete, ottimizzare il traffico o l'energia dissipata sono compiti che richiedono l'utilizzo dei ***network algorithms***, i quali possono lavorare su particolari ***interconnection topologies*** (***IT***), i.e. disposizioni dei nodi e degli archi tali da ottenere specifiche proprietà che vengono sfruttate al meglio dall'algoritmo.","x":-370,"y":-1459,"width":600,"height":287,"color":"6"},
		{"id":"846dce13513dafd6","type":"text","text":"# Costi degli Archi e Tipologie di Algoritmi di Routing\n\nI ***costi*** degli archi possono essere\n\n- ***statici*** (e.g. tutti i costi sono `1`), da cui nascono gli algoritmi di ***non-adaptive routing*** che si traducono in problemi di ***shortest path*** (i.e. i percorsi vengono calcolati *once and for all*);\n- ***dinamici*** (e.g. il costo rappresenta il livello di saturazione del link, i.e. il traffico, o la probabilità che questo si rompa), da cui nascono i problemi di ***least cost path*** gestiti da algoritmi di ***adaptive routing***.\n\t- Ovviamente il primo è un caso particolare del secondo. Le situazioni reali rientrano spesso nel secondo caso, ma possono esistere algoritmi che alternano questi due approcci (***half-adaptive routing***) per ridurre complessità ed overhead;\n\t- Ad ogni modifica dei costi o ad ogni timeout di un timer, l'algoritmo dinamico ricalcola i percorsi;\n\t- Nota che il costo può anche rappresentare un link che si rompe (e.g. $\\infty$). Ci si può riferire ad un algoritmo che tiene conto di questo problema come algoritmo di ***fault-sensitive routing***.\n","x":-1615,"y":-5767,"width":910,"height":393,"color":"4"},
		{"id":"d27672ae4c020959","type":"file","file":"Cabled Networks/Layouts/NotSoWise.png","x":-9007,"y":-1000,"width":400,"height":354},
		{"id":"0a98e240f74a5ea3","type":"text","text":"# Wise Layout\n\nÈ una griglia ruotata di $45\\degree$ in cui la distanza tra due <span style=\"color:#00b050\">layer logici</span> cresce in modo esponenziale. Il fatto che sia piena di incroci non deve spaventare: i due insiemi di linee parallele (i.e. le rosse e le nere) si trovano su due diversi <span style=\"color:#cd0a0a\">layer fisici</span> (è infatti un 2-<span style=\"color:#cd0a0a\">layer</span> layout).\n\nL'idea è quella di implementare una BN, ma presenta diversi problemi.\n\n- Ogni quadratino blu è un ulteriore interruttore multistadio (in più oltre ai nodi), necessario per impedire ai segnali di uscire dalla board o di finire nel nodo sbagliato;\n- Rispetto ad una BN, l'ordine dei nodi è diverso (guarda i quadratini blu al centro);\n- Ovviamente ha le linee oblique, ma tra loro sono ortogonali.\n\nDi buono c'è che\n\n- Ha una buona area, essendo $2n^2+o(n^2)$;\n\t- Gli haters dicono che se applichiamo la definizione standard di area (i.e. con le linee dritte) viene $4n^4 + o(n^2)$. Ma non c'ha già abbastanza problemi sto layout? Lasciatelo in pace...\n- Tutti i fili tra <span style=\"color:#00b050\">layer</span> adiacenti hanno la stessa lunghezza;\n- I <span style=\"color:#00b050\">layer</span> di input ed output sono automaticamente sui bordi.\n\n<span style=\"color:#FFA500\"> Non capisco la logica dei colori delle linee nel grafico sotto. Cioè, ok il mapping, ma è solo per farmelo vedere?</span>","x":-8440,"y":-1000,"width":820,"height":559,"color":"4"},
		{"id":"3408dbb01038ad25","type":"file","file":"Cabled Networks/Layouts/ConfusingWiseButterfly.png","x":-9007,"y":-564,"width":399,"height":123},
		{"id":"3631eb3da23e034b","type":"text","text":"# Loop - Costi Negativi\n\nIl fatto che esista un collegamento da i nodi $u$ e $v$ non garantisce che questo si riesca a trovare con un algoritmo di least cost path. Perché? Perché esistono i ***costi negativi***, che possono portare a ***cicli negativi*** che bloccano un algoritmo di ottimizzazione in un loop infinito.\n\n- Abbiamo nodi `A`, `B` `C` e `D` in cui i costi sono `AB`$=5$, `AC`$=1$, `CD`$=-10$, `DA`$=6$. È chiaro che se parto da `A` e voglio arrivare a `B` l'unico cammino fattibile è l'arco `AB` di costo $5$. Ma cosa potrebbe vedere un algoritmo di LCP? `C` pubblicizza un LCP verso `B` che costa $-10+6+5 = 1$ passando per `CDAB`. `A` vede questo costo e dice una cosa del tipo `uhm, se lo mando a C posso raggiungere B con un costo 1 + 1 = 2, che è meglio del mio attuale costo 5`, quindi modifica la rotta: `quando mi arriva un pacchetto diretto a B devo mandarlo a C`. `D` vede `C` pubblicare un costo verso `B` pari a `2`, e pensa `-10 + 2 = -8 è meglio del mio costo 11, manderò a C ogni pacchetto diretto a B`. Senza farla lunga, non se ne esce a meno di prendere delle contromisure che questo algoritmo per come l'ho descritto evidentemente non ha.\n\nBene, perché esistono? Sono utili, in determinate circostanze (e non entriamo nel dettaglio, perché tanto questo corso li ignora). Come li gestisco? Ho due alternative.\n\n- Li vieto e uso algoritmi più semplici;\n- Li permetto, ma l'algoritmo deve essere in grado di rompere il loop (e.g. numero massimo di hop).","x":-1615,"y":-6386,"width":910,"height":514,"color":"4"},
		{"id":"d4f9095c56d98baf","type":"text","text":"# Routing Problem\n\nGestisco il traffico con algoritmi dinamici che tengono conto delle modifiche dei costi degli archi (e.g. un link si rompe, il suo costo diventa $\\infty$) e provando a trovare il least cost path per ogni coppia di nodi.\n\nPer ipotesi, assumo di non avere loop di costo negativo (quindi in generale di non avere costi negativi), che in generale portano tali algoritmi a non convergere (non è detto che esista una distanza minima). È possibile in teoria rilassare questa condizione con opportune contromisure.\n\nDistinguiamo gli algoritmi di routing in due macro-categorie:\n\n- One-To-All - L'algoritmo calcola il ***Least Cost Path*** (***LCP***) tra un nodo e tutti i restanti. Deve quindi essere fatto girare singolarmente per ogni nodo della rete (e.g. Dijkstra, Bellman-Ford);\n- All-To-All - L'algoritmo fornisce direttamente tutti i vari LCP tra tutte le coppie di nodi (e.g. Floyd-Warshall).","x":-490,"y":-5767,"width":840,"height":393,"color":"6"},
		{"id":"25aa86cc5f128d11","type":"text","text":"# Algoritmi di Instradamento (Reti)\n\nPer per essere in grado di direzionare il traffico in rete mi servono due cose:\n\n- Conoscere la ***topologia della rete***, che si traduce nel costruire un ***grafo pesato*** $G = (N, E)$, dove $N$ è l'insieme dei router ed $E$ l'insieme dei collegamenti fisici;\n\t- Nelle *flow table* dei singoli router ad ogni interfaccia è associato un ***costo***, ad esempio proporzionale a quanto tempo impiega il pacchetto a raggiungere l'*hop* successivo;\n\t\t- Il costo di un collegamento è spesso definito da un *admin* di rete, il quale può in realtà scegliere come vuole la logica dei costi. Può penalizzare (i.e. assegnare un costo alto ad) un collegamento verso una rete che gli sta *antipatica*;\n\t\t- Il costo di un collegamento che non esiste o che si rompe è $\\infty$;\n\t- La conoscenza della topologia divide gli algoritmi di instradamento in due macro-categorie:\n\t\t- ***Distribuiti (Distance-Vector)*** - Ogni router conosce solo le sue immediate vicinanze (e.g. ***RIP***);\n\t\t- ***Centralizzati (Link-State)*** - Ogni router conosce l'intera topologia della rete (e.g. ***OSPF***, è una centralizzazione logica mentre a livello fisico ho ridondanza), oppure questa informazione è in possesso di un ***controller*** esterno (***SDN***, e.g. ***OpenFlow***, centralizzazione sia logica che fisica, anche se di norma un controller ha un paio di computer di backup fisici);\n\t\t- In entrambi i casi i router comunicano tra loro scambiando messaggi;\n\t\t- Di norma gli algoritmi centralizzati sono più potenti dei distribuiti (hanno più informazioni!);\n- Essere in grado di **modificare le tabelle dei singoli router**.\n\t- Questa cosa può in certe situazioni può essere fatta manualmente, sia per evitare l'overhead computazionale di un algoritmo che modifica costantemente le tabelle (***dinamico***) sia per controllare in modo più preciso il flusso di dati. Qualcuno lo chiama algoritmo ***statico***, secondo me non è neanche considerabile un algoritmo (piuttosto, una configurazione manuale);\n\t- Non devo esagerare con il dinamismo. Pensa se il navigatore aggiornasse il percorso ogni 5 secondi.\n\nIpotizziamo di partire da $u$ e diamo dei nomi semplici ai concetti importanti.\n\n- $c_{x,y}$ il ***costo del collegamento*** tra $x$ e $y$.\n- $N$ è l'insieme di ***nodi per i quali il percorso minimo è stato già trovato***. Inizialmente $N = \\{u\\}$, poi tra i primi vicini di $u$ è facile vedere che l'arco dal costo minore è quello che porta a $x$, quindi dopo il primo step avremo $N = \\{ux\\}$, e così via;\n- Ipotizziamo di essere ancora al primo step. Attualmente conosco solo $u$ e i suoi primi vicini, quindi per quanto ne so il percorso ottimale $u \\rightarrow w$ costa $5$. Chiamo questa ***stima provvisoria*** $D(w)$. Più avanti nell'algoritmo mi renderò conto che il percorso che minimizza $D(w)$ è $u \\rightarrow x \\rightarrow w$;\n- Ipotizziamo di voler minimizzare $D(w)$ e di ritrovarci con due valori, $5$ e $4$. Come faccio a distinguere a livello di algoritmo qual è il percorso che è costato meno? Mi serve tenere traccia del ***nodo predecessore*** per disambiguare tra i valori di $D(w)$. Lo indico con $P(w)$, e in questo modo distinguo $D(w)\\,P(w) = \\{(5, u),\\,(4, x)\\}$.","x":-520,"y":-8520,"width":916,"height":1025,"color":"4"},
		{"id":"188f2ac3e643b8c4","type":"text","text":"# Algoritmo di Bellman-Ford (Distance-Vector) (Reti)\n\nNasce dall'idea che se i costi cambiano *poco* voglio eseguire *poco* codice.\n\nL'inizializzazione è identica a Dijkstra: supponiamo di essere il router $u$ e di avere una stima $D_u(w) = 5$, mentre ad esempio $x$ avrà una stima $D_x(w) = 3$.\n\nA questo punto tutti i router inviano ai primi vicini le proprie stime. In particolare, $x$ comunica la sua stima $D_x(w)$ ad $u$, il quale ricalcola $D_u(w)$ tramite l'***equazione di Bellman-Ford***\n\n$$D_u(w) = \\min\\limits_{i}(c_{u,i} + D_i(w)) = \\min\\limits_{i}(\\text{distanza}_{ui} + \\text{minima distanza}_{iw})$$\n\ndove $i$ sono tutti e soli i primi vicini. Quando $i = x$, $u$ si accorge di aver trovato una stima migliore (questo è chiamato ***relaxation step***, i.e. parto da una stima più strict e se possibile la rilasso) e la comunica ai propri primi vicini. $v$ riceve questa nuova stima ma la sua vecchia $D_v(w) = 3$ è ancora la scelta più conveniente, quindi non la aggiorna e non la comunica ai primi vicini. Riassumendo, ogni router\n\n- ***Attende*** la modifica del costo di un link a cui è direttamente collegato o un messaggio da un router vicino;\n\t- Algoritmo ***asincrono*** - non ha un un *refresh rate* fisso, ma aspetta un evento. **Se non cambiano i costi, il router non calcola niente**;\n- ***Ricalcola*** le proprie stime;\n- Se cambiano, ***avvisa*** i vicini.\n\t- In quanto algoritmo ***distribuito*** nessun nodo conosce il percorso globale, e spesso il cambiamento dei costi influisce solo su una piccola parte di rete.\n\nNotare che ***l'informazione si propaga a velocità finita***, quindi quando il singolo router calcola le proprie stime lo sta in realtà facendo con dati vecchi. In realtà la velocità di propagazione dell'informazione dipende dal tipo di notizia, e porta a due ***comportamenti patologici***:\n\n- Le buone notizie si propagano velocemente. Questo può portare rapidamente ad una situazione di ***black-holing***, in cui un router pubblicizza dei costi molto bassi, il traffico viene massicciamente spostato su di lui e si crea un bottleneck;\n- Le cattive notizie si propagano lentamente. Se si rompe un cavo si verifica il ***conteggio all'infinito***.\n\nE il costo?\n\n- Inizializzo la distanza a $\\infty$ per tutti gli $n$ nodi, quindi è almeno $O(n)$;\n- Il doppio ciclo `for` è $O(nm)$, quindi complessivamente è $O(mn) = O(n^3)$, dal momento che $m=O(n^2)$.\n\t- Notare che è $\\Omega(n)$ per i grafi connessi.\n\nIl maggiore costo rispetto a Dijkstra è compensato dal fatto che Bellman-Ford può gestire pesi negativi.\n\n","x":-1615,"y":-8520,"width":910,"height":1025,"color":"4"},
		{"id":"7aff029b7f5f646e","type":"text","text":"# Algoritmo di Dijkstra (Link-State) (Reti)\n\nLa premessa di ogni algoritmo Link-State è che ogni router comunichi a tutti gli altri router tutti i costi (e.g. livelli di \"intasamento\") di tutte le porte. Una volta acquisite tutte le informazioni globali, ogni nodo risolve il proprio Dijkstra (i.e. quel Dijkstra che ha se stesso come nodo di partenza).\n\nL'algoritmo si può dividere in due parti:\n\n- ***Inizializzazione*** - Definisco il nodo di partenza e per ogni nodo $k$ della rete inizializzo il valore di $D(k)$ a\n\t- $c_{u, k}>0$ se $k$ è direttamente collegato a $u$;\n\t- $\\infty$ altrimenti (in pratica scelgo un `terror_value` molto grande);\n- ***Loop*** - Ciclo le seguenti operazioni finché non riempio $N$ con tutti i nodi:\n\t- `i = find()` - A questo punto ho un insieme di nodi non ancora in $N$. Tra questi, seleziono quello per cui $D(i)$ è minima;\n\t\t- Sono sempre sicuro di non selezionare un \"falso minimo\";\n\t- `add_to_N(i)` - Una volta trovato, lo aggiungo ad $N$. In questo modo ho trovato il percorso ottimale definitivo per $i$, quindi non devo più cercarlo.\n\t- `for (j adjacent_to i) and (j not in N)` - Mi metto in $i$ e guardo i primi vicini, ignorando quelli per cui ho già trovato il percorso ottimale;\n\t- `D(j) = min(D(j), D(i) + c_{i,j})` - Aggiorno le stime provvisorie per tutti i $j$. Questa riga mi dice sostanzialmente che le possibilità sono due:\n\t\t- Avevo già una stima migliore di quella attuale, lascio quella;\n\t\t- Ho trovato una stima migliore, sostituisco.\n\t- Ricomincio.\n\nUna volta che converge, ogni router conosce il percorso ottimale per raggiungere qualsiasi altro router sulla rete.\n\nDijkstra funziona bene per reti piccole, altrimenti è un problema far conoscere a tutti la topologia della rete. Se $n$ router inviano ciascuno $n$ messaggi, la ***complessità di comunicazione*** (i.e. l'overhead del processo di scambio di messaggi) è $O(n^2)$.\n\nPuò avere ***comportamenti patologici*** se si definiscono male i pesi degli archi. Se ad esempio uso il volume istantaneo di traffico, ogni aggiornamento sposta i flussi creando nuovi bottleneck, che portano ad un nuovo ricalcolo, che sposta i flussi, ... (***oscillazioni***).\n\nAd ogni variazione di anche un solo costo bisogna ricalcolare tutto (c'è un *refresh rate*, ogni $t$ secondi).\n\nIl costo dell'algoritmo dipende dalla struttura dati di supporto $Q$ (qua mi fido perché non ho fatto Algoritmi II):\n\n- Se è una coda, il costo è $O(n^2)$;\n- Se è un heap, il costo è $O(m\\log n)$;\n- Se è un fibonacci heap, il costo è $O(m+n\\log n)$.","x":604,"y":-8520,"width":916,"height":1025,"color":"4"},
		{"id":"81c67bbb8a1cba08","type":"file","file":"Cabled Networks/Routing/Reti di Elaboratori/Protocolli di Instradamento/BadNewsMrBellmanFord.png","x":-2120,"y":-7136,"width":400,"height":271},
		{"id":"c6f0767927f3b557","type":"text","text":"# Loop - Conteggio all'Infinito (Reti)\n\n- $y$ ha un pacchetto per $x$, controlla il cavo e si accorge che il costo è aumentato;\n- Nota allora che $z$ afferma di poter arrivare ad $x$ con costo $5$;\n\t- $z$ dice così perché sta usando l'informazione non aggiornata di $y$, e si basa sul mandare il pacchetto proprio ad $y$;\n- $y$ aggiorna la sua *best route* per $x$, perché \"`z dice che ci mette 5, io per z ci metto 1, 6 è meglio di 60`\". Ora nella tabella di $y$ c'è scritto $x \\rightarrow 6$, e prevede di mandare i pacchetti a $z$;\n- $y$ aggiorna $z$, dicendogli che per arrivare ad $x$ ci mette $6$;\n- $z$ aggiorna le sue stime: \"`y dice che ci mette 6, io per y ci metto 1, 7 è meglio di 50`\";\n- $z$ aggiorna $y$, dicendogli che per arrivare ad $x$ ci mette $7$;\n- \\[...\\]\n\nIn pratica, se si rompe il cavo tra $x$ ed $y$, $y$ e $z$ aggiornano il costo sommando ciclicamente il costo del collegamento tra loro due.\n\nCome si risolve il problema delle ***rotte cicliche***?\n\n- ***Split Horizon*** - Tutto questo sta succedendo perché $z$ invia ad $y$ aggiornamenti dei percorsi che prevedono di passare da $y$ stesso (idem per $y$). Quanto poco senso ha per un umano dire \"`ciao z io ci metto 5 passando da z`\"? Non ha senso dire a $z$ le informazioni che mi ha già dato lui, quindi semplicemente gli comunico tutte le rotte **tranne** quelle che prevedono di passare da lui;\n- ***Poisoned Reverse*** - Una specie di \"non ti azzardare a rimandarmi quello che ti mando io\". In pratica comunico a $z$ che il costo del nostro link è appena diventato *enorme*, in modo da rompere la rotta ciclica;","x":-1615,"y":-7314,"width":910,"height":627,"color":"4"},
		{"id":"2c22d4b4635fe807","type":"file","file":"Cabled Networks/Routing/PseudocodiceDijkstra.png","x":1660,"y":-8162,"width":400,"height":309},
		{"id":"8934ea2435a5c421","type":"file","file":"Cabled Networks/Routing/PseudocodiceFloydWarshall.png","x":1660,"y":-7138,"width":400,"height":276},
		{"id":"0cf213e4da0de072","type":"file","file":"Cabled Networks/Routing/PseudocodiceBellmanFord.png","x":-2120,"y":-8139,"width":400,"height":264},
		{"id":"3e6d4dd9674719b8","type":"text","text":"# Floyd-Warshall\n\nAlgoritmo all-to-all che prende in input il grafo pesato e restituisce la matrice delle distanze di costo minore.\n\nPer passare dal nodo $u$ al nodo $v$ il percorso può essere\n\n- L'arco tra $u$ e $v$, esiste. Questo è il caso banale in cui va bene il valore di inizializzazione $\\dist(u,v) = w(u,v)$;\n- Il cammino da $u$ fino a $k$ e poi il cammino da $k$ a $v$, ovvero $\\dist(u,v) = \\dist(u,k)+\\dist(k,v)$.\n\nCome faccio a sapere qual è il migliore? Ovviamente faccio un triplo ciclo `for` annidato con dentro $$\\dist(u,v) = \\min\\{\\dist(u,v), \\dist(u,k)+\\dist(k,v)\\}$$\n\nQuindi il costo è $\\Theta(n^3)$.","x":604,"y":-7172,"width":916,"height":343,"color":"4"},
		{"id":"1e447a14c975bb8a","type":"text","text":"# Mesh Network (Paper)","x":-8357,"y":-4026,"width":655,"height":340,"color":"3"},
		{"id":"8570332b3639b827","type":"file","file":"Cabled Networks/Layouts/ForbiddenLayouts.png","x":-6800,"y":-3613,"width":820,"height":165},
		{"id":"d07e0547b6ef80cf","type":"text","text":"# Modello di Thompson\n\nQuando devo stampare sulle board in silicio dei circuiti ***VLSI*** (***Very Large Scale Integration***, che in pratica significa \"qui ci stanno un sacco di transistor in poco spazio\") ho diversi constraints:\n\n- Il processo per la ***fabbricazione*** di circuiti integrati (***fotolitografia***) è ***ottimale*** (i.e. minimizza costi ed errori massimizzando l'efficienza) se si stampano solo ***pattern ortogonali***, rendendo di fatto questa condizione un vincolo;\n- Per evitare interferenze è richiesto un certo spaziamento tra gli elementi circuitali, portando all'uso di una ***griglia equispaziata***;\n- \"***Wires cannot cross***\". Se proprio necessario, è possibile dividere un'intersezione stampando i due fili su due lati diversi della board, passando da una parte all'altra tramite dei piccoli fori (***vias***). Il loro numero andrebbe comunque minimizzato, in quanto costosi;\n- Più corti sono, meglio è (altrimenti aumenta il ***propagation delay***). Se poi faccio una struttura a layer, devono essere tutti della stessa lunghezza (<span style=\"color:#FFA500\">... really? sarebbe interessante indagare</span>).\n- Il silicio stesso è costoso, per cui sarebbe meglio ***minimizzare l'area*** del circuito.\n\nDetto questo, il modello vero e proprio si basa su tre regole:\n\n- Ogni nodo è mappato in un'intersezione delle tracce (i.e. wires);\n- Ogni edge è mappato in una spezzata che tocca solo e soltanto i suoi endpoint nodes (i.e. se un edge collega `A` e `B`, non può intersecare `C` durante il percorso);\n- Nono ci possono essere overlap e/o \"knock-knees\" tra coppie di edges.\n\nPer via della definizione del problema, è impossibile disegnare in questo modo grafi di grado $>4$.","x":-6800,"y":-3373,"width":820,"height":637,"color":"4"},
		{"id":"bcef48638324e695","type":"file","file":"Cabled Networks/Layouts/HTree.png","x":-8230,"y":-3373,"width":400,"height":218},
		{"id":"ea0aa6b73724a2f1","type":"text","text":"# Complete Binary Tree (H-Trees)\n\nGenera un albero binario completo su griglia ortogonale.\n\n- Se devo generare sotto-alberi di altezza dispari, piazzo i figli in verticale, e viceversa;\n- L'area occupata è $\\Theta(n)$, che diventa $\\Omega(n\\log n)$ se richiedo che le foglie siano sui bordi. Per dimostrare il risultato esatto $2(n+1)$ si procede per induzione sui casi $h=\\{0,1,2\\}$:\n\t- Base induttiva - A seconda dell'altezza, l'albero spawnato ha un diverso numero di nodi:\n\t\t- $h = 0$ - L'albero ha un solo nodo. Dovendo essere su un vertice di una griglia di area $>0$, l'unica opzione è che sia al centro di $4$ \"quadretti\" di lato $1$. L'area è $2\\cdot2=4$, come ci si aspetta dalla formula $2(1+1)=4$;\n\t\t- $h = 1$ - Una delle due dimensioni è come prima, l'altra raddoppia $\\so 8$;\n\t\t- $h = 2$ - Copia e incolla, raddoppia il $2\\so4\\cdot4=16=2(7+1)$.\n\t- Ipotesi induttiva - La formula è vera per un albero di altezza $h-1$;\n\t- Passo induttivo - Distinguiamo $h$ pari o dispari per larghezza $l$ e altezza $w$:\n\t\t- Even - Se $h$ è pari abbiamo $$\\begin{cases} l_h = l_{h-1}=2l_{h-2}\\\\ w_h = 2w_{h-1} = 2w_{h-2}\\end{cases}$$\n\t\t\t- Risaliamo ricorsivamente ad $l_h=2^k\\,l_{h-2k}$, essendo il caso base per $h-2k=1$ (i.e. $l_1=2$) otteniamo la formula generale $l_h=2^{h+1\\over 2}$ ;\n\t\t\t- In modo analogo $w_h=2^{h+3\\over2}$;\n\t\t\t- Ricordando che un albero binario completo di altezza $h$ ha $n(h)=2^{h+1}-1$ nodi e che quindi se ho $n$ nodi ho altezza $h=\\log(n+1)-1$ ottengo la tesi.\n\t\t- Odd - Stessa identica cosa, ma al contrario. Per la proprietà commutativa del prodotto il risultato è identico.","x":-8440,"y":-3054,"width":820,"height":698,"color":"4"},
		{"id":"e56580a6f5083976","type":"text","text":"# Interconnection Topologies (IT)\n\nLo studio delle IT si concentra sul trovare delle strutture aventi proprietà utili per un algoritmo di instradamento del traffico. Pur vero che in una NoC ***il grafo è fissato***, non è detto che lo sia il flusso di dati, da cui la necessità di poterlo ridistribuire dinamicamente. Distinguiamo due livelli concettuali:\n\n- Costruire un ***modello teorico*** avente come obiettivo l'ottimizzazione del routing senza curarsi troppo dell'esatta implementazione fisica (e.g. ***Butterfly***, ***Beneš***). In particolare, la sfida è produrre una topologia sulla quale sia semplice realizzare un algoritmo di ***shortest path***.\n\t- Non è un problema assumere la presenza di un global controller o di sovrapposizioni tra i fili, \"tanto alla peggio se ne occupa chi implementa\";\n- Realizzare il modello teorico sull'HW.\n\t- I ***layout*** sono un'implementazione delle IT che devono rispettare criteri diversi rispetto a quelli del modello teorico, (e.g. ***efficienza energetica***, minimizzazione della superficie). Un esempio di \"raccolta\" di simili criteri è il ***modello di Thompson***;\n\t- Non è così ovvia la possibilità di avere a disposizione un global controller.\n","x":-5160,"y":-3280,"width":820,"height":451,"color":"6"},
		{"id":"0ad1eb68f4cc5f23","type":"file","file":"Cabled Networks/Routing/MinimumTimeWastingGraph.png","x":-659,"y":-5065,"width":339,"height":400},
		{"id":"083dff6be0a78b0e","type":"file","file":"Cabled Networks/Layouts/HatersGonnaHate.png","x":-9480,"y":-1000,"width":365,"height":354},
		{"id":"a8462c1ce6b6bf95","type":"text","text":"# Even&Even Layout\n\nPiù che un layout, è una procedura. Introduce il concetto di ***Layered Cross Product*** (***LCP***), che permette di ottenere un ***layered layout*** (***LL***, un grafo esprimibile come $G=(\\{V_i\\},E)$, in cui $\\{V_i\\}$ è il set di vertici sul layer $i$) più complesso a partire dal prodotto di due layered layout più semplici. \n\nLa costruzione di $G=G^1\\times G^2$ è abbastanza intuitiva.\n\n- Sul layer $i$ di $G$ troviamo un set di nodi $\\{V_i\\}$ dato dal prodotto cartesiano $\\{V_i^1\\}\\times\\{V_i^2\\}$;\n\t- e.g. in riferimento a `LCP.png`, il layer $1$ ha nodi {`Aa`, `Ab`, `Ba`, `Bb`} in quanto risultato del prodotto cartesiano {`A`, `B`}$\\times${`a`, `b`}.\n- $((u^1, u^2), (v^1, v^2)) ∈ E \\iff (u^1, v^1) ∈ E^1 ∧ (u^2, v^2) ∈ E^2$, i.e. visto che ogni nodo di $G$ è una coppia di nodi $u^1, v^1\\in G^1$ e $u^2, v^2 \\in G^2$, il criterio per stabilire se $(u^1, u^2)$ è collegato a $(v^1, v^2)$ e che $u^1$ sia collegato a $v^1$ in $G^1$ ***e*** $u^2$ sia collegato a $v^2$ in $G^2$.\n\t- e.g. `Aa` è collegato a `Cc` perché `A` è collegato a `C` ***e*** `a` è collegato a `c`.\n\nQuesta è la teoria, ma LCP deve produrre un layout realizzabile con, diciamo, VLSI. Un albero o una BN non sono direttamente disegnabili su un wafer, perché così come li si rappresenta di solito non rispettano il modello di Thompson. Che si fa?\n\nIntroduciamo la ***Projection Methodology*** (***PM***, che nasce come procedimento $\\dD\\to\\tD\\to\\dD$, poi qualcuno si è reso conto che si può fare direttamente $\\dD\\to\\dD$). Anche qui, l'idea è intuitiva: faccio il prodotto cartesiano graficamente tracciando le linee tra layer con lo stesso indice, poi unisco i vertici esattamente come prima. È in buona sostanza una [proiezione ortogonale](https://it.wikipedia.org/wiki/Proiezioni_ortogonali) di un solido di cui conosci solo le proiezioni laterali.\n\nÈ possibile verificare che facendo una PM sull'albero dell'esempio precedente viene esattamente un H-Tree layout. C'è un piccolo problema: i nodi `De` ed `Ef` collassano nello stesso punto. Questo perché da sola la PM non risolve tutti i problemi: restano tre accorgimenti da considerare.\n\n- ***Collasso dei nodi*** - Questo avviene solo se metto a prodotto due edges verticali (e.g. `DE` e `ef` producono un solo nodo in cui collassano `De` ed `Ef`), quindi evito situazioni del genere;\n- ***Collasso degli edges*** - Questo può avvenire se ci sono ***inconsistent edges***. Anche qui, morale della favola: non ci devono stare;\n- ***Edges obliqui*** - LCP di due edges obliqui produce un edge obliquo. Per risolvere questo problema si introducono dei nodi fittizi per far sì che gli edges obliqui compaiano al layer $i$ di uno solo dei grafi, ma non in entrambi.\n\nLa superficie della BN così ottenuta è $4N^2+o(N^2)$, che non è proprio ottimale. Peggio, i nodi di <span style=\"color:#AB0000\">input</span> e quelli di <span style=\"color:#775fb6\">output</span> si trovano per la maggior parte all'interno dell'IT.","x":-6800,"y":-1000,"width":820,"height":975,"color":"4"},
		{"id":"2a5be57ad234c816","type":"text","text":"# Hypercube Layout (paper)\n\nLetteralmente i vertici e i lati che avrebbe un ipercubo $n$-dimensionale. Interessante perché ha diametro $\\log N \\simeq n$ (che è anche il path minimo per certe coppie di nodi). No dim\n\nha una bisection width $N/2$, enorme. sketch of proof: guarda la costruzione per fare un tesseract, per dividere in due devi tagliare i collegamenti tra i due cubi, che sono proprio $N/2$.\n\nper fare un'area ottimale mi rifaccio al collinear. quando conto le tracks ho due casi:\n\n- dimensione dispari - mi servono $f(n) = 2f(n-1)+1$ track\n- pari -$f(n) = 4f(n-2)+2$\n\nla prova del teorema sulle tracks (slide 87) praticamente la skippa\nl'altra (88) non sto capendooo che stai a fa ok mezzo skippa pure questa\n\napprofondire sta roba è un paper","x":-5160,"y":-1000,"width":820,"height":559,"color":"2"},
		{"id":"58f1b1ae15330a4d","type":"text","text":"# 3D Layouts (Paper)\n\nna roba recente, come ogni modello nasce prima della sua possibile realizzazione pratica. c'hai n slices e ci posso fare quello che voglio. riduce spazio occupato. biezione tra il grafo e lo spazio 3D. \n\ndice che c'è un problema di temperatura e che è meglio mettere i nodi sugli estremi della struttura 3D. ma non ho capito bene comecosaquandoperché\n\nperché in effetti in 2D accetto i crossing? (qui no)\n\nma ci sta la cosa delle stampe ortogonali anche in 3D? (guess so)\n\npenso che sta roba oltre che minimizzazione di spazio abbia anche una potenza computazionale molto maggiore","x":-5160,"y":-2705,"width":820,"height":359,"color":"2"},
		{"id":"6d1791a0f74b9b2c","type":"file","file":"Cabled Networks/Layouts/FinalButterflyEvenEven.png","x":-5940,"y":-563,"width":400,"height":405},
		{"id":"55192ab584a0cd85","type":"file","file":"Cabled Networks/Layouts/InconsistentEdges.png","x":-5940,"y":-845,"width":400,"height":125},
		{"id":"6b1241ca58e29582","type":"text","text":"# Least Cost Path e Distanza\n\nSupponiamo di avere a disposizione per ogni link la probabilità $p(u,v)$ che questo ***non*** si rompa.\n\nUn possibile LCP è quello che minimizza $p(\\text{path})$. Se assumiamo eventi indipendenti, questa sarà data dal prodotto delle probabilità dei link attraversati dal path. Dal momento che non è immediato minimizzare un prodotto, passiamo ad una somma. Come? Con una funzione monotona sul dominio $(0,1)$ di una probabilità (non avrebbe molto senso includere gli estremi...), e che trasforma prodotti in somme. Ovviamente è il logaritmo. Definendo$$w(u,v)=-\\log(p(u,v))$$\n(il segno $-$ è perché il $\\log$ di una roba $\\in (0, 1)$ è negativo, e per qualche motivo preferiamo lavorare con problemi di minimo piuttosto che di massimo) il problema si riduce a minimizzare sul grafo$$w(\\text{path}(u,v))=\\sum_{i\\in\\text{path}(u,v)}\\log(p_i)$$Ora, questa specifica definizione di minimizzazione del costo è un caso specifico di un problema più generale. La ***distanza*** tra due nodi $(u,v)$ è il path di costo minimo tra tutti quelli che collegano $u$ e $v$, ovvero$$\\text{dist}(u,v) = \\min_{\\{\\text{path}(u,v)\\}}w(\\text{path}(u,v))_i$$Ovviamente, se abbiamo un digraph la distanza non è simmetrica. ","x":-1615,"y":-5145,"width":910,"height":560,"color":"4"},
		{"id":"8bd0e02aa130f6a5","type":"text","text":"# Glossario\n\n- ***Interconnection Network*** - Di per sé è un grafo i cui nodi sono dispositivi elettronici che scambiano informazioni mediante gli archi, ma si usa in gergo anche per intendere una ***interconnection topology complessa***.\n- ***Layer*** - Si usa sia per intendere gli \"step di computazione\" in una IT (e.g. BN) che per i diversi strati di una board in silicio. Notare che questi due significati individuano piani ortogonali. In genere si capisce, ma quando c'è ambiguità\n\t- <span style=\"color:#00b050\">layer logico</span>;\n\t- <span style=\"color:#cd0a0a\">layer fisico</span>.\n- ***Greedy Algorithm*** - Un algoritmo greedy non si preoccupa di trovare una soluzione globalmente ottimale. Piuttosto, cerca di ottimizzare la scelta ad ogni step (e.g. nel travelling salesman potrebbe avere come logica \"`visita la più vicina città non ancora visitata`\"). Questo in generale porta l'algoritmo a terminare in un numero ragionevole di step, a scapito dell'ottimizzazione della soluzione complessiva.","x":-1640,"y":-2269,"width":935,"height":402,"color":"4"},
		{"id":"50ee741910a5fe7f","type":"text","text":"# The Minimum Vertex Cover Problem\n\n Se $G$ è un grafo non orientato, una ***vertex cover*** (***VC***) di $G$ è un sottoinsieme di nodi tali che questi toccano tutti gli archi di $G$. È ovvio che $G$ meno un singolo nodo è una VC di $G$, probabilmente anche meno due nodi. Decidere se $G$ ha una VC di $k$ nodi è un problema $\\mathbb{NP}$-$\\mathbf{Complete}$. Risolvere questo problema è equivalente a trovare ***una possibile*** (non è unica!) ***VC minima*** per $G$, i.e. $k_{min}$.\n \n Perché siamo interessati alla VC minima per un grafo?\n\n - Un ***worm*** che infetta ogni nodo della VC può raggiungere tutti gli altri nodi in un solo step. Questo è il punto di vista di chi vuole attaccare una rete;\n - Visto che l'attaccante può sfruttare questa vulnerabilità, dal punto di vista del difensore il problema si traduce nel trovare il ***minimo set di vertici da difendere***.\n\nEssendo un problema $\\NPC$, pur essendo risolvibile in modo esatto con una formulazione del problema in ***Integer Linear Programming*** (***ILP***),  la letteratura scientifica offre diversi algoritmi per trovare una ***soluzione approssimata*** in tempo polinomiale.","x":3210,"y":-3280,"width":820,"height":451,"color":"6"},
		{"id":"39b8b62db54759a1","type":"text","text":"# Premesse e Definizioni sui Grafi\n\nStrutture dati $G=(V,E)$ i cui nodi $V$ (***vertex***) sono collegati tramite link $E$ (***edge***). Dato un nodo, il numero di archi ad esso collegati prende il nome di ***grado del nodo***. Il massimo tra tutti i gradi dei nodi è il ***grado del grafo***.\n\n- Se tutti i nodi del grafo hanno lo stesso grado (e.g. $3$) il grafo è ***regolare*** (e.g. $3$-regolare o ***cubic graph***);\n- Gli archi possono essere ***orientati***. In questo caso si parla di ***digrafo***;\n\t- Nota che questi stessi appunti sono un digrafo.\n- Se esiste una coppia di nodi $(u, v)$ collegata da più di un arco o esiste un singolo nodo $z$ che presenta un arco che collega $z$ a se stesso (***loop***), si parla di ***multigrafo***. Viceversa, qui assumiamo ***grafi semplici***;\n- Se è possibile dividere i nodi in due insiemi disgiunti $U$ e $V$ tali che gli archi sono solo tra $u\\in U$ e $v\\in V$ (i.e.  non esistono archi tra nodi di uno stesso insieme) parliamo di grafo ***bipartito***;\n- Se per ogni coppia di nodi $(u, v)$ esiste un arco da $u$ a $v$, il grafo è detto ***completo***, generalmente indicato come $K_n$ dove $n$ è il numero di nodi;\n\t- Intuitivamente, il grafo è completo se ogni nodo è collegato a tutti gli altri.\n\t- In un grafo ***bipartito completo*** ogni nodo dell'insieme $U$ è collegato ad ogni nodo dell'insieme $V$. Si indica con $K_{n,m}$, dove $n$ è il numero di nodi di $U$ ed $m$ quello di $V$.\n\t\t- Un esempio di $K_{n,m}$ sono due layer consecutivi di una Shallow Neural Network;\n\t\t- Un grafo a ***stella*** è un $K_{1,n}$ in cui un unico nodo in $U$ (quello centrale) è connesso a tutti gli altri.\n- Un grafo è ***planare*** se è possibile disegnarlo su un piano senza che i sui archi si intersechino;\n\t- e.g. $K_4$ è planare, mentre $K_5$ no.\n- Se per ogni coppia di nodi $(u, v)$ esiste almeno un cammino da $u$ a $v$, il grafo è detto ***connesso***.\n\t- È possibile verificare questa proprietà tramite un algoritmo ***Breadth First Search*** (***BFS***, e.g. ***Algoritmo di Moore***) o analogamente ***Depth First Search*** (***DFS***). Verificare la connessione di un grafo ha importanti applicazioni, e.g. individuare dei cluster in grandi dataset.\n- Una sequenza di nodi $v_1,..., v_n$ tale che $(v_i,v_{i+1})\\in E(G)$ (i.e. ogni coppia adiacente di nodi nella sequenza è connessa da un edge) è detta ***cammino*** sul grafo;\n\t- Un ***path*** è un cammino in cui tutti i nodi sono distinti;\n\t- Un ***path graph*** è un grafo lineare, indicato come $P_n$ con $n$ numero di nodi;\n\t- Un ***wheel graph*** è un path graph in cui il nodo iniziale e finale sono collegati (i.e. è un ciclo).\n- Se agli edges sono associati dei costi si parla di ***grafo pesato***.\n\nGran parte della teoria sui grafi si focalizza sul trovare, se esistono, specifici cammini e path.","x":-1640,"y":-1753,"width":935,"height":876,"color":"4"},
		{"id":"bf126287e54f6be7","type":"text","text":"# Perché trovare il v di grado massimo è O(m) e non O(n)????","x":4770,"y":-3760,"width":388,"height":250},
		{"id":"925c7c49ad926dc9","type":"text","text":"# Eternal Vertex Cover\n\nCome detto, un admin di rete vuole difendere un set minimale di nodi per garantire protezione a tutta la rete. Se però è necessario spostare una risorsa difensiva da un nodo $\\in VC$ a un nodo $\\notin VC$ è necessario ***riorganizzare dinamicamente la VC in modo che resti una VC***. Questo problema è detto di ***Eternal Vertex Cover*** (i.e. una VC che pur riorganizzandosi resta sempre una VC).\n\nPer riorganizzare le guardie, è necessario che l'informazione viaggi rapidamente tra di esse. Per questo motivo richiediamo che la EVC sia ***connessa***. Questo introduce una complessità aggiuntiva che si traduce in una cardinalità minima maggiore rispetto a quella della VC semplice:$$\\a^\\infty(G)\\geq\\a(G)$$ ","x":3210,"y":-3810,"width":820,"height":317,"color":"4"},
		{"id":"a6f2c320c3ffdcb2","type":"text","text":"# Shadow Guards\n\nQuando una guardia deve spostarsi, sarebbe comodo averne una \"di riserva\" che prenda il suo posto senza destabilizzare l'intera VC.\n\n`Theorem` - Data una VC connessa $V'$ possiamo proteggere $G$ con una EVC di dimensione al più $V'+1$, ovvero$$\\a^\\infty(G)\\leq|V'|+1$$\n`Proof` - Prendiamo un vertice $\\notin V'$ (ma connesso a $V'$) e ci aggiungiamo una ***shadow guard***, cioè una nuova guardia oltre a quelle già presenti nella VC. In qualsiasi punto avvenga un attacco, le guardie \"slittano\" verso quel punto (i.e. si spostano sequenzialmente) e sono certe di mantenere la VC perché c'è la shadow guard a subentrare all'ultima guardia in movimento.\n\n`Lemma` - Data una VC con $k$ ***connected components*** (i.e. consta di $k$ sottografi connessi, che però non sono connessi tra loro) $V'$, allora $$\\a^\\infty(G)\\leq|V'|+k$$\n`Proof` - Segue direttamente applicando $k$ volte il teorema.\n\nNel caso degenere di dubbio interesse in cui $V'$ ha $|V'|$ connected components (i.e. nessun nodo è connesso ad un altro), si trova la disuguaglianza$$\\a(G)\\leq\\a^\\infty(G)\\leq2\\a(G)$$","x":2880,"y":-4611,"width":660,"height":613,"color":"4"},
		{"id":"48b70622c72eb3c5","type":"text","text":"# Worms","x":3700,"y":-4611,"width":660,"height":613},
		{"id":"ea9adcf1142783df","type":"text","text":"# Applicazioni\n\n- [Brain](https://www.researchgate.net/publication/375148180_Application_of_Minimum_Vertex_Cover_Problem_in_Functional_Brain_Connectivity_Graphs) - Brain regions are nodes, connection between them are the edges.\n","x":3210,"y":-2667,"width":820,"height":107},
		{"id":"a395388c75b4a5e6","type":"text","text":"# Collinear Layout (Graph Degree > 4)\n\nSecondo il modello di Thompson è possibile realizzare in orthogonal layout solo grafi di grado al più $4$ (che diventano $6$ in $3D$). Come supero questo limite?\n\nIn un ***non-constant node degree model*** un nodo di grado $d$ occupa un'area $\\Theta(d)$ invece di essere puntiforme, dopodiché i collegamenti vengono realizzati tutti su un solo lato (<span style=\"color:#FA4509\">... circa</span>).\n\n- Numeriamo gli $n$ ***nodi*** per come verranno poi ***disposti in linea retta*** nel layout, e distinguiamo conseguentemente diversi tipi di link:\n\t- <span style=\"color:#FA4509\">Type-1</span> - Collegano due nodi adiacenti (e.g. `1-2`, `5-6`);\n\t- <span style=\"color:#00AFFC\">Type-2</span> - Collegano nodi distanti $2$ (e.g. `1-3`, `5-7`);\n\t- \\[...\\] Type-$i$ - Collegano nodi distanti $i$.\n- Definiamo ***tracks*** il numero di linee orizzontali utilizzate dai link. Per non sovrapporsi, l'insieme dei link Type-$i$ necessita di un totale di $\\min(i,n-i)$ tracks. Segue che per $n$ nodi serve un numero di tracks pari a$$\\sum_{i=1}^{n-1}\\min(i,n-i) = \\text{[...]} = {n^2\\over 4}$$\n- A questo punto l'area è ${n^2\\over4}\\cdot n^2 = {n^4\\over4}$.\n\nÈ possibile migliorare ulteriormente questo design realizzando diverse righe di nodi di grado $d$ (i.e. costruendo una matrice). Si dimostra che questo ***orthogonal layout*** ha area ${n^4\\over16}+o(n^4)$.","x":-5160,"y":-2178,"width":820,"height":606,"color":"4"},
		{"id":"373aaa95500d2c52","type":"text","text":"# Optimal Area Layout (BN)\n\nLa criptica idea è che se prendo $j-k$ colonne consecutive di una BN, questa struttura può essere vista come un inseme di più BN di dimensione minore disgiunte. In che senso?\n\nDiciamo che $n=3$, i.e. ci sono $4$ layer. Partiamo dal layer $j=1$ (contato a partire dall'input, che è il layer $0$) e fermiamoci al livello $j+k=2$ (i.e. $k=1$). Riconosciamo la presenza di $2^{n-k}=4$ BN di dimensione $k=1$ che sono quelle riportate nell'immagine a fianco.\n\n- `Lemma` -  Data una BN di dimensione $n$, qualunque scelta di $j,k\\in\\N$ tali che$$0\\leq j\\leq j+k\\leq n$$permette di schematizzare il grafo ottenuto isolando i livelli da $j$ a $j+k$ della BN come un insieme di $2^{n-k}$ BN di dimensione $k$.\n\nBene, e che ci faccio? Visto che posso applicare questo gioco in modo ricorsivo, riduco di una dimensione alla volta. Realizzo quindi il layout come layout più piccoli collegati da layer ponte.","x":-8439,"y":-2092,"width":820,"height":435,"color":"4"},
		{"id":"0f9c5528fb0d2128","type":"file","file":"Cabled Networks/Layouts/Optimal.png","x":-8412,"y":-1572,"width":321,"height":306},
		{"id":"e4932f0ed846fa22","type":"file","file":"Cabled Networks/Layouts/IInsideOptimal.png","x":-7966,"y":-1572,"width":301,"height":306},
		{"id":"050668ecfe632219","type":"file","file":"Cabled Networks/Layouts/Lemma.png","x":-8973,"y":-2292,"width":225,"height":399},
		{"id":"19bc2b8ef4a1cfd6","type":"file","file":"Cabled Networks/Layouts/ImplementazioneAltroEsempio.png","x":-9060,"y":-1399,"width":400,"height":133},
		{"id":"8b9aad2d5c4f419c","type":"file","file":"Cabled Networks/Layouts/AltroEsempio.png","x":-8972,"y":-1858,"width":225,"height":399},
		{"id":"7e531cf6501a561c","type":"file","file":"Cabled Networks/Layouts/EvenEven2D2DButNotThompson.png","x":-7240,"y":-440,"width":400,"height":385},
		{"id":"1fcf39557e30d4c7","type":"file","file":"Cabled Networks/Layouts/LCP.png","x":-7240,"y":-960,"width":400,"height":437},
		{"id":"cbe04eb6b7a42a4f","type":"text","text":"# Colorazione di un Grafo: $(h,k)\\text{-Labeling}$ \n\nPoniamo di voler colorare i nodi di un grafo con due regole:\n\n- Se due nodi sono ***adiacenti*** (i.e. collegati da un edge), i due colori usati devono essere distanti almeno $h$ (assumiamo che i colori siano numerati, diciamo da $1$ a $N$);\n- Se due nodi sono \"***vicini***\" (i.e. a distanza $2$), i due colori usati devono essere distanti almeno $k$.\n\nQual è il ***numero minimo di colori*** che devo utilizzare per colorare secondo queste regole?\nQuesto problema prende il nome di $(h,k)\\text{-Labeling}$.\n\nLa funzione $L(h,k)$ prende in input i parametri $h$ e $k$, ma anche il grafo da colorare (quindi a rigore sarebbe una $L(h, k, G)$, ma per brevità o per pigrizia lo diamo per scontato), e restituisce il minimo set di colori da utilizzare (ed eventualmente anche il grafo colorato, visto che ad oggi è un problema $\\NPC$ che deve esplorare tutte le possibilità).\n\nPosto che consideriamo solo i casi in cui $(h,k)$ sono coprimi e $h>k$, le applicazioni più studiate sono\n\n- ***Vertex Covering*** $L(1,0)$ - Usato per modellizzare la diffusione di un ***worm*** su una rete;\n- ***Channel Assignment*** $L(2,1)$ - Noto come problema dell'***assegnazione delle frequenze***.","x":1440,"y":-1565,"width":820,"height":499,"color":"6"},
		{"id":"e2adc07649e4c8fe","type":"text","text":"# $L(h,k)$ è $\\NPC$\n\nNo","x":1440,"y":-980,"width":820,"height":120},
		{"id":"17559ea1adfc4706","type":"text","text":"# Double-Greedy ($\\sim$ Matching)\n\nCome Greedy 1, ma metto entrambi i nodi terminali nella VC.\n\nIn questo modo però ottengo un $AR \\leq 2$.\n\n`Proof` - Sicuramente $V'$ è una VC. Sia $A$ l'insieme degli edges scelti da $E'$, ovvero quelli che via via seleziono. Per ognuno di essi aggiungo entrambi i nodi estremali alla VC, quindi$$|V'|=2|A|$$Ma sto per definizione costruendo un ***matching***, quindi so che$$|A|\\leq |V^*|$$\nUnendo le due cose trovo che$$|V'|\\leq 2|V^*|$$","x":6811,"y":-3850,"width":545,"height":430,"color":"4"},
		{"id":"1c74269dfe67f918","type":"text","text":"# Double-Greedy\n$$\n\\begin{array}{l}\n1.\\quad V'=\\emptyset,\\,E'=E \\\\\n2.\\quad \\textbf{while} \\; E'\\neq \\emptyset \\; \\textbf{do} \\\\\n3.\\quad\\quad \\text{random\\_choose}(i,j)\\in E' \\; \\\\\n4.\\quad\\quad V'=V'\\cup \\{(i,j)\\} \\\\ \n5.\\quad\\quad \\textbf{for}\\;(i,k)\\in E \\textbf{ do}\\\\ \n6.\\quad\\quad\\quad E'=E'-\\{(i,k)\\} \\\\ \n7.\\quad \\quad\\textbf{end for} \\\\ \n8.\\quad\\quad \\textbf{for }(j,h)\\in E\\textbf{ do} \\\\\n9.\\quad\\quad\\quad E'=E'-\\{(j,h)\\} \\\\ \n10.\\quad\\quad \\textbf{end for} \\\\\n11.\\quad \\textbf{end while} \\\\ \n12.\\quad \\textbf{return} \\; \\text{V'} \\end{array}$$","x":7451,"y":-3818,"width":300,"height":366,"color":"5"},
		{"id":"19537ff13325ff86","type":"text","text":"# LP Approximation Algorithm\n\nSe $x_i\\in \\R$ metto come valore di soglia $0.5$ e lancio il grafo in pasto ad un LP solver gentilmente fornitoci da Dio.\n\n- $\\{x_i\\}$ è il set di valori $\\in [0, 1]\\in\\R$ restituito dal solver;\n- $\\{y_i\\}$ è il set di valori $\\in [0, 1]\\in\\N$ che definisce la VC.\n- Ciclo sugli $x_i$ avendo $0.5$ come soglia:\n\t- Se $x_i \\geq {1\\over2}\\so y_i=1$; \n\t- Altrimenti $y_i=0$.\n\nSicuramente $\\{y_i\\}$ è una VC: per via del constraint$$x_i+x_j\\geq1\\quad\\forall (i,j)\\in E$$ almeno uno tra $x_i$ ed $x_j$ sarà $\\geq{1\\over2}$. E l'$AR$? Definiamo$$Z=\\sum_{i=1}^nx_i\\leq|V^*|$$Ma è anche vero in generale che $y_i\\leq2x_i$, quindi$$|V'|=\\sum_iy_i\\leq2\\sum_ix_i=2Z\\leq2|V^*|$$\n<span style=\"color:#FFA500\">Questa dimostrazione mi sembra fallace. Chi lo dice che $Z\\leq |V^*|$?? Banale controesempio: metto la logica di separazione a $1\\over2$, e $x_i\\in [0,1]$. Tutti i vertex \"giusti\" sono identificati da $x_i = 1$ (o se preferite $0.\\overline{9}$...) e tutti quelli sbagliati da $0.5-\\varepsilon$. Ammettiamo che la soluzione trovata sia quella esatta, o (indifferente) sia sbagliata di un solo nodo e il numero di nodi è $\\gg1$. Allora $Z={3\\over2}|V^*|$.</span>","x":6811,"y":-3308,"width":545,"height":1083,"color":"3"},
		{"id":"8e6064b195e14846","type":"text","text":"# Greedy Approximation  Algorithms\nSi basano sul selezionare e rimuovere un edge alla volta, che ha costo $O(n+m)$.\n\n- $n$ perché faccio un ciclo for su tutte le possibili coppie $(u,v)$ in cui $u$ è fissato ma $v$ no, $m$ perché poi devo trovare l'edge da rimuovere all'interno di $E$.\n\nIn più, Greedy 2 deve fare ricerca sequenziale sui nodi per trovare quello con grado massimo, quindi il suo costo diventa $O(m(n+m))$.","x":5611,"y":-3760,"width":729,"height":250,"color":"4"},
		{"id":"c6dab239c4b403e2","type":"text","text":"# Soluzioni Approssimate\n\nLa soluzione esatta è semplice: prendo un set di $n$ variabili binarie $\\{x_i\\}$ che valgono $1$ se il nodo $1$ appartiene alla VC e $0$ viceversa e minimizzo $\\sum_ix_i$ sotto il constraint che $$x_i+x_j\\geq1\\quad\\forall (i,j)\\in E$$ i.e. se $x_i$ ed $x_j$ sono collegati da un edge, allora almeno uno dei due deve essere $\\in VC$. Questa formulazione ha senso per \"piccoli\" input, perché è $\\NPC$, almeno fintantoché le $x_i$ sono vincolate ad assumere valori interi. Ci sono quindi diversi modi per trovare un algoritmo che approssima la soluzione:\n\n- Rilasso la condizione sui valori interi $\\so x_i\\in\\mathbb{R}$.  Il problema diventa $\\in\\P$, ma per via dell'ambiguità di scelta ($x_i=0.6\\stackrel{?}{\\so}i\\in VC$) la soluzione non sarà più esatta;\n- Cerco delle euristiche per produrre degli algoritmi ***greedy***;\n- Sfrutto il problema duale del ***matching***.\n\nPosso valutare la \"bontà\" della soluzione approssimata tramite il rapporto\n\n$$AR=\\text{approx ratio}={\\text{dimensione della soluzione ottimale}\\over\\text{dimensione della soluzione approssimata}}\\in(1,\\infty)$$\nEsistono teoremi che dimostrano un limite inferiore per l'AR di qualsiasi soluzione approssimata. Ad oggi sembra essere $1.3606$, ma in pratica la maggior parte degli algoritmi si aggirano sul $2$ (i.e. sono delle $2$-approximation).","x":5611,"y":-3340,"width":729,"height":596,"color":"4"},
		{"id":"95f89f0231d71765","type":"text","text":"# Maximum Matching Approximation Algorithm\n\nDato un solver che trova il MM, è sufficiente aggiungere alla VC tutti i nodi che vi compaiono. Risolvibile in $O(m\\sqrt{n})$, dipende dall'efficienza del solver.\n\nAnche qui, otteniamo un limite superiore per l'AR di 2.\n\n`Proof` - Che questo produca una VC è ovvio. Che sia una $2$-approximation si vede dalla diseguaglianza $|M|\\leq|V|$, che quindi implica anche $|M|\\leq|V^*|$, e in questo caso$$|V'|=2|M|\\leq2|V^*|$$","x":5611,"y":-2510,"width":729,"height":285,"color":"4"},
		{"id":"063e09fb76d545e6","type":"text","text":"# Greedy 1\n\nInizializza $V'=\\emptyset$ (che a fine algoritmo sarà la VC) ed $E'=E$, dopodiché finché $E'$ non è vuoto (`while` loop)\n\n- Scegli un $(i,j)\\in E'$ e uno dei suoi due nodi terminali, e.g. $i$;\n- Aggiungi $i$ a $V'$ e cancella da $E'$ tutti gli archi $(i, *)$.\n\nSeppur ragionevole, questa roba ha un pessimo $AR$ nel caso peggiore. Consideriamo un ***grafo bipartito completo*** $K_{n,m}$ in cui $n\\gg m$. È chiaro che $\\{m\\}$ è una VC, ma l'algoritmo potrebbe scegliere solo i nodi del sotto-grafo $n$, e per realizzare una VC è costretto a prenderli tutti. Segue che$$AR={n\\over m}\\gg 1$$<span style=\"color:#FFA500\">A me pare inutile quello che fa lei nelle slides, questa cosa che ho detto mi sembra più che sufficiente a far vedere che nel caso peggiore l'algoritmo fa schifo... EDIT: lo fa per confrontarlo con greedy 2, i casi peggiori coincidono... vabbè inutile</span> ","x":6068,"y":-4451,"width":545,"height":509,"color":"4"},
		{"id":"616050734c119734","type":"file","file":"Cabled Networks/Vertex Cover/OhNoGreedy2.png","x":6068,"y":-4667,"width":545,"height":163},
		{"id":"9b0770ff84448f48","type":"text","text":"# Greedy 2\n\nL'idea è che Greedy 1 sbaglia perché non dà alcuna priorità ai nodi con grado alto. Allora modifichiamo l'algoritmo\n\n- Scegli un nodo $i$ con grado massimo in $V-V'$;\n- Aggiungilo a $V'$ e cancella da $E'$ tutti gli archi $(i, *)$.\n\nPerché questa roba funziona comunque male? Consideriamo il grafo nell'immagine. Dati gli $r$ nodi di sopra, costruiamo i nodi di sotto con la seguente logica:\n\n- Ogni nodo $r_i$ è collegato ad un <span style=\"color:#FFA500\">nodo</span> (i.e. ci sono <span style=\"color:#FFA500\">$r$ nodi</span> di grado 1);\n- Ogni coppia di nodi $(r_{2i},r_{2i+1})$ è collegata ad un <span style=\"color:#FF2800\">nodo</span> (i.e. ci sono <span style=\"color:#FF2800\">$\\floor*{r\\over2}$ nodi</span> di grado 2, perché se $r$ è dispari l'ultimo nodo non è accoppiato a nessun altro);\n- In generale, ci sono $\\floor*{r\\over i}$ nodi di grado $i$, quindi abbiamo$$n = r+\\sum_{i=1}^r\\floor*{r\\over i}\\leq r+r\\sum_{i=1}^r{1\\over i} = \\Theta(r\\log r)$$nodi nel set di sotto.\n\nPer le proprietà dell'algebra modulare, i nodi di grado massimo sono il primo del set di sopra e l'ultimo del set di sotto. Se l'algoritmo parte da quest'ultimo fa una VC avente$$AR = {\\Theta(r\\log r)\\over r}=\\Theta(\\log r)$$","x":5339,"y":-4667,"width":545,"height":725,"color":"4"},
		{"id":"13a6925d665fb511","type":"text","text":"# The Maximum Matching Problem\n\nDefiniamo un ***independent set*** (IS) $S\\subseteq G(V)$ come insieme di vertici tali che $$\\forall u,v\\in S\\quad\\nexists (u,v)\\in E(G)$$In altre parole, i nodi dell'IS non sono collegati da archi. Possiamo allora definire in modo equivalente il VCP dicendo che $V'$ è una $VC$ ***se e solo se*** il suo complemento $V-V'$ è un IS.\n\n- Per contraddizione, se esistesse un arco che collega due nodi del complemento. Allora quei nodi non sono in $V'$, ma quindi quell'arco non è toccato da alcun nodo di $V'$, che non è una VC;\n- Sempre per contraddizione, se $V'$ non fosse una VC significherebbe avere un arco non toccato da alcun nodo di $V'$, quindi entrambi i nodi sono nel complemento, che non è un IS.\n\nIn generale, il numero di nodi in un grafo è dato dalla somma delle dimensioni della MVC e del Massimo IS (MIS). Un altro modo di vedere l'independent set è dal punto di vista degli edges.\n\nUn ***matching*** $M$ di un grafo è un sottoinsieme di archi tali che nessuna coppia di archi $\\in A$ ha vertici in comune. Trovare il ***maximum matching*** è evidentemente il ***problema duale*** della MVC.\n\n`Theorem` - La dimensione del matching è minore o uguale della dimensione della VC:$$|M|\\leq |VC|$$\nNel caso dei grafi bipartiti, il ***teorema di Kőnig*** afferma che vale l'uguaglianza. Inoltre , se $|M| = |VC|$ allora $M$ è un maximum matching e $VC$ è una MVC. <span style=\"color:#FFA500\">Non sono molto sicuro di queste ultime due frasi</span>","x":4411,"y":-2667,"width":820,"height":598,"color":"4"},
		{"id":"38ba0c46c4111daf","type":"text","text":"# Teoremi belli sui Grafi (e dove vengono usati in queste note)\n\n- ***Eulero*** - Un grafo connesso contiene un ciclo euleriano (i.e. un ciclo che attraversa ogni arco esattamente una volta) se e solo se ogni nodo ha grado pari (cfr. ***Data Mule***);\n- ***König*** -  In un grafo bipartito, la dimensione del massimo matching è uguale alla dimensione del minimo vertex cover (cfr. ***Vertex Cover***);\n- ***Handshaking*** - In qualsiasi grafo, il numero di nodi con grado dispari è pari, e la somma dei gradi di tutti i nodi è $2|E|$ (cfr. ***Data Mule***);\n- ***Kuratowski*** - Un grafo è planare (può essere disegnato sul piano senza archi che si intersecano) se e solo se non contiene un sotto-grafo isomorfo a $K_5$​ (grafo completo su $5$ nodi) o $K_{3,3}$​ (grafo bipartito completo su 6 nodi). (cfr. ***Modello di Thompson***, è il motivo per cui il grado del grafo rappresentabile è al più $4$);\n- ***Dirac*** - Un grafo semplice con $n\\geq3$ nodi è hamiltoniano (contiene un ciclo che visita ogni nodo esattamente una volta) se ogni nodo ha grado almeno $n/2$ (non usato direttamente, ma utile per il ***Data Mule***);\n- ***Brooks***: Per un grafo connesso diverso da un ciclo dispari o un grafo completo, il numero cromatico (il minimo numero di colori necessari per colorare i nodi) è al massimo pari al massimo grado $\\D$ dei suoi nodi (cfr. ***Colorazione di un Grafo***);\n- ***Tutte***: Un grafo ha un perfect matching se e solo se, per ogni sottoinsieme $S$ dei suoi nodi, il numero di componenti connesse dispari del grafo rimanente è al massimo pari alla dimensione di $S$ (cfr. ***Perfect Matching***).","x":-1640,"y":-770,"width":935,"height":750,"color":"4"},
		{"id":"b9e0920af020317d","type":"file","file":"Cabled Networks/Butterfly/RecursiveButterfly.gif","x":-4267,"y":-5462,"width":215,"height":400},
		{"id":"1d1bb348e26741be","type":"text","text":"# Butterfly Network (BN)\n\nDisponi dei nodi su una griglia avente $n+1$ colonne (da qui in poi ***layer***) ed $N=2^n$ righe.\n\n- $n=\\log N$ è la ***dimensione*** di tale struttura;\n- $N$ è anche il numero di nodi per ogni layer;\n- La più semplice struttura di questo tipo ha $2$ colonne e $2$ righe, cioè i vertici di un quadrato;\n\t- Incrementando linearmente il numero di layer (i.e. la dimensione), il numero di righe (e quindi il numero di nodi per layer) di questa struttura cresce esponenzialmente.\n- Segue che una griglia $n$-dimensionale ha $N(n+1)$ nodi. \n- Il generico nodo è individuato dalla coppia di coordinate $wi$, dove\n\t- $w$ è una stringa binaria che indicizza la riga (e.g. se ci sono 8 righe servono `3` bit);\n\t- $i$ è un normale intero che indicizza il layer.\n\nQuesto però non è ancora un grafo: mancano gli edges. Come li metto? I nodi possono collegarsi solo tra layer adiacenti, e hanno solo due modi per farlo: il nodo in posizione $(w,i)$ è collegato\n\n- con uno ***straight edge*** al nodo $(w,i+1)$;\n- con un ***cross edge*** al nodo $(w', i+1)$, dove $w$ e $w'$ differiscono solo per l'$i$-esimo bit.\n\t- e.g. `(000, 0)` è collegato a `(100, 1)`, e `(101, 2)` è collegato a `(100, 3)`.\n\nSeguendo queste regole si crea una topologia a strati detta ***Butterfly Network***, che presenta una ***struttura ricorsiva***. Data una BN $n$-dimensionale, è possibile crearne una $(n+1)$-dimensionale tramite le seguenti regole:\n\n1. Duplica la struttura $N\\times M$ aggiungendola sotto all'originale, ottenendo una griglia $2N\\times M$;\n2. Aggiungi un layer a sinistra, quindi una colonna avente $2N$ righe;\n3. Disegna gli edges tra il nuovo layer $1$ e il vecchio layer $1$. Ora hai una BN $2N\\times(M+1)$.\n\nIn questo modo notiamo che il cross edge `(000, 0)`$\\to$`(100, 1)` è un collegamento tra il primo nodo della nuova BN $(n+1)$-dimensionale e il primo nodo del duplicato della vecchia a $n$ dimensioni. Questo suggerisce che i cross edges collegano la metà superiore dell'$i$-esimo layer alla BN inferiore che parte dal layer successivo. Bello, ma a che serve?\n\nIpotizzando di partire da un generico ***nodo di input*** (i.e. un nodo del layer $0$) e voler arrivare ad un generico ***nodo di output*** (i.e. un nodo del layer $n+1$), scegliere se prendere uno straight edge o un cross edge significa fare ***ricerca binaria***.\n\nSeguendo questa logica si finisce per seguire un percorso ottimale, detto ***greedy path***. Fare in modo che il pacchetto segua il greedy path è compito del ***greedy path algorithm***, che in pratica dice ad ogni nodo in che direzione fare forwarding (i.e. seguire il cross o lo straight edge). Come?\n\nOgni nodo è un ***crossbar switch*** (***interruttore multistadio***), ovvero dati input $AB$ e output $A'B'$ può assumere due stati:\n\n- ***Swap*** (***Cross***) - $A\\to B'$ e $B\\to A'$;\n- ***Straight*** (***Bar***) - $A\\to A'$ e $B\\to B'$.\n\nIn pratica, una BN è una ***topologia ottimizzata per fare commutazione di pacchetto***.","x":-5160,"y":-5766,"width":820,"height":1181,"color":"4"},
		{"id":"dd0d131e13f35659","type":"file","file":"Cabled Networks/Butterfly/SimplestButterfly.png","x":-4267,"y":-5766,"width":215,"height":211},
		{"id":"32aacfc0fa15edc0","type":"file","file":"Cabled Networks/Butterfly/GreedyButterfly.png","x":-4272,"y":-6564,"width":225,"height":393},
		{"id":"73186b9e785a6d9f","type":"text","text":"# Greedy Routing Algorithm\n\nAssumiamo sempre di lavorare in una situazione in cui ***al più un pacchetto parte da ciascun nodo di input*** e ***a ciascun nodo di output è indirizzato al più un pacchetto***. \n\nAnzitutto, è ovvio che il greedy path sia unico e che passi esattamente una volta per ogni layer, perché sto facendo ricerca binaria. Ogni layer è l'equivalente di uno step.\n\nDetto questo, il problema sorge quando devo fare $N$ ricerche binare contemporaneamente. Non posso far condividere un singolo edge a più packets, e il problema peggiora al crescere di $N$.\n\n- Nel ***caso migliore*** sono necessari $n$ step per passare dall'input all'output;\n- Prendiamo un edge \"intermedio\" (verde in figura) e costruiamo un albero binario completo verso destra e uno verso sinistra (non è difficile, visto che ogni nodo ha esattamente due link in ingresso e due in uscita). Ogni ramo rappresenta un possibile flusso di informazione che passa per il link verde. Il ***caso peggiore*** è quello in cui tutte le foglie rosse scelgono un greedy path lungo l'albero rosso (i.e. devono andare alle foglie blu). Se in `(000, 1)` arrivano due pacchetti insieme, uno dei due va messo nella ***queue*** e vedrà un ***delay*** di uno step.\n\t- Ma questo è un caso con $n = 3 \\Rightarrow N = 8$. Con $n=4$ possono arrivare $2$ pacchetti a quelli che in figura sono i nodi `(000, 0)` e `(100, 0)`, quindi `(000, 1)` potrebbe dover smaltire ininterrottamente $4$ pacchetti (i.e. ha throughput $X \\neq 0$ per $4$ step consecutivi). E se $n=5$? Intuitivamente avrà $X\\neq0$ per $8$ step consecutivi;\n\t- In generale, un pacchetto che passa dal generico edge $e_i$ può essere ritardato al più per un numero di step $n_i - 1$, dove $n_i$ è il numero di greedy paths passanti per $e_i$.\n\t\t- Non per forza tutte le $2^{i-1}$ foglie dell'albero blu scelgono proprio un greedy path passante per $e_i$, quindi in generale $n_i \\leq 2^{i-1}$ ( e analogo a destra, $n_i\\leq2^{n-i}$);\n\t- A questo punto, il delay totale del pacchetto è la somma di tutti i delay che può incontrare in ogni nodo che attraversa:$$\\sum_{i=1}^n (n_i - 1)= \\bigg[\\sum_{i=1}^{A={n+1\\over 2}}+\\sum_{i=B={n+3\\over2}}^n\\bigg](n_i+1)\\leq \\sum_{i=1}^A(2^{i-1}-1)+\\sum_{i=B}^n(2^{n-i}-1) \\leq 2^{n+1\\over2}+2^{n-1\\over2}-n$$dove ho spezzato la somma tra ritardo incontrato nei nodi dell'albero blu e rosso, maggiorato secondo il criterio del punto precedente ed eseguito la somma. Segue che nel caso peggiore il greedy routing algorithm è $O(\\sqrt{N}) = O(2^{n\\over2})$.\n\t- Il fatto che questa struttura possa portare a delay la rende una ***blocking topology***.\n\nOra, la domanda è: a che mi serve un algoritmo che ci mette un tempo esponenziale rispetto alla dimensione del problema? ... perché a quanto pare in pratica il caso medio gira in $\\sim n + o(n)$ step. Così, senza dimostrazioni. Ma allora cosa l'ho fatto a fare il caso peggiore? Boh, ci fidiamo.","x":-5160,"y":-6864,"width":820,"height":993,"color":"4"},
		{"id":"7cef3692c96911ff","type":"file","file":"Cabled Networks/Butterfly/RecursiveButterfly.png","x":-4267,"y":-4985,"width":215,"height":400},
		{"id":"1ea4e9935cbc3ccb","type":"file","file":"Cabled Networks/Butterfly/ButterflyIndicizzazione.png","x":-5620,"y":-5711,"width":225,"height":399},
		{"id":"f9aff2fe04035044","type":"file","file":"Cabled Networks/Butterfly/BenesMultipath.png","x":-7460,"y":-5524,"width":399,"height":193},
		{"id":"027c0cd624270dfd","type":"file","file":"Cabled Networks/Butterfly/RecursiveBenes.png","x":-7460,"y":-5276,"width":399,"height":201},
		{"id":"987d223816397269","type":"file","file":"Cabled Networks/Butterfly/Butterfly.png","x":-5720,"y":-5015,"width":425,"height":400},
		{"id":"2e2ca95eba644e09","type":"file","file":"Cabled Networks/Butterfly/NodeDisjointLooping.png","x":-7460,"y":-5005,"width":400,"height":177},
		{"id":"6d3314bb9107a820","type":"text","text":"# Non-Blocking Topology (GPT)\n\nUna rete ha una **topologia non-bloccante** se è possibile stabilire una nuova connessione tra una coppia di nodi sorgente e destinazione **senza dover interrompere** le connessioni esistenti. In altre parole, una rete non-bloccante garantisce che, indipendentemente da quante connessioni siano già attive, è sempre possibile stabilire nuove connessioni, a condizione che ci sia un percorso disponibile, senza interferire con i percorsi già in uso.","x":-5757,"y":-6514,"width":500,"height":294,"color":"5"},
		{"id":"415ae513e0597c9f","type":"text","text":"# Beneš Network (BšN) e Looping Algorithm\n\nVorrei tanto costruire una ***non-blocking topology***. Posso farlo se esistono più percorsi per andare dal nodo A di input al nodo B di output e se posso modificare i percorsi in corso d'opera. La BšN permette di fare proprio questo, e viene realizzata giustapponendo due BN specchiate.\n\nFormalmente, una ***rearrangeable network*** (RN) è una rete tale che per ogni permutazione $\\{i_i\\to \\pi(i_i) = o_j\\}$ (i.e. per ogni possibile set di regole che manda l'$i$-esimo input nel $j$-esimo output) è possibile costruire un set di ***edge-disjoint paths***.\n\nIl fatto che la BšN sia una RN si dimostra per induzione.\n\n- Il caso $n=0$ è banale, in quanto l'intera rete è un solo nodo;\n- Assumo vero il caso $n-1$ e dimostro per $n$. Ma una BšN di dimensione $n$ è composta da una BšN di dimensione $n-1$ con l'aggiunta dei layer di input e di output, quindi mi basta costruire dei percorsi senza conflitti tra i primi due layer e tra gli ultimi due.\n\t- L'idea è iniziare con un path che passa dalla upper sub-network, ed una volta raggiunto l'output rientrare nello stesso nodo e passare dalla lower sub-network;\n\t\t- Dentro la singola sub-network faccio esattamente la stessa cosa.\n\t- Questo procedimento prende il nome di ***looping algorithm***. La configurazione finale è tale che si possa creare un loop in cui si seguono tutti i percorsi \"senza mai staccare la penna dal foglio\" (i.e. parto dall'input `1` e raggiungo il suo output, rientro da un diverso output e raggiungo il relativo input, e via dicendo) e senza mai passare due volte per uno stesso edge (i.e. ***edge-disjoint***); \n\t- Esiste una variante in cui ogni nodo di input ha un solo ingresso. In questo caso è possibile costruire un loop (quindi dei percorsi) ***node-disjoint***.\n\nIl problema di tutto questo è che servirebbe un ***global control*** per comunicare la configurazione degli switch data la permutazione. Esistono metodi per evitarlo, ma vanno oltre gli scopi del corso.\n\nResettare gli switch, in ogni caso, richiede un tempo $\\Theta(N\\log N)$ ad ogni cambio di configurazione.","x":-6800,"y":-5559,"width":820,"height":767,"color":"4"},
		{"id":"d274be6ad99d7896","type":"file","file":"Cabled Networks/Layouts/GraphToCollinearize.png","x":-4006,"y":-2131,"width":116,"height":120},
		{"id":"4d081cb1dc52385a","type":"file","file":"Cabled Networks/Layouts/GraphCollinearized.png","x":-3846,"y":-2131,"width":300,"height":120},
		{"id":"f217cb40d8312551","type":"file","file":"Cabled Networks/Layouts/OrthogonalCollinear.png","x":-3890,"y":-1919,"width":300,"height":308},
		{"id":"61ea744984748c18","type":"text","text":"# Bisection Width\n\nQuanti edges devo tagliare per dividere una rete in due sotto-reti aventi lo stesso numero di nodi?\n\nIn un grafo completo questo numero, detto ***bisection width*** di dimostra essere $n^2/4+o(n^2)$. A che mi serve? Si dimostra essere il lower bound per il numero di tracks in un collinear layout.<span style=\"color:#FFA500\"> Dico \"si dimostra\" perché sulle slides la dimostrazione è criptica e non mi va di approfondire. Ci sarebbe anche da chiedersi se davvero serve solo a questo, ma di nuovo, non mi va. AGGIUNGI TEOREMA LOWER BOUND SLIDE 33</span>","x":-3972,"y":-1460,"width":464,"height":380,"color":"4"},
		{"id":"bc7307e7d62eb05d","type":"text","text":"# EVC Notevoli\n\n- ***Cicli*** - Dato un grafo ciclico con $n\\geq3$ vertici, è sufficiente posizionare le guardie su nodi alterni. Qualsiasi nodo venga attaccato, è sufficiente ruotare la EVC di $1$. Abbiamo quindi che$$\\a^\\infty(C_n)=\\a(C_n)=\\ceil*{n\\over2}$$\n- ***Path*** - Dal momento che il grafo","x":1930,"y":-4611,"width":660,"height":613},
		{"id":"ccd5d58aee1a1854","type":"text","text":"# Wireless Networks Algorithms\n\nSe le comunicazioni avvengono in aria bisogna anzitutto risolvere il problema dell'interferenza, tipicamente tramite una ***assegnazione di frequenze*** (i.e. ***minima colorazione del grafo***).\n\nDal momento che questo tipo di comunicazione è particolarmente energivora per sistemi a batteria (e.g. ***sensori***), si pone il problema dell'***efficienza***. Se poi più sensori devono eseguire una task cooperativa, è necessario un ***coordinamento***.","x":-480,"y":198,"width":820,"height":237,"color":"6"},
		{"id":"cf03900286e23529","type":"text","text":"# Wireless Sensor Networks (WSN)\n\nCi sono due scenari principali in cui ho a che fare con una WSN.\n\n- ***Static WSN*** - Sono tendenzialmente legate alla raccolta dati. La topologia della rete è nota, ma nascono problemi di ***efficienza energetica*** (in vista di un utilizzo a lungo termine);\n- ***Dynamic WSN*** - Sono legate a compiti sul breve termine, motivo per cui l'interesse principale è ***ottimizzare il compito cooperativo*** loro richiesto.","x":-480,"y":920,"width":820,"height":234,"color":"6"},
		{"id":"7ff3d7cc9445913c","type":"text","text":"# \\[Xal14\\] Paper\n\nDobbiamo far comunicare in wireless e nel modo più efficiente possibile un gruppo di veicoli senza controller centralizzato, che era invece la norma nello stato dell'arte al 2014.\n\nSpero che questo paper verrà eliminato come scelta da questo esame.","x":15828,"y":184,"width":910,"height":265,"color":"6"},
		{"id":"2b58db98d883eb5c","type":"text","text":"# Minima Assegnazione di Frequenze\n\nAssegnazione delle Frequenze\n\nNon è vero - il problema non è limitato al singolo provider!!! E gli effetti di bordo???? E il fatto che in Albania prendono la Rai????\n\nh, k sono interpretabili come canale (i.e. range di frequenze)\n\nnon capisco se h e k sono i parametri da trovare o cosa. cioè, devo trovare L(h,k) minima (L sarebbe la bandwidth?? che stiamo facendo??)\n\n- No, h e k sono dati in partenza dal problema\n- No, L è la colorazione risultante, i.e. è in set di nodi con relative frequenze\n\nCosa devo minimizzare allora? il numero di frequenze utilizzate sia perché altrimenti devi comprarne di più sia per ottimizzare (l'entropia? l'energia? non so come dirlo, ma è chiaro che più frequenze uso più il sistema it's a mess, also se devo gestire 10 frequenze diverse in un singolo device serve più energia. ma questo mi sa che non succede...?). constraints:\n\n- ci sono normative che limitano l'uso di certe frequenze\n- devo considerare sia interferenze intra-ISP che inter-ISP\n- una particolare assegnazione di frequenze potrebbe incentivare o limitare il traffico? Approfondire!\n\nin genere h è un constraint rigido (i.e. due nodi adiacenti devono differire per ESATTAMENTE h canali), mentre k è più morbido (i.e. nodi distanti 2 devono differire di ALMENO k canali)\n\nSta roba è NP-Complete, sia che si tratti di determinare se una soluzione esiste sia trovarla (si fa in entrambi i casi bruteforce).\n\nla colorazione si indica con $\\sigma$, ma i colori sono $\\sigma+1$ \n\nteorema interessante - possiamo restringerci ad h,k coprimi (se non lo sono, la soluzione è la stessa dei rispettivi minimi termini).\n\n- Segue che se h=k allora h=k=1 che coincide con il vertex cover.\n- h=2k è il caso più studiato","x":19678,"y":-483,"width":800,"height":932},
		{"id":"75e3f9291afb2635","type":"text","text":"# NP-Completeness\n\nLa versione decisionale del labeling L(2,1) si chiama DL.\n\nConsideriamo IDL e dimostriamo che è NP-complete, e che poi DL si riduce a IDL in tempo polinomiale. \n\nIDL è equivalente al problema del cammino hamiltoniano\n\nordiniamo i nodi secondo il colore $i\\in [0,|V|)$. Segue che non c'è alcun edge tra i nodi $v_i$ e $v_{i+1}$, if you switch in the ***complement*** graph there is a path (ovvio). Quindi IDL su G è equivalente su hampath su $\\overline{G}$.\n\n- $DL\\in NP$ è ovvio, data una soluzione è verificabile in tempo polinomiale (devo fare due check: se il massimo numero di colori è V e se per ogni edge i colori agli estremi distano almeno 2);\n- Riduzione da IDL a DL: costruiamo un nuovo grafo aggiungendo un nodo x a G (connesso a tutti gli altri nodi) rendendolo un G' che è sempre di ***diametro*** 2. esiste una f biettiva tale che$$|f(x)-f(y)|\\geq2 \\forall(x,y)\\in E(chi è E??) \\iff \\lambda_{2,1}(G')\\leq|V'|$$orcod\n\nla stella si può scrivere come $K_{1,t}$ in quanto grafo perfettamente bipartito con 1 da una parte e t dall'altra\n\nogni volta che serve un upper bound è sufficiente trovare un algoritmo che realizza il compito. il numero di step necessari magari non è ottimale, ma è appunto un upper bound","x":20638,"y":-483,"width":800,"height":932},
		{"id":"77ba41fe37aca09d","type":"text","text":"# Minima Assegnazione di Frequenze - Riassunto\n\nSe due canali di comunicazione wireless geograficamente vicini usano frequenze troppo vicine avrò interferenza. Una soluzione ovvia è scegliere sempre frequenze lontane tra loro, ma nel farlo devo considerare che il range di frequenze a mia disposizione è spesso limitato per vari motivi:\n\n- regolamenti (e.g. posso legalmente utilizzare frequenze solo in un certo range)\n- limiti tecnici (e.g. non posso usare le microonde per una trasmissione radio);\n\nIn pratica, bisogna minimizzare il numero di frequenze. Schematizziamo così il problema:\n\n- Lo spettro è diviso in ***slot*** (e.g. la ***banda*** $500$ potrebbe prendere il range $[500, 600]Hz$);\n- Ad ogni slot viene assegnato un numero di ***canale*** (e.g. la banda $500$ diventa il canale $5$);\n- Risolvo il problema $L(2,1)$ in cui i canali sono i colori, ovvero\n\t- A nodi adiacenti sono assegnati canali che differiscono di ***almeno*** $2$;\n\t- A nodi vicini sono assegnati canali che differiscono di ***almeno*** $1$.\n- Assegnare un colore ad un nodo significa che questo può ***trasmettere*** solo su quel canale. Ogni nodo è in grado di ***ascoltare*** su qualsiasi canale ammesso dalla colorazione.\n\nEssendo un problema $\\NPC$, non è facile trovare soluzioni esatte. Ci si riesce per grafi con particolari simmetrie definite, come i path, i cicli e le grid, altrimenti ci stanno lower ed upper bounds che non riporto perché non mi va.","x":3210,"y":34,"width":820,"height":565,"color":"4"},
		{"id":"07c729782ba8ac2d","type":"text","text":"# Shortest Path su IT\n\nNel modello teorico di una IT, assumiamo costi statici e cerchiamo un algoritmo di shortest path.","x":-2631,"y":-3992,"width":435,"height":120,"color":"6"},
		{"id":"c32d8ea37fb31cb0","type":"text","text":"Nodo convoluto quasi quanto questo corso","x":-2608,"y":-3699,"width":389,"height":50},
		{"id":"b6989927b66669c2","type":"text","text":"# Mobile Element Scheduling (MES)\n\nIl problema è in realtà un po' più complesso rispetto al TSP. Ogni sensore ha un buffer finito in cui salva i dati in attesa del Mule, e la sfida è trovare un percorso tale che nessuno vada in buffer overflow. Dal momento che diversi sensori hanno in generale diversi rate di raccolta dati e diverse dimensioni del buffer, potrebbe essere necessario passare più volte nello stesso sito prima di tornare alla base.\n\nQuindi, se in TSP i costi sono fissi, in MES bisogna inserire nelle equazioni delle ***deadline dinamiche***. (In ogni caso è utile partire da TSP per poi complicare la cosa)","x":-10910,"y":1742,"width":547,"height":359,"color":"4"},
		{"id":"16f55a6de0f9c077","type":"text","text":"# TSP come ILP\n\nSi può formulare TSP come ILP. Definiamo le variabili booleane come $x_{ij}=1 \\iff (i,j)\\in HC$ e $x_{ij}=0$ altrimenti e usiamo la funzione di peso $w_{ij}$. L'obiettivo è minimizzare$$\\min\\bigg[\\sum_{i,j}^Nw_{ij}x_{ij}\\bigg]\\quad s.t.\\quad\\sum_{i}^Nx_{ij}=\\sum_{j}^Nx_{ij}=1\\quad\\text{and}\\quad\\sum_{i,j\\in S}x_{ij}<|S|$$dove i constraints mirano a garantire che\n\n- da $i$ parte uno ed un solo arco, e a $j$ punta uno ed un solo arco;\n- una ***cycle cover*** (i.e. quando grafo viene ricoperto da cicli disgiunti) non sia una soluzione. $S$ indica un generico subset proprio di nodi di $V$, e se i suoi nodi sono collegati da un ciclo allora il numero di archi sarà uguale al numero di nodi. Per evitare questa possibilità impongo una disuguaglianza di minore stretto, detta ***subtour elimination constraint***.\n\t- Questa cosa va fatta $\\forall S\\ss V$, quindi abbiamo un numero esponenziale di constraints!","x":-11047,"y":2328,"width":820,"height":423,"color":"4"},
		{"id":"8c76a0adfff8363b","type":"text","text":"# Travelling Salesman Problem (TSP)\n\nSia $G=(V,E)$ un grafo non orientato. Sappiamo che determinare se $G$ contiene un HC è $\\NPC$.\n\nQuesto però non è TSP, perché il Data Mule può muoversi tra qualsiasi coppia di nodi. Sia $K_n(V,E')$ un grafo completo tale che $E\\ss E'$ e $t\\in\\R^+$. È chiaro che $K_n$ contiene almeno un HC, ma ne contiene uno il cui costo è minore di $t$? O in modo analogo, qual è il minimo $t$ take che $K_n$ ha un costo $\\leq t$?\n\n***`Theorem`*** - Quest'ultimo problema, anche detto TSP, è $\\NPC$. Segue `proof`.\n\n- Sicuramente TSP $\\in\\P$. Verificare che un ciclo sia un HC ha costo $O(|V|)=O(n)$, e fare la somma dei costi per verificare che essa sia $\\leq t$ è $O(|E'|)=O(m)$;\n- Sappiamo che HC $\\in\\NPC$, basta trovare una riduzione da HC a TSP.\n\t- Definiamo una ***weight function*** $w$ tale che\n\t\t- $w(i,j)=1$ se $(i,j)\\in E$ (i.e. hanno costo $1$ gli archi $\\in G\\ss K_n$);\n\t\t- $w(i,j)=2$ se $(i,j)\\in E'-E$. (i.e. hanno costo $2$ gli archi di $K_n$ che non compaiono in $G$)\n\t- Assumiamo che $G$ abbia un HC. Visto che $G\\ss K_n$, allora esiste un HC su $K_n$ di costo $t$, dove $t$ è il numero di archi dell'HC $\\in G$, che coincide con il costo complessivo, essendo $=1\\forall (i,j)\\in E$, e che coincide con il numero di nodi di $G$, essendo la soluzione un HC, e che quindi coincide con il numero di nodi $n$ di $K_n$ (in breve: in questa costruzione $t=n$);\n\t- Viceversa, se $K_n$ ha un HC di costo $t=n$ significa che gli archi che ha utilizzato hanno tutti costo $1$, quindi sono tutti $\\in E$ e quindi $G$ contiene un HC.\n\nIl grosso problema è che non solo TSP è $\\NPC$, lo è anche un qualsiasi algoritmo $r$-approssimante. Questo significa che ***TSP non è in generale approssimabile entro una costante***.\n\nAnche qui, ci sono situazioni particolari in cui questo limite si aggira. Se $w$ rispetta la disuguaglianza triangolare $w(a,c) ≤ w(a,b)+w(b,c)$ (e.g. $w$ è una ***distanza euclidea***, guarda caso proprio quella che ci serve) possiamo trovare fino ad una $1.5$-approssimazione.","x":-9995,"y":2508,"width":910,"height":727,"color":"4"},
		{"id":"99acb315effd1dbf","type":"text","text":"# Non-Approssimabilità di TSP\n\n`Theorem` - Se esiste un algoritmo $\\in\\P$ che produce una $r$-approssimazione per TSP, allora $\\P=\\NP$.\n\n`Proof` - L'idea è dimostrare che se TSP è $r$-approssimabile, allora esiste un algoritmo $\\in\\P$ che fornisce una soluzione esatta per l'HC. Siano $G$ e $K_n$ definiti come prima. Generalizziamo la weight function $w$ definita in precedenza:\n\n- $w(i,j)=1$ se $(i,j)\\in E$\n- $w(i,j)=2 +(r-1)n$ se $(i,j)\\in E'-E$.\n\nSe $r=1$ (soluzione esatta) torniamo correttamente alla $w$ precedente, quindi sappiamo che$$K_n\\text{ ha un HC di costo }n\\iff G\\text{ contiene un HC}$$\nUn algoritmo $r$-approssimante trova quindi una soluzione di costo al più $r\\cdot n$. I casi sono due:\n\n- La soluzione contiene solo gli archi ottimali. In questo caso, è la soluzione esatta. Ma l'ho trovata in tempo polinomiale, quindi ho risolto HC su $G$ in tempo polinomiale, quindi sto dicendo che ho trovato un algoritmo $\\P$ per un problema $\\NPC$, da cui segue $\\P=\\NP$;\n- La soluzione contiene un edge $\\notin E$, quindi quantomeno tolgo un arco ottimale e lo sostituisco con un arco sub-ottimale (o peggio), il che si traduce nel dire che $$\\text{Cost}(H)\\geq n - 1 + 2+ (r-1)n=r\\cdot n+1$$Questo contraddice l'ipotesi di algoritmo $r$-approssimante.","x":-11047,"y":2807,"width":820,"height":606,"color":"4"},
		{"id":"70df56e5a6d283e3","type":"text","text":"# Algoritmi Approssimanti per `TSP`\n\nSe $w$ è una metrica (i.e. $w$ rispetta la disuguaglianza triangolare) arrivo fino ad una $2$-approssimazione. Se poi uso quella simpatica metrica chiamata distanza euclidea arrivo fino a $1.5$.\n\nNel farlo teniamo in considerazione che se $T$ è un MST sul grafo, $P$ è un path e $H^*$ la soluzione ottimale per HC,$$w(T)\\leq w(P)\\leq w(H^*)$$cioè il peso di un qualsiasi MST è un lower bound per la soluzione $H^*$ di HC.","x":-9995,"y":3648,"width":910,"height":261,"color":"4"},
		{"id":"d1ed892b5da0140a","type":"text","text":"# Nota sulla Non-Approssimabilità\n\nQuando dimostro che un certo problema non è $r$-approssimabile, intendo sempre nel caso generale (i.e. in qualsiasi dimensione, per qualsiasi funzione dei pesi, ...).\n\nSpesso nei casi di interesse pratico l'approssimazione polinomiale esiste.","x":-12020,"y":3020,"width":687,"height":180,"color":"4"},
		{"id":"a745896f4c0a6e74","type":"text","text":"# MST + Data Mule\n\nMST e Data Mule vengono generalmente usati insieme, perché ottimizzano due aspetti differenti.\n\nMST non è ottimale per raccogliere le informazioni dai sensori. Questo perché una comunicazione multi-hop all-to-all così costruita è squilibrata in termini di energia e di complessità:\n\n- Se tutti mandano i dati raccolti al ***sink***, i nodi sono sempre costretti ad usare tutta la potenza necessaria a raggiungere il primo vicino sul MST, quindi si scaricano più rapidamente (specie quelli vicini al sink, perché sono quelli più spesso chiamati in causa);\n- Per evitare le `broadcast storm`, ogni nodo dovrebbe implementare protocolli di routing.\n\nOvviamente, il Data Mule non è ottimale per trasmettere informazioni di controllo ai nodi perché non sai mai quando li raggiungerà.\n\nInoltre, per via della sua struttura ottimizzata MST ha davvero poca ***fault tolerance***: se si guasta un nodo, il suo sotto-albero viene di fatto disconnesso. Il Data Mule può mitigare il problema, ma in genere si tende a creare una struttura di partenza con più ridondanza rispetto al MST.","x":-8375,"y":2807,"width":820,"height":459,"color":"4"},
		{"id":"898ca3659127a5c2","type":"text","text":"# Definire gli Archi\n\nNonostante il suo range di azione sia in linea di principio infinito, la potenza del segnale in aria decade come ${1\\over r^\\a}$. Questo significa che oltre una certa distanza sarà pressoché inintelligibile.\n\nDefiniamo quindi un ***transmission range*** $R$ tale che due nodi $u$ e $v$ sono collegati da un arco se e solo se la loro distanza è $<R$:$$R\\,:\\,\\{(u,v)\\in E \\iff \\dist(u,v)<R\\}$$\nQuesto per evitare che il nodo sia tentato di urlare troppo forte se il collegamento è molto debole.\n\nSicuramente è il dispositivo stesso ad avere un ***limite di potenza*** oltre il quale non può trasmettere, ma anche restando al di sotto di esso alzare $R$ significa consentire al nodo di sparare più forte, il che potrebbe portarlo a consumare più batteria (dipendentemente dalla soluzione del MST: magari a quel nodo è sufficiente sussurrare ad un nodo vicino per raggiungere il resto della rete, o può essere costretto ad usare tutta la potenza a sua disposizione). Di contro, un $R$ troppo basso potrebbe produrre un grafo non connesso.","x":-7965,"y":3909,"width":820,"height":456,"color":"4"},
		{"id":"6bc931ed33956145","type":"text","text":"# Non un MST, ma...\n\nPotrei provare a risolvere il problema del minimo costo del broadcast senza costruire un MST.\n\n- ***SPT*** (***Spanning Path Tree***) - Uso ***Dijkstra*** per costruire il percorso di costo minimo verso ogni singola foglia. Dista dalla soluzione ottimale $\\e^2 + {n\\over2}(1-\\e)^2$, dove non ho capito bene chi è $\\e$, ma per qualche motivo alla fine fa un commento su $\\e\\to0$;\n- ***BAIP*** (***Broadcast Average Incremental Power***) - Variante di Dijkstra in cui scelgo se aggiungere un nodo allo ST con la seguente logica:\n\t- Definisco un `Minimum Average Cost` = `Energy Increase`/`# of Nodes in the Tree`;\n\t- Se per il nodo che Dijkstra vorrebbe aggiungere questo valore è $<1$, accetto.\n\t- L'efficienza media, definita come `Potenza Complessiva`/`# Nodi Raggiunti`, è in questo caso $=1$ (per qualche motivo che non mi è chiarissimo);\n\t- Calcolando la minima potenza usata, si trova che questo metodo è una$$\\bigg({4n\\over\\log n}+O(1)\\bigg)-\\text{approssimazione}$$\n","x":-7965,"y":5181,"width":820,"height":466,"color":"3"},
		{"id":"b2ede386eecbdbc3","type":"file","file":"Wireless Networks/Fixed WSN/KissMeSphere.png","x":-7755,"y":6261,"width":400,"height":209},
		{"id":"b0c24905e1ce0e5d","type":"text","text":"# Euclidean TSP ($1.5$-approssimazione)\n\nIl ***Christofides Algorithm*** abbassa l'approximation ratio sempre sfruttando MST.\n\n- Scegli un nodo radice $r\\in K_n$ e calcolane un MST $T$;\n- Sia $O$ il set di nodi di $T$ aventi grado dispari, e sia $G_O$ il sub-grafo indotto da $O$;\n\t- Ogni MST ha un numero pari di nodi aventi grado dispari (cfr. ***Handshaking Theorem***).\n- Esegue un ***perfect matching*** su $G_O$, cioè organizza a coppie i nodi di $G_O$ scegliendo gli archi che minimizzano il costo complessivo e creando il grafo (non connesso) $M$;\n\t- È sempre possibile perché sono partito da un grafo completo (cfr. ***Lemma di Berge***)\n- Unisce $M$ e $T$, creando una duplicazione degli archi sui nodi di grado dispari (i.e. crea un ***multigrafo***). Il risultato è un grafo in cui ogni nodo ha grado pari;\n- Crea un ***ciclo euleriano***, cioè un ciclo che passa da ogni arco esattamente una volta (sempre possibile in quanto ogni nodo ha grado pari, cfr. ***Teorema di Eulero***);\n- Converti il ciclo euleriano in un ciclo hamiltoniano. Chiaramente non potrà essere esattamente un $H^*$, ma come detto l'approximation rate è al più $1.5$.\n\n`Theorem` - Se $w$ è una metrica, questo algoritmo è una $1.5$-approssimazione.\n\n`Proof` - Dividiamo gli archi $M$ della soluzione ottimale $H^*$ (***grafo orientato***) in due subset:\n\n- $M_o$, il cui nodo di partenza aveva originariamente grado dispari su $K_n$;\n- $M_e$ stessa cosa con i nodi di grado pari.\n\nQuesti subset sono tali che $w(M_o)+w(M_e)=w(H^*)$, e per almeno uno dei due subset (e.g. w.l.o.g. $M_o$) deve essere vero che$$w(M_o)\\leq {1\\over2}w(H^*)$$\nA questo punto l'algoritmo fa un perfect matching $M$ di $G_O$, ottenendo un peso complessivo migliore rispetto a quello di $M_o$, per cui$$w(M)\\leq w(M_o)\\leq {1\\over2}w(H^*)$$\nQuando infine sommo questo grafo con l'MST creato all'inizio, il peso complessivo della soluzione sarà minore della somma dei pesi dei due contributi (magari ci stanno archi in comune che non si sommano). Sapendo che $w(T)\\leq w(H^*)$ e applicando entrambi gli upper bound abbiamo che$$w(H)\\le w(M)+w(T)\\le {1\\over2}w(H^*)+w(H^*)={3\\over2}w(H^*)$$","x":-9415,"y":4228,"width":820,"height":953,"color":"4"},
		{"id":"f02c829c1a6717bd","type":"text","text":"# Metric TSP ($2$-approssimazione)\n\nChiamiamo l'algoritmo \"`2-Approx-mTSP`\" e vediamo come agisce.\n\n- Scegli un nodo radice $r\\in K_n$ e calcolane un MST;\n- L'HC approssimato è una sua visita in ***preordine*** $L$ senza ripetizioni.\n\n`Theorem` - Se $w$ è una metrica `2-Approx-mTSP` è una $2$-approssimazione.\n\n`Proof` - Sappiamo che $w(T)\\leq w(H^*)$. In una visita in preordine ogni edge compare esattamente due volte, quindi la soluzione approssimata $C$ così costruita è tale che $w(C)=2w(T)$. Questo prova l'uguaglianza, ma possiamo eliminare qualche arco ridondante ed abbassare il costo, grazie alla disuguaglianza triangolare (e.g. se devo visitare i nodi $A$, $B$ e $C$ tutti connessi tra loro, posso fare $A\\to B$ e poi direttamente $B\\to C$ dove invece il preordine su un albero prevede $B\\to A\\to C$).\n\nIn definitiva, $$w(H) ≤ w(C) =2 w(T) ≤ 2 w(H^*)$$","x":-10485,"y":4486,"width":820,"height":438,"color":"4"},
		{"id":"aa34b39e6cc56ccf","type":"file","file":"Wireless Networks/Fixed WSN/PreOrder.gif","x":-11070,"y":4613,"width":400,"height":184},
		{"id":"a73d0d136ca95187","type":"text","text":"# Soluzioni Ancora Migliori & Trivia\n\nDi recente qualcuno ha trovato mediante il Polynomial Time Approximation Scheme (PTAS) un'approssimazione pari a $1+{1\\over c}$ dove $c$ è tale che il tempo impiegato per risolvere il problema è$$O\\bigg(n\\bigg[\\log n\\bigg]^{\\big(O(c\\sqrt d)\\big)^{d-1}}\\bigg)$$e $d$ è la dimensione dello spazio euclideo in cui risolvo il problema. Chissà perché, la gente continua usare euristiche più semplici.\n\nDetto questo, lo sapevi che...\n\n- Se rimuoviamo il vincolo per cui ogni nodo deve comparire solo una volta potremmo trovare soluzioni migliori. Questo però non è vero in caso di TSP metrico (banalmente, vale la disuguaglianza triangolare);\n- Partire da un grafo orientato $K'_n$ dimezza il numero di possibili soluzioni;\n- Il TSP è una di quelle cose che gli esseri umani sono particolarmente bravi a risolvere entro una buona approssimazione. Questo ha aperto diversi occhi in giro per il mondo, alcuni dei quali hanno scoperto che guarda caso anche le reti neurali sono particolarmente brave a farlo.","x":-9995,"y":5528,"width":910,"height":481,"color":"4"},
		{"id":"9795fe394b77892c","type":"text","text":"# Minimum Spanning Tree\n\nQuando invio un segnale in aria, la potenza si conserva sulla superficie della sfera, quindi cala come ${1\\over r^\\a}$, dove in generale $\\a\\geq2$ (è $=2$ solo in assenza di ostacoli).\n\nSe $u$ vuole inviare un messaggio a $v$, la potenza con cui dovrà sparare il segnale è $\\propto \\dist(u,v)^\\a$. Passare per un nodo intermedio $w$ equidistante da $u$ e da $v$ significa passare da un singolo messaggio mandato con potenza $\\sim r^\\a$ a due messaggi a potenza $({r\\over2})^\\a$, ovvero nel complesso ${r^\\a\\over2}$.\n\nSchematizzo i dispositivi come nodi e assegno un peso proporzionale alla loro distanza agli archi tra essi. A differenza del routing, qui non posso fare `unicast`: ogni messaggio è un `broadcast` (i.e. inoltrare un messaggio significa fare `flooding` entro la mia gittata). La domanda è: ***qual è la minima potenza che mi garantisce che la catena di `broadcast` raggiunga tutti gli altri nodi della rete?***\n\nRisolvere questo problema per $u$ è equivalente a trovare il suo ***minimum spanning tree***, i.e. il set di archi tale che l'albero di radice $u$ sia connesso ad ogni altro $v$ e che il costo complessivo sia minimo.\n\nEssendo un problema $\\NPH$, si usano ***algoritmi approssimanti***.","x":-6800,"y":3281,"width":820,"height":456,"color":"6"},
		{"id":"65b789493892badd","type":"text","text":"# Premesse agli Algoritmi Approssimanti\n\nSiamo interessati a fare un ***Broadcast Range Assignment*** minimale, ovvero assegnare ad ogni nodo la minima potenza di trasmissione necessaria a raggiungere ogni altro nodo, i.e. risolvere il ***Minimum-Energy Broadcast*** (`MinBroadcast`) problem. C'è un problema.\n\n`THM` - Non esiste, in generale, un algoritmo polinomiale che approssima `MinBroadcast` entro un fattore costante, i.e. l'approssimazione peggiora al crescere della dimensione del problema.\n\n`Proof` - Dimostro che `MinBroadcast` è polinomialmente riconducibile a `MinSetCover` e dimostro che quest'ultimo non è approssimabile entro un fattore costante.\n\n- `MinSetCover` - Il problema è così definito: abbiamo un ***Universal Set*** $U$ che possiamo pensare come un alfabeto ed $N$ subset $S_i\\ss U$. Posto che $\\bigcup_{i=1}^N S_i = U$ (i.e. se prendo tutti gli $S$, questi ricoprono $U$), qual è il set minimale $\\calS=\\{S_k\\}_{k=1}^{n<N}$ che ricopre $U$ (i.e. $\\bigcup_{k=1}^{n<N} S_k = U$)?\n\t- Ci fidiamo che non è approssimabile per nessuna costante $c\\log|U|$.\n- `Riduzione` - L'idea è costruire un albero a tre layer:\n\t- Il primo layer consta della sola radice, il nodo sorgente $s$ (i.e. $\\calS$), che punta ad $n$ nodi $\\{S_k\\}$;\n\t- Tali nodi formano il secondo layer, che rappresenta gli $n$ subset $\\{S_k\\}$. Ognuno di essi ha al suo interno un certo numero $j_k$ di simboli $\\{U_i\\}^{j_k}_{i=1}$, quindi ogni $S_k$ punta ai rispettivi simboli con $j_k$ archi orientati;\n\t- Gli $N$ simboli $\\{U_i\\}^N_{i=1}$ di $U$ costituiscono l'ultimo layer.\n\t- Assegnando a tutti gli archi lo stesso costo (e.g. $1$), abbiamo mappato la minimizzazione dei subset $\\calS$ alla minimizzazione del costo dello spanning tree.\n\nPur vero questo, nel caso speciale di ***distanza Euclidea $\\dD$*** possiamo fare un po' meglio, e trovare fino ad una $6$-approssimazione. Procediamo allora osservando che\n\n- Possono esistere diversi MST con lo stesso costo complessivo;\n\t- Se tutti i pesi sono uguali ogni ST sul grafo è minimo (pure massimo, se è per questo...);\n\t- Viceversa, se tutti i costi sono diversi il MST è unico. Si dimostra per contraddizione assumendo che non lo sia e vedendo che il costo dell'altro è diverso (non essendo uguale, il MST è unico, come atteso).\n- Se nel grafo è presente un ciclo ed uno degli archi che lo forma ha costo maggiore della somma di tutti gli altri, allora questo arco non potrà essere nel MST (fa una `proof`, ma è ovvio);\n- Se nel grafo è presente un unico arco dal costo minimo, allora questo sarà nel MST;\n- Nelle slides ci sono altre osservazioni, ma non mi pare siano utili.","x":-6800,"y":4228,"width":820,"height":953,"color":"4"},
		{"id":"d3a257d13fa24f9f","type":"text","text":"# Algoritmi Approssimanti per `MinimumSpanningTree`\n\nSono tutti algoritmi greedy basati sulla stessa logica:\n\n- Parti da un set vuoto $A$;\n- Fintantoché $A$ non è un MST aggiungi un ***safe arc***, i.e. tale da non violare le proprietà dell'MST.\n\nIl grafo $G_A$ che va costruendosi consta di diverse componenti connesse, le quali possono essere singoli nodi o alberi. Ogni nuovo arco che viene aggiunto ad $A$ connette due componenti di $G_A$.\n\nIn cosa differiscono i diversi algoritmi?\n\n- ***Kruskal*** - Si basa sulla seguente logica: dato $G_A$, tra gli archi che connettono due componenti connesse disgiunte scegli quello con costo minore;\n\t- Usa la struttura dati ***Union-Find***, che opera su insiemi disgiunti e si basa su due azioni:\n\t\t- **Find** - Dato un elemento, individua l'insieme di cui fa parte;\n\t\t- **Union** - Unione degli insiemi disgiunti;\n\t- Questo significa che si creeranno diverse \"bolle\" che verranno infine collegate tra loro;\n\t- Complessità $O(m\\log n)$ (al solito, $n$ nodi ed $m$ edges);\n\t- ***Ottimale per grafi sparsi*** ($m\\sim n$).\n- ***Prim*** - La logica è collegare la componente connessa già presente con il nodo isolato avente il collegamento meno costoso;\n\t- L'albero si sviluppa come un singolo \"embrione\" che cresce;\n\t- La complessità dipende dalla struttura dati di supporto:\n\t\t- Heap - $O(m\\log n)$;\n\t\t- Fibonacci Heap - $O(m+n\\log n)$\n\t- ***Ottimale per grafi densi*** ($m\\sim n^2$).\n- ***Boruvka*** (o ***Sollin***) - Nell'ipotesi che tutti gli archi abbiano costi diversi (?), fa un ciclo su tutti i cluster $C_i$ e per ognuno di essi sceglie l'arco di costo minore con la stessa logica di Prim.\n\t- L'albero si sviluppa \"a bolle\" come in Kruskal, ma la logica per far espandere queste bolle è simile a Prim (i.e. è una sorta di Prim a più cluster);\n\t- Complessità $O(m\\log n)$;\n\t- Non ho capito bene per cosa è ottimale, [dicono](https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm) in contesti distribuiti e/o paralleli (specie se usato insieme a Prim, e.g. in computazione parallela).\n\nDato un grafo e un suo MST, è più facile ($O(\\log n$)) ricalcolarlo se il grafo cambia leggermente. Ancora più facile ($O(n+m)$) è verificare se uno ST è effettivamente minimo.","x":-6800,"y":5601,"width":820,"height":953,"color":"4"},
		{"id":"a103b01e8a81d674","type":"text","text":"# Altre Applicazioni\n\nOltre al `MinBroadcastProblem`, il MST viene usato in Data Science per compiti di ***clustering*** e di ***image segmentation*** (i.e. una sorta di \"compressione\" in cui i pixel sono nodi e le loro differenze di colore sono il peso degli archi, il mio obiettivo è raggruppare pixel simili per individuare oggetti o aree specifiche (credo eh, non so nulla di computer vision e simili...)).","x":-5635,"y":4002,"width":480,"height":270,"color":"4"},
		{"id":"11d2cdcba60abc54","type":"text","text":"# MST + CDS\n\nNonostante MST non sia ottimale per raccogliere i dati, se non ho un Data Mule sono costretto ad usarlo, provando a far durare quanto più possibile le batterie dei sensori.\n\nImplemento un CDS con Duty Cycle, il che presenta anche dei vantaggi:\n\n- Nessun HW aggiuntivo (che invece sarebbe il Data Mule);\n- Minima latenza nella raccolta dei dati (mentre il DM è un po' come l'autobus).\n\nIl prezzo da pagare è una minore tolleranza ai guasti (quando c'è, il DM fa da backup) ed una minore efficienza energetica.\n\nInoltre, mentre in MST + DM <span style=\"color:#FFA500\">non mi ricordo cosa volevo scrivere eheheh</span>","x":-5225,"y":2807,"width":820,"height":459,"color":"3"},
		{"id":"7d50dae939e9af68","type":"text","text":"# Unit Disk Graphs\n\nSchematizziamo una rete wireless come ***intersection graph*** nel seguente modo:\n\n- i dispositivi sono i nodi, ed il loro range $\\calR$ di trasmissione definisce una sfera;\n- esiste un arco che collega i nodi $i$ e $j$ sse le sfere generate da $i$ e $j$ si intersecano tra loro.\n\nIn questo ***intersection model***, se prendiamo $\\calR$ tutti uguali costruiamo un ***unit disk graph***. In questo specifico setting abbiamo un ***algoritmo per ridurre la dimensione di un CDS dato in input***.\n\n- Un ***convex hull*** ($CH$) di un insieme di punti $X$ nello spazio $\\dD$ è il più piccolo ***convex set*** che contiene tutti i nodi di $X$;\n- `while` - Seleziona il nodo $u\\in$ CDS con grado minore, prendi il set dei primi vicini $\\calN(u)$ e costruisci il suo Convex Hull $CH(\\calN(u))$. Quindi:\n\t- `for` -  Cicla sui primi vicini $i\\in\\calN(u)$, e per ognuno di essi costruisci $\\calN(i)$;\n\t- Se $CH(\\calN(u))\\sse \\bigcup_iCH(\\calN(i)$, ovvero se il vicinato di $u$ è interamente coperto dai vicinati dei suoi vicini, allora è possibile rimuovere $u$ <span style=\"color:#FFA500\">Questa cosa non mi torna, in questo modo tolgo tutti i nodi. Dovrei limitarmi a considerare i nodi $i$ del vicinato che sono anche $\\in$ CDS no?</span>\n- Se ci sono nodi $u\\in$ CDS non ancora considerati, torna al `while`.\n\nQuesta logica riduce la dimensione del CDS secondo logiche di geometria, ma non c'è alcun approximation ratio garantito.","x":-4815,"y":4509,"width":820,"height":586,"color":"3"},
		{"id":"9e0723de15a3ec51","type":"file","file":"Wireless Networks/Fixed WSN/ConvexHull.png","x":-4605,"y":5141,"width":400,"height":190},
		{"id":"14a9a2ec8131ff94","type":"file","file":"Wireless Networks/Fixed WSN/MinDomSet_Step1.png","x":-4230,"y":5981,"width":400,"height":184},
		{"id":"adfbeb8244aff198","type":"file","file":"Wireless Networks/Fixed WSN/MinDomSet_Step2.png","x":-4230,"y":6248,"width":400,"height":131},
		{"id":"83d6521bc77abe03","type":"text","text":"# $\\NPC\\mathbf{ness}$ e Approssimazioni\n\nIl fatto che MDS sia $\\NPC$ si dimostra provando una biezione con `MinSetCover` (che è $\\NPC$).\n\n- ***Da Dominating Set a Set Cover*** - Se DS è costruito su un grafo $G=(V,E)$, poniamo l'universo $U=V$, mentre i set che lo ricoprono sono tali che $S_u$ consta del nodo $u$ e dei suoi primi vicini.\n\t- Se $D$ è un DS per $G$, allora $C=\\{S_u\\,:\\,u\\in D\\}$ è una set cover $U$;\n\t- Viceversa, se $C=\\{S_u\\,:\\,u\\in D\\}$ è una set cover per $U$, è chiaro che $C$ è anche un DS.\n- ***Da Set Cover a Dominating Set*** - Sia $(U,S)$ dove $S=\\{S_i\\,:\\, i\\in \\calI\\text{ tale che }\\calI\\cap U=\\emptyset\\}$ la definizione del problema di SC.\n\t- $\\calI\\cap U=\\emptyset$ significa che l'universo non contiene il set di valori che indicizza gli insiemi ricoprenti. Si noti che è il caso opposto al precedente, in cui $u$ essendo nodo di $G$ era sia $\\in U$ che indice di $S_u$);\n\t- Costruiamo $G=(V,E)$ nel seguente modo: $V=\\calI\\cup U$, mentre $(i,j)\\in E$ se\n\t\t- $i,j\\in\\calI$ (i.e. i nodi corrispondenti agli indici formano una ***clique***);\n\t\t- $i\\in\\calI\\text{ and }j\\in S_j$ ($U$ è un ***independent set***, i.e. i suoi nodi non sono connessi tra di loro);\n\t\t- Un grafo che consta di una clique e di un independent set è detto ***split graph***. Questa constatazione qui non serve a molto, ma pare sia utile in ottimizzazione combinatoria.\n\t- Se $C=\\{S_d\\,:\\,d\\in D\\sse\\calI\\}$ è una Set Cover per $U$, allora $D$ è un Dominating Set per $G$. Potrei fare una dimostrazione rigorosa, ma è sufficiente farsi lo schemino: sopra hai la clique, sotto l'independent set. Se $C$ è una SC significa selezionando solo alcuni nodi della clique (sopra) sto \"toccando\" tutti i nodi di sotto (i.e. elementi di $U$). È ovvio che sto toccando anche tutti i nodi della clique... perché è una clique;\n\t- Viceversa, se $D$ è un Dominating Set per $G$ posso provare a ridurne la dimensione. Come? Sostituendo un elemento $d\\in D$ con un suo vicino $\\in\\calI$. Posso sempre farlo perché\n\t\t- rimuovere un nodo $d\\in U$ dal DS non crea problemi in $U$, in quanto independent set;\n\t\t- creerebbe problemi in $\\calI$, ma proprio per questo lo sostituisco con quel nodo $\\in\\calI$.\n\t\t- Iterando questa procedura trovo un DS completamente $\\sse\\calI$, ovvero una Set Cover.\n\nQuesto implica anche che ***qualsiasi algoritmo polinomiale $r$-approssimante per `MinSetCover` è valido come algoritmo polinomiale $r$-approssimante anche per `MinDominatingSet`***.\n\nC'è un'altro problema per il quale possiamo trovare questa stessa proprietà. Dato un grafo $G$ avente $n>2$ nodi, definiamo su di esso un Minimum CDS (MCDS) $\\calD$ avente $d$ nodi ed un ***maximum leaf spanning tree*** (i.e. uno ST tale che il numero di foglie è massimo) $\\calL$ avente $l$ foglie.\n\n- Se $G$ ha almeno $n>2$ nodi, allora $n=d+l$. Segue `proof`.\n\t- Parto da $\\calD$ e costruisco uno ST collegando ogni nodo $\\notin\\calD$ al più vicino nodo $\\in\\calD$. In questo modo avremo un numero di foglie $l'\\leq l$. Ma $l'=n-d$, quindi $l \\geq l-d$;\n\t- Viceversa, parto da $\\calL$ e rimuovo le foglie, costruendo di fatto un CDS che non necessariamente è minimo, i.e. $d'\\geq d$. Ma $d'=n-l$, quindi $n-l \\ge d$.\n\t- Unendo le disuguaglianze trovo il teorema.\n- Questo dimostra che anche trovare $\\calL$ è un problema $\\NPC$ (in forma decisionale, determinare se esiste un CDS con meno di $d$ nodi $\\iff$ determinare se esiste un MLST con almeno $l$ foglie);\n- Ci importa perché gli algoritmi approssimanti per MCDS arrivano ad un rate $2+\\ln\\D$ (con $\\D$ grado di $G$), mentre con quelli per MLST si riesce ad arrivare a $2$.\n\t- Se $\\D\\le3$, entrambi i problemi sono $\\in\\P$.","x":-3674,"y":4228,"width":910,"height":1148,"color":"4"},
		{"id":"a4c55563f0f19700","type":"text","text":"# Algoritmi Approssimanti per `MinimumDominatingSet`\n\nPrendiamo $G=(V,E)$ ed un subset $D\\ss V$. Dividiamo i nodi di $V$ in tre classi:\n\n- Black ($\\calB$) - Nodi $\\in D$;\n\t- Questi nodi possono in generale indurre $C$ componenti connesse. \n- Gray ($\\calG$) - Nodi $\\notin D$, ma adiacenti a $D$;\n\t- Se $G$ fosse composto dai soli nodi $\\calB$ e $\\calG$, allora $D$ sarebbe un DS. Se poi il grafo indotto dai nodi $\\calB$ fosse anche connesso (i.e. $C=1$), allora $D$ sarebbe un CDS.\n- White ($\\calW$) - Nodi $\\notin D$ né adiacenti a $D$.\n\t- Affinché $D$ sia un DS, è necessario che $|\\calW|=0$\n\nIn virtù di questo, il nostro obiettivo è $|\\calW|+C=1$ (visto che $C\\ge1$, l'unica soluzione è per $|\\calW|=0$). Sulla base di questo costruisco l'algoritmo greedy, che però avviene in ***due step***.\n\n- ***Troviamo un Dominating Set*** - Partiamo con un subset $D$ casuale o scelto tramite semplici euristiche (e.g. includiamo i nodi di grado massimo), quindi andiamo in `loop`:\n\t- `while` esiste un nodo $\\calW$ o $\\calG$ tale che rendendolo $\\calB$ e rendendo $\\calG$ i suoi primi vicini $\\calW$ si abbassa il valore di $|\\calW|+C$, effettua questa operazione su tale nodo.\n\t- Si noti che questo mi garantisce di trovare miglioramenti fintantoché $|\\calW|\\neq0$. Non necessariamente, quindi, ottengo $C=1$ già con questo ciclo. Inoltre, potrei benissimo aggiungere nodi sub-ottimali.\n- ***Rendiamolo un Connected Dominating Set*** - Se $C>1$ devo renderlo $=1$. Come? Con un altro `loop`:\n\t- Fintantoché $C\\neq1$, sposta uno o due nodi di $\\calG$ in $\\calB$.\n\t- Non ha senso aggiungerne più di due alla volta per ridurre $C$, altrimenti significherebbe ammettere l'esistenza di almeno un nodo $\\calW$.\n\nQuesto algoritmo è una $\\big(3+\\log \\D\\big)$-approssimazione, dove $\\D$ è il grado massimo di $G$. Ci sono lavori successivi in cui si arriva ad una $\\big(2+\\log \\D\\big)$-approssimazione.","x":-3674,"y":5835,"width":910,"height":719,"color":"4"},
		{"id":"f8b66801739f159b","type":"text","text":"# Connected Dominating Set\n\nSe una ***vertex cover*** seleziona un subset di nodi tali che tutti gli ***archi*** siano \"coperti\", un ***dominating set*** (***DS***) lo fa garantendo che tutti i ***nodi*** siano raggiungibili. Si possono considerare dunque problemi duali\n\nDefiniamo ***Connected Dominating Set*** (***CDS***) un DS che induce un grafo connesso. L'idea è che in una rete di sensori posso dividere i nodi in due gruppi:\n\n- ***Backbone*** - Un CDS sempre a attivo, o che segue un ***duty cycle*** regolare (e.g. i nodi del CDS si risvegliano regolarmente per controllare se qualcuno vuole inviare dati al sink);\n\t- La backbone ha un consumo maggiore rispetto al resto della rete, quindi tenderà ad esaurire prima la batteria. Una possibile soluzione è ricalcolare il CDS dopo un certo periodo, alternando i nodi al suo interno ed dando priorità volta per volta a quelli con maggiore energia residua.\n- I restanti nodi possono seguire un duty cycle più permissivo, e.g. rimanendo in stato di `sleep` fintantoché non hanno dati da inviare.\n\nTrovare il DS (e quindi il CDS) ***minimo*** (MDS, MCDS) è un problema $\\NPC$.","x":-3674,"y":1693,"width":910,"height":463,"color":"6"},
		{"id":"75515ee37aaeb128","type":"text","text":"# Static Wireless Sensor Network\n\nQuando una WSN statica viene disposta sul territorio, non è più possibile modificarne la topologia, né è comodo cambiare delle batterie che si scaricano frequentemente. Devo quindi\n\n- Assicurarmi che ogni nodo sia raggiungibile da ogni altro (i.e. che il grafo sia connesso), e che al contempo la comunicazione avvenga con il minimo dispendio possibile di energia $\\so$ ***minimum spanning tree***;\n\t- La costruzione del MST avviene generalmente per il nodo \"coordinatore\", i.e. quello che deve ***mandare informazioni di controllo alla rete***.\n- Trovare un modo efficiente di ***raccogliere grandi quantità di informazioni dalla rete***. Ho due vie principali:\n\t- Dal momento che non è ottimale farlo con il MST, assoldiamo un simpatico galoppino chiamato ***data mule*** che fa il giro della rete provando a seguire il percorso ottimale;\n\t- Se non dispongo di un DM, devo ridurre al minimo l'attività non necessaria per non sprecare batteria (***Duty Cycle***), mantenendo al contempo una backbone \"un po' più attiva\" in grado di raggiungere tutti i nodi $\\so$ ***connected dominating set***;\n\t- Se il sistema è particolarmente complesso, si possono usare entrambe le strategie insieme.","x":-6845,"y":1693,"width":910,"height":463,"color":"6"},
		{"id":"73f5e1ff244b7ffd","type":"text","text":"# Dynamic Wireless Sensors Network\n\nUna WSN dinamica ammette che la topologia della rete e i pesi degli archi cambino nel tempo. Come?\n\n- ***Carrier-Based*** - C'è qualcuno (umano) che controlla un qualcosa (robot) che sposta i sensori. Per problemi di ***centralized deployment*** si usa il ***Minimum Weight Perfect Matching*** su Grafi Bipartiti.\n- ***Self-Deployment*** - I sensori si spostano da soli, tipicamente sfruttando i diagrammi di ***Voronoi***.\n\nI compiti vengono svolti entro una certa ***Area of Interest*** (***AoI***), e il primo grande problema da risolvere è quello della ***coverage***, i.e. devo ricoprire meglio possibile l'AoI. Il primo pensiero va ad un'area, ma può essere anche un set di punti chiave o un confine. Da questo nascono problemi di ***minimum coverage***, ovvero trovare il minimo numero di sensori necessari a ricoprire l'AoI.\n\nSe è sufficiente controllare le zone ogni tempo $T$ piuttosto che monitorarle costantemente si parla di ***$T$- sweep coverage***, e $T$ è detto ***sweep period***. Oltre al minimo numero di sensori, devo includere i relativi percorsi.\n\nSi punta in generale a minimizzare, in ordine di importanza, la distanza percorsa nel deployment, il numero di start&stop (che sono più energivori di un moto uniforme) e, se avanza tempo, l'overhead di comunicazione.","x":5795,"y":1693,"width":910,"height":463,"color":"6"},
		{"id":"8d9929233e830de4","type":"text","text":"# Premesse: Deployment e Coperture Ottimali\n\nSe non ho alcuna conoscenza sull'AoI, posso agire sostanzialmente in due modi:\n\n- Un ***random deployment*** potrebbe funzionare insospettabilmente bene, soprattutto perché richiede poca energia e poco overhead computazionale. Più frequentemente, tuttavia, assumiamo di partire da esso (che resta comunque una discreta approssimazione) per poi ottimizzare la copertura;\n- Si può usare un ***incremental deployment***, in cui si introducono i sensori uno ad uno ed ogni nuovo sensore sfrutta al meglio le informazioni acquisite da quelli già posizionati. Ovviamente così ci metto una vita, senza contare che c'è un assurdo quantitativo di calcoli da fare. Di buono c'è che questo approccio lento e meticoloso mi assicura di fare la scelta ottimale volta per volta, quindi se posso permettermi di aspettare tanto tempo e consumare tanta energia in funzione di una copertura ottimale, perché no?\n\nDal momento che di norma la gente ha poco tempo e pochi soldi, si parte dal random e si ottimizza. In che modo? Conosciamo particolari simmetrie (che si traducono in griglie) che corrispondono a coperture ottimali.\n\n- Se i sensori sono tutti identici (i.e. hanno tutti lo stesso $r_c$ ed $r_s$) e la simmetria del loro raggio d'azione è sferica, la soluzione ottimale si traduce in una griglia triangolare.\n\t- Perfect Matching?\n- Possiamo approssimare la soluzione ottimale\n\t- Voronoi?","x":5795,"y":2760,"width":910,"height":554,"color":"3"},
		{"id":"c76dfe719cc543c2","type":"text","text":"# Carrier-Based - Minimum Weight Perfect Matching\n\nDato un grafo $G=(V,E)$, definiamo ***matching*** $M$ un sottoinsieme di archi tali che nessun nodo sia incidente a più di un arco nel matching (i.e. ogni nodo $\\in V$ individua al più un arco $\\in M$).\n\nDati $n$ sensori $\\{S_i\\}$ e $p$ luoghi $\\{L_j\\}$ entro l'AoI (dove per garantire la copertura assumiamo $n>p$), definiamo un ***grafo pesato bipartito completo*** come segue:\n\n- Abbiamo un nodo per ogni sensore e per ogni location $\\so V=S\\cup L$;\n- Abbiamo un arco da ogni sensore $S_i$ ad ogni location $L_j$ (i.e. il grafo è bipartito tra $S$ ed $L$);\n- Il peso dell'arco $i,j$ è $\\propto$ all'energia che deve usare il sensore $S_i$ per andare in posizione $L_j$.\n\nRisolvere il problema della disposizione ottimale al minimo costo energetico si traduce nel trovare\n\n- il ***perfect matching*** - Ogni sensore deve andare in una qualche posizione;\n- ***di peso minimo*** - Nel farlo, vorremmo ottimizzare i costi di deployment.\n\nQuesto si traduce in un ***algoritmo centralizzato***.","x":2712,"y":2808,"width":820,"height":459,"color":"6"},
		{"id":"af5a6c815869b8d2","type":"text","text":"# Sensori\n\nSolitamente, nei sensori distinguiamo un ***sensing range*** $r_s$ (i.e. quello entro il quale è in grado di raccogliere informazioni) ed un ***communication range*** $r_c$ (i.e. quello entro il quale è in grado di comunicare con un altro nodo). Questo perché sono in generale dati da componenti HW differenti.\n\nSe si assume $r_c\\ge2\\,r_s$ si può dimostrare che...?","x":5795,"y":880,"width":910,"height":463,"color":"3"},
		{"id":"30e8e7468451ecf0","type":"file","file":"Wireless Networks/Dynamic WSN/TriangularGridCoverage.png","x":6050,"y":3560,"width":400,"height":272},
		{"id":"6a1fa8e5d9387640","type":"text","text":"# Criticità palesi ed evidenti (oltre a grammatica e sintassi)\n\n- Il fatto che scrivano \"$\\text{Seq(u)}==\\text{Token}$ è chiaramente in contrasto con l'interpretazione di $\\text{Seq}(u)$ come array indicizzato da $\\text{Token}$. Potrei pensare che sia semplicemente un valore e che $u$ non tenga traccia di quello che fanno gli altri nodi, ma sinceramente preferisco avere il vettore... tanto in ogni caso per capire in che posizione sono dovrei crearne uno e scorrerlo facendo dei check sui vari `ID` finché non trovo il mio... a quel punto che senso ha cancellare quelle informazioni? Oltretutto facendo questa ricerca prima del resto del protocollo sto rallentando l'intero algoritmo...\n- Gli `step 7` e `8` costituiscono una sorta di ciclo. Questo va bene (per quanto il `go to` sia un pugno in entrambi gli occhi), il problema è che il cuore dello `step 7` è un enigmatico \"$\\text{Priority Add}$\". A parte il fatto che non si capisce che diavolo voglia dire, ma soprattutto $\\text{Priority}$ ***non viene utilizzato in nessun altro punto del ciclo***.","x":18068,"y":-1473,"width":910,"height":347},
		{"id":"1d8b1c7af73a068f","type":"text","text":"# Algorithm\n\nFirst part of the algorithm chooses the primary channels:\n$$\n\\begin{array}{l}\\\\\n\\textbf{Input:\\,\\,} C,\\;ChEstimate(u),\\; N_1(u),\\; NumCh(u),\\; R(u),\\; Rate(u)\\\\\n\\textbf{Output:\\,\\,} \\; \\text{A single primary channel }CH_1(u)\\text{ and a set of secondary channels }CH_2(u) \\\\\\\\\n1.\\quad\\text{Every node broadcasts its ID (which most probably includes temporary }\\vec{c}_u);\\\\\n2.\\quad\\text{When receiving the ID of a first neighbour, every node broadcasts it;}\\\\\n3.\\quad\\text{Every node now has all the informations regarding its interference set }\\calN(u); \\\\\n4.\\quad {\\bf for}\\,\\, u\\in V \\;{\\bf do}:\\\\ \n5.\\quad\\quad \\vec{c}_u=\\text{BoolSum}(\\calX(\\calN(u)\\cup\\{u\\})\\oplus \\text{BoolSum}(\\calX(\\calN(u))\\\\ \n6.\\quad\\quad CH_1(u) = \\text{RandomChoice}(\\vec{c}_u)\\\\\n7.\\quad\\textbf{end for}\\\\\n\\end{array}\n$$\nSecond part chooses the secondary channels. Let's focus on a single $u$.$$\n\\begin{array}{l}\\\\\n8.\\quad{\\bf for}\\,\\,v\\in \\calN(u)\\textbf{ do}:\\\\\n9.\\qquad C = C-CH_1(v)\\\\\n10.\\quad\\textbf{end for}\\\\\n11.\\quad\\text{Priority}(u)={R(u)\\over \\text{Rate}(u)}\\\\\n13.\\quad \\text{NodeSequence}(u)=\\text{SortNodes}(\\text{Priority}(u\\,\\cup\\,\\calN(u)))\\\\\n14.\\quad \\text{Token}=1\\\\\n15.\\quad {\\bf while} (\\text{Exists a }) \\,\\,|CH_2(u)|<\\text{NumCh}(u)\\\\\n15.\\quad {\\bf if} \\,\\,|CH_2(u)|<\\text{NumCh}(u) \n\\end{array}\n$$","x":19528,"y":-2510,"width":740,"height":1304},
		{"id":"177ea2d809b550a8","type":"text","text":"# Superimposed-Code (SC)\n\nPrendi delle stringhe binarie lunghe $N$. Ci sono $2^N$ possibili word, che formano il set $W$.\n\n- La somma booleana di due word è un `or` bit a bit;\n- Somma booleana di due word $\\in A$ è chiaramente ancora una word $\\in W$;\n- Ci sono però situazioni particolari in cui date $w_1,w_2\\in W$ si ha che $w_1\\vee w_2=w_1$. In questo caso si dice che $w_1$ ***copre*** $w_2$ (e.g. `1100101` copre `1000001`).\n\nL'obiettivo di un ***Superimposed-Code*** (***SC***) è quello di fornire un codice (i.e. un set $M$) il più robusto possibile rispetto alle coperture. Ci sono tre parametri di interesse:\n\n- $N$ - La lunghezza della singola codeword. Nonostante esistano $2^N$ possibili codeword lunghe $N$, imporre dei vincoli ridurrà il numero di quelle che faranno parte del SC (i.e. $M\\subset W$);\n- $L$ ed $s$ - Due numeri tali che se prendo $s$ codeword $\\in M$ e le sommo, il risultato $r$ copre al più $L-1$ word tra le restanti $|M| - s$, i.e. esistono al più $L-1$ codeword $w \\in \\{M-\\{s\\}\\}$ tali che $r\\vee w = r$.\n\t- $L$ è detta ***reliability*** (o ***overlap bound***);\n\t\t- Un valore di $L$ grande significa ammettere molte coperture. Porre $L'=|M|-s+1$  significa che la somma sopracitata copre tutte le word del set complementare. Si noti che $W$ è un SC con $L=L'$. Segue che generare un SC con $L$ ***grande è computazionalmente semplice***, ma ***non ha molto senso*** se si vogliono evitare le coperture;\n\t\t- Viceversa, generare un SC con un ***valore ottimale $L''=1$ è molto dispendioso***;\n\t\t- Un buon trade-off tra la complessità computazionale e il risultato è $L=2$. In questo caso parliamo di ***s-disjunct code***. Ipotizziamo nel prosieguo di lavorare con $L=2$, ovvero esiste al più ***una*** codeword $w \\in \\{M-\\{s\\}\\}$ tale che $r\\vee w = r$.\n\t- $s$ viene detta ***strength***, e il motivo è intuitivo:\n\t\t- Un valore di $s$ \"piccolo\" (e.g. $s=2$) significa che sommando due codeword (che sono \"poche\") ne esiste al più una tra le restanti $M-2$ (che sono \"tante\") che può essere coperta dalla somma. Non così incredibile, ecco.\n\t\t- Un valore di $s$ \"grande\" (e.g. $|M|-2$) significa che sommando $|M|-2$ codeword (che sono quasi tutte) ne esiste al più una che viene coperta tra le restanti due, i.e. ne esiste almeno una non coperta. Questo è già più incredibile, e fa capire perché questo parametro si chiama così;\n\nÈ da notare che quando si parla di *s-disjunct code* si specifica $L=2$ ma non $s$, né $N$. Questo perché l'upper bound per $s$ dipende da $N$ (i.e. $|M|\\propto N$, e chiaramente $1\\leq s\\leq|M|-2$), ed $N$ dipende dal problema.\n\nIn un'applicazione tipica, ***$N$ è il numero di canali*** a disposizione del protocollo di comunicazione wireless.","x":14720,"y":-2132,"width":910,"height":925,"color":"3"},
		{"id":"e6316db3416c4b1e","type":"text","text":"# SC applicato ad una rete veicolare (i.e. trovare $\\PCH$)\n\nL'obiettivo di una rete veicolare è trovare il set di canali principali privi di interferenza $\\PCH$. Come si fa?\n\n- Preparo un ***s-disjunct code*** e distribuisco ad ogni nodo della rete tutte le codeword $M$;\n\t-  Questo presuppone che la rete sappia già quale range di frequenze può usare (e ciò ha senso);\n- Iniziare il protocollo significa scegliere a caso una di queste codeword e mandarla in `broadcast` insieme al proprio `ID` con un pacchetto avente `TTL = 2`. Ipotizziamo di essere un nodo e di iniziare il protocollo;\n\t- Questo si basa sull'idea che sia improbabile scegliere la stessa codeword di uno dei miei vicini.\n- Anche gli altri nodi a me vicini hanno iniziato il protocollo, quindi riceverò una coppia `ID`$(v), M(v)$ dove $v$ indicizza i miei vicini;\n- A questo punto ogni nodo conosce gli `ID` e le codeword del suo vicinato, e può usarle per scegliere $\\PCH$.\n\t- Questo si basa sull'idea che la probabilità di aver scelto proprio quell'unica codeword che verrà coperta dalla somma delle codeword del mio vicinato sia trascurabile. Ma possiamo fare di meglio e dire che in certe condizioni la probabilità è esattamente zero, secondo questo ***lemma***:$$s\\geq|\\calN(u)|\\so \\exists \\PCH(u)$$ovvero se $s$ è almeno pari al numero di nodi nel vicinato del nodo $u$, allora esiste almeno un $\\PCH(u)$. Convincersi che sia vero è abbastanza facile: il significato di $s$ è che la somma di un qualsiasi set di $s$ codeword non copre nessuna delle restanti $|M|-s$ codeword. Se $|\\calN|$ fosse $>s$ non avremmo questa proprietà garantita. Viceversa, ne siamo certi per definizione di SC;\n\t- Viene anche da sé un altro ***lemma***, cioè che una volta scelto $\\PCH(u)$, questo non andrà in interferenza con nessuno degli altri $\\PCH(v)$ dove $v\\in\\calN(u)$. Anche qui, è facile convincersi di questo. La scelta di $\\PCH(u)$ avviene tra tutti i canali che $u$ può scegliere come $\\PCH$ meno i canali che i nodi in $\\calN(u)$ potrebbero scegliere come $\\PCH$. Segue che la scelta di $u$ è safe.","x":14720,"y":-1133,"width":910,"height":665,"color":"4"},
		{"id":"723b2dd42fcce0d4","type":"text","text":"# Costo Computazionale per Generare un SC\n\nPosto che nel caso in analisi diamo per scontato di partire con un SC e che quindi non è davvero rilevante il costo computazionale per generare un SC, magari uno è curioso.\n\nEsistono molti modi per costruire un SC, e non esiste un andamento asintotico esatto. Di certo esistono dei bound per il numero $|M|$ di codeword di lunghezza $M$ realizzabili:$$\\O\\bigg({2^N\\over s}\\bigg)\\leq |M| \\leq O\\bigg({2^N\\over s^2}\\bigg)$$Fonte ChatGPT perché non mi andava di cercare, ma tanto è giusto per dare un'idea. Qua si cerca di massimizzare $|M|$. Viceversa, uno si può porre il problema al contrario e chiedersi qual è il minimo $N$ per realizzare $|M|$ codeword (basta ricavare $N$ dalle disuguaglianze sopra, esce $\\propto \\log(|M|)$).\n\nOra, questi sono i bound, ma in genere  $|M| \\sim {N^s\\over s!}$. In ogni caso, come detto, $s$ è \"grande\", quindi anche $M$ tenderà ad essere \"grande\". Long story short, la complessità per un simile problema si aggira intorno a$$O(NM)\\so\\P(N)$$Quindi, diciamo, è fattibile senza troppi problemi. Se invece volessi trovare il SC ottimale dati $N$ ed $s$ (ovvero il massimo $|M|$), questo diventa $\\NPH$.","x":14816,"y":-2882,"width":718,"height":563,"color":"4"},
		{"id":"c1690a87fa9debb2","type":"text","text":"# \\[Xal14\\] Decodifichiamo il cinese arcaico \\w ChatGPT\n\nAnzitutto, dotiamo ogni nodo della rete con un ***s-disjunct code*** $\\calX$, i.e. un particolare tipo di ***Superimposed-Code***. Scelgo la lunghezza $N$ della codeword pari al numero di canali ortogonali $\\{k_n\\}$. Il problema è da qui in poi completamente definito dal grafo $G(V, E, \\calX)$, dove\n\n- $V$ è l'insieme dei vertici, i.e. i veicoli;\n- $E$ è l'insieme degli edges, i.e. i collegamenti tra coppie di veicoli;\n- $\\calX$ rappresenta tutte le possibili codeword lunghe $N$ (assumo sia vero che $|\\calX| \\gg |V|$).\n\nIl primo obiettivo del protocollo è ***trovare il canale principale*** $\\PCH$ per ogni nodo $u$. Come?\n\n- Il generico nodo $u$ sceglie casualmente una codeword $\\calX(u)=\\vec{c_u}$ tra le $|\\calX|$ disponibili, e.g. $$\\vec{c_u}=(100100101\\cdots)$$L'elemento $\\vec{c_u}(i)$ rappresenta il canale $k_i$. In particolare, se $k_i=1$ sto dicendo che $k_i$ è un candidato per diventare il canale principale $\\PCH(u)$ per il nodo $u$;\n- Ogni nodo fa `broadcast` della propria coppia \\{`ID` (e.g. un `MAC Address`), $\\vec{c_u}$\\}, e in caso fa `forwarding` delle coppie dei vicini secondo le regole descritte nella sezione \"***SC applicato ad una rete veicolare***\";\n- A questo punto ogni nodo $u$ conosce `ID` e codeword scelta da ogni nodo del suo vicinato, che costituisce il suo ***interference set*** $\\calN(u)$, i.e. i nodi che devono scegliere $\\PCH$ disgiunti per non avere mutua interferenza (i.e. un labeling $L(1,1)$). Calcola quindi due elementi:\n\t- $\\text{BoolSum}(\\calX(\\calN(u)\\cup \\{u\\}))$ - Tutti i possibili $\\PCH$ nel vicinato, ***compreso*** $u$;\n\t- $\\text{BoolSum}(\\calX(\\calN(u)))$ - Tutti i possibili $\\PCH$ nel vicinato, ***escluso*** $u$.\n- A questo punto la lista dei canali $\\PCH(u)$ è data dallo ***XOR*** di queste due grandezze:$$\\text{BoolSum}(\\calX(\\calN(u)\\cup\\{u\\})\\oplus \\text{BoolSum}(\\calX(\\calN(u))$$Sono sicuro che ne esista almeno uno per via del lemma dimostrato nella sezione di cui sopra.\n\t- Credo si possa calcolare anche solo $\\text{BoolSum}(\\calX(\\calN(u)))$ e fare direttamente $$\\calX(u)\\text{ AND } (\\text{NOT }\\text{BoolSum}(\\calX(\\calN(u)))$$\n\nSappiamo dai lemmi che data un'opportuna scelta di $s$ ogni nodo è in grado di scegliere i propri $\\PCH$ in modo tale che nessuno di essi possa andare in interferenza con qualsiasi $\\PCH$ di qualsiasi altro nodo del vicinato.\n\nA questo punto passiamo alla ***ricerca dei canali secondari*** $\\SCH$, cambiando totalmente approccio.\n\nOgni nodo manda in `broadcast` la propria lista dei $\\PCH$ secondo le solite regole. In ogni vicinato, ogni nodo $u$ conosce i $\\PCH(v)$ di tutti e soli i suoi vicini $v\\in\\calN(u)$ (<span style=\"color:#FFA500\">si noti che potrebbe benissimo calcolarseli da solo, qui il paper ci lascia libertà di implementazione, grazie, vorrei sapere come lo avete realizzato voi</span>);\n\nConsideriamo la lista $C$ dei canali complessivi (i.e. da $1$ a $N$), e costruiamo i canali disponibili come$$\\text{AvailableCh}(u) = C - \\PCH(u) - \\sum_{v\\in \\calN(u)}\\PCH(v)$$banalmente togliendo i $\\PCH$ di tutto il vicinato, $u$ compreso. Questo garantisce che i canali secondari non interferiscano con quelli primari (nella parte precedente erano solo i $\\PCH$ a non interferire tra loro);\n\nBisogna ***spartire i canali rimasti tra i membri del vicinato***. Con che logica?\n\n- Ogni nodo stima due grandezze: la propria velocità di trasmissione nominale $\\text{Rate}(u)$ e la propria necessità di throughput $R(u)$ (i.e. quanti dati deve inviare). Sulla base di questo calcola un valore di ***priorità***$$\\text{Priority}(u)={R(u)\\over\\text{Rate}(u)}$$Per come è definita, favorisce i nodi più lenti e quelli con più roba da mandare;\n- `broadcast` con il solito `TTL = 2` per avvisare i vicini, ed ogni nodo è ora in grado di fare una lista ordinata delle varie priorità del vicinato, che chiameremo $\\text{Seq}(u)$ <span style=\"color:#FFA500\">o forse no? logica vorrebbe fosse un vettore, ma poi sembra usarlo come scalare</span>;\n- Qui l'algoritmo diventa oscuro, e verrà trattato nella sezione \"***Magia Nera (i.e. l'assegnazione dei $\\SCH$)***\"","x":15828,"y":-2132,"width":910,"height":1664,"color":"4"},
		{"id":"520edf73b73c5a61","type":"text","text":"# Magia Nera (i.e. l'assegnazione dei $\\SCH$)\n\nPartiamo da un presupposto: gli autori affermano nell'abstract di aver realizzato un algoritmo distribuito. Cerchiamo di capire come (<span style=\"color:#FFA500\">probabilmente inventandoci qualcosa, perché a me puzza troppo di centralizzato</span>).\n\nSiamo arrivati al punto in cui, in qualche modo, ogni nodo $u$ ha\n\n- l'<span style=\"color:#FFA500\">array?</span> $\\text{Seq}(u)$ delle ***priorità del proprio vicinato*** (i.e. $\\text{Seq}(u)[1]$ è l'`ID` del nodo con la massima priorità);\n- l'array $\\text{AvailableCh}(u)$ dei ***canali disponibili*** (i.e. $\\text{AvailableCh}(u)[1] = 1\\iff$ il canale $1$ è disponibile).\n\nNota che questa implementazione ***è una mia interpretazione***, perché l'articolo non è affatto chiaro a riguardo.\n\nA questo punto compaiono due ulteriori grandezze:\n\n- $\\text{NumCh}(u)$ - Una stima della risposta alla seguente domanda: \"in quanti canali si traduce una necessità di throughput $R(u)$?\". Il paper ci lascia due possibili metodi alternativi:\n\t- \"A braccio\", cioè detto più elegantemente con una logica ***fuzzy*** (quanto suona bene in inglese, eh?). Che significa? Che se $R(u)$ è \"alto\" allora $\\text{NumCh}(u)$ è alto (idem con medio e basso, o comunque con una qualsiasi divisione in macro-categorie). Poi in caso serva si arrotonda ad un intero;\n\t- Con ***un*** algoritmo ***BABS*** (***Bounded Adaptive Broadcast Scheduling***), <span style=\"color:#FFA500\">che non ho capito bene se gli stessi autori sanno cos'è (probabilmente no), io di certo non l'ho capito</span>.\n- $\\text{ChEstimate}(u)$ - Ad ogni canale disponibile viene associata una stima della sua qualità, se ho interpretato bene. <span style=\"color:#FFA500\">Come viene calcolata? Enorme mistero, non c'è né una spiegazione né una citazione a riguardo</span>.\n\nSiamo pronti per il delirio. Qui è ***dichiaratamente al $70\\%$ mia interpretazione, anche a tratti contraria a quello che sembra esserci scritto nell'articolo*** \n\n1. Tutti i nodi concordano sul valore iniziale di un $\\text{Token}=1$;\n2. Ad ogni step temporale, ogni nodo $u$ valuta $\\text{Seq}(u)[\\text{Token}]$.\n\t- Se tale valore è il proprio `ID`, allora <span style=\"color:#FFA500\">eh no, questo è proprio insensato per come è scritto. Bisogna necessariamente chiedere. C'è un ciclo la cui operazione principale è aggiornare $Priority$, che però non sta nel ciclo. Che senso ha?</span>\n\t- In ogni caso, incremento il valore di $\\text{Token}$;\n3. Cito testualmente: \"Se esiste almeno un nodo $u$ che non è stato coinvolto nell'allocazione, allora riprendi dallo `step 2.`\" (lo `step 2` è di questo mio schema, nel paper è la `riga 7`). <span style=\"color:#FFA500\">Come fa a non essere un algoritmo centralizzato? Come fa un nodo a sapere chi ha scelto cosa? Ci sono dei `broadcast` che hanno omesso? Usano i $\\PCH$? C'è effettivamente una sequenza temporale inframezzata da comunicazioni? A me pare che sia scritto per un controller globale.</span>\n\n","x":17008,"y":-1810,"width":910,"height":1020,"color":"4"},
		{"id":"53f6e2fd4996e72c","type":"text","text":"# Matrimoni, Flussi e Cammini Alternati\n\nIl ***teorema di Hall*** pone una condizione di esistenza per il perfect matching, mentre il parallelismo con il problema dei flussi fornisce un algoritmo che ne trova uno in un tempo $O(mn)$.\n\nPossiamo trovare un algoritmo alternativo sfruttando il seguente concetto:\n\n- Un ***alternating path*** su un matching $M$ è un cammino che alterna visite a nodi $\\in M$ e $\\notin M$;\n- un ***augmenting path*** (***AP***) è un alternating path che inizia e finisce con un nodo $\\notin M$.\n\n`Theorem (Berge)` - Dato un matching $M$ in un grafo $G$, $M$ è ***maximum*** sse non esistono augmenting paths rispetto ad $M$. Segue `proof`:\n\n- $\\so$ Se esistessero augmenting paths potremmo aumentare la cardinalità di $M$ invertendo i ruoli degli edge, contraddicendo la sua massimalità;\n- $\\Leftarrow$ Se $M$ non fosse massimo, esisterebbe $M'$ tale che $|M'|>|M|$. Se però considero il multigrafo $H$ ottenuto sovrapponendo $M$ ed $M'$, le sue componenti connesse contengono almeno un augmenting path, da cui la contraddizione. <span style=\"color:#FFA500\">sì ok lo so zero voglia</span>\n\nDato un grafo bipartito, possiamo determinare se esiste o meno un AP nel seguente modo:\n\n- ***Orientiamo gli archi in modo tale che quelli nel matching puntano da $V_1$ a $V_2$, e viceversa***;\n- Su tale digrafo $D$, un directed path che parte da un free node (i.e. un nodo non toccato dal matching) in $V_1$ e arriva ad un free node in $V_2$ è equivalente ad un AP rispetto al matching.\n\t- Possiamo eseguire questa ricerca con una Depth First Search (DFS) sui nodi $V_1$ del grafo $D$. Questo porta ad una complessità $O(n+m)$ per ogni nodo di $V_1$ da cui parto, quindi complessivamente è $O(nm)$;\n\t- Come condizione necessaria, il grafo non deve avere odd cycles (esplorare il ciclo nella direzione sbagliata può portare a non rilevare l'augmenting path <span style=\"color:#FFA500\">perché?</span>)\n\nL'algoritmo di ***Hopcroft-Karp*** sfruttando idee simili abbassa la complessità a $O(m\\sqrt n)$:\n\n- Fa girare un BFS in parallelo su tutti i nodi di $V_1$. Ogni iterazione può trovare diversi free nodes al livello $k$, che vengono aggiunti al set $F_k$. Questi sono gli endpoint dei possibili AP ($O(m)$);\n- Fa girare un DFS al contrario, partendo dai nodi di $F_k$. Iterativamente, ogni AP così trovato viene usato per aggiornare la stima del matching.\n- <span style=\"color:#FFA500\">mi arrendo, o qualcuno me lo spiega o lo salto e basta</span>","x":2712,"y":4355,"width":820,"height":901,"color":"2"},
		{"id":"6be5a5347948cdc9","type":"text","text":"# Matrimoni (i.e. CNES per il Perfect Matching)\n\nPartiamo dal Perfect Matching e dimostriamo il ***teorema di Hall*** (o teorema ***del matrimonio***).\n\n`Theorem` - Sia $G=(V_1,V_2,E)$ un grafo bipartito con $|V_1|\\le |V_2|$. $G$ ammette un perfect matching sse per ogni set $S$ di $k$ nodi in $V_1$ ci sono almeno $k$ nodi in $V_2$ adiacenti (i.e. collegati da un arco) ad un qualche nodo di $S$.\n- $\\forall\\,S\\sse V_1\\,:\\,|S|=k,\\quad|S|\\le|\\text{adj}(S)|$\n- Intuitivamente: nei casi estremi la condizione del teorema è ovvia:\n\t- Se $k=1$ sto dicendo che ogni nodo di $V_1$ deve essere collegato ad almeno un nodo di $V_2$. Banalmente, se così non fosse non potrei avere perfect matching;\n\t- Se $k=|V_1|\\iff|V_1|\\le |V_2|$, i.e. ho abbastanza nodi in $V_2$ per fare un perfect matching.\n- La condizione non ovvia si ha per i casi intermedi.\n\n`Proof` - Per assurdo, poniamo che la condizione sia vera ma che non esista un perfect matching. Allora $M$ è un maximum matching, ma al contempo $|M|<V_1$, i.e. non tutti i nodi di $V_1$ sono coperti.\n\nPoniamo che il nodo non coperto sia $u$. Consideriamo $S=\\{u\\}$ applichiamo la condizione di Hall$$|\\text{adj}(S)|\\ge |S|= 1$$quindi esiste almeno un nodo $v\\in V_2$ adiacente a $u\\in V_1$. Distinguiamo due casi:\n\n1. $v$ non è tra i nodi toccati da $M$. Al contempo, per quanto detto, neanche l'arco $(u,v)$ è in $M$. Questo significa che possiamo aggiungerlo ad $M$ senza violare le proprietà del matching. Ma per ipotesi $M$ è un maximum matching, da cui la ***contraddizione***;\n2. $v$ è tra i nodi toccati da $M$. Questo significa che è connesso ad un nodo $u'\\in V_1$. Ridefiniamo $S=\\{u, u'\\}$ e riapplichiamo la definizione: esistono almeno due nodi adiacenti ai nodi di $S$. Uno è $v$, l'altro è $v'$. Anche qui, abbiamo due casi:\n\t- Se $v'$ non è tra i nodi toccati da $M$, siamo di nuovo nel caso 1 $\\so$ ***contraddizione***;\n\t- Se lo è, siamo di nuovo nel caso 2, quindi di ritroveremo ricorsivamente due casi: uno in cui trovo la contraddizione ed uno che funge da chiamata ricorsiva. Quando finisce questo gioco? Visto che $|V_1|\\le |V_2|<\\infty$, ad un certo punto finiranno i nodi di $V_1$ e mi ritroverò con un nodo $v^k\\in V_2$ che non è toccato dal matching. A quel punto potrò collegarlo con l'$u$ iniziale (l'esistenza dell'arco $(u,v^k)$ è garantita da $|\\text{adj}(S)|\\ge |S|$) ed estendere $M$, il quale quindi non era massimale $\\so$ ***contraddizione***.","x":1280,"y":4355,"width":820,"height":901,"color":"4"},
		{"id":"8608d3634f9588e8","type":"text","text":"- First, we equip every node in the network with an _**s-disjunct code**_ $\\calX$. We set the length $K$ of the codeword equal to the number of orthogonal channels ${k_i}$;\n- A generic node $u$ randomly selects a codeword $\\calX(u)=\\vec{c_u}$ from the $|\\calX|$ available options, e.g. $$\\vec{c_u}=(100100101\\cdots)$$\n- The element $\\vec{c_u}(i)$ represents channel $k_i$. Specifically, $k_i=1$ means that $k_i$ is a candidate to become the primary channel $\\PCH(u)$ for node $u$;\n- Each node broadcasts its pair {`ID` (e.g. a `MAC Address`), $\\vec{c_u}$}, and forwards the pairs of its neighbors so that every neighbor reaches is whole neighborhood.\n\t- It's more or less like a broadcast with `TTL = 2`.\n- At this point, each node $u$ knows the `ID` and the codeword chosen by every node in its neighborhood, which forms its _**interference set**_ $\\calN(u)$, i.e., the nodes that must choose disjoint $\\PCH$ to avoid mutual interference (i.e. a labeling $L(1,1)$).\n\n\n$$a$$\n\n- It then calculates two elements:\n    - $\\text{BoolSum}(\\calX(\\calN(u)\\cup {u}))$ - All possible $\\PCH$ in the neighborhood, _**including**_ $u$;\n    - $\\text{BoolSum}(\\calX(\\calN(u)))$ - All possible $\\PCH$ in the neighborhood, _**excluding**_ $u$.\n- Finally, the list of channels $\\PCH(u)$ is obtained from the _**XOR**_ of these two$$\\text{BoolSum}(\\calX(\\calN(u)\\cup\\{u\\})\\oplus \\text{BoolSum}(\\calX(\\calN(u))$$Or, in a simpler way,\n\n$$\\calX(u)\\text{ AND } (\\text{NOT }\\text{BoolSum}(\\calX(\\calN(u)))$$","x":16862,"y":-2742,"width":718,"height":642},
		{"id":"63d418fb4103a8b5","type":"file","file":"s-disjunct.png","x":12940,"y":-1811,"width":400,"height":284},
		{"id":"30ff3d1a672765f6","type":"text","text":"# Superimposed-Code (Tentativo 2)\n\nDiciamo che esistono $t$ codeword di lunghezza $t$. $\\calX$ è una matrice $N\\times t$ la cui $i$-esima colonna (i.e. l'$i$-esima codeword) è $\\calX(i)$, avente elementi $\\{x_j(i)\\}$. Definiamo il ***column weight*** come$$w_i = \\sum_{k=1}^Nx_k(i)$$(i.e. il numero di $1$ all'interno della codeword $i$) e il ***row weight*** come$$\\l_j=\\sum_{k=1}^tx_j(k)$$(i.e. il numero di $1$ nella riga $j$, nell'analogia con la rete MR-MC il numero di nodi che ha il canale $j$ registrato come primario). Detto questo vale tutto il discorso della somma booleana e della copertura fatto in precedenza.\n\nQuesta roba è un ***Superimposed-Code*** $(s, L, N)$ di size $t$ se per ogni subset di grandezza $s$ la somma booleana delle $s$ codeword nel subset copre al più $L-1$ codeword tra le restanti $t-s$.\n\nQuesta roba è un $s$***-disjunct Code*** se $L=1$.\n\n","x":13480,"y":-2132,"width":910,"height":925,"color":"4"},
		{"id":"0ba91366af6367ab","type":"text","text":"# Self-Deployment - Voronoi Diagrams\n\nIn setting rischiosi (e.g. incendi, campi di battaglia), i sensori devono essere in grado di disporsi autonomamente sul territorio, massimizzando la copertura dell'area.\n\nOgni sensore si basa su un ciclo Look-Compute-Move, e la schematizzazione è simile ad un insieme di particelle massive aventi cariche dello stesso segno (i.e. si attraggono e si respingono con intensità diverse, ed esiste una configurazione di equilibrio che sarà il risultato finale dell'algoritmo, eventualmente aiutata da un fattore di smorzamento per limitare le oscillazioni).\n\nDato un set di ***siti*** (i.e. punti sul piano) $\\{P_i\\}$, un ***diagramma di Voronoi*** è una divisione del piano in celle $\\{V_i\\}$ tali che se scelgo un punto $X\\in V_i$ allora $X$ è più vicino al sito $P_i$ piuttosto che a qualsiasi altro sito $P_j$, ovvero$$X\\in V_i\\so\\dist(X,P_i)<\\dist(X,P_j)\\quad\\forall\\,j\\neq i$$\nSfruttare i diagrammi di Voronoi permette di sviluppare un sistema decentralizzato, che consente maggiore fault-tolerance e minori delay.","x":8966,"y":2808,"width":820,"height":459,"color":"6"},
		{"id":"f2a98d5ae11dd396","type":"text","text":"# Costruire un Diagramma di Voronoi\n\nIn generale, considerare il segmento che congiunge due siti primi vicini e tracciarne l'asse permette di costruire facilmente un diagramma di Voronoi.\n\n- Un ***asse*** di Voronoi è il luogo dei punti equidistanti da tale coppia di primi vicini (i.e. dai siti delle celle ad esso confinanti);\n- Un ***vertice*** di Voronoi (i.e. l'intersezione di tre assi) è il punto equidistante dai tre siti che definiscono le celle ad esso confinanti.\n\n`Teorema` - Poniamo di avere $n\\ge3$ siti. Allora gli assi sono al più $|e|\\le3n-6$ e i vertici $|v|\\le2n-5$.\n\n`Proof` - Anzitutto notiamo un simpatico parallelismo: se chiamiamo gli assi \"archi\" e i vertici \"nodi\" abbiamo appena costruito un grafo di grado $\\ge3$... o quasi. Perché questo sia un ***grafo planare*** devo aggiungere un ***nodo fittizio*** a cui convergono tutti gli archi che se ne vanno all'infinito. Ora, in un grafo planare quelle che abbiamo chiamato celle si chiamano ***facce***, e si indicano con $f$. Per i grafi planari si può dimostrare\n- la ***formula di Eulero*** $|v|-|e|+f=2$\n- la proprietà per cui la somma dei gradi dei vertici è due volte il numero di archi $\\sum_i\\text{deg}(v_i)=2|e|$\n\nA questo punto sapendo che il grafo ha grado almeno $3$ abbiamo che $$\\text{deg}(v)\\ge3\\so3|v|\\le\\sum_i\\text{deg}(v_i)=2|e|$$da cui sostituendo della formula di Eulero $|v|-|e|+n = 1$ troviamo le due tesi.\n\nOra, se invece tracciamo i segmenti che congiungono ogni coppia di siti primi vicini otteniamo delle figure triangolari entro le quali si trova al più un vertice del diagramma di Voronoi. I triangoli sono tali che il cerchio circoscritto non contenga nessun altro sito. Se così non è, il segmento viene detto illegale, ma è possibile modificare la figura per creare una configurazione valida (<span style=\"color:#FFA500\">booh guarda l'immagine, da un lato è chiaro, dall'altro meno. dice che deve valere $\\min_i\\a_i<\\min_i\\b_i$</span>).\n\nÈ possibile sfruttare la costruzione di questa ***Delaunay Triangulation*** per trovare il diagramma di Voronoi, in quanto sono evidentemente problemi duali.\n\nAltrimenti, usiamo metodi alternativi.","x":8966,"y":4355,"width":820,"height":901,"color":"4"},
		{"id":"294b8d8e6f1d5a69","type":"file","file":"Wireless Networks/Dynamic WSN/AreYouDelaunay.png","x":9436,"y":5360,"width":350,"height":400},
		{"id":"5ae52405bd3ba1b6","type":"text","text":"# Sensori Eterogenei\nTutto questo finora non tiene conto del sensing range del sensore. D'altronde, se sono tutti uguali non ha senso pensarci, uno vale l'altro.\n\nQuesta assunzione si rompe se i sensori hanno sensing range diversi tra loro. Non è più vero che uno vale l'altro, la soluzione ottimale dovrebbe prevedere l'assegnazione dei sensori più potenti alle celle più grandi, ma in Voronoi classico non c'è modo di controllare questa cosa.\n\n***Modifichiamo allora la nozione di distanza per tenere conto del sensing range***.\n","x":8966,"y":5929,"width":820,"height":276,"color":"6"},
		{"id":"ef5af769f02d7697","type":"text","text":"# Self-Deployment - Voronoi\noldò (although)\n\neuler's formula for planar graph (I hope you know it)\n\nesempio classico di movement obstacles: un corridoio","x":11600,"y":6240,"width":820,"height":459},
		{"id":"af046ebb94346322","type":"text","text":"# Grafo Generico\n\n\nOra, tutto questo ha problemi nel caso di generico grafo, perché potrei avere odd cycles. Un odd cycle contenente un numero massimale di archi nel matching $M$ è detto ***blossom*** $B$.\n\n`Lemma` - Se ho un blossom $B$ in un grafo $G$, ricavo $G'$ contraendo $B$ in un singolo punto.$$M'\\text{ è massimo in }G'\\iff M\\text{ è massimo in }G$$\nQuesto si dimostra per contraddizione, <span style=\"color:#FFA500\">ma mi rifiuto perché sto odiando questo capitolo</span>.\n\nQuesto `Lemma` fornisce una regola di calcolo su cui costruire un algoritmo: dato un grafo $G$, fai collassare ogni blossom $B$ in un singolo nodo creando $G'$. A questo punto trova il maximum matching usando gli algoritmi precedenti, poi riporta $G'$ in $G$. Questa procedura è nota come algoritmo di Edmonds. La complessità varia tra $O(n^3$) e la migliore conosciuta che è $O(m\\sqrt n)$.\n\n<span style=\"color:#FFA500\">Segue Edmonds' Algorithm ma mi rifiuto perché sto odiando questo capitolo sempre di più</span>\n","x":4144,"y":5687,"width":820,"height":581,"color":"1"},
		{"id":"3584e1659bcd870e","type":"text","text":"# ... for Weighted Matching\n\nLa definizione del problema in caso di grafo pesato non è così diversa da quella già vista, ma dobbiamo ridefinire un concetto: un ***(weighted) augmenting path*** su un grafo pesato è un qualsiasi alternating path tale che il suo peso complessivo è maggiore del peso del matching (nella somma, i segni dei pesi sono alternati coerentemente con il verso di percorrenza degli edges orientati).\n\nA questo punto l'idea è esattamente come nel caso precedente iniziare con un matching vuoto e fare un ciclo `while` in cui\n\n- Trovo un (weighted) augmenting path di peso massimo;\n- `if` - Se ne esiste uno, inverto i ruoli degli edges e aggiorno la mia attuale stima del matching;\n- `else` - `return` il matching che ho trovato.\n\nCome visto prima, un simile ha complessità $O(nm)$.\n\nQuesto roba si può formulare come problema ILP, e prende il nome di ***Hungarian Method***. $x_{ij}=1$ se $(i,j)\\in M$, ed è $0$ altrimenti (i.e. gli unici archi con peso non-nullo sono quelli del matching). A questo punto la condizione si scrive come il dover trovare$$\\min\\bigg[\\sum_{i,j}c_{ij}x_{ij}\\bigg]\\quad:\\quad \\sum_jx_{ij}=\\sum_ix_{ij}=1$$\nche porta ad una complessità $O(n^3)$.\n","x":2712,"y":5687,"width":820,"height":581,"color":"3"},
		{"id":"2b0eb76c35ded182","type":"file","file":"Wireless Networks/Dynamic WSN/BuildingFlowGraph.png","x":4354,"y":4355,"width":400,"height":185},
		{"id":"269918eea9cb6b6a","type":"file","file":"Wireless Networks/Dynamic WSN/Flow.png","x":4354,"y":5062,"width":400,"height":194},
		{"id":"292a836ba0520432","type":"text","text":"# Flussi (i.e. un problema equivalente)\n\nPossiamo rappresentare un sistema di flussi tramite un grafo orientato in cui, ad esempio,\n\n- i nodi sono stazioni di pompaggio;\n- gli archi sono tubature;\n- i pesi degli archi sono la portata massima delle tubature.\n\nIl problema qui consiste nel determinare il ***massimo flusso*** $f$ che può fluire da un ***nodo sorgente*** ad un ***nodo pozzo*** rispettando queste capacità. Ovviamente se poniamo solo capacità intere anche il massimo flusso sarà intero, e coinciderà con la cardinalità del perfect matching $|M|=f$.\n\nL'idea qui è di sfruttare gli algoritmi per la risoluzione del ben studiato problema del massimo flusso.\n\nL'algoritmo di ***Ford-Fulkerson*** trova il ***massimo flusso in una rete*** in un tempo $O(mf)$. In un grafo bipartito in cui i tutti i costi degli archi sono $1$ $f\\leq \\min(|V_1|,|V_2|)$, quindi l'algoritmo gira in $O(mn)$.\n","x":4144,"y":4601,"width":820,"height":409,"color":"4"},
		{"id":"36340e2de86a0954","type":"text","text":"# Approximation Ratio Bounds\n\nNel caso di grafo a stella si trova una $6$-approssimazione. Questo numero sembra essere proprio il lower bound del problema generale, e coincide con il ***kissing number*** in $\\dD$ (i.e. il massimo numero di sfere tangenti tra loro e ad una sfera centrale). L'upper bound si attesta invece su $12$.","x":-7812,"y":5972,"width":514,"height":211,"color":"4"},
		{"id":"42f6d4efb4f98e2f","type":"text","text":"# Data Mule Scheduling\n\nIl Data Mule è un nodo mobile che va in giro a raccogliere dati, consentendo ai nodi fissi di comunicare grandi moli di dati usando bassa potenza (i.e. consumando poca batteria) e sgravandoli dal compito di fare routing.\n\nIl problema di trovare il ***percorso ottimale*** tra i nodi si formalizza nel seguente modo:\n\n- Un ***percorso hamiltoniano*** è una cammino che tocca tutti i nodi una ed una sola volta;\n- Un ***ciclo hamiltoniano*** (***HC***) è un percorso hamiltoniano il cui ultimo nodo coincide col primo;\n- Trovare il ciclo hamiltoniano ottimale si traduce nel ***travelling salesman problem*** (***TSP***).\n\nPosto di aver trovato il path, ci sono altre due variabili da tenere in considerazione:\n\n- ***Controllo della velocità*** - Una volta entrato in range di trasmissione, il Mule deve restarci per il tempo necessario a scaricare tutti i dati;\n- ***Job Scheduling*** - Se il percorso del Mule passa per il range di più dispositivi contemporaneamente, deve scegliere a quale dei due dare la precedenza per il trasferimento dei dati.\n\nCi focalizziamo solo sul TSP, e la soluzione è sempre un ***grafo orientato***.","x":-9995,"y":1679,"width":910,"height":483,"color":"6"},
		{"id":"8279c766076594f2","type":"text","text":"# Distanza di Laguerre\n\nLa ***distanza di Laguerre*** tra due sensori $p$ e $q$ nello spazio $\\dD$ individuati da circonferenze di centro $C_p=(x_p,y_p)$ e raggio $r_p$ (e analogo con $C_q$ ed $r_q$) è definita come$$d_L^2(P,Q)=(x_p-x_q)^2+(y_p-y_q)^2-|r_p-r_q|^2=\\dist^2(C_p,C_q)- (\\D r)^2$$dove con $\\dist(C_p,C_q)$ si intende la distanza euclidea in $\\dD$ tra i centri delle circonferenze e con $\\D r$ il valore assoluto della differenza tra i due raggi. Questa distanza è un po' strana.\n\n- Se $\\D r=0$ (i.e. i due sensori hanno lo stesso sensing range) si ricade nella distanza euclidea;\n- Se invece $\\dist(C_p,C_q)=0$ (i.e. i sensori si trovano nello stesso punto), la distanza pesa solo la differenza dei raggi. Questa è ovviamente una situazione di scarso interesse pratico;\n- In quali situazioni l'intera distanza si annulla?\n\t- I due sensori sono identici e nello stesso punto (caso banale e di scarso interesse);\n\t- $\\D r=\\dist(C_p,C_q)$, i.e. le due metriche si bilanciano. Quando può succedere? Definiamo $R=\\max(r_p,r_q)$, $r=\\min(r_p,r_q)$ e $d=\\dist(C_p,C_q)$.\n\t\t- Se $d>r+R$, i.e. se le circonferenze sono disgiunte, la distanza non può annullarsi;\n\t\t- Se $d=r+R$, i.e. le circonferenze sono tangenti dall'esterno, l'unica soluzione è che una delle due sia degenere in un punto (i.e. $r=0$);\n\t\t- Se $r<d<R+r$, i.e. le circonferenze sono secanti, poniamo che $d=r+\\D$, con $\\D<R$. Dovendo essere vero che $d=R-r$, la soluzione è avere $r={1\\over2}(R-\\D)$, da cui vediamo anche bene che per circonferenze tangenti la soluzione è degenere e per quelle disgiunte la soluzione non è definita;\n\t\t\t- Si noti quindi che il caso $d=R$ coincide con il caso $d=r+R$.\n\t\t- Se $d\\leq r$ l'unica soluzione è che le due circonferenze siano tangenti dall'interno. Pensa di avere una circonferenza grande di raggio $R$ centrata in zero ed una di raggio $r$ da posizionare lungo l'asse $x$ in modo tale che $d=\\D r$. Il problema diventa trovare $x$ tale che $x^2-(R-r)^2=0$, ovvero $x=R-r$. Dovendo essere $d\\le r$ avrò che $r\\le{R\\over2}$, che non contraddice alcuna ipotesi ed è pertanto accettabile.\n\t\t\t- Questo ad esempio succede nel caso asimmetrico in cui ho un sensore di raggio $4$ in $(0,0)$ e uno di raggio $1$ in $(0,3)$, oppure se scelgo $d=r$ ed $r={R\\over2}$.\n\nPer riassumere: l'unica situazione non banale e non degenere (i.e. $R>r\\ne0$) in cui la distanza di Laguerre fa $0$ è quella in cui la circonferenza piccola è tangente dall'interno a quella grande. Non è invece definita in tutte le situazioni in cui la circonferenza piccola è strettamente contenuta in quella grande. Per un riassunto grafico e forse per capirci davvero qualcosa gioca con [questo](https://www.desmos.com/calculator/tcbqoibyaw).\n\nLa grande domanda potrebbe essere \"ma che mi frega di sapere quando si annulla la distanza\"? Mi interessa perché questo concetto è strettamente legato a quello di ***asse radiale***, i.e. il luogo dei punti equidistanti da due circonferenze secondo Laguerre.\n\n\n","x":8966,"y":6400,"width":820,"height":1017,"color":"4"},
		{"id":"8a89387f90c7b1d1","type":"text","text":"# Algoritmo Divide-Et-Impera\n\nPer ogni sito considero il segmento che lo congiunge con il suo primo vicino, ne traccio l'asse e mi metto in tasca il semipiano delimitato da questo asse e che contiene il sito che sto considerando.\n\nIterativamente trovo un set di $k=\\T(n)$ semipiani. Per trovare le celle devo intersecarli in modo opportuno . Come si fa? Tramite un algoritmo divide-et-impera:\n\n- ***Divide*** - Parto dal set di questi semipiani e ne costruisco un ***albero binario***;\n\t- Con che logica? Questo punto non è molto chiaro, perché in linea di principio qualsiasi ordine di split io scelga il risultato finale dell'algoritmo sarà identico. In genere, dice ChatGPT, si sceglie un ordine che massimizza l'efficienza (no shit Sherlock), tipo il bilanciamento dei nodi (in qualsiasi modo venga poi applicato...)\n- ***Impera*** - Interseco ogni foglia (i.e. gli unici nodi che contengono un semipiano) con lo spazio di ricerca (i.e. sto costruendo Voronoi in uno spazio finito, mentre un semipiano è infinito), in modo da ottenere poligoni dall'area $<\\infty$;\n- ***Combine*** - A questo punto a partire dalle foglie calcolo ricorsivamente l'intersezione dei fratelli e metto il risultato nel padre.\n\nTutto ciò ha una complessità $O(k\\log k)\\so O(n\\log n)$ per singola cella, quindi $O(n^2\\log n)$ per l'intero diagramma. ","x":7521,"y":3808,"width":820,"height":547,"color":"4"},
		{"id":"79617be8e0aa4bae","type":"text","text":"# [Algoritmo di Fortune](https://www.youtube.com/watch?v=k2P9yWSMaXE&ab_channel=KevinSchaal)\n\nSi basa sullo scorrimento dall'alto in basso di una cosiddetta ***beach line***. L'idea è molto semplice:\n\n- La parabola è il luogo geometrico dei punti equidistanti dal fuoco e dalla direttrice;\n- La beach line funge da direttrice, mentre i siti sono i fuochi;\n- Scorrendo dall'alto in basso, ogni sito incontrato genera una parabola;\n- Le intersezioni delle parabole associate ai siti $i$ e $j$ definiscono i punti equidistanti dai siti $i$ e $j$, che è esattamente la definizione di asse di Voronoi;\n- Ogni nuova parabola (i.e. ogni volta che la beach line incontra un sito, pertanto detto ***site event***) crea due nuovi ***breakpoints*** (i.e. punti d'intersezione tra due parabole);\n- Le intersezioni di tre parabole portano all'estinzione di uno dei tre archi, e alla formazione di un cosiddetto ***circle event*** (il vertice di Voronoi è equidistante dai tre siti associati alle parabole che lo hanno generato, ma anche tangente alla beach line).\n\nLa sta facendo più complicato di quello che è, basta sapere la definizione di parabola e guardare il video linkato nel titolo...\n\nIl costo computazionale sul tempo è $O(n\\log n)$, che è un ***risultato ottimale*** perché si può dimostrare una riduzione dal problema del sorting per confronto a quello della costruzione del diagramma di Voronoi, mentre sullo spazio occupato è $O(n)$.","x":5840,"y":4532,"width":820,"height":547,"color":"4"},
		{"id":"b6c36e2f41c565c3","type":"text","text":"# Complessità Minima dell'Ordinamento per Confronto \n\nGli algoritmi *naive* sono tutti $\\Theta(n^2)$. Si può fare di meglio? Se sì, quanto?\n\nPer rispondere a questa domanda costruiamo un ***albero di decisione binaria*** in cui\n\n- Ogni nodo è un confronto tra due valori, e ha esattamente due figli;\n\t- i.e. i casi sono due: $a>b$ oppure $a\\leq b$.\n- Ogni foglia è una permutazione della sequenza di input.\n\nA questo punto è utile notare alcune cose.\n\n1. Il caso peggiore corrisponde al percorso più lungo sull'albero, cioè ad $h$ step (dove $h$ è l'altezza dell'albero);\n2. Dato un input di $n$ elementi esistono $n!$ permutazioni, e una sola è soluzione;\n3. Un albero binario di altezza $h$ non può contenere più di $2^h$ foglie.\n\nSegue dalle affermazioni `2` e `3` che $2^h \\geq n!$, ovvero $h \\geq log_2(n!)$. Ma nel nome di Stirling sappiamo che $log(n!) = \\Theta(n\\,log(n))$, quindi$$h\\geq\\Theta(n\\,log(n)) \\Rightarrow h = \\Omega(n\\,log(n))$$Questo ci dice che ***qualsiasi algoritmo di ordinamento basato su confronti ha un costo asintotico minimo*** pari a $n\\,log(n)$.","x":5840,"y":5270,"width":820,"height":581,"color":"4"},
		{"id":"23551488cd52cb0d","type":"file","file":"Wireless Networks/Dynamic WSN/LaguerreDistanzaMinima.png","x":7730,"y":7257,"width":400,"height":118},
		{"id":"61d8e15fb8ec7659","type":"file","file":"Wireless Networks/Dynamic WSN/Laguerre.gif","x":7730,"y":7417,"width":400,"height":118},
		{"id":"885454e7cd3ae6ea","type":"text","text":"# Algoritmi per Voronoi\n\nNel caso di ***sensori omogenei*** (i.e. aventi tutti lo stesso sensing range) è sufficiente ridurre il problema ad un diagramma di Voronoi classico, per cui applichiamo algoritmi come un ***Divide-et-Impera*** o ***Fortune*** sfruttando implicitamente la ***distanza euclidea*** classica.\n\nNel caso di ***sensori disomogenei*** è necessario tenere conto delle differenze di sensing range tramite la ***distanza di Laguerre***, eseguendo iterativamente un classico Divide-et-Impera.","x":7521,"y":4692,"width":820,"height":227,"color":"6"},
		{"id":"9ed663a17e65c38a","type":"text","text":"# Assi Radiali e Diagrammi di Voronoi-Laguerre\n\nL'idea è usare gli ***assi radiali*** trovati secondo la ***distanza di Laguerre*** in modo analogo agli assi euclidei usati per l'algoritmo Divide-et-Impera.\n\nSupponiamo w.l.o.g. di avere la circonferenza più grande in $(0,0)$, e che quella più piccola si muova solo lungo l'asse $x$, a distanza $k$ dall'origine. Gli assi radiali sono allora definiti dall'equazione$$x^2+y^2-R^2 = (x-k)^2+y^2-r^2\\quad\\so\\quad x^2-R^2 = (x-k)^2-r^2$$Da qui possiamo fissare i due raggi $R$ ed $r$ ed analizzare il comportamento dell'asse radiale in funzione della distanza euclidea $k$ tra i due centri. Troviamo anzitutto $$x(k)={k\\over2}+{\\D\\over2k}\\quad\\so\\quad \\partial_k\\bigg[x(k)\\bigg]\\impose 0 \\quad\\text{sono i punti stazionari}$$dove $\\D=R^2-r^2$. Ricaviamo quindi che, rispetto al centro della circonferenza più grande, il minimo si ha quando i due centri sono a distanza $k=\\sqrt\\D$, e il minimo è proprio tale distanza euclidea $k$$${k\\over2}+{\\D\\over2k}={k^2+\\D\\over2k}={2\\D\\over2\\sqrt\\D}=\\sqrt\\D$$\nNotare che se $R=r$ tale minimo è $0$ (in $k=0$). Ne risulta nel complesso [questa](https://www.desmos.com/calculator/gofyg9lwdj) situazione.\n\nQuindi qual è il punto? Che ***gli assi radiali vanno bene finché le due circonferenze sono disgiunte***. In caso contrario, iniziano ad esserci problemi, specialmente quando quella piccola viene inglobata in quella grande: l'asse esiste, ma produce una ***cella di Voronoi-Laguerre*** vuota.\n\nDa qui la necessità di produrre un ***algoritmo*** che, dopo aver calcolato le celle valuta, se la copertura è buona. In caso contrario, sposta i sensori per migliorare la copertura e ricalcola il diagramma.\n\n- Parto da una disposizione pseudocasuale dei sensori e costruisco il diagramma di Voronoi-Laguerre con i metodi precedenti;\n- Ogni sensore valuta se è ***soddisfatto*** o meno della sua copertura. Se non lo è, si sposta verso il centro geometrico della sua cella (secondo il diagramma di Voronoi classico);\n\t- I cerchi piccoli tenderanno a spostarsi molto, perché è probabile che per le proprietà viste sopra siano molto spostati rispetto a tale centro (se non addirittura fuori dalla propria cella, se una circonferenza grande li ha inglobati). In questo senso, potremmo dire che hanno \"poca inerzia\";\n\t- I cerchi grandi, viceversa, hanno \"molta inerzia\" e tenderanno a spostarsi poco. È verosimile assumere che partano già molto vicini al centro della propria cella;\n\t- In ogni caso, il massimo movimento possibile è limitato dal range del sensore più piccolo, per evitare eccessivi stravolgimenti del diagramma tra un'iterazione e l'altra.\n- Le nuove posizioni vengono usate per calcolare un nuovo diagramma di Voronoi-Laguerre, e si ricomincia il `loop` finché la copertura non converge.\n\t- Per assicurare la convergenza ed evitare infinite piccole aggiustatine si mette un limite $\\e$ sulla distanza di movimento, sotto al quale il sensore resta fermo.","x":7520,"y":6067,"width":820,"height":1092,"color":"4"},
		{"id":"b64dc0121fd2eb98","type":"text","text":"# Universalità dei Diagrammi di Voronoi\n\nHai presente la sequenza di Fibonacci che compare in posti lontani e apparentemente scorrelati tipo una conchiglia e la Via Lattea? Ecco, i diagrammi di Voronoi sono simili, essendo usati\n\n- In antropologia, per descrivere le aree di influenza culturale;\n- In ecologia, per modellizzare la competizione tra piante;\n- Da Snow nel 1854 per dimostrare che il colera era correlato all'acqua contaminata (i siti erano le fontane pubbliche, e i casi si concentravano nelle celle di alcune di esse);\n- [...]\n\nLe celle sono note in cristallografia come celle di ***Wigner-Seitz***, si usano in teoria dei gruppi con il nome di domini fondamentali e in topologia vengono chiamate poligoni fondamentali.\n\nInsomma, una roba utile a qualcosa. Proprio come il matching :)","x":10500,"y":2799,"width":632,"height":468,"color":"4"},
		{"id":"42fbb61aeb2f3203","type":"text","text":"# Tipi di Matching\n\nA seconda di come costruisco il matching, posso ottenere\n\n- ***Maximal Matching*** - È un matching $M$ tale che non posso aggiungere altri archi senza violarne le proprietà (i.e. se aggiungo un qualsiasi altro arco, $M$ non è più un matching);\n\t- Non necessariamente un massimizza $|M|$;\n\t- Semplice da trovare con algoritmi greedy;\n\t- Spesso rappresenta uno step intermedio degli algoritmi di ottimizzazione.\n- ***Maximum Matching*** - Metto in $M$ il maggior numero possibile di archi (massimizza $|M|$);\n\t- Risulta un po' più semplice da trovare se il grafo è bipartito.\n- ***Perfect Matching*** - Particolare Maximum Matching in cui richiedo che ogni nodo tocchi esattamente un arco $\\in M$ (i.e. che ogni nodo sia ***coperto***). La soluzione ottimale è organizzare i nodi del grafo a coppie, motivo per cui $|M|\\sim n/2$.\n\n Un singolo arco è un matching, probabile anche due. La domanda interessante quindi è: qual è il matching massimo? O, nel caso gli archi siano pesati, qual è il matching massimo dal peso minimo?","x":1280,"y":2808,"width":820,"height":459,"color":"4"},
		{"id":"74c6c373164b0c2a","type":"text","text":"# OPIS KA869B9G","x":880,"y":640,"width":377,"height":128,"color":"1"},
		{"id":"b5e90606dfa7c37c","type":"text","text":"# Unmanned Aerial Vehicles (UAV, i.e. Droni)\n\nUna flotta di droni che deve coprire un'Area of Interest (AoI) partendo da una base $v_0$ deve essere in grado di farlo nel minor tempo possibile, tenendo conto che la batteria limitata (di durata $B$) di ognuno di essi va ricaricata periodicamente alla base.\n\nI siti dell'AoI si schematizzano come grafo i cui pesi sono i tempi di viaggio tra di essi. Ogni UAV parte da $v_0$, visita un sottoinsieme di nodi $\\{v_i\\}$ e torna in $v_0$ per un tempo di ricarica $R$ $\\sim(2.5\\div5)\\,B$.\n\nL'obiettivo varia a seconda dell'applicazione. Ad esempio, è possibile ottimizzare\n\n- ***Completion Time*** - Voglio coprire la AoI (i.e. visito tutti i siti) nel minor tempo possibile;\n- ***Average Waiting Time*** - Voglio minimizzare l'intervallo di tempo tra due visite allo stesso sito;\n- ***Numero di Cicli*** - Voglio ridurre il numero totale di viaggi.\n\nIl problema è $\\NPH$, e non è riconducibile in modo semplice a problemi noti.\n","x":-480,"y":7360,"width":820,"height":409,"color":"6"},
		{"id":"4c8a56bcdfd5b133","type":"text","text":"# Approssimazioni Inadeguate\n\nCome detto, il problema non si riesce a mappare in modo semplice a problemi noti. Perché?\n\n- ***mTSP*** (multiple TSP) - Abbiamo diversi data mule. Ci piace la definizione del problema, però l'obiettivo non tiene conto dei constraints di tempo legati alla batteria;\n- ***kTRPR*** (k-Traveling Repair-person Problem with Repair-times) - Tiene conto di quanto tempo richiede visitare ogni nodo e punta a minimizzare il tempo complessivo, ma non gli si può mettere il battery constraint;\n- ***mTRPD*** (multiple Traveling Repair-person Problem with Distance Constraints) - Permette il battery constraint, essendo una schematizzazione di tipo \"deposito-customers-deposito-...\", ma non tiene conto del tempo di visita per singolo nodo;\n- ***VRP*** (Vehicle Routing Problem) - Generico nome per una classe di algoritmi che però hanno limitazioni incompatibili con il problema dei droni;\n- ***TOP*** (Team Orienteering Problem) - Ci sta il deposito e tutto, ma l'obiettivo è massimizzare il numero di siti coperti (il che ovviamente non ci piace, devo coprirli tutti per definizione).\n\n","x":-1940,"y":7360,"width":930,"height":409,"color":"4"},
		{"id":"1d7ea229076247ab","type":"text","text":"# Approssimazioni Adeguate - MDMT-VRP-TCT\n\nL'obiettivo di un ***Rooted Minimum Bounded Cycle Cover Problem*** (***RMCCP***) è quello di trovare un set di cicli radicati in $v_0$​ aventi costo massimo complessivo $x$ che coprano tutti i siti $\\{v_i\\}$ minimizzando il numero di cicli.\n\nQuesta schematizzazione è molto simile al nostro problema, tanto che\n\n- RMCCP è approssimabile con ratio $\\a\\quad\\so\\quad$ Il nostro problema è approssimabile con ratio $5\\a+1$\n- Il nostro problema è approssimabile con ratio $\\g\\quad\\so\\quad$ RMCCP è approssimabile con ratio $2\\g+1$\n\nBene, ma allora qual è \"il nostro problema\"? Dobbiamo minimizzare il completion time, non il numero di cicli.\n\nUn ***Multi-Depot Multi-Trip Vehicle Routing Problem with Total Completion Times minimization*** (***MDMT-VRP-TCT***, e sì, non sto scherzando) fa esattamente questo. Personalmente, per brevità, lo chiamerei ***Gianni***.\n\nL'idea è che permette più depositi (i.e. il buon vecchio $v_0$), più ***trip*** (i.e. una sequenza di nodi visitati da un singolo UAV) e un ***battery constraint*** (i.e. un trip è accettabile solo se la sua durata totale è $\\le B$). Questo problema può essere formulato come ***MILP*** (***Mixed ILP***), in cui\n\n- la durata della sequenza di $k$ nodi è la somma dei pesi degli archi attraversati e dei pesi delle visite dei nodi;\n- per la durata del trip si aggiungono le visite al deposito (i.e. partenza e arrivo).\n\nIntuitivamente, il numero di soluzioni è esponenziale. Per questo motivo si usano delle euristiche (dette per qualche motivo ***matheuristics***) per ridurre lo spazio di ricerca, e.g. introdurre una priorità per i nodi cruciali come scuole, ospedali, ...\n\nOn top of that, si possono costruire meccanismi più raffinati, e.g. ***criteri dinamici*** che modificano il comportamento preimpostato del drone (e.g. se rilevi una persona ferita fermati ad assisterla).","x":-535,"y":8080,"width":930,"height":663,"color":"4"},
		{"id":"28115221b2179ae7","type":"file","file":"Wireless Networks/Dynamic WSN/Gianni_1.png","x":500,"y":8080,"width":400,"height":258},
		{"id":"015791e1734d0fb0","type":"file","file":"Wireless Networks/Dynamic WSN/Gianni_2.png","x":500,"y":8485,"width":400,"height":258},
		{"id":"a76d498b7e4708a5","type":"text","text":"# Si vola alle Topologies! Così, de botto, senza senso.\n\nTi ricordi il discorso delle topologie non-blocking? Ecco, qua ci sta tutto un discorso su come sfruttare gli algoritmi di matching su grafi bipartiti.\n\nIn pratica il punto è che non essendo rearrangeable tocca mettere i buffer e ci sta del delay. Lo scheduler fa un matching per <span style=\"color:#FFA500\">boooooh ma che cazzo ne so</span>","x":1280,"y":5794,"width":820,"height":367,"color":"1"},
		{"id":"4da779e73cee6293","type":"text","text":"# Commenti all'Ottavo Pacco di Slides\n\nIl problema di tutto ciò che segue è che sono nozioni senza alcun filo logico che le collega.\n\nIl Teorema di Hall non ha utilità pratica, la parte degli augmenting path è al limite del comprensibile, l'Hungarian Method e il problema dei flussi vengono definiti ma non viene dedicato loro alcuno spazio, la digressione sulle Topologies è, mi permetto di dire, inopportuna.\n\nInsomma, è un grosso minestrone al quale purtroppo non sono riuscito a dare una logica semplice e intuitiva.","x":2712,"y":3680,"width":820,"height":285,"color":"5"}
	],
	"edges":[
		{"id":"2dd1c710e5237308","fromNode":"d2544beca5412320","fromSide":"right","toNode":"50ee741910a5fe7f","toSide":"left"},
		{"id":"395a0006bfce063c","fromNode":"a357e03f7f1a5b24","fromSide":"top","toNode":"d2544beca5412320","toSide":"bottom","label":"1, 2, 3"},
		{"id":"2dd643dcf93bbe8d","fromNode":"a357e03f7f1a5b24","fromSide":"bottom","toNode":"ccd5d58aee1a1854","toSide":"top","label":"4 - 10"},
		{"id":"83e5bc3b5da3124e","fromNode":"d2544beca5412320","fromSide":"left","toNode":"e56580a6f5083976","toSide":"right","label":"2"},
		{"id":"ce292b22e8d0ca1c","fromNode":"b9e0920af020317d","fromSide":"bottom","toNode":"7cef3692c96911ff","toSide":"top"},
		{"id":"98f1b66052568d98","fromNode":"dd0d131e13f35659","fromSide":"bottom","toNode":"b9e0920af020317d","toSide":"top"},
		{"id":"52dcd9497d407530","fromNode":"1d1bb348e26741be","fromSide":"left","toNode":"987d223816397269","toSide":"right"},
		{"id":"b4fd51dac7c566b6","fromNode":"1d1bb348e26741be","fromSide":"left","toNode":"1ea4e9935cbc3ccb","toSide":"right"},
		{"id":"de399d1b4232d29c","fromNode":"1d1bb348e26741be","fromSide":"left","toNode":"415ae513e0597c9f","toSide":"right"},
		{"id":"c80cfaff64d1a832","fromNode":"1d1bb348e26741be","fromSide":"top","toNode":"73186b9e785a6d9f","toSide":"bottom"},
		{"id":"141bb11ada042eb9","fromNode":"415ae513e0597c9f","fromSide":"left","toNode":"f9aff2fe04035044","toSide":"right"},
		{"id":"11e188c063588764","fromNode":"415ae513e0597c9f","fromSide":"left","toNode":"027c0cd624270dfd","toSide":"right"},
		{"id":"862a2b692dcd8b6d","fromNode":"415ae513e0597c9f","fromSide":"left","toNode":"2e2ca95eba644e09","toSide":"right"},
		{"id":"f76cab158aecfd39","fromNode":"e56580a6f5083976","fromSide":"left","toNode":"d07e0547b6ef80cf","toSide":"right"},
		{"id":"5db45bc5b407bd82","fromNode":"d07e0547b6ef80cf","fromSide":"top","toNode":"8570332b3639b827","toSide":"bottom"},
		{"id":"c020c69c0af0098f","fromNode":"d07e0547b6ef80cf","fromSide":"bottom","toNode":"320fe254853146fb","toSide":"top"},
		{"id":"1ae6b576c8420cbb","fromNode":"d274be6ad99d7896","fromSide":"right","toNode":"4d081cb1dc52385a","toSide":"left"},
		{"id":"6cc8514c00eeb11d","fromNode":"320fe254853146fb","fromSide":"left","toNode":"ea0aa6b73724a2f1","toSide":"right"},
		{"id":"a04e068be72fe082","fromNode":"ea0aa6b73724a2f1","fromSide":"top","toNode":"bcef48638324e695","toSide":"bottom"},
		{"id":"4a31491dd10c39d1","fromNode":"320fe254853146fb","fromSide":"left","toNode":"0a98e240f74a5ea3","toSide":"right"},
		{"id":"92e1a7d7c29609d3","fromNode":"0a98e240f74a5ea3","fromSide":"left","toNode":"d27672ae4c020959","toSide":"right"},
		{"id":"4e92c4ac5b11d3ec","fromNode":"0a98e240f74a5ea3","fromSide":"left","toNode":"3408dbb01038ad25","toSide":"right"},
		{"id":"75aac25d765e1dee","fromNode":"320fe254853146fb","fromSide":"bottom","toNode":"a8462c1ce6b6bf95","toSide":"top"},
		{"id":"a78511e3a6a10e04","fromNode":"320fe254853146fb","fromSide":"right","toNode":"58f1b1ae15330a4d","toSide":"left"},
		{"id":"fcfc9429a5f3c907","fromNode":"320fe254853146fb","fromSide":"right","toNode":"2a5be57ad234c816","toSide":"left"},
		{"id":"6ea041bb2a155d43","fromNode":"d2544beca5412320","fromSide":"right","toNode":"cbe04eb6b7a42a4f","toSide":"left"},
		{"id":"b3bae50304e98fc6","fromNode":"ccd5d58aee1a1854","fromSide":"right","toNode":"cbe04eb6b7a42a4f","toSide":"left"},
		{"id":"90210e3d9e5ffaaf","fromNode":"cbe04eb6b7a42a4f","fromSide":"right","toNode":"50ee741910a5fe7f","toSide":"left","label":"3"},
		{"id":"fa2ab0a43d5e5458","fromNode":"cbe04eb6b7a42a4f","fromSide":"right","toNode":"77ba41fe37aca09d","toSide":"left","label":"4"},
		{"id":"623f005aa3e55522","fromNode":"2b58db98d883eb5c","fromSide":"right","toNode":"75e3f9291afb2635","toSide":"left"},
		{"id":"eca53a4d159389f9","fromNode":"ccd5d58aee1a1854","fromSide":"right","toNode":"77ba41fe37aca09d","toSide":"left"},
		{"id":"3ed864e9fb272af7","fromNode":"846dce13513dafd6","fromSide":"top","toNode":"3631eb3da23e034b","toSide":"bottom"},
		{"id":"dd416b794d397ab8","fromNode":"846dce13513dafd6","fromSide":"bottom","toNode":"6b1241ca58e29582","toSide":"top"},
		{"id":"7a9eeb20d00f4cff","fromNode":"3631eb3da23e034b","fromSide":"top","toNode":"c6f0767927f3b557","toSide":"bottom","fromEnd":"arrow","label":"Stesso problema\ni.e. Rotte Cicliche\n"},
		{"id":"744ad05ed1d202e7","fromNode":"d4f9095c56d98baf","fromSide":"left","toNode":"846dce13513dafd6","toSide":"right"},
		{"id":"12e9b8c1b3a311e2","fromNode":"d2544beca5412320","fromSide":"top","toNode":"d4f9095c56d98baf","toSide":"bottom","label":"1"},
		{"id":"cb2f1a40ee4a3dfe","fromNode":"d4f9095c56d98baf","fromSide":"top","toNode":"25aa86cc5f128d11","toSide":"bottom","label":"One-To-All\nReti di Elaboratori"},
		{"id":"c33690af6183d6b4","fromNode":"188f2ac3e643b8c4","fromSide":"bottom","toNode":"c6f0767927f3b557","toSide":"top"},
		{"id":"999dc9bf8bc98b71","fromNode":"d4f9095c56d98baf","fromSide":"top","toNode":"3e6d4dd9674719b8","toSide":"bottom","label":"All-To-All"},
		{"id":"94aa39f42e685150","fromNode":"73186b9e785a6d9f","fromSide":"left","toNode":"6d3314bb9107a820","toSide":"right"},
		{"id":"40276521fcecd417","fromNode":"25aa86cc5f128d11","fromSide":"left","toNode":"188f2ac3e643b8c4","toSide":"right"},
		{"id":"d1f7b34d4761bf1f","fromNode":"c6f0767927f3b557","fromSide":"left","toNode":"81c67bbb8a1cba08","toSide":"right"},
		{"id":"8553bb1e8145f000","fromNode":"188f2ac3e643b8c4","fromSide":"left","toNode":"0cf213e4da0de072","toSide":"right"},
		{"id":"f3ccdf4e5de64a7b","fromNode":"3e6d4dd9674719b8","fromSide":"right","toNode":"8934ea2435a5c421","toSide":"left"},
		{"id":"35550b1d9f8dc429","fromNode":"7aff029b7f5f646e","fromSide":"right","toNode":"2c22d4b4635fe807","toSide":"left"},
		{"id":"66283ec5ed2f40a0","fromNode":"25aa86cc5f128d11","fromSide":"right","toNode":"7aff029b7f5f646e","toSide":"left"},
		{"id":"4e4eeac17b65bc52","fromNode":"6b1241ca58e29582","fromSide":"right","toNode":"0ad1eb68f4cc5f23","toSide":"left"},
		{"id":"f654dc85c659ee9c","fromNode":"846dce13513dafd6","fromSide":"left","toNode":"07c729782ba8ac2d","toSide":"top"},
		{"id":"d5918bbdd94e088d","fromNode":"e56580a6f5083976","fromSide":"top","toNode":"07c729782ba8ac2d","toSide":"bottom"},
		{"id":"31e8abcb286b645d","fromNode":"07c729782ba8ac2d","fromSide":"left","toNode":"1d1bb348e26741be","toSide":"bottom"},
		{"id":"657a9975e3df5883","fromNode":"d2544beca5412320","fromSide":"top","toNode":"07c729782ba8ac2d","toSide":"right"},
		{"id":"4093cbfb270b96bd","fromNode":"d27672ae4c020959","fromSide":"left","toNode":"083dff6be0a78b0e","toSide":"right"},
		{"id":"edf010bc4ffa664d","fromNode":"cbe04eb6b7a42a4f","fromSide":"bottom","toNode":"e2adc07649e4c8fe","toSide":"top"},
		{"id":"864d238ffb42b33a","fromNode":"50ee741910a5fe7f","fromSide":"top","toNode":"925c7c49ad926dc9","toSide":"bottom"},
		{"id":"97537b80f23377cd","fromNode":"50ee741910a5fe7f","fromSide":"right","toNode":"c6dab239c4b403e2","toSide":"left"},
		{"id":"8174db304776fbec","fromNode":"c6dab239c4b403e2","fromSide":"top","toNode":"8e6064b195e14846","toSide":"bottom"},
		{"id":"55a4481b39f18799","fromNode":"8e6064b195e14846","fromSide":"top","toNode":"063e09fb76d545e6","toSide":"bottom"},
		{"id":"3408d88bbea81273","fromNode":"8e6064b195e14846","fromSide":"top","toNode":"9b0770ff84448f48","toSide":"bottom"},
		{"id":"5ff8df2fa73d7d42","fromNode":"9b0770ff84448f48","fromSide":"right","toNode":"616050734c119734","toSide":"left"},
		{"id":"c7b18ed04503ab99","fromNode":"8e6064b195e14846","fromSide":"left","toNode":"bf126287e54f6be7","toSide":"right"},
		{"id":"cd1c535817508347","fromNode":"063e09fb76d545e6","fromSide":"left","toNode":"9b0770ff84448f48","toSide":"right"},
		{"id":"622d8f8f5027592a","fromNode":"063e09fb76d545e6","fromSide":"right","toNode":"17559ea1adfc4706","toSide":"top"},
		{"id":"df63c0470bfcf52d","fromNode":"8e6064b195e14846","fromSide":"right","toNode":"17559ea1adfc4706","toSide":"left"},
		{"id":"d590a69355b00c20","fromNode":"17559ea1adfc4706","fromSide":"right","toNode":"1c74269dfe67f918","toSide":"left"},
		{"id":"744e9dfb0b955d82","fromNode":"c6dab239c4b403e2","fromSide":"right","toNode":"19537ff13325ff86","toSide":"left"},
		{"id":"39aa5c9fd01814e4","fromNode":"c6dab239c4b403e2","fromSide":"bottom","toNode":"95f89f0231d71765","toSide":"top"},
		{"id":"9174cfb4fb040c90","fromNode":"13a6925d665fb511","fromSide":"right","toNode":"95f89f0231d71765","toSide":"left"},
		{"id":"4637962d3b047102","fromNode":"925c7c49ad926dc9","fromSide":"top","toNode":"48b70622c72eb3c5","toSide":"bottom"},
		{"id":"8c94b8ebce0113e7","fromNode":"925c7c49ad926dc9","fromSide":"top","toNode":"a6f2c320c3ffdcb2","toSide":"bottom"},
		{"id":"bfb36a1ac0a197cb","fromNode":"50ee741910a5fe7f","fromSide":"right","toNode":"13a6925d665fb511","toSide":"top"},
		{"id":"39f7df0e3845715a","fromNode":"a6f2c320c3ffdcb2","fromSide":"left","toNode":"bc7307e7d62eb05d","toSide":"right"},
		{"id":"f1b5289553cf4dc9","fromNode":"50ee741910a5fe7f","fromSide":"bottom","toNode":"ea9adcf1142783df","toSide":"top"},
		{"id":"47b87137b6e20145","fromNode":"373aaa95500d2c52","fromSide":"bottom","toNode":"0f9c5528fb0d2128","toSide":"top"},
		{"id":"e83bbbd432c6de7a","fromNode":"373aaa95500d2c52","fromSide":"bottom","toNode":"e4932f0ed846fa22","toSide":"top"},
		{"id":"b1a749b068ad452e","fromNode":"8b9aad2d5c4f419c","fromSide":"bottom","toNode":"19bc2b8ef4a1cfd6","toSide":"top"},
		{"id":"44e91b3da429d67b","fromNode":"a395388c75b4a5e6","fromSide":"right","toNode":"d274be6ad99d7896","toSide":"bottom"},
		{"id":"6da4c558b832121f","fromNode":"a395388c75b4a5e6","fromSide":"right","toNode":"f217cb40d8312551","toSide":"left"},
		{"id":"296e4da61e5a4570","fromNode":"373aaa95500d2c52","fromSide":"left","toNode":"050668ecfe632219","toSide":"right"},
		{"id":"4a39a6b94edcf4b5","fromNode":"373aaa95500d2c52","fromSide":"left","toNode":"8b9aad2d5c4f419c","toSide":"right"},
		{"id":"0c6ca5eff99e1a43","fromNode":"320fe254853146fb","fromSide":"left","toNode":"373aaa95500d2c52","toSide":"right"},
		{"id":"6c0ea7a15e73c4ae","fromNode":"320fe254853146fb","fromSide":"right","toNode":"a395388c75b4a5e6","toSide":"left"},
		{"id":"463e5ef20602e771","fromNode":"a395388c75b4a5e6","fromSide":"bottom","toNode":"2a5be57ad234c816","toSide":"top"},
		{"id":"62a5f4f0d6483ea9","fromNode":"a395388c75b4a5e6","fromSide":"bottom","toNode":"61ea744984748c18","toSide":"left"},
		{"id":"8ade0c11afeca704","fromNode":"75515ee37aaeb128","fromSide":"left","toNode":"42f6d4efb4f98e2f","toSide":"right","label":"6"},
		{"id":"7ed74cd0d3a145f5","fromNode":"177ea2d809b550a8","fromSide":"bottom","toNode":"e6316db3416c4b1e","toSide":"top"},
		{"id":"971d1f37e856609e","fromNode":"c1690a87fa9debb2","fromSide":"left","toNode":"177ea2d809b550a8","toSide":"right"},
		{"id":"2d4c9a2038b51bb1","fromNode":"177ea2d809b550a8","fromSide":"right","toNode":"c1690a87fa9debb2","toSide":"left"},
		{"id":"bfb767e2df0d9a9a","fromNode":"c1690a87fa9debb2","fromSide":"left","toNode":"e6316db3416c4b1e","toSide":"right"},
		{"id":"1a0f91fe1656563f","fromNode":"c1690a87fa9debb2","fromSide":"right","toNode":"520edf73b73c5a61","toSide":"left"},
		{"id":"6b019472a9d4cc6e","fromNode":"520edf73b73c5a61","fromSide":"right","toNode":"6a1fa8e5d9387640","toSide":"left"},
		{"id":"c95a7954cb144550","fromNode":"cf03900286e23529","fromSide":"left","toNode":"75515ee37aaeb128","toSide":"top","label":"5, 6, 7"},
		{"id":"cae4782b045330e7","fromNode":"cf03900286e23529","fromSide":"right","toNode":"73f5e1ff244b7ffd","toSide":"top","label":"8, 9"},
		{"id":"0171410e5ec2a308","fromNode":"75515ee37aaeb128","fromSide":"right","toNode":"f8b66801739f159b","toSide":"left","label":"7"},
		{"id":"8dc0dc68c45f2e50","fromNode":"73f5e1ff244b7ffd","fromSide":"bottom","toNode":"c76dfe719cc543c2","toSide":"top","label":"8"},
		{"id":"face0045a1c8ab44","fromNode":"73f5e1ff244b7ffd","fromSide":"bottom","toNode":"0ba91366af6367ab","toSide":"top","label":"9"},
		{"id":"66084ca914028881","fromNode":"77ba41fe37aca09d","fromSide":"right","toNode":"7ff3d7cc9445913c","toSide":"left"},
		{"id":"c346a4455923bbf7","fromNode":"177ea2d809b550a8","fromSide":"top","toNode":"723b2dd42fcce0d4","toSide":"bottom"},
		{"id":"6a048fd152ebebfa","fromNode":"9795fe394b77892c","fromSide":"left","toNode":"898ca3659127a5c2","toSide":"right"},
		{"id":"6f32c415e1cdd6d8","fromNode":"9795fe394b77892c","fromSide":"bottom","toNode":"65b789493892badd","toSide":"top"},
		{"id":"1225d17e57aae32a","fromNode":"75515ee37aaeb128","fromSide":"bottom","toNode":"9795fe394b77892c","toSide":"top","label":"5"},
		{"id":"a22ee51cebd34a40","fromNode":"42f6d4efb4f98e2f","fromSide":"bottom","toNode":"8c76a0adfff8363b","toSide":"top"},
		{"id":"e5eb224a47610bcf","fromNode":"8c76a0adfff8363b","fromSide":"left","toNode":"16f55a6de0f9c077","toSide":"right"},
		{"id":"a707df74556e67f9","fromNode":"8c76a0adfff8363b","fromSide":"left","toNode":"99acb315effd1dbf","toSide":"right"},
		{"id":"4294e075b352ab14","fromNode":"16f55a6de0f9c077","fromSide":"bottom","toNode":"99acb315effd1dbf","toSide":"top"},
		{"id":"7b0dc62462085a51","fromNode":"8c76a0adfff8363b","fromSide":"bottom","toNode":"70df56e5a6d283e3","toSide":"top"},
		{"id":"f638a6c7d3b80fb8","fromNode":"99acb315effd1dbf","fromSide":"left","toNode":"d1ed892b5da0140a","toSide":"right"},
		{"id":"15068b61a0c9602e","fromNode":"70df56e5a6d283e3","fromSide":"bottom","toNode":"f02c829c1a6717bd","toSide":"top"},
		{"id":"429e18f468e13ad0","fromNode":"70df56e5a6d283e3","fromSide":"bottom","toNode":"b0c24905e1ce0e5d","toSide":"top"},
		{"id":"c7d449be42f71055","fromNode":"42f6d4efb4f98e2f","fromSide":"left","toNode":"b6989927b66669c2","toSide":"right"},
		{"id":"04cc67bcf79c3996","fromNode":"b0c24905e1ce0e5d","fromSide":"bottom","toNode":"a73d0d136ca95187","toSide":"top"},
		{"id":"39f6085563deef38","fromNode":"f02c829c1a6717bd","fromSide":"bottom","toNode":"a73d0d136ca95187","toSide":"top"},
		{"id":"d693bd1a42ab7704","fromNode":"d3a257d13fa24f9f","fromSide":"left","toNode":"36340e2de86a0954","toSide":"right"},
		{"id":"3a8433e7afd82a5a","fromNode":"65b789493892badd","fromSide":"bottom","toNode":"d3a257d13fa24f9f","toSide":"top"},
		{"id":"321a873088cc4282","fromNode":"9795fe394b77892c","fromSide":"left","toNode":"a745896f4c0a6e74","toSide":"right"},
		{"id":"f39cdcbf3b35c73f","fromNode":"42f6d4efb4f98e2f","fromSide":"right","toNode":"a745896f4c0a6e74","toSide":"left"},
		{"id":"9f27b133234bb31a","fromNode":"65b789493892badd","fromSide":"left","toNode":"6bc931ed33956145","toSide":"right"},
		{"id":"be866bdf9cd7d4d8","fromNode":"d3a257d13fa24f9f","fromSide":"left","toNode":"6bc931ed33956145","toSide":"right"},
		{"id":"e20c650b487283d9","fromNode":"9795fe394b77892c","fromSide":"right","toNode":"a103b01e8a81d674","toSide":"left"},
		{"id":"d30bedbaab2e0323","fromNode":"9795fe394b77892c","fromSide":"right","toNode":"11d2cdcba60abc54","toSide":"left"},
		{"id":"c0895372a5ef4c69","fromNode":"f8b66801739f159b","fromSide":"bottom","toNode":"11d2cdcba60abc54","toSide":"right"},
		{"id":"468a472e7686ecbb","fromNode":"f8b66801739f159b","fromSide":"bottom","toNode":"83d6521bc77abe03","toSide":"top"},
		{"id":"6720031187de39c7","fromNode":"ccd5d58aee1a1854","fromSide":"bottom","toNode":"cf03900286e23529","toSide":"top"},
		{"id":"158fda56a9202a0e","fromNode":"83d6521bc77abe03","fromSide":"bottom","toNode":"a4c55563f0f19700","toSide":"top"},
		{"id":"5ad8da5543f07896","fromNode":"83d6521bc77abe03","fromSide":"left","toNode":"7d50dae939e9af68","toSide":"right"},
		{"id":"5deedc75322ef7b6","fromNode":"73f5e1ff244b7ffd","fromSide":"bottom","toNode":"8d9929233e830de4","toSide":"top"},
		{"id":"c9add1137841f6d5","fromNode":"8d9929233e830de4","fromSide":"left","toNode":"c76dfe719cc543c2","toSide":"right","label":"Centralized"},
		{"id":"9d414e76b263fb5e","fromNode":"8d9929233e830de4","fromSide":"right","toNode":"0ba91366af6367ab","toSide":"left","label":"Decentralized"},
		{"id":"440e2d8bcd19adea","fromNode":"73f5e1ff244b7ffd","fromSide":"top","toNode":"af5a6c815869b8d2","toSide":"bottom"},
		{"id":"97aa0bb302373860","fromNode":"7ff3d7cc9445913c","fromSide":"top","toNode":"c1690a87fa9debb2","toSide":"bottom"},
		{"id":"5f10efdcaff7b02b","fromNode":"c76dfe719cc543c2","fromSide":"bottom","toNode":"53f6e2fd4996e72c","toSide":"top","label":"\n"},
		{"id":"0a85f58bb91d122d","fromNode":"53f6e2fd4996e72c","fromSide":"left","toNode":"6be5a5347948cdc9","toSide":"right"},
		{"id":"83602dfe424da65a","fromNode":"53f6e2fd4996e72c","fromSide":"right","toNode":"292a836ba0520432","toSide":"left"},
		{"id":"813b6b040e164d0f","fromNode":"177ea2d809b550a8","fromSide":"left","toNode":"30ff3d1a672765f6","toSide":"right"},
		{"id":"67099b3ca4ec90e5","fromNode":"53f6e2fd4996e72c","fromSide":"bottom","toNode":"3584e1659bcd870e","toSide":"top"},
		{"id":"439882c1392f1c0d","fromNode":"3584e1659bcd870e","fromSide":"left","toNode":"a76d498b7e4708a5","toSide":"right"},
		{"id":"ec620ebe32a56c31","fromNode":"0ba91366af6367ab","fromSide":"right","toNode":"b64dc0121fd2eb98","toSide":"left"},
		{"id":"22f7852bcac836aa","fromNode":"0ba91366af6367ab","fromSide":"bottom","toNode":"f2a98d5ae11dd396","toSide":"top"},
		{"id":"77ccbf7cdc21fe86","fromNode":"f2a98d5ae11dd396","fromSide":"bottom","toNode":"5ae52405bd3ba1b6","toSide":"top"},
		{"id":"5f8691051d0b8886","fromNode":"53f6e2fd4996e72c","fromSide":"bottom","toNode":"af046ebb94346322","toSide":"top"},
		{"id":"3564add71f425e6b","fromNode":"292a836ba0520432","fromSide":"bottom","toNode":"269918eea9cb6b6a","toSide":"top"},
		{"id":"6487188a7e746c14","fromNode":"292a836ba0520432","fromSide":"top","toNode":"2b0eb76c35ded182","toSide":"bottom"},
		{"id":"1ca2c068a0ad9c09","fromNode":"79617be8e0aa4bae","fromSide":"bottom","toNode":"b6c36e2f41c565c3","toSide":"top","label":"Algoritmi I"},
		{"id":"75e3b520f9cc6657","fromNode":"f2a98d5ae11dd396","fromSide":"left","toNode":"885454e7cd3ae6ea","toSide":"right"},
		{"id":"94d977d26b44aa30","fromNode":"885454e7cd3ae6ea","fromSide":"top","toNode":"8a89387f90c7b1d1","toSide":"bottom"},
		{"id":"ca5aee5fbe8de91c","fromNode":"885454e7cd3ae6ea","fromSide":"left","toNode":"79617be8e0aa4bae","toSide":"right"},
		{"id":"ead3ae97f5b68341","fromNode":"885454e7cd3ae6ea","fromSide":"bottom","toNode":"9ed663a17e65c38a","toSide":"top"},
		{"id":"bde6bc0cfa4a12a6","fromNode":"5ae52405bd3ba1b6","fromSide":"left","toNode":"9ed663a17e65c38a","toSide":"right"},
		{"id":"39995bbf1eec5495","fromNode":"5ae52405bd3ba1b6","fromSide":"bottom","toNode":"8279c766076594f2","toSide":"top"},
		{"id":"1f5ceb917c208fed","fromNode":"8279c766076594f2","fromSide":"left","toNode":"9ed663a17e65c38a","toSide":"right"},
		{"id":"fce61c0d671ccbb3","fromNode":"c76dfe719cc543c2","fromSide":"left","toNode":"42fbb61aeb2f3203","toSide":"right"},
		{"id":"92fdce10b2ae8b70","fromNode":"cf03900286e23529","fromSide":"bottom","toNode":"b5e90606dfa7c37c","toSide":"top","label":"10"},
		{"id":"8748824e42545be9","fromNode":"b5e90606dfa7c37c","fromSide":"left","toNode":"4c8a56bcdfd5b133","toSide":"right"},
		{"id":"571d5dd883bc5134","fromNode":"4c8a56bcdfd5b133","fromSide":"bottom","toNode":"1d7ea229076247ab","toSide":"left"},
		{"id":"c0159cfe0c5c1f2d","fromNode":"b5e90606dfa7c37c","fromSide":"bottom","toNode":"1d7ea229076247ab","toSide":"top"}
	]
}