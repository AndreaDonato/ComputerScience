{
	"nodes":[
		{"id":"39b8b62db54759a1","type":"text","text":"# Premesse sui Grafi\n\nStrutture dati in cui i nodi sono collegati tramite link (***edges***).\n\nSe per ogni coppia di nodi $(u, v)$ esiste almeno un cammino da $u$ a $v$, il grafo è detto ***connesso***. È possibile verificare questa proprietà tramite un algoritmo **Breadth First Search** (**BFS**, e.g. **Algoritmo di Moore**) o analogamente **Depth First Search** (**DFS**). Verificare la connessione di un grafo ha importanti applicazioni, e.g. individuare dei cluster in grandi dataset (i.e. data mining).\n\nI ***costi*** degli archi possono essere\n\n- ***statici*** (e.g. tutti i costi sono `1`), da cui nascono i problemi di ***shortest path***;\n- ***dinamici*** (e.g. il costo è il livello di saturazione del collegamento, o la probabilità che questo si rompa), da cui nascono i problemi di ***least cost path*** gestiti da algoritmi ***adaptive***.\n\t- Ovviamente il primo è un caso particolare del secondo. Le situazioni reali rientrano spesso nel secondo caso, ma possono esistere algoritmi che alternano questi due approcci per ridurre complessità ed overhead.\n\nIl fatto che esista un collegamento da i nodi $u$ e $v$ non garantisce che questo si riesca a trovare con un algoritmo per il cammino minimo. Perché? Perché esistono i ***costi negativi***, che possono portare a ***cicli negativi*** che bloccano un algoritmo di ottimizzazione in un loop infinito. Come li gestisco? Ho due alternative.\n\n- Li vieto e uso algoritmi più semplici;\n- Li permetto, ma l'algoritmo deve essere in grado di rompere il loop, e.g. mettendo un numero massimo di hop. Perché mai dovrei complicare le cose? Perché i costi negativi sono utili!\n\t- esempio finanza o nave o nave della finanza (l'ultimo è un meme, non cercarlo)","x":-480,"y":-1380,"width":820,"height":677,"color":"6"},
		{"id":"2b58db98d883eb5c","type":"text","text":"# Colorazione di un Grafo\n\nAssegnazione delle Frequenze","x":492,"y":-1017,"width":428,"height":118},
		{"id":"2d6864a05567bd50","type":"text","text":"# Wireless Networks","x":564,"y":-1262,"width":396,"height":122},
		{"id":"20678bdf9496c5aa","type":"text","text":"# Routing Problem\n\nDistinguiamo tra due tipologie di algoritmi di routing.\n\n\n\nEsistono algoritmi di shortest path solo per grafi in cui non compaiono cicli negativi (i.e. cicli in cui la somma dei costi è negativa). In questo caso si creano i loop infiniti in cui non sempre esiste una distanza minima tra due generici nodi a e b, anche se il grafo è connesso (per quello che dice dopo bisogna capire che intende per connesso). non è vero, dice che esistono, basta mettere un limite al numero di hop\n\nalgoritmo di moore? Breadth First Search? se faccio BFS e trovo tutte distanze finite dalla radice allora il grafo è connesso (tipo teorema boh ok)\n\ndigraph intende grafo orientato. dice che il teorema sopra è falso in caso di digraph (obv)\n\na volte cicli negativi sono utili (esempio sulla finanza slides).\n\nbellman-ford è basato su relaxation (i.e. parto da distanza stimata infinita e faccio dei relaxation steps in cui la diminuisco) (ed è O(nm) con n nodi ed m archi). m=O(n^2) o =$\\Omega$(n) per i grafi connessi (o per i digrafi?)\n\nfloyd-warshall risolve all-to-all, gli altri non lo sono! permette i pesi negativi essendo simile o migliore di BF e dijkstra ($O(m\\log n$)).\n\nproblema delle code (CNP)","x":-600,"y":-2660,"width":880,"height":740},
		{"id":"50ee741910a5fe7f","type":"text","text":"# Minima Copertura dei Vertici\n\nInfettare una rete con un worm","x":-1161,"y":-1794,"width":473,"height":233},
		{"id":"d07e0547b6ef80cf","type":"text","text":"# Disegno Ortogonale su Griglia\n\nlayout of interconnection network","x":519,"y":-1769,"width":486,"height":183},
		{"id":"e7fe42a008f734d6","type":"text","text":"# Amministrazione della Rete (SNMP, NETCONF)\n\nMa in pratica come fa l'admin di rete ad esercitare questo ruolo?\n\nInternamente ad ogni ***managed device*** vi è un ***Management Information Base*** (***MIB***), cioè un database contenente dati di configurazione del dispositivo la cui struttura è definita dal *Data Definition Language* ***Structure of Management Information*** (***SMI***).\n\nBene, abbiamo un DDL. E il linguaggio d'interrogazione? L'admin usa il ***Simple Network Management Protocol*** (***SNMP***), che gira a livello Applicazione e si appoggia su UDP porta 161 (si può implementare anche su TCP, l'uso di UDP prova ad evitare la congestione di rete). Oltre ai messaggi standard di ***request/response***, SNMP prevede dei messaggi ***trap*** provenienti dal *managed device*, che segnalano eventuali errori o malfunzionamenti (*eccezioni*, in generale). **SNMPv3** introduce autenticazione e crittografia per evitare spoofing (qualcun altro configura i router al posto mio).\n\nTutto molto bello, non fosse che SNMP ha dei limiti (e.g. parla con un solo router alla volta, la modifica del DB può essere delicata, ...), per questo è nato ***NETCONF***.\n\nAggiunge il concetto di gruppi di router e si appoggia su SSH. I messaggi sono in formato XML, un buon punto d'incontro tra la leggibilità umana e la semplicità di un *parser* che deve estrarre i dati. La scrittura di un codice NETCONF è ulteriormente semplificata dal DDL ***YANG***, anch'esso XML.","x":-185,"y":-7455,"width":731,"height":612,"color":"4"},
		{"id":"d6b2b74e24c9c9fc","type":"text","text":"# Pseudocodice Dijkstra\n\n```\n###    Initialization    ###\nN = {u}; \nfor all nodes k\n\tif k is_adjacent_to u\n\t\tD(k) = c_{u,k}\n\telse D(k) = ∞\n\n###         Loop         ###\n\ni = find();\nadd_to_N(i);\n\nfor (j adjacent_to i) and (j not in N):\n\tD(j) = min(D(j), D(i) + c_{i,j})\n\n### Until all nodes in N ###\n```\n","x":-116,"y":-6255,"width":447,"height":506,"color":"4"},
		{"id":"27ef6c0cc5929f9c","type":"text","text":"# Control Plane\n\nA livello globale, il Control Plane definisce i percorsi end-to-end dei pacchetti modificando le singole tabelle di forwarding dei router.","x":-46,"y":-7754,"width":453,"height":211,"color":"6"},
		{"id":"5fcdf84f02f9dba3","type":"text","text":"# Algoritmo di Dijkstra (Link-State)\n\nLa premessa di ogni algoritmo Link-State è che ogni router comunichi a tutti gli altri router tutti i costi (e.g. livelli di \"intasamento\") di tutte le porte. Una volta acquisite tutte le informazioni globali, ogni nodo risolve il proprio Dijkstra (i.e. quel Dijkstra che ha se stesso come nodo di partenza).\n\nL'algoritmo si può dividere in due parti:\n\n- ***Inizializzazione*** - Definisco il nodo di partenza e per ogni nodo $k$ della rete inizializzo il valore di $D(k)$ a\n\t- $c_{u, k}$ se $k$ è direttamente collegato a $u$;\n\t- $\\infty$ altrimenti (in pratica scelgo un `terror_value` molto grande);\n- ***Loop*** - Ciclo le seguenti operazioni finché non riempio $N$ con tutti i nodi:\n\t- `i = find()` - A questo punto ho un insieme di nodi non ancora in $N$. Tra questi, seleziono quello per cui $D(i)$ è minima;\n\t\t- Sono sempre sicuro di non selezionare un \"falso minimo\";\n\t- `add_to_N(i)` - Una volta trovato, lo aggiungo ad $N$. In questo modo ho trovato il percorso ottimale definitivo per $i$, quindi non devo più cercarlo.\n\t- `for (j adjacent_to i) and (j not in N)` - Mi metto in $i$ e guardo i primi vicini, ignorando quelli per cui ho già trovato il percorso ottimale;\n\t- `D(j) = min(D(j), D(i) + c_{i,j})` - Aggiorno le stime provvisorie per tutti i $j$. Questa riga mi dice sostanzialmente che le possibilità sono due:\n\t\t- Avevo già una stima migliore di quella attuale, lascio quella;\n\t\t- Ho trovato una stima migliore, sostituisco.\n\t- Ricomincio.\n\nUna volta che converge, ogni router conosce il percorso ottimale per raggiungere qualsiasi altro router sulla rete.\n\nDijkstra funziona bene per reti piccole, altrimenti è un problema far conoscere a tutti la topologia della rete. Se $n$ router inviano ciascuno $n$ messaggi, la ***complessità di comunicazione*** (i.e. l'overhead del processo di scambio di messaggi) è $O(n^2)$.\n\nPuò avere ***comportamenti patologici*** se si definiscono male i pesi degli archi. Se ad esempio uso il volume istantaneo di traffico, ogni aggiornamento sposta i flussi creando nuovi bottleneck, che portano ad un nuovo ricalcolo, che sposta i flussi, ... (***oscillazioni***). \n\nIn generale, ad ogni variazione di anche un solo costo bisogna ricalcolare tutto (c'è un *refresh rate*, diciamo ogni $t$ secondi).\n\n","x":445,"y":-6519,"width":711,"height":1034,"color":"4"},
		{"id":"f0ad34e51e80f865","type":"text","text":"# OpenFlow\n\nIl paradigma match-plus-action permette di programmare ad alto livello il comportamento della rete. I router non comunicano tra loro come in un algoritmo di instradamento classico, ma sono tutti connessi ad un ***controller remoto*** che raccoglie i dati, fa girare un Dijkstra, ritocca qualche dettaglio e restituisce i risultati.\n\nQuesti \"ritocchi\" permettono di implementare ***politiche di instradamento*** (e.g. far passare il traffico su una rotta meno conveniente perché quella migliore attraversa la Corea del Nord), ***bilanciamento di carico*** e altre cose belle che gli algoritmi da soli non riescono a gestire.\n\nTramite le ***API OpenFlow***, il controller parla con il livello Applicazione (***Northbound API***) e con le tabelle dei router (***Southbound API***).\n\nLa comunicazione Southbound (tra router e controller) è gestita dal ***protocollo OpenFlow***, basato su TCP, e prevede tre tipologie di messaggi:\n\n- ***controller-to-switch***\n\t- `features` - il controller chiede allo switch che tipo di operazioni supporta;\n\t- `configure` - legge o modifica i parametri di configurazione dello switch;\n\t- `modify-state` - modifica la flow table;\n\t- `packet-out` - posso iniettare un pacchetto nello switch e mandarlo su un'interfaccia;\n- ***switch-to-controller*** (**asincrono**)\n\t- `packet-in` - lo switch può mandare un pacchetto al controller (e.g. non ha un match nella flow table, evito di buttarlo);\n\t- `flow-removed` - elimina una riga della flow table ed informa il controller;\n\t- `port status` - informa il controller sullo stato di operatività di un'interfaccia.\n- ***simmetrici*** (e.g. `echo`, messaggi di errore).\n\nAd oggi le SDN sono alternative all'instradamento Intra-AS, ma è possibile pensare ad un'evoluzione Inter-AS in cui potenzialmente si implementa un controllo della congestione.","x":1966,"y":-9600,"width":780,"height":782,"color":"4"},
		{"id":"80091a40e54ea2e1","type":"text","text":"# Firewall\n\nTra la rete privata e la rete pubblica si erge tipicamente un ***firewall***, il cui compito è sostanzialmente filtrare i pacchetti in ingresso. Ciò include la prevenzione di attacchi di ***SYN Flooding*** (i.e. bombardamento di richieste di aperture di connessioni TCP fittizie, una sorta di ***DoS***), nonché impedire modifiche o letture non autorizzate ad utenti esterni (implementando un meccanismo di autenticazione). La scelta può essere fatta secondo criteri\n\n- di indirizzo IP di origine e/o destinazione;\n- di protocollo utilizzato (TCP/UDP) e/o porta logica (e.g. bloccare la porta 23 significa bloccare Telnet);\n- di tipologia di messaggio ICMP (e.g. impedire i broadcast sulla propria rete che provengono dall'esterno);\n\nTutto questo avviene in modo \"stupido\", i.e. c'è una tabella che specifica quali range di IP o porta ammettere (`allow`) o bloccare (`deny`). Per un controllo più intelligente (e.g. correlazioni tra più pacchetti, in grado di identificare un traffico \"inusuale\") serve un ***Intrusion Detection System*** (***IDS***).","x":800,"y":-8694,"width":916,"height":409,"color":"#4545ff"},
		{"id":"9c6f202c7af4038c","type":"text","text":"# Software Defined Network (SDN)\n\nParticolare tipo di instradamento ***Intra-AS*** gestito tramite un controller remoto che sfrutta il ***forwarding generalizzato***.","x":2086,"y":-8552,"width":540,"height":125,"color":"6"},
		{"id":"7fd69126270e4787","type":"text","text":"# Algoritmi di Instradamento\n\nPer per essere in grado di direzionare il traffico in rete mi servono due cose:\n\n- Conoscere la ***topologia della rete***, che si traduce nel costruire un ***grafo pesato*** $G = (N, E)$, dove $N$ è l'insieme dei router ed $E$ l'insieme dei collegamenti fisici;\n\t- Nelle *flow table* dei singoli router ad ogni interfaccia è associato un ***costo***, ad esempio proporzionale a quanto tempo impiega il pacchetto a raggiungere l'*hop* successivo;\n\t\t- Il costo di un collegamento è spesso definito da un *admin* di rete, il quale può in realtà scegliere come vuole la logica dei costi. Può penalizzare (i.e. assegnare un costo alto ad) un collegamento verso una rete che gli sta *antipatica*;\n\t\t- Il costo di un collegamento che non esiste o che si rompe è $\\infty$;\n\t- La conoscenza della topologia divide gli algoritmi di instradamento in due macro-categorie:\n\t\t- ***Distribuiti (Distance-Vector)*** - Ogni router conosce solo le sue immediate vicinanze (e.g. ***RIP***);\n\t\t- ***Centralizzati (Link-State)*** - Ogni router conosce l'intera topologia della rete (e.g. ***OSPF***, è una centralizzazione logica mentre a livello fisico ho ridondanza), oppure questa informazione è in possesso di un ***controller*** esterno (***SDN***, e.g. ***OpenFlow***, centralizzazione sia logica che fisica, anche se di norma un controller ha un paio di computer di backup fisici);\n\t\t- In entrambi i casi i router comunicano tra loro scambiando messaggi;\n\t\t- Di norma gli algoritmi centralizzati sono più potenti dei distribuiti (hanno più informazioni!);\n- Essere in grado di **modificare le tabelle dei singoli router**.\n\t- Questa cosa può in certe situazioni può essere fatta manualmente, sia per evitare l'overhead computazionale di un algoritmo che modifica costantemente le tabelle (***dinamico***) sia per controllare in modo più preciso il flusso di dati. Qualcuno lo chiama algoritmo ***statico***, secondo me non è neanche considerabile un algoritmo (piuttosto, una configurazione manuale);\n\t- Non devo esagerare con il dinamismo. Pensa se il navigatore aggiornasse il percorso ogni 5 secondi.\n\nIpotizziamo di partire da $u$ e diamo dei nomi semplici ai concetti importanti.\n\n- $c_{x,y}$ il ***costo del collegamento*** tra $x$ e $y$.\n- $N$ è l'insieme di ***nodi per i quali il percorso minimo è stato già trovato***. Inizialmente $N = \\{u\\}$, poi tra i primi vicini di $u$ è facile vedere che l'arco dal costo minore è quello che porta a $x$, quindi dopo il primo step avremo $N = \\{ux\\}$, e così via;\n- Ipotizziamo di essere ancora al primo step. Attualmente conosco solo $u$ e i suoi primi vicini, quindi per quanto ne so il percorso ottimale $u \\rightarrow w$ costa $5$. Chiamo questa ***stima provvisoria*** $D(w)$. Più avanti nell'algoritmo mi renderò conto che il percorso che minimizza $D(w)$ è $u \\rightarrow x \\rightarrow w$;\n- Ipotizziamo di voler minimizzare $D(w)$ e di ritrovarci con due valori, $5$ e $4$. Come faccio a distinguere a livello di algoritmo qual è il percorso che è costato meno? Mi serve tenere traccia del ***nodo predecessore*** per disambiguare tra i valori di $D(w)$. Lo indico con $P(w)$, e in questo modo distinguo $D(w)\\,P(w) = \\{(5, u),\\,(4, x)\\}$.","x":800,"y":-8151,"width":916,"height":1005,"color":"4"},
		{"id":"cdc3b22ee0187fc4","type":"text","text":"# Protocolli di Instradamento su Internet\n\nScelgo l'algoritmo di instradamento migliore, no? ... Ni. Ci sono due macro-problemi:\n\n- L'intera ***Internet è troppo grande*** perché ogni router abbia davvero una tabella dei costi verso tutti, senza contare che inviarle agli altri router creerebbe tonnellate di traffico;\n- **Gli algoritmi assumono router identici e rete non-gerarchica**. Nella realtà bisogna tenere in considerazione l'***indipendenza dei singoli ISP***, che possono voler implementare i propri algoritmi per le proprie sottoreti.\n\nLa situazione reale è che già gli esistono dei ***domini*** (anche detti ***AS*** ***Autonomous Systems***, e.g. le sottoreti di un ISP) si distinguono due tipi di instradamento:\n\n- ***Intra-AS*** - Tutti i router all'interno dello stesso AS seguono lo stesso algoritmo di instradamento (e.g. ***RIP***, ***EIGRP***, ***OSPF***), oppure si utilizza una ***SDN***;\n- ***Inter-AS*** - I gateway router dei vari AS sono connessi tra loro tramite un unico protocollo (***BGP***), e vengono distinti in\n\t- ***egress router*** - gestiscono il traffico in uscita verso un altro AS;\n\t- ***ingress router*** - gestiscono il traffico in ingresso proveniente da un altro AS.\n\t\t- Possono essere considerati fisicamente lo stesso router, ma sono spesso separati.","x":1966,"y":-8151,"width":780,"height":551,"color":"4"},
		{"id":"527cbf2fca10c976","type":"text","text":"# Protocolli Intra-AS","x":2196,"y":-7491,"width":320,"height":41,"color":"6"},
		{"id":"7cb0784c66f4d079","type":"text","text":"# EIGRP\n\nEnhanced Interior Gateway Routing Protocol  (EIGRP) è un protocollo basato su un algoritmo ***Distance-Vector***, originariamente proprietario di Cisco ma diventato open source nel 2013.","x":2976,"y":-7531,"width":780,"height":121,"color":"4"},
		{"id":"131a1ae82abc7862","type":"text","text":"# Open Shortest Path First (OSPF)\n\nSfrutta un algoritmo ***Link-State*** classico (***Dijkstra***) i cui messaggi viaggiano direttamente come ***payload di IP***. I costi dei link sono decisi a priori dall'admin di rete.\n\nRispetto all'algoritmo di base, OSPF è ***gerarchico***. Distingue infatti due livelli:\n\n- una ***backbone***, di cui ogni router che ne fa parte conosce la topologia;\n- diverse ***aree locali***, ognuna a conoscenza della propria topologia ma non di quelle altrui.\n\nA fare da anello di congiunzione ci sono gli ***Area Border Routers*** (***ABR***), che conoscono sia la topologia della backbone sia quella della propria area (in pratica fanno da ***gateway*** per le proprie aree locali, come se dalla backbone in poi fosse già Internet). Nessun router conosce l'intera topologia: il ***flooding*** delle tabelle è limitato all'interno della singola area, riducendo il numero di messaggi scambiati. Quindi è sia scalabile che ottimizzato per piccole LAN.\n\nOSPF implementa un ***digest hash*** per proteggere i pacchetti dalla manomissione. Non sembra invece esserci interesse nell'evitare l'eavesdropping, cosa che comunque su IPsec è prevenuta dalla cifratura dell'intero payload.","x":2976,"y":-7331,"width":780,"height":487,"color":"4"},
		{"id":"e2f96606940a2d1c","type":"file","file":"3 - Rete/Protocolli di Instradamento/HierarchicOSPF.png","x":2976,"y":-6700,"width":780,"height":239},
		{"id":"80407a58a65495fa","type":"text","text":"\"Se conoscete Linux sapete cosa sono i demoni\"","x":3150,"y":-6199,"width":431,"height":29},
		{"id":"95bfd2c3b3bef71f","type":"text","text":"# Protocolli Inter-AS","x":3201,"y":-7896,"width":330,"height":41,"color":"6"},
		{"id":"70cd0cc6659bf109","type":"text","text":"# Routing Information Protocol (RIP)\n\nProtocollo che gira a ***livello Applicazione*** (**routed**, o **route deamon**) e si appoggia su UDP (porta $520$). Usa un algoritmo ***Distance-Vector*** in cui ***tutti i link hanno costo 1*** (**distance metric**), con un massimo di $15$ ($16$ equivale a $\\infty$).\n\n- Le tabelle vengono inviate\n\t- a seguito di una ***RIP request*** (si parla di ***solicited RIP response***);\n\t- alla scadenza di un ***timer*** di circa $30$ secondi (***unsolicited RIP response***);\n- Vi sono poi tre ulteriori timer:\n\t- Se dopo circa $180$ secondi il router non riceve aggiornamenti da un vicino, questo viene considerato spento (il costo verso di lui è posto a 16);\n\t- Ogni circa $120$ secondi rimuove le righe con costi pari a $16$ (***garbage collection***).\n\t- Se arriva un'informazione da un router considerato non valido, si avvia un timer. Tutti i messaggi che arrivano entro la scadenza di tale timer vengono ignorati (***Hold-Down***);\n\nRIP non è più in uso da almeno 20 anni.","x":1966,"y":-7331,"width":780,"height":487,"color":"4"},
		{"id":"6e372e660ad0c67d","type":"file","file":"3 - Rete/Protocolli di Instradamento/TopologiaRete.png","x":979,"y":-7027,"width":559,"height":369},
		{"id":"93e25518be010e99","type":"text","text":"# Algoritmo di Bellman-Ford (Distance-Vector)\n\nNasce dall'idea che se i costi cambiano *poco* voglio eseguire *poco* codice.\n\nL'inizializzazione è identica a Dijkstra: supponiamo di essere il router $u$ e di avere una stima $D_u(w) = 5$, mentre ad esempio $x$ avrà una stima $D_x(w) = 3$.\n\nA questo punto tutti i router inviano ai primi vicini le proprie stime. In particolare, $x$ comunica la sua stima $D_x(w)$ ad $u$, il quale ricalcola $D_u(w)$ tramite l'***equazione di Bellman-Ford***\n\n$$D_u(w) = \\min\\limits_{i}(c_{u,i} + D_i(w)) = \\min\\limits_{i}(\\text{distanza}_{ui} + \\text{minima distanza}_{iw})$$\n\ndove $i$ sono tutti e soli i primi vicini. Quando $i = x$, $u$ si accorge di aver trovato una stima migliore e la comunica ai propri primi vicini. $v$ riceve questa nuova stima ma la sua vecchia $D_v(w) = 3$ è ancora la scelta più conveniente, quindi non la aggiorna e non la comunica ai primi vicini. Riassumendo, ogni router\n\n- ***Attende*** la modifica del costo di un link a cui è direttamente collegato, oppure un messaggio da un router vicino;\n\t- Algoritmo ***asincrono*** - non ha un un *refresh rate* fisso, ma aspetta un evento. **Se in qualche modo non cambiano i costi, il router non calcola niente**;\n- ***Ricalcola*** le proprie stime;\n- Se cambiano, ***avvisa*** i vicini.\n\t- In quanto algoritmo ***distribuito*** nessun nodo conosce il percorso globale, e spesso il cambiamento dei costi influisce solo su una piccola parte di rete.\n\nNotare che ***l'informazione si propaga a velocità finita***, quindi quando il singolo router calcola le proprie stime lo sta in realtà facendo con dati vecchi. In realtà la velocità di propagazione dell'informazione dipende dal tipo di notizia, e porta a due ***comportamenti patologici***:\n\n- Le buone notizie si propagano velocemente. Questo può portare rapidamente ad una situazione di ***black-holing***, in cui un router pubblicizza dei costi molto bassi, il traffico viene massicciamente spostato su di lui e si crea un bottleneck;\n- Le cattive notizie si propagano lentamente, in particolare se si rompe un cavo si verifica il ***conteggio all'infinito***.\n\n\n\n","x":1354,"y":-6519,"width":725,"height":1034,"color":"4"},
		{"id":"9494b49cb8593932","type":"file","file":"3 - Rete/Protocolli di Instradamento/PropagazioneInformazioneBellmanFord.png","x":2176,"y":-6185,"width":400,"height":366},
		{"id":"ec7bcb061b59b4f3","type":"text","text":"# Broadcast e Multicast\n\nQuando si parla di instradamento e percorsi più brevi si sottintende di avere un solo IP di destinazione (***unicast***). E se volessi mandare lo stesso messaggio a più IP?\n\n- ***Broadcast*** - Qualsiasi IP che abbia come parte host tutti `1` è un messaggio broadcast sulla sottorete specificata nel prefisso di rete. Ogni nodo che riceve un messaggio broadcast lo inoltra a tutte le altre interfacce (**uncontrolled flooding**). Questo può portare all'**instradamento ciclico**, motivo per cui si controlla il flooding con tre tecniche:\n\t- ***Sequence Number*** - Ogni nodo tiene traccia dei pacchetti già inoltrati, evitando di inoltrarli di nuovo se dovessero tornare da lui;\n\t- ***Reverse Path Forwarding*** (***RFP***) - Ipotizziamo che il mittente sia `A`. `D` inoltra solo se ha ricevuto il pacchetto dall'interfaccia che lo collega a `B`, perché corrisponde alla rotta più breve verso `A`. Se lo stesso pacchetto arriva da qualsiasi altra interfaccia, lo scarta a priori. Questo elimina una parte del problema, ma si può fare di meglio;\n\t- ***Spanning Tree*** - All'interno del grafo di rete si costruisce un albero, in modo tale che i pacchetti vengano inoltrati solo verso i figli. Questo elimina tutti i messaggi inutili.\n- ***Multicast*** - Se voglio mandare un messaggio ad un gruppo di utenti, è scomodo fare tanti unicast. Allora assegno a tutti gli host di quel gruppo uno stesso ***indirizzo IP secondario*** nel range da `224.0.0.0/8` a `239.0.0.0/8`, che definisce il ***gruppo multicast***.\n\t- I router apprendono le associazioni tra gli host e i gruppi multicast tramite ***IGMP*** (***Internet Group Management Protocol***). Sono mandati direttamente su IP con `protocol number = 2` e `TTL = 1`. I messaggi possono essere\n\t\t- `Membership Query` - Il router chiede periodicamente agli host direttamente connessi a quali gruppi multicast aderiscono. Questo perché ogni  associazione interna al router ha un timer, che viene *refreshato* dai messaggi `Report`;\n\t\t- `Membership Report` - L'host comunica al router l'adesione ad un gruppo multicast (non necessariamente in risposta ad una `Query`, e.g. appena si unisce al gruppo);\n\t\t- `Leaver Group` - L'host comunica esplicitamente al router l'abbandono di un gruppo multicast (è opzionale, il router annulla l'associazione anche se scade il timer).\n\t- A livello di instradamento, è un problema parallelo all'unicast. Questo significa che esistono ***protocolli intra-AS*** (DVMRP, ***MOSPF***, PIM) ***e inter-AS*** (***MBGP***) ***specifici per il multicast***.","x":4116,"y":-9189,"width":860,"height":840,"color":"4"},
		{"id":"b72cb83273d9af73","type":"text","text":"# Border Gateway Protocol (BGP)\n\nProtocollo ***Distance-Vector pseudo-gerarchico*** basato su connessioni ***TCP***, è la \"*colla che tiene insieme Internet*\". Opera a due livelli:\n\n- ***eBGP*** (***External BGP***) - Collega tra loro i gateway router dei vari AS. A nome del proprio AS, possono pubblicizzare una destinazione agli altri router eBGP (i.e. `sono NEXT-HOP e posso raggiungere PREFISSO`). Il messaggio di annuncio consta di due parti:\n\t- ***prefisso***, cioè chi dichiaro di poter raggiungere (e.g. `100.1.1/24`);\n\t- ***attributi***, cioè ulteriori specifiche circa il percorso che sto pubblicizzando, ad esempio\n\t\t- `AS-PATH` - Lista degli AS da cui è passato l'annuncio, in modo tale che chi lo riceve possa fare il percorso inverso e ritrovare l'AS che lo ha divulgato;\n\t\t- `NEXT-HOP` - Indirizzo IP dell'interfaccia dell'**egress router** che ha pubblicizzato la rotta;\n\t\t- `COMMUNITY` - Etichette utili a prendere decisioni di ***policy***;\n\t\t- `ORIGIN` - Specifica chi ha generato la rotta. Se pubblicizzo un range di indirizzi interno al mio AS è `= IGP` (\"`Internal Gateway Protocol`\"), se sto inoltrando un'informazione ricevuta da un altro AS è `= EGP`. Se l'origine non è chiara trovo `INCOMPLETE`; \n- ***iBGP*** (***Internal BGP***) - All'interno del singolo AS, divulga a tutti i router le rotte apprese tramite eBGP.\n\nIl formato di un messaggio BGP prevede messaggi di tipo\n\n- `OPEN` - Apre la connessione TCP e autentica il router;\n- `UPDATE` - Pubblicizza un nuovo percorso, o ne ritira uno vecchio;\n- `KEEP-ALIVE` - A partire dal primo `ACK` di risposta alla `OPEN`, mantiene attiva la connessione in assenza di `UPDATE`;\n- `NOTIFICATION` - Usato per segnalare errori nei messaggi precedenti e per chiudere la connessione.","x":4116,"y":-8217,"width":860,"height":684,"color":"4"},
		{"id":"54ee5c735ee71d4d","type":"text","text":"# Policy-Based Routing\n\nSe il routing interno è governato dall'ottimizzazione dei flussi di traffico, in quello inter-AS entrano in gioco interessi economici, diplomatici e politici. Pertanto, gli amministratori di Rete possono definire delle ***policy*** sulla base delle quali prendere decisioni come ***scegliere di non pubblicizzare una rotta*** oppure ***rifiutare una rotta*** che arriva da un altro AS.\n\nUn certo provider può essere ad esempio interessato a non far passare il proprio traffico per un certo paese. Questo si traduce in un controllo del campo `AS-PATH` come ***condizione per accettare una rotta***.\n\nPosso scegliere di non pubblicizzare un percorso se temo che questo mi inonderà di traffico che non voglio. Tipico è ad esempio un ISP che vuole solo il traffico dei propri clienti, evitando di instradare il traffico altrui. Oppure, se sono una rete piccola che collega due reti grosse non mi conviene pubblicizzare questa rotta, altrimenti mi inondano di roba.\n\nAnche internamente al singolo AS vi sono delle policy. Se ad esempio ci sono due egress router che offrono due rotte per la stessa destinazione, il router interno sceglierà l'egress router con il minor costo intra-AS, ignorando il costo inter-AS (***hot potato routing***).","x":4116,"y":-7440,"width":860,"height":596,"color":"3"},
		{"id":"cf46f6f934b967cc","type":"file","file":"3 - Rete/Protocolli di Instradamento/SpanningTreeBroadcast.png","x":5056,"y":-8888,"width":627,"height":238},
		{"id":"dd5acbaad366dba0","type":"file","file":"3 - Rete/Protocolli di Instradamento/BGP.png","x":5056,"y":-8008,"width":628,"height":266},
		{"id":"8b14404d77f86787","type":"text","text":"# Quale usare?\n\n- ***Dijkstra*** ha complessità computazionale $O(n^2)$ (a meno di oscillazioni), ma è possibile implementarlo $O(n\\,log(n))$, ed una complessità di comunicazione pari a $O(n^2)$, poiché ogni messaggio comunicato dagli $n$ router al resto della rete impiega un tempo $O(n)$ con algoritmi efficienti;\n- conviene sulle reti dense (di archi) e grandi\n- non può gestire pesi negativi;\n- Si usa con un controller esterno nelle SDN;\n- Tipicamente Intra-AS\n- \n- ***Bellman-Ford*** ha complessità computazionale $O(n)$, è più veloce ma richiede condizioni molto favorevoli;\n- gestisce pesi negativi\n- conviene su reti piccole e sparse (pochi link)\n- è tipicamente Inter-AS.","x":445,"y":-5322,"width":711,"height":726,"color":"3"},
		{"id":"68bfc712300eb518","type":"text","text":"# Conteggio all'Infinito\n\n- $y$ ha un pacchetto per $x$, controlla il cavo e si accorge che il costo è aumentato;\n- Nota allora che $z$ afferma di poter arrivare ad $x$ con costo $5$;\n\t- $z$ dice così perché sta usando l'informazione non aggiornata di $y$, e si basa sul mandare il pacchetto proprio ad $y$;\n- $y$ aggiorna la sua *best route* per $x$, perché \"`z dice che ci mette 5, io per z ci metto 1, 6 è meglio di 60`\". Ora nella tabella di $y$ c'è scritto $x \\rightarrow 6$, e prevede di mandare i pacchetti a $z$;\n- $y$ aggiorna $z$, dicendogli che per arrivare ad $x$ ci mette $6$;\n- $z$ aggiorna le sue stime, trovando che \"`y dice che ci mette 6, io per y ci metto 1, 7 è meglio di 50`\";\n- $z$ aggiorna $y$, dicendogli che per arrivare ad $x$ ci mette $7$;\n- \\[...\\]\n\nIn pratica, se si rompe il cavo tra $x$ ed $y$, $y$ e $z$ aggiornano il costo sommando ciclicamente il costo del collegamento tra loro due.\n\nCome si risolve il problema delle ***rotte cicliche***?\n\n- ***Split Horizon*** - Tutto questo sta succedendo perché $z$ invia ad $y$ aggiornamenti dei percorsi che prevedono di passare da $y$ stesso (idem per $y$). Quanto poco senso ha per un umano dire \"`ciao z io ci metto 5 passando da z`\"? Non ha senso dire a $z$ le informazioni che mi ha già dato lui, quindi semplicemente gli comunico tutte le rotte **tranne** quelle che prevedono di passare da lui;\n- ***Poisoned Reverse*** - Una specie di \"non ti azzardare a rimandarmi quello che ti mando io\". In pratica comunico a $z$ che il costo del nostro link è appena diventato *enorme*, in modo da rompere la rotta ciclica;","x":1346,"y":-5322,"width":725,"height":726,"color":"4"},
		{"id":"6fb49afd9589235c","type":"file","file":"3 - Rete/Protocolli di Instradamento/BadNewsMrBellmanFord.png","x":2176,"y":-5094,"width":400,"height":271},
		{"id":"94a097e2aa28a467","type":"text","text":"# Routing Problem Reti di Elaboratori","x":-1440,"y":-7719,"width":605,"height":141,"color":"1"},
		{"id":"42f6d4efb4f98e2f","type":"text","text":"# Fixed Sensors","x":-261,"y":-580,"width":383,"height":63},
		{"id":"d2544beca5412320","type":"text","text":"# Cabled Networks\n\nConosciamo i computer e le loro interconnessioni (non è così in wireless!)","x":-256,"y":-1769,"width":373,"height":245},
		{"id":"44d3fce08f129fab","x":535,"y":-4282,"width":405,"height":182,"type":"text","text":"# Esempio Dijkstra\n\ntrain schedule \\[J\\]"},
		{"id":"7f76f671296685db","type":"text","text":"# Algoritmi Dinamici (prob)\n\nA volte il costo di un link (***edge***) rappresenta la probabilità che questo si rompa. In questo caso, il LCP corrisponde al percorso più affidabile. Ma la probabilità complessiva è il prodotto delle singole probabilità. Come li trasformo in una somma (per avere la somma dei costi)? Prendo il $\\log$ che è monotono crescente e lo rendo positivo: sostituisco ogni probabilità $p(e)$ con $-\\log(p(e)) := w(e)$ .\n\ndijkstra è dinamico","x":520,"y":-2550,"width":510,"height":520},
		{"id":"0ad1eb68f4cc5f23","type":"file","file":"MinimumTimeWastingGraph.png","x":1140,"y":-2490,"width":339,"height":400},
		{"id":"1c951750f45e94cc","x":-366,"y":-3920,"width":413,"height":231,"type":"text","text":"# Dijkstra\none-to-all (va fatto girare per ogni nodo)\ndijkstra è greedy (?) e dinamico\nfibonacci heap?\n\ngraphs used to find minimum-time-wasting schedule for projects. \\[J\\]\n\n"},
		{"id":"3e6d4dd9674719b8","x":-1360,"y":-3420,"width":560,"height":432,"type":"text","text":"# Floyd-Warshall\n\nall-to-all\ndevo conoscere la distanza tra ogni coppia di nodi. questo assume che si siano tutti gli edge ij. se non c'è, la distanza è $\\infty$ (as usual)\nper passare da i a j possiamo fare\n- il classico cammino fino a k e poi edge da k a j (e viceversa)\n- cammino da i fino a k e cammino da k fino a j\n- inizio $d(i,i) = 0$ (che è una metrica) e $d(i,j) = w(i,j)$. come in dijkstra, è solo l'inizializzazione.\n- triplo ciclo for annidato $ijk$ con dentro $dist(i,j) = \\min\\{dist(i,j), dist(i,k)+dist(k,j)\\}$\n\nquindi $\\Theta(n^3)$."},
		{"id":"e68e740bcf76e7f3","x":-325,"y":-3245,"width":345,"height":60,"type":"text","text":"# Routing Algorithms"},
		{"id":"92e685044d2277a9","x":535,"y":-3250,"width":250,"height":60,"type":"text","text":"# Bellman Ford"},
		{"id":"a1d45ffba23cb74d","x":-1360,"y":-4104,"width":727,"height":600,"type":"text","text":"# Applicazioni incidentali?\n\ncioè credo roba a cui si possono applicare quegli algoritmi nati originariamente per gestire il routing problem.\n\nsimile a schedule for project dell'esempio a destra ma con più processori in parallelo.\n\none node each task, dummy starting node $v_0$ . add an edge of cost 0 from $v_0$ to all other nodes (i.e. I could start from anything, in principle). then if j has to wait i add an edge $(j,i)$ of cost $d_i$ (tempo di esecuzione di i).\n\nguarda le slides per capire se è giusto...\n\n$s_3 + b_3 \\leq s_2$ significa che 3 deve essere eseguito prima di 2 impiegando b_3, la freccia va da 3 a 2. ho $\\infty$ cpu parallele in linea di principio.\n\nanche social network friendships."},
		{"id":"5b784d3ce58a7125","x":-2040,"y":-2600,"width":760,"height":1094,"type":"text","text":"# Interconnection Topology\n\ninterconnection topology connette devices entro la stessa macchina (ram, cpu, ...). graph is fixed and well-known, connections do not fail (reliable) efficiency is primary.\n\nhow processors are connected inside a multicore machine\n\nserve un controller globale per sapere a priori i percorsi vietati. visto che esistono, a sto punto non li stampo (mia ipotesi, quindi(?)), o meglio, ci sono delle particolari simmetrie per le reti di interconnessione chiamate butterfly network. nodi indicizzati da `string + int`, dove `int` indicizza il layer (colonna) e `string` tradotta in base 10 è la riga.\n\ngli edge invece sono orizzontali oppure cross che differiscono per il bit i-esimo (se ci sono 3 bit, il primo bit fa saltare di 4 righe, quindi la prima colonna ha cross edges che saltano di 4 righe e via dicendo). ogni nodo ha così grado 4 (i.e. numero di edges ad esso connessi). \"eh ma primo ed ultimo layer no\". e infatti ci aggiungo due terminali fake (che ci faccio? forse perché così se entrano 32bit ne escono 32)\n\ni nodi sono crossbar switches, ovvero potrebbero invertire o no i percorsi.\n\nche ci faccio co sta roba?\n\n- ha struttura ricorsiva. se copio e metto sotto e aggiungo a sx ho creato un'altra butterfly network (che ci faccio?)\n- data una qualsiasi coppia di righe, $\\exists!$ shortest path (greedy path) da input sulla prima riga ad output sulla seconda, ed è lungo $n$. Passa esattamente una volta per ogni layer.\n\t- tra l'altro è anche molto facile da computare, basta guardare le coppie di bit di w per capire se devo andare dritto o storto. questa roba si chiama greedy routing algorithm.\n\nvisto che non puoi avere due packets che attraversano the same edge potrebbero esserci problemi se vado a regime (faccio un parallelo di N segnali). come risolvo? con le code. ma quindi introduco delay! Sì, infatti si chiama **blocking network**. non solo! è probabile che con N input molti percorsi passino per lo stesso edge. sta roba si dimostra sulle ***slides***. come? a partire da ogni input node posso riconoscere un albero binario completo. (in realtà con qualsiasi nodo, ne avrò uno a sx e uno a dx). \\[...\\] se partono N pacchetti a sx, ci mettono $O(\\sqrt{N})$ step per giungere a dx (ergo **fino a** sqrtN step).\n\nsunto dim: quanto può attendere in coda nel caso peggiore? è la somma dei casi peggiori per ciascuna queue. come sono fatti tali termini? $\\sum_{i=1}^n (n_i-1)$, faccio un poò di magheggi e maggiorazioni e trovo $O(\\sqrt{N})$. nonostante la lunghezza del percorso sia log n. è utile un algoritmo che ci mette un tempo esponenziale rispetto alla lunghezza? ... sorprendentemente sì. perché? difficile che si verifichino grossi bottleneck. Nel caso medio gira in n step.\n\ndevi capire perché N = 2^n (i.e. chi sono N ed n)"}
	],
	"edges":[
		{"id":"032dba069a0c9de1","fromNode":"39b8b62db54759a1","fromSide":"right","toNode":"2d6864a05567bd50","toSide":"left"},
		{"id":"caac7cfb3b51ef30","fromNode":"39b8b62db54759a1","fromSide":"bottom","toNode":"42f6d4efb4f98e2f","toSide":"top"},
		{"id":"fa8c70711b194b32","fromNode":"39b8b62db54759a1","fromSide":"top","toNode":"d2544beca5412320","toSide":"bottom"},
		{"id":"3b6318ede6ff98f3","fromNode":"27ef6c0cc5929f9c","fromSide":"right","toNode":"7fd69126270e4787","toSide":"left"},
		{"id":"21814dd87a352376","fromNode":"27ef6c0cc5929f9c","fromSide":"bottom","toNode":"e7fe42a008f734d6","toSide":"top"},
		{"id":"5e7dc56167324c3d","fromNode":"5fcdf84f02f9dba3","fromSide":"left","toNode":"d6b2b74e24c9c9fc","toSide":"right"},
		{"id":"bb8f2b5f07b181c4","fromNode":"5fcdf84f02f9dba3","fromSide":"bottom","toNode":"8b14404d77f86787","toSide":"top"},
		{"id":"d1b4603e18824d4f","fromNode":"6e372e660ad0c67d","fromSide":"bottom","toNode":"5fcdf84f02f9dba3","toSide":"top"},
		{"id":"bd703bd066749261","fromNode":"93e25518be010e99","fromSide":"right","toNode":"9494b49cb8593932","toSide":"left"},
		{"id":"e0f6fde78e5593db","fromNode":"93e25518be010e99","fromSide":"bottom","toNode":"68bfc712300eb518","toSide":"top"},
		{"id":"743d187f14210f5a","fromNode":"93e25518be010e99","fromSide":"bottom","toNode":"8b14404d77f86787","toSide":"top"},
		{"id":"78fe8a3130adee1e","fromNode":"6e372e660ad0c67d","fromSide":"bottom","toNode":"93e25518be010e99","toSide":"top"},
		{"id":"67b0391dbd2fe53d","fromNode":"68bfc712300eb518","fromSide":"right","toNode":"6fb49afd9589235c","toSide":"left"},
		{"id":"288ace197d813ddd","fromNode":"6fb49afd9589235c","fromSide":"left","toNode":"68bfc712300eb518","toSide":"right"},
		{"id":"4825e11a69c91925","fromNode":"7fd69126270e4787","fromSide":"bottom","toNode":"6e372e660ad0c67d","toSide":"top"},
		{"id":"c11632c104faa4cf","fromNode":"7fd69126270e4787","fromSide":"right","toNode":"cdc3b22ee0187fc4","toSide":"left"},
		{"id":"1f4f2592d8b8bd29","fromNode":"b72cb83273d9af73","fromSide":"bottom","toNode":"54ee5c735ee71d4d","toSide":"top"},
		{"id":"102bbec25407b724","fromNode":"b72cb83273d9af73","fromSide":"right","toNode":"dd5acbaad366dba0","toSide":"left"},
		{"id":"acbb3e66fbb1f012","fromNode":"95bfd2c3b3bef71f","fromSide":"right","toNode":"b72cb83273d9af73","toSide":"left"},
		{"id":"0b268dfce38c05c1","fromNode":"cdc3b22ee0187fc4","fromSide":"top","toNode":"9c6f202c7af4038c","toSide":"bottom"},
		{"id":"e078b7d9868c69e9","fromNode":"cdc3b22ee0187fc4","fromSide":"right","toNode":"95bfd2c3b3bef71f","toSide":"left"},
		{"id":"aeec85b7b713b9f8","fromNode":"cdc3b22ee0187fc4","fromSide":"bottom","toNode":"527cbf2fca10c976","toSide":"top"},
		{"id":"190cf89ad9107f90","fromNode":"cdc3b22ee0187fc4","fromSide":"right","toNode":"ec7bcb061b59b4f3","toSide":"left","label":"Instradamento Multicast"},
		{"id":"e44e2ec1ab4dcd1e","fromNode":"cdc3b22ee0187fc4","fromSide":"left","toNode":"80091a40e54ea2e1","toSide":"right"},
		{"id":"2e3e30937048e0e6","fromNode":"527cbf2fca10c976","fromSide":"right","toNode":"7cb0784c66f4d079","toSide":"left"},
		{"id":"fd7ec917556a26ca","fromNode":"527cbf2fca10c976","fromSide":"bottom","toNode":"70cd0cc6659bf109","toSide":"top"},
		{"id":"ac0c3130d469efe0","fromNode":"131a1ae82abc7862","fromSide":"bottom","toNode":"e2f96606940a2d1c","toSide":"top"},
		{"id":"4b77bf4270fa505a","fromNode":"527cbf2fca10c976","fromSide":"right","toNode":"131a1ae82abc7862","toSide":"left"},
		{"id":"4e2f7e171dd0bc6c","fromNode":"ec7bcb061b59b4f3","fromSide":"right","toNode":"cf46f6f934b967cc","toSide":"left"},
		{"id":"806c318217303670","fromNode":"9c6f202c7af4038c","fromSide":"top","toNode":"f0ad34e51e80f865","toSide":"bottom"},
		{"id":"9aaa38afb65a46a4","fromNode":"f0ad34e51e80f865","fromSide":"bottom","toNode":"9c6f202c7af4038c","toSide":"top"},
		{"id":"65a927649b0b4ebc","fromNode":"94a097e2aa28a467","fromSide":"right","toNode":"27ef6c0cc5929f9c","toSide":"left"},
		{"id":"5eaeafd5218ae641","fromNode":"20678bdf9496c5aa","fromSide":"right","toNode":"7f76f671296685db","toSide":"left"},
		{"id":"b9ba52ae3ae0d7df","fromNode":"20678bdf9496c5aa","fromSide":"top","toNode":"e68e740bcf76e7f3","toSide":"bottom"},
		{"id":"71dd79b6a22928b3","fromNode":"e68e740bcf76e7f3","fromSide":"left","toNode":"3e6d4dd9674719b8","toSide":"right"},
		{"id":"435ab8a0b78c9549","fromNode":"e68e740bcf76e7f3","fromSide":"top","toNode":"1c951750f45e94cc","toSide":"bottom"},
		{"id":"e48cb1a1a63e1316","fromNode":"e68e740bcf76e7f3","fromSide":"right","toNode":"92e685044d2277a9","toSide":"left"},
		{"id":"9bd71e8a42cd8f2d","fromNode":"1c951750f45e94cc","fromSide":"left","toNode":"a1d45ffba23cb74d","toSide":"right"}
	]
}