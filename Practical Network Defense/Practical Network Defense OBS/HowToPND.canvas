{
	"nodes":[
		{"id":"213cb7424970c6c4","type":"text","text":"fuzzy attack?\n\nwireshark e simili modificano direttamente la NIC per entrare in promiscuous mode? questa cosa diventa difficile se la rete è segmentata (faccio diverse VLAN? o comunque lo switch è più intelligente del previsto e manda la roba solo al vero destinatario)\n\nARP requests are always broadcast ethernet packets\n\nposso collegare uno switch ad un altro switch. questo significa che ad una porta possono corrispondere più MAC\n\nARP tables for hosts, called CAM for switches (HW-based, so fast. in fact, destination is the very first info in ethernet so that switch can decide output port asap)\n\n- CAM overflow - costringo lo switch a non ricordarsi le cose in modo da fargli fare broadcast ogni volta (mi interessa per fare sniffing, altrimenti i packet non mi arrivano!)\n\nInternet non è una grande ethernet network perché sta roba si basa sui broadcast. per risolvere questo problema crei IP. similmente a come poi visto che è inefficiente fare routing su cose troppo grandi dividi in ISP (e poi BGP ecc)\n\nSapienza è connessa a GAR (?) che collega tutte le università italiane\n\nbroadcast su IP poco comune (satelliti, ping), di norma si ignora (per ovvi motivi). multicast più comune, specie su IPv6\n\nClassi ABCDE: guarda il primo 0. \n\n- A - 0xxxxxxx fino a 127\n- B - 10xxxxxx da 128 a 191, ecc...\n- C\n- D - 1110xxxx (multicast)\n- E - (unused) 111110xx\n\nnon si usa più perché la classe A è troppo grande, quindi CIDR (parte network e parte host)\n\nprivate networks (RFC1918, i.e. non-routable IPs) definisce 10.xxx.xxx.xxx, 172.16.xxx.xxx e 192.168.xxx.xxx (guarda slide 34)\n\nbroadcast è sempre \"tutti 1 nella host part\", anche se questo non produce in generale in CIDR un 255!","x":-398,"y":1400,"width":478,"height":1400},
		{"id":"0f2a36c9dcf84a3e","type":"text","text":"# Linux Shell Commands (Bandit)\n\nApprofonditi in ordine di utilità nel gioco [Bandit](https://overthewire.org/wargames/bandit/bandit0.html) proposto da OverTheWire.\n\nSi accede al livello `N` del gioco loggando in `ssh` all'`host` `bandit.labs.overthewire.org` mettendo come `user` `banditN` e come `password` quella ottenuta al livello `N-1`.\n\nLa sia username che password del livello zero sono `bandit0`. Nel seguito, il riquadro `Level N` contiene la soluzione per trovare la password del livello `N`.","x":880,"y":1325,"width":759,"height":250,"color":"6"},
		{"id":"4b0914af8d708d70","type":"text","text":"# **🕵️‍♂️ Sono Dentro! Ora Cosa Faccio?**\n\nHai appena stabilito una connessione **SSH** con una macchina remota. Il tuo obiettivo ora è **capire dove ti trovi**, **chi sei**, **cosa puoi fare** e **fino a che punto puoi spingerti**. Un hacker esperto deve ottenere **il massimo delle informazioni nel minimo tempo possibile**, quindi seguiamo un approccio **metodico ed efficiente**. 🚀\n\n---\n\n## **📍 1. Dove Mi Trovo? Identificare il Sistema**\n\nLa prima domanda da porsi è: **che macchina è questa?** Potresti essere su un server Linux, un container Docker, una macchina virtuale... e ogni situazione cambia le tue possibilità d’azione.\n\n🔹 **Controllare il sistema operativo e la distribuzione**\n\n```bash\nuname -a   # Versione del kernel e architettura\ncat /etc/os-release  # Nome della distribuzione Linux\ncat /proc/version  # Info dettagliate sul kernel\n```\n\n💡 **Se vedi qualcosa tipo `container` o `lxc` nel kernel, probabilmente sei in un container Docker o LXC!**\n\n🔹 **Dove sei nel filesystem?**\n\n```bash\npwd   # Mostra la tua directory corrente\nls -la  # Lista tutto, inclusi file nascosti\nmount | column -t  # Controlla i filesystem montati\n```\n\n💡 **Se sei in `/home/user` o `/tmp`, probabilmente sei un utente normale. Se sei in `/root`... jackpot!**\n\n---\n\n## **🆔 2. Chi Sono? Controllare i Permessi dell’Utente**\n\n```bash\nwhoami   # Nome dell’utente attuale\nid       # UID, GID e gruppi dell’utente\ngroups   # Quali gruppi sono associati al tuo utente\n```\n\n💡 **Se il tuo UID è `0`, sei root!** Se no, controlla se sei in gruppi **privilegiati** (`sudo`, `docker`, `adm`... questi possono aiutarti a scalare privilegi).\n\n🔹 **Chi è loggato sulla macchina?**\n\n```bash\nwho      # Lista degli utenti connessi\nw        # Chi è connesso e cosa sta facendo\nlast     # Storico degli accessi\n```\n\n💡 **Se vedi admin o root attivi, potresti aspettare che eseguano un comando con `sudo` e provare un attacco di hijacking.**\n\n🔹 **Sto usando un account di servizio o un utente reale?**\n\n```bash\ncat /etc/passwd | grep $(whoami)\n```\n\nSe vedi qualcosa tipo `/bin/bash` o `/bin/sh` alla fine della riga, **sei un utente interattivo**. Se invece vedi `/usr/sbin/nologin` o `/bin/false`, è un account di servizio con accesso limitato.\n\n---\n\n## **🔎 3. Cosa Posso Fare? Capire i Privilegi**\n\n### **🔹 Ho accesso a `sudo`?**\n\n```bash\nsudo -l\n```\n\n💡 **Se puoi eseguire comandi senza password (`NOPASSWD`), potresti ottenere root facilmente!**\n\n### **🔹 Ci sono comandi con `SUID`?**\n\n```bash\nfind / -perm -4000 2>/dev/null\n```\n\n💡 **Se trovi `/bin/bash` con il bit SUID attivo, puoi eseguire una shell con privilegi elevati!**\n\n---\n\n## **📂 4. Esplorare il Filesystem e i Dati Sensibili**\n\n### **🔹 File Importanti da Controllare**\n\n```bash\ncat /etc/passwd  # Lista degli utenti\ncat /etc/shadow  # Hash delle password (richiede root, ma puoi provare...)\ncat /etc/sudoers  # Configurazione sudo\nls -la /root/  # Vedi cosa c'è nella home di root (se puoi)\n```\n\n💡 **Se hai accesso a `/etc/shadow`, puoi tentare di craccare le password con John the Ripper o Hashcat.**\n\n### **🔹 File con permessi deboli**\n\n```bash\nfind / -type f -perm -o+w 2>/dev/null  # File scrivibili da chiunque\nfind / -type d -perm -o+w 2>/dev/null  # Directory scrivibili da chiunque\n```\n\n💡 **Se un file di configurazione critico è scrivibile da te, potresti modificarlo per ottenere accesso elevato!**\n\n---\n\n## **📡 5. Controllare la Rete e il Contesto**\n\nSe sei entrato via **SSH**, probabilmente il sistema è **parte di una rete più grande**. Potresti cercare altre macchine vulnerabili da attaccare.\n\n🔹 **Quali interfacce di rete ci sono?**\n\n```bash\nip a\n```\n\n💡 **Se vedi un IP privato (`192.168.x.x`, `10.x.x.x`), potresti essere in una rete interna con altre macchine interessanti!**\n\n🔹 **Quali connessioni sono attive?**\n\n```bash\nnetstat -tulnp  # Mostra porte aperte e processi associati\nss -tulnp       # Alternativa più moderna a netstat\n```\n\n💡 **Se vedi servizi con porte aperte, potresti attaccarli per espandere il tuo accesso.**\n\n🔹 **Quali processi stanno girando?**\n\n```bash\nps aux --sort=-%mem  # Processi ordinati per uso memoria\nps aux --sort=-%cpu  # Processi ordinati per uso CPU\n```\n\n💡 **Se vedi un servizio con privilegi elevati, potresti provare un attacco tramite privilege escalation.**\n\n---\n\n## **🎭 6. Rimanere Invisibili**\n\nSe sei entrato in un sistema e vuoi **minimizzare le tracce**, ci sono alcune tecniche per coprire il tuo ingresso.\n\n🔹 **Pulire la cronologia della shell**\n\n```bash\nhistory -c && history -w\n```\n\n🔹 **Disabilitare la cronologia temporaneamente**\n\n```bash\nunset HISTFILE\nexport HISTSIZE=0\nexport HISTFILESIZE=0\n```\n\n🔹 **Eliminare i log SSH**\n\n```bash\n> ~/.bash_history\necho \"\" > /var/log/auth.log  # Richiede privilegi elevati\n```\n\n💡 **Tieni a mente:** Se sei in un ambiente monitorato, potrebbero comunque accorgersi di movimenti sospetti.\n\n---\n\n## **🚀 Conclusione: La Prima Mossa È Capire il Campo di Battaglia**\n\nOra sai **come raccogliere rapidamente informazioni su un sistema** una volta dentro via SSH.\n\n✅ **Dove sei?** Controlla il sistema operativo, il filesystem e la rete.  \n✅ **Chi sei?** Determina i tuoi privilegi e i gruppi a cui appartieni.  \n✅ **Cosa puoi fare?** Scansiona permessi, file sensibili, processi e accessi di rete.  \n✅ **Come coprirti?** Ripulisci tracce, disabilita log e cronologia.\n\n🔎 **Vuoi ora esplorare le tecniche di privilege escalation per ottenere root?** 😈","x":800,"y":1942,"width":763,"height":4038},
		{"id":"7b351e91b16f865e","type":"text","text":"# Level 0\n\n\n\nLa password per il livello 1 si trova banalmente nel file `readme` del livello 0:\n\n```\nZjLjTmM6FvvyRnrb2rfNWOZOTa6ip5If\n```","x":1837,"y":1325,"width":759,"height":250,"color":"4"},
		{"id":"ea0a31adef225299","type":"text","text":"# Level 1, 2, 3, 4, 5\n\n1. Il file si chiama `-`, se provi a fare `cat -` ovviamente quello si aspetta che stai per scrivere un'opzione. Io ho risolto facendo `cp - /tmp/hello` (non avevo i permessi per scrivere altrove, `/tmp` è stato il best guess) e poi leggendo `cat /tmp/hello`.\n\n```\n263JGJPfgU6LtdEvgfWU1XP5yac29mFx\n```\n\n2. La difficoltà sarebbe che il file contiene spazi. A parte che se scrivi `cat s` e poi fai `tab` ti scrive già tutto in automatico, ma in caso te lo scordi puoi mettere l'escape character (`\\ `) oppure il nome tra virgolette (`cat 'spaces in this filename'`).\n\n```\nMNk8KNH3Usiio41PRUEoDFPqfxLPlSmx\n```\n\n3. I file nascosti si vedono con `ls -a`.\n\n```\n2WmrDFRmJIq3IPxneAaMGhap0pFhF3NJ\n```\n\n4. Come prima, visto che i file cominciano con `-` tocca trovare un altro modo, tipo `cat ./-file00`. Non mi andava di controllarli uno per uno: sotto parliamo di ***script bash***.\n\n```\n4oQYVPkxZOOEOO5pTW81FB8j8lxXGUQw\n```\n\n5. Qui il punto è: posso anche fare `for f in ./*; do ls -la ./$f; done | grep 1033`, e in effetti esce un unico file, il problema è che non mi dà il percorso (solo il nome!). Non so se ci sono modi per far stampare il percorso a `ls`, ma nel dubbio `du` lo fa già in modo nativo. Quindi `du -ab | grep 1033` (`-a` per stampare tutti i file e `-b` per le dimensioni in `byte`), restituisce `1033    ./maybehere07/.file2`, quindi `cat`.\n\n```\nHWasnPhtq9AVKe0dmk45nxy20cvUa6EG\n```","x":2820,"y":1027,"width":759,"height":846,"color":"4"},
		{"id":"339d53393538d01d","type":"text","text":"# Laboratorio 1\n\n","x":-4680,"y":1240,"width":759,"height":560},
		{"id":"b50e7d92657b8d61","type":"text","text":"# Linux Shell\n\n- `grep` - Trova occorrenze dell'espressione che richiedo all'interno di un file, o più in generale di qualsiasi cosa gli venga data in input\n- `find` - Trova occorrenze dell'espressione che richiedo all'interno dei soli ***nomi*** dei file;\n- ","x":-1821,"y":-1573,"width":621,"height":493},
		{"id":"0ab6e3f18680f1a9","type":"text","text":"curl","x":520,"y":1265,"width":250,"height":60},
		{"id":"6033fbd5014b0cba","type":"text","text":"# PND\n\n6o67wtg\n\nACME è una rete virtuale in ambiente sapienza sulla quale implementare le cose del corso (sulla quale girano circa 15 VM). Usa una VM con Katharà, NON fare sta roba sul pc direttamente perché esplode tutto\n\ncompleteness\ncorrectness\neffort (scrivi più di 1-2 pagine nel report, che sennò si incazza)","x":-2500,"y":-1520,"width":560,"height":360},
		{"id":"e5fc1848775e11e1","type":"text","text":"- find - looks for files (by name, size, ...)\n- la shell ha comandi interni ad essa ed esterni. con `which ls` trovi il percorso dei comandi esterni (se è interno non restituisce niente). `ls` è esterno\n- `man comando` restituisce il manuale di `comando`.\n- `apropos comando` ti dice cosa fa `comando`\n- `info comando` è la vecchia versione di `man comando`, ma su editor (man è su terminale)\n- `alias` restituisce tutte le shortcut alternative per i comandi\n\t- `ll` è `ls -afD`, se fai `ll /proc/` ti escono cose che non sono né `d` (directory) né `-` (file), ma `c` (??) o `s` (file compresso??) \n- cosa sono i gruppi `shadow` e `dialout` ???\n- s al posto di x = prima dell'esecuzione cambia la proprietà del file. `which passwd` e poi `ll /output/passwd` (vedrò la `s` sull'user, quando lo esegue il possesso passa a root). Vedi rec\n\t- mi sa che devi chiedergli cosa recuperare... SO2?\n\n`shadow` sono le password pare, e sono separate dal file `passwd`!!\nQuella NON è una RegEx!! è una EXPANSION del bash\n\n`for i in 'la -1 *a.txt'; do echo $i.backup; done`\n\nfa un backup di ....... guarda la rec. link simbolici con `ln`. \n\nanche per una parte sui permessi, è circa l'una e mezza \n\n`cat` = concatenate (cerca le motivazioni dietro ai comandi!!!)\n\n`echo '3 is a number' | wc -w | tr '[0-9]' '[n-z]'` che fa sta roba?\n\n- echo manda in output la frase\n- la prende word count (wc) con opzione -w (conta sola le parole), quindi restituisce 4\n- tr.....\n\n128 è 10000000....","x":-2500,"y":-1120,"width":560,"height":992},
		{"id":"28ffaf4f75ea584b","type":"text","text":"# Virtual Machines e Containers (Docker)\n\nTutta questa roba gira su una VM, perché simulare un kernel anziché modificare quello della propria macchina è sempre una scelta safe. Tutto questo ci isola completamente dal SO nativo della macchina. Detto questo, all'interno della VM lavoriamo in un ambiente isolato a livello di processi, detto ***container***. In particolare, usiamo ***Docker***.\n\nDocker è un servizio di sistema il cui demone (`dockerd`) parte all'avvio del SO. Il suo scopo è quello di permettere all'utente di creare e gestire i container, ambienti virtuali in cui gruppi di processi vengono isolati dai restanti (a livello tecnico, questo avviene con le funzioni `namespace` e `cgroups` del kernel Linux, ma non ci addentriamo).\n\nDiversi gruppi di processi (i.e. diversi container) hanno in generale diverse necessità di comunicazione. Pertanto, Docker configura di default (prima ancora di creare il primo container!) tre tipologie di reti (visualizzabili con `sudo docker network list`):\n\n- `bridge` - Una rete predisposta a collegare tra di loro i vari container ad essa connessi. Questo non li connette direttamente ad Internet. Funziona in modo simile ad un ***NAPT***, quindi se voglio farli accedere alla rete esterna devo fare ***port mapping***;\n- `host` - Il container condivide la rete dell’host. Se il container apre una porta, la apre direttamente sul sistema host. Usato per evitare l'overhead di virtualizzazione di rete;\n- `none` - Al container configurato con questa rete è impedita qualsiasi comunicazione, i.e. non ha alcuna interfaccia di rete. Usato generalmente per le sandbox.\n\nSi possono poi creare ulteriori reti personalizzate con `sudo docker network create`.\n\nTutto molto bello, ora però tocca creare un container. Come?\n\nIn pratica, Docker si comporta come se fosse una sorta di server interno al SO. Ha un file ***socket*** (`/var/run/docker.sock`) gestito dal demone `dokerd`: chi vuole creare un nuovo container deve mandare la richiesta al socket, e può farlo solo se sta nel gruppo `docker`, l'unico ad avere i giusti permessi sul socket stesso (oltre ovviamente a `root`).\n\n<span style=\"color:rgb(236, 155, 14)\">**Attenzione:** Chi può scrivere su `/var/run/docker.sock` può **controllare tutto Docker**, il che equivale ad avere accesso **root senza password**.</span>\n","x":-4680,"y":200,"width":759,"height":846,"color":"4"},
		{"id":"c43c09b5a27c6f80","type":"text","text":"# Katharà\n\nCon Docker, creiamo un container per ogni nodo virtuale, dopodiché definiamo una rete di tipo `bridge` personalizzata con cui connettere i vari nodi. Questo crea uno schema di packet switching interno all'ambiente Docker, che di fatto simula una rete internet.\n\nAbbiamo sostanzialmente descritto il principio di funzionamento di ***Katharà***.\n\nPartiamo da una cartella in cui siano presenti i file di configurazione\n\n- `lab.conf`, che definisce il ruolo dei vari elementi di rete (e.g. router o pc);\n- `*.startup`, che definiscono le configurazioni iniziali dei vari elementi di rete.\n\nA questo punto possiamo fare `kathara start`, o sfruttiamo l'`alias` `lstart`, se presente. In modo analogo possiamo riavviare l'ambiente se qualcosa non va (`lrestart`), fermare tutto (`lclean`) o forzare la pulizia dell'ambiente se abbiamo bloccato tutto (`kwipe`).","x":-5600,"y":1240,"width":759,"height":560,"color":"3"},
		{"id":"0b25b95bc5c2ea6a","type":"text","text":"nella cartella lab1, il contenuto di ogni cartella ex1 è la topologia della rete, e in lab.conf la configurazione di rete\n\n- r1[0]='A' significa che il router r1 ha un interfeccia eth0 connessa alla rete A.\n- r1[bridged] - r1 è connesso ad internet, i.e. gli viene assegnato un IP per l'esterno, diventa il default gateway.\n- `r1[sysctl]` - sysctl setuppa delle cose del kernel, in ex1 configuro r1 come forwarder (router) sia per ipv4 che 6.\n\nin una cartella dove c'è lab.conf, `katharà lstart` o `lstart` se c'è l'alias.\n\n`kathara settings` - docker network plugin deve essere settato alla prima opzione (senza `_vde`).\n\ndice una roba su come cambiare il font, vedi rec intorno a 20 min (dopo settings)\n\nslide 11 - nel file di configurazione sono tutti là (ip, netmask, ...)\n- ifconfig ipmask e mask, route for default gateway, e ??.conf (REC!!)\n\nex1 - ?\n\nex2 - configura server, avvialo, poi passa ai pc. per pc2 usa dhclient","x":-7280,"y":1000,"width":1025,"height":857},
		{"id":"625ede0e186681f5","type":"text","text":"# Level 6\n\nQuesta è una ricerca in tutto il filesystem partendo dalla radice e con criteri di dimensione e permessi. In questo caso è sufficiente `find / -type f -user bandit7 -group bandit6 2>/dev/null`.\n```\nmorbNTDkSW6jIlUc0ymOdMaLnOlFVAaj\n```","x":3800,"y":1027,"width":759,"height":846},
		{"id":"1aee8251fddfc28d","type":"text","text":"# Wireshark Lab\n\nhijacking\n\nalternative per sniffare traffico\n\n- dumpcap solo capture dei packet, no analysis\n- tcpdump less flexible than wireshark (no display filter, no GUI)\n- netflow - non fa deep packet inspection, fa solo un sommario di quello che sta succedendo (conta i pacchetti, i byte, RTT, ...)\n- ne ha saltato uno\n\nsono tutti basati sulla libreria `pcap`.\n\nl'idea di wireshark è di dissezionare il pacchetto e trovare i limiti del frame (DLL), segmento (Trasporto), pacchetto (Applicazione).\n\nè scemo, nel senso che se vede una roba su porta 80 prova a dissezionarlo pensando sia http. il che ha senso, ma puoi fregarlo usando porte non standard.\n\ndue tipi di filtri\n\n- capture - quelli esclusi dal filtro vengono proprio persi\n- display - quelli esclusi non vengono mostrati (ma ws li ha presi!)\n\nberkley packet filter (BPF) syntax\n```\nprotocol(tcp, ip6, ...) direction (src, dst) type\n```\ncon `type` puoi fare N cose, tra cui operatori e simili. vedi slides\n\n","x":-3600,"y":1240,"width":640,"height":1000},
		{"id":"399d0f8bfe3f80d5","type":"text","text":"# IPv6\n\nad oggi abbiamo finito gli IPv4, e ne allochiamo di nuovi solo se qualcuno li restituisce a IANA. \n\nIoT con IPv6?\n\nIPv6 ha $\\sim 3.4\\cdot 10^{38}$ (o alla 36?) indirizzi. In teoria risolve la necessità di usare il NAT. Ogni hex sono 4 bit. 128 bit sono 32 esadecimali in 8 gruppi da 4. parte di rete e parte di host sono simmetriche (16 e 16 hex). huge amount of hosts, questo protegge gli host perché enumeration diventa difficilissimo (ci metti ordine secoli).\n\n:: comprime intere stringhe di 0. Non ogni singolo blocco da 4 hex!: cioè non si trova `AB::::CD:1200::10`, si comprime solo la più lunga (e se ce ne sono due uguali si comprime solo la prima).\n\nslide 25 (ignora anycast)\n\n- global unicast = identico a ipv4\n- link local sono usati solo in un link interno alla rete. ogni coppia che comunica in locale ha una coppia di ipv6.\n- unique local = indirizzi privati di ipv4\n- embedded ipv4 - retrocompatibilità\n\n\n","x":-3600,"y":2420,"width":640,"height":1040},
		{"id":"04825a06a9d94d59","type":"text","text":"# Bash - Controllo di Flusso\n\n```\nfor f in ./*; do echo \"file $f: \"; cat \"$f\"; echo; echo; done\n```\n\nQuesta è la ***concatenazione*** di comandi bash con cui si può risolvere il livello 4. In generale:\n\n- `comando &` esegue il `comando` in ***background***;\n- `c1; c2` esegue prima `c1` e poi `c2`, ***indipendentemente dall'esito*** del primo;\n- `c1 && c2` esegue `c2` solo se `c1` ha ***successo*** (i.e. `exit status 0`);\n- `c1 || c2` esegue `c2` solo se `c1` ***fallisce*** (e.g.  `mkdir prova || echo \"errore\"`).\n\nQualsiasi comando ha due tipologie di output: ***`stdout`*** per i risultati ordinari e ***`stderr`*** per gli errori. Se non viene specificato diversamente, entrambi vengono stampati su terminale. Altrimenti, entriamo nel mondo degli ***operatori di reindirizzamento***:\n\n- `comando > file` sovrascrive `file` con lo `stdout` di `comando`, mentre `comando >> file` lo aggiunge in coda (`append`);\n- `comando 2> file` e `comando 2>> file` discorso analogo, ma con `stderr`;\n\t- Posso anche dare entrambi i comandi insieme, e.g. `comando > file 2> errors` reindirizza `stdout` in `file` e `stderr` in `errors`;\n\t- Molto comune è la scrittura `2> /dev/null`, che reindirizza gli errori in un file che fa le veci di un buco nero in cui tutto viene distrutto (per un output più pulito). \n- `comando &> file` reindirizza entrambi, e anche lui ha il suo analogo in versione `append` con `comando &>> file.log`. Questa sarebbe la forma abbreviata di `comando > output 2>&1`, cioè `metti stdout in output, e stderr dove hai messo stdout`;\n\t- È l'unico caso in bash in cui `&` viene usato come \"puntatore\" (allo stream `1`).\n- `comando < file` usa `file` come input per `comando`;\n- `c1 | c2` esegue `c1`, quindi passa il suo output come input di `c2`.\n\t- I comandi \"telefonati\" da usare con `|` sono `grep` e `tee` (`comando | tee file` mostra l'output di `comando` a schermo e lo salva anche su `file`).\n","x":2820,"y":2042,"width":759,"height":797,"color":"4"},
		{"id":"3d73dc291ec51cb6","type":"text","text":"# Bash - Espansioni, Espressioni, Logica\n\nPer avere il quadro completo manca il ruolo del meraviglioso operatore `$`.\n\n- ***`$f`*** (***espansione di variabile***) - Se `f` è una variabile, `$f` sostituisce il suo contenuto;\n- ***`$(comando)`*** (***espansione di comando***) - Ogni `comando` restituisce un certo output. Questa scrittura esegue `comando` e ne utilizza l'output in una espressione;\n- ***`$((algebra))`*** (***espressione algebrica***) - Questa scrittura esegue operazioni di `algebra` elementare. Non si possono innestare comandi (e.g. `du`) al suo interno!\n\nA questo dobbiamo aggiungere l'operatore di ***test logico*** per condizioni booleane. La scrittura è `[[ condizione ]]`, e restituisce il valore `True` o `False` della `condizione`.\n\n- ***Test su `file`*** - La scrittura `-X file` restituisce `True` se, per diversi `-X`, `file`\n\t- esiste (`-e`), è un file (`-f`), è una directory (`-d`), è non-vuoto (`-s`);\n\t- è leggibile (`-r`), scrivibile (`-w`) o eseguibile (`-x`);\n- ***Confronto tra `file`*** - La scrittura `file1 -nt file2` restituisce `True` se `file1` è più nuovo (i.e. ha data di modifica più recente) di `file2` (e viceversa con `-ot`);\n- ***Test su `stringa`*** - `-z str` restituisce `True` se `str` è vuota (non-vuota con `-n`);\n- ***Confronto tra `stringhe`*** - Classici operatori di `=`, `!=`, `>` e `<` (questi ultimi due a livello lessicografico). Molto è interessante è verificare se una `stringa` è il prodotto di una ***regex*** con la condizione `str =~ regex`;\n- ***Confronto tra numeri*** - Classici operatori `-eq`, `-ne`, `-lt` `-le`, `-gt`, `-ge`.\n\nPuoi combinare più `condizioni` secondo gli operatori `&& (AND)`, `|| (OR)` e `! (NOT)`.","x":2820,"y":2960,"width":759,"height":646,"color":"4"},
		{"id":"1cdecb81c364493b","type":"text","text":"# Orientarsi\n\nBene, sono entrato in `ssh`. Sì, ma dove?\n\n- ***Kernel e SO*** - Posso stampare un riassunto con `uname -a`, che mostra \n\t- `nome_kernel`, e.g. `Linux`;\n\t- `hostname`, e.g. `my_pc`;\n\t- `versione_kernel`, e.g. `5.15.0-91-generic` (`generic` è la versione di Ubuntu);\n\t- `numero_build`, i.e. quante volte il kernel è stato ricompilato. In che senso? Quelli che distribuiscono il SO (e.g. ***Canonical*** per Ubuntu) non si mettono a firmare nuove versioni ad ogni minimo fix. Un aggiornamento minore (eseguito con `apt upgrade`) può includere una modifica al kernel ed una conseguente ricompilazione, che incrementa solo il numero di build, e.g. `#102-Ubuntu SMP Fri Jan 5 12:06:54 UTC 2024` (di norma ti dice anche quando è stato ricompilato l'ultima volta);\n\t\t- Se so che nella build `#102` c'è una ***vulnerabilità*** nota che è stata fixata solo successivamente (e.g. nella `#105`, l'ultima), posso sfruttarla per fare robe;\n\t\t- Se poi sono molto interessato a queste cose, con `cat /proc/version` trovo anche i dettagli sul tipo di compilatore usato.\n\t- `architettura`, e.g. `x86_64`;\n\t- `SO`, e.g. `GNU/Linux`;\n\t\t- Se mi interessa la distribuzione specifica del kernel, `cat /etc/os-release`. Questo in genere serve per capire la compatibilità dei SW che vuoi usare.\n- ***Chi sono io?*** - Potrei essere interessato a capire in qualità di che utente sono loggato.\n\t- `whoami` - Restituisce il nome dell'utente attuale (in teoria dovrei saperlo, se sono entrato con `ssh` dovrebbe coincidere con l'`user`);\n\t\t- <span style=\"color:rgb(236, 155, 14)\">Sono un utente standard o un account di servizio?</span> `cat /etc/passwd | grep $(whoami)` restituisce le righe del file `passwd` in cui compare il mio `user`. <span style=\"color:rgb(236, 155, 14)\">Se vedi qualcosa tipo `/bin/bash` o `/bin/sh` alla fine della riga, **sei un utente interattivo**. Se invece vedi `/usr/sbin/nologin` o `/bin/false`, è un account di servizio con accesso limitato.</span>\n\t- `id` - L'`user` è solo una label. Il SO mi identifica con un numero, detto ***UID***;\n\t\t- `0` corrisponde a `root`, `1-999` sono in genere utenti di sistema (e.g. servizi, demoni, ...) e `1000+` sono utenti normali;\n\t\t- Posso specificare `id -u mario` per sapere l'`UID` dell'utente `mario`;\n\t\t- A questo utente saranno associati anche dei gruppi, pertanto l'output di `id` sarà una lista `#id(group)` dove `#id` è il numero associato alla label `group`.\n- ***Chi sono gli altri?*** - Chi altro è loggato, e cosa sta facendo?\n\t- `who` e `w` permettono di vedere, rispettivamente, queste due cose;\n\t- `last` è uno storico degli accessi <span style=\"color:rgb(236, 155, 14)\">SSH</span>;\n- ***Cosa posso fare?*** - Per capirlo, mi serve sapere quali sono i miei privilegi. ","x":1837,"y":2042,"width":759,"height":1278,"color":"3"},
		{"id":"efbeb23d6fccc658","type":"text","text":"# Script Bash\n\nOgni ***script bash*** inizia con `#!/bin/bash`. Perché? Bash è un ***linguaggio interpretato***, e questo simpatico operatore `#!` (detto ***shebang***, da `sharp (#) + bang (!)` se te lo stessi chiedendo) serve a specificare il percorso dell'interprete da usare. Per capirci, se scrivi `#!/usr/bin/python3` e poi esegui `./script.py`, questo verrà interpretato in automatico da `python3`, senza bisogno di scrivere sulla shell `python3 script.py`. \"Quindi posso non mettere `#!/bin/bash` e scrivere direttamente sulla shell `bash script.sh`?\". Sì, ma basta con le digressioni, andiamo avanti.\n\nTutti questi operatori ci portano con molta naturalezza a voler mettere un botto di comandi in fila utilizzando i costrutti fondamentali di un qualsiasi linguaggio di programmazione.\n\nTutti i costrutti che seguono possono essere scritti come singola riga. In quel caso, gli \"a capo\" si sostituiscono con l'operatore `;`. Partiamo con l'`if` e vediamo un esempio:\n\n```\nif [[ condizione ]]; then\n\tcomando1\n\tcomando2\nelif [[ altra condizione ]]; then\n\tcomando3\nelse\n\tcomando4\nfi\n```\n\nChe su una sola riga diventa\n\n```\nif [[ condizione ]]; then comando1; comando2; elif [[ altra condizione ]]; then comando3; comando4; else comando4; fi\n```\n\nPuò essere utile `case`, quando mettere troppi `elif` diventa noioso:\n\n```\ncase variabile in\n\tpattern1) comando1 ;;\n\tpattern2) comando2 ;;\n\t...\n\t*) comando_default ;;\nesac\n```\n\nSeguono i `loop`: `for`, `while` e poi boh, a qualcuno evidentemente non andava di scrivere `while [[ ! condizione]]` (che continua a girare finché `! condizione` non diventa `True`) e si è inventato `until [[ condizione ]]` (gira finché `condizione` non diventa `False`).\n\n```\nfor var in elenco; do\n\tcomando1\n\tcomando2\ndone\n```\n\n```\nwhile [[ condizione ]]; do\n    comando1\n    comando2\ndone\n```\n\n```\nuntil [[ condizione ]]; do\n    comando1\n    comando2\ndone\n```\n\nIn basso segue come definire le funzioni.","x":3800,"y":2042,"width":759,"height":1564,"color":"4"},
		{"id":"592cc115c760d58b","type":"text","text":"# Script Bash - Funzioni\n\nCi sono due modi equivalenti di dichiarare le funzioni:\n\n```\nfunction nome_funzione {\n    comando1\n    comando2\n}\n```\ne\n```\nnome_funzione() {\n    comando1\n    comando2\n}\n```\n\nIn ogni caso, i ***parametri*** non vanno passati tra parentesi.\n\n```\nsomma() {\n\techo $(( $1 + $2 ))\n}\n\nsomma 4 5    # Output: 9\n```\n\nIntuitivamente, `$N` è l'`N`-esimo parametro passato, dove `N` può essere qualsiasi (il numero di parametri letti dalla funzione è accessibile con `$#`). Posso poi prendere tutti i parametri insieme e trattarli come ***lista*** (`$@`) o come ***stringa*** (`$*`).\n\n`return` qui rappresenta il codice di uscita, ed è pertanto recuperabile con `$?` (restituisce il codice di uscita dell'ultimo comando eseguito) subito dopo la sua esecuzione.\n\nTutte le variabili dentro le funzioni sono intese come globali, salvo specifica `local`.\n\nUn'applicazione interessante è fare override di comandi noti, e.g.\n\n```\nls() {command ls --color=auto \"$@\"}\n\nls   # Usa ls con colori sempre attivi\n```","x":3800,"y":3777,"width":759,"height":983,"color":"4"},
		{"id":"d8bd274b8f96df69","type":"text","text":"# Bash - Enumerare e Leggere Cose\n\nAnzitutto bisogna capire ***cosa c'è*** nella directory, con ***`ls`***. `-l` mostra i dettagli dei vari file: `permessi #hard_link proprietario gruppo dimensione(byte) ultima_modifica nome`.\n\n - Posso ordinare i file per dimensione (`-lS`) o per ultima modifica (`-lt`)\n- Altre opzioni rilevanti sono `-a` (mostra anche i file nascosti), `-R` (mostra in modo ricorsivo il contenuto di tutte le sotto-directory), `-h` (`dimensione` viene tradotta in un formato più leggibile, e.g. `Kb`, `Gb`), `-d` (mostra solo le directory) e `-i` (mostra gli ***inode*** dei file);\n- Posso anche combinarlo con altri comandi per filtrare l'output:\n\t- ``ls -lhS | head -n 10`` mostra i 10 file più pesanti in formato leggibile;\n\t- `ls -l *.txt` mostra solo i file con estensione `.txt` (senza usare `grep`!).\n\nUna volta capito cosa c'è, la prossima domanda può essere ***cosa c'è dentro ai file***.\n\n- ***`file`*** - Restituisce la ***codifica del contenuto*** di un `file1` (e.g. `ASCII`, `EXIF`). Questo perché ci metto un attimo a salvare un'immagine come `immagine.txt` nonostante non sia affatto un `.txt` (... o un malware come `file.innocuo`);\n- ***`more`*** or ***`less`*** - Entrambi servono per ***mostrare il contenuto*** di un `file1`.\n\t- `more` è la versione più datata, stampa una riga per volta e ti fa andare solo avanti;\n\t- `less` è una sorta di reader integrato (come può essere `nano` per gli editor di testo), permette di andare su e giù e supporta la ricerca (`/parola` per l'occorrenza successiva, `?parola` per quella precedente).\n\t\t- ***`man`*** usa `less` come reader, e pertanto supporta la ricerca in questo modo.\n- ***`head`*** or ***`tail`*** - Non sempre voglio leggere davvero tutto il file. `head` mostra ***solo le prime `10` righe*** (`-n N` per mostrarne `N`), `tail` le ***ultime*** `10` (anche qui `-n N`);\n\t- `tail` può seguire in diretta l'evoluzione di un file con `-f` (e.g. `tail -f log.txt | grep \"error\"`, stampa in diretta solo gli errori).\n- ***`cat`*** - Nato originariamente con l'idea di concatenare più file in uno solo (`cat file1 file2 > file3` concatena i file `1` e `2` a formare il `file3`) viene di fatto utilizzato per ***stampare roba*** (`cat file1` mostra il contenuto di `file1` su `stdout`);\n\t- Le opzioni `-n` e `-b` su un singolo `file1` restituiscono rispettivamente il numero di righe di `file1` ed il numero di righe non vuote, `-s` stampa `file1` riducendo ogni `N` righe vuote consecutive ad una sola;\n\t- Ha una utile variante `tac` per ***stampare i file al contrario***!\n\t- Va facilmente in combo con i comandi di lettura di prima (e.g. `cat file1 | less`).\n","x":2820,"y":-86,"width":759,"height":957,"color":"4"},
		{"id":"eab759960ddcf808","type":"text","text":"# Attaccare SSH\n\nPartiamo da un presupposto: se il server è configurato bene, è tendenzialmente difficile.\n\nNelle opzioni di configurazione, `sshd_config` può prevedere un numero massimo di tentativi da un certo `IP` (`MaxAuthTries`), oltre il quale un sistema come `fail2ban` può bannare il tuo `IP` (i.e. non accettare più alcun tentativo da parte tua).\n\nQuesto chiaramente presuppone che tu stia facendo brute force su una password debole. È però possibile che l'`host` accetti solo autenticazione con chiavi asimmetriche, rendendo di fatto qualsiasi attacco impossibile (a meno che non fai tipo MitM al momento dello scambio di chiavi, ma stiamo parlando di cose complicate).\n\nSe sei già dentro al sistema, potresti voler trovare le `password` di altri `user`. Questo si riduce a un meccanismo di hacking interno alla macchina, per cui dovresti avere i permessi per accedere a `/bin/shadow` e usare un tool come `hashcat` o `john` per risalire ai dati a partire dagli hash (cosa notoriamente difficile).","x":880,"y":-997,"width":759,"height":439,"color":"4"},
		{"id":"4282f1f0f685c1b7","type":"text","text":"# `ssh-keygen`\n\nSe non ti va di mettere la password ad ogni connessione (anche perché mandarla ogni volta in giro su Internet è una potenziale vulnerabilità) puoi creare una ***coppia di chiavi*** con il comando ***`ssh-keygen`*** e copiare la chiave pubblica sulla macchina remota con `ssh-copy-id user@host`. La scrittura più generale possibile è`ssh-keygen [opzioni] -t <algoritmo> [opzioni dell'algoritmo]`, dove\n\n- le `[opzioni]` includono `-f <file>` (specifica il file di output in cui vengono salvate le chiavi), `-C \"comment\"` (inserisce un commento, tipo \"`Chiave per GitHub`\"), `-N \"passphrase\"` (protegge l'accesso alla chiave privata), `-q` (modalità \"silenziosa\") e `-y` (data una chiave privata, ne estrae la pubblica);\n- `-t <algoritmo>` è in realtà facoltativo (in assenza di specifica si usa ***RSA*** con chiave a `3072 bit`), ma si usa in genere ***ed25519***, che rappresenta un buon compromesso tra sicurezza e velocità;\n- le `[opzioni dell'algoritmo]` si riducono di norma alla lunghezza della chiave (`-b`), ma ad esempio `ed25519` usa sempre chiavi a `256 bit`.\n","x":880,"y":125,"width":759,"height":536,"color":"4"},
		{"id":"8603be4ae948e472","type":"text","text":"# Opzioni Furbe\n\nLe `[options]` di `ssh` sono in realtà uno strumento molto potente.\n\n- `-N -f -q -L` - ha senso usarli insieme: `-N` apre una connessione senza terminale, e uno si potrebbe chiedere \"ma allora a che serve?\". Ecco perché parliamo anche di `-L`, che fa ***port forwarding*** dalle mie porte locali a quelle dell'host remoto. Cioè?\n\t- `-L <porta_locale>:<host_remoto>:<porta_remota>` si comporta così: quando arriva un qualcosa alla mia `porta_locale`, questo qualcosa viene reindirizzato direttamente alla `porta_remota` dell'`host_remoto`;\n\t\t- Nota che `host_remoto` potrebbe non essere l'`host` con cui ho stabilito la connessione `ssh`! Con `ssh -L 3306:192.168.1.50:4070 user@host` sto dicendo \"`Ciao host, mo' io ti mando qualsiasi cosa arrivi sulla mia porta 3306, tu devi girare tutto a 192.168.1.50:4070 (dal tuo punto di vista, i.e. come se fossi tu a mandarla). Come? Boh, veditela tu`\";\n\t\t- Di norma sta roba si usa per accedere ad un qualche servizio dal punto di vista di `host`, quindi scrivendo `ssh -L 3306:localhost:3307 user@host`. In pratica così sto dicendo una roba del tipo `Devi fare una roba per me, ti inoltro tutto ciò che passa sulla mia porta 3306 alla tua porta 3307` (***`localhost`*** è un placeholder per l'indirizzo di ***loopback*** `127.0.0.1`);\n\t- `-N` evita di aprire il terminale, quindi fa consumare meno risorse all'`host`, mentre `-f` mette il processo in ***background***;\n\t\t- Uno potrebbe pensare che così si guadagna in privacy, ma non è vero. Il processo resta visibile ad un comando `ps aux`, anche se si può provare a limitare la quantità di log registrati tramite la ***quiet mode*** (`-q`).\n\t- `-L` ha anche l'opzione inversa: `-R a:localhost:b` significa che tutto ciò che arriva all'`host` sulla porta remota `a` viene mandato alla mia macchina sulla porta `b`.\n- `-D` - Configura un ***proxy SOCKS***, i.e. un proxy che opera a livello di trasporto. Questo gli permette di inoltrare dati senza fare le solite porcate che fanno i proxy `HTTP` (e.g. filtrare il traffico, o spiarlo), nonché di inoltrare qualsiasi tipo di richiesta. `ssh -D 8080 user@host` sta dicendo ad `host` che quando arrivano richieste da me, lui deve mandarle su Internet come se venissero da lui. ","x":1837,"y":-1208,"width":759,"height":848,"color":"4"},
		{"id":"22dfa299c258426a","type":"text","text":"# SSH - `ssh [options] user@host`\n\n***Secure Shell*** usa di norma la  ***porta 22*** per connettere il proprio terminale ad un terminale remoto eseguito come `user` all'indirizzo `host` (che può sia essere un indirizzo `IP` sia un nome, che verrà in caso risolto da DNS).\n\nQuesto non significa che puoi entrare a caso nei sistemi altrui. Il campo `user` deve essere un utente registrato su quell'`host`, e ti verrà richiesta la sua `password`.\n\nLe opzioni di base includono\n\n- `-p 1234` - si connette alla porta `1234` invece che alla `22`;\n- `-i </path/to/key>` - specifica che chiave usare per la connessione;\n- `-T` - usalo se vuoi eseguire solo un comando (concatenato come \"`ssh -T user@host 'comando'`\" e poi chiudere la connessione, senza aprire una shell interattiva;\n- `-X` - se vuoi avviare applicazioni con una GUI X11 sull'`host` remoto, questa opzione ti permette di visualizzare tale GUI sul tuo computer (risultato simile si ottiene con `-Y`, che ha meno restrizioni di sicurezza e in genere si usa se `-X` non funziona).\n\nUna sessione funzionante si termina con `exit` o `CTRL + D`, una \"rotta\" con `~.` (senza poi premere invio!), altrimenti killando il processo `ssh` da un altro terminale (se proprio devi).","x":1837,"y":125,"width":759,"height":536,"color":"6"},
		{"id":"4e494b0e134ff4a7","type":"text","text":"# Bash - Trovare Cose: `find` e `grep`\n\nSono tra i comandi più potenti di Linux. Per ***trovare `file` nel `filesystem`*** abbiamo\n\n```\nfind [path] [options] [criteria]\n```\n\n`[path]` è autoesplicativo: è il punto di partenza della ricerca. `[options]` e `[criteria]` vanno tipicamente insieme, perché posso cercare basandomi su\n\n- `-type` - il tipo di file. I più comuni sono `f` per i file \"standard\", `d` per le directory, `l` per i link simbolici, `c` per i file a caratteri (e.g. `/dev/tty`, terminale, o `/dev/random`,  generatore di numeri casuali), `b` per i file a blocchi (e.g. le partizioni come `/dev/sda` o `/dev/loop0`), `p` per i file `pipe` utili a far comunicare i processi tra loro ed `s` per i file di tipo `socket` (e.g. `Docker` si comporta come una specie di server interno al computer, ed ha un file `socket` a cui i processi devono mandare le richieste);\n\t- `-type` ricerca sostanzialmente sul tipo di ***inode***.\n- `-size` - la dimensione del file. `+1G`, i.e. solo i file più grandi di `1Gb`;\n\naa\n\n- `-name '*.txt'`, i.e. tutti i file che finiscono per `.txt`. Questo è il punto in cui sfrutto le expansions: `*` sta per `qualsiasi numero di caratteri`, `?` per `un solo carattere`, `{a, b}` esegue due comandi, uno per `a` e uno per `b` (e.g. `ls {giochi, libri}` legge sia la cartella `giochi` che la cartella `libri`);\n- `-exec` permette di eseguire ulteriori comandi `bash` sui file trovati.","x":3800,"y":-86,"width":759,"height":957,"color":"3"},
		{"id":"b008c9c94e60d49d","x":4740,"y":-86,"width":759,"height":957,"type":"text","text":"# Bash - Manipolare Cose: `awk`"},
		{"id":"f4f2a29153e51075","x":2820,"y":-1208,"width":759,"height":848,"type":"text","text":"# Bash - Utility\n\n- ***`wc`*** - Restituisce il numero di  righe (`-l`), parole (`-w`) o `byte` (`char`, `-c`) di un `file1`. Se non specifico nessuna opzione, restituisce tutte queste cose in quest'ordine;\n- ***`du`*** - Disk Utilization della directory. Tipicamente utilizzato con opzioni `-ah` (restituisce il peso in formato leggibile di tutti i file della directory) o `-sh` (per le sole directory);"},
		{"id":"db8524057030a7aa","x":3800,"y":-2214,"width":759,"height":834,"type":"text","text":"# Linux `filesystem`\n\nfilesystem virtuali, `stat /sys`, mounting, device number e nuova chiave primaria per identificare gli inodes"},
		{"id":"9d6e1bc42fdc8fff","x":2820,"y":-2214,"width":759,"height":834,"type":"text","text":"# Risultato: un `filesystem` apparentemente unico!\n\nMentre in Windows ogni unità (disco) ha la propria lettera (e.g. `C:\\`), Linux costruisce una ***root directory*** `/` da cui si evolve tutto il contenuto del sistema. Se faccio `ls` vi trovo\n\n- `bin@` - Contiene eseguibili \n\t- Oddio, ma non è una directory! Già non lo è. In principio qui c'era `/bin`, ma versioni più recenti del SW hanno spostato questa cartella in `/usr/bin`. Questo è pertanto un ***symlink*** alla sua versione più recente. E che significa? Posso ancora usare il path `/bin`, il sistema leggerà direttamente gli ***inodes*** di `/usr/bin`."},
		{"id":"9353a581758bae87","type":"text","text":"# Hard and Soft (... links)","x":4740,"y":-1208,"width":759,"height":848},
		{"id":"b3872fe16b478ecb","type":"text","text":"# HowTo`filesystem`\n\nQuesta parte, premetto, è un po' un delirio. Spero di averci capito qualcosa.\n\nUno si immagina un `filesystem` come una struttura ad albero. In realtà non è così, perché posso creare dei link che collegano diversi nodi in modo non gerarchico: è un ***grafo aciclico diretto*** (***DAG***). E come rappresento un DAG? Ovviamente con una tabella in cui salvo i nodi (che chiamo ***inodes***) e cosa fanno, e.g. puntare a dei dati (`inode` di tipo `file`), puntare a elenchi di altri `inodes` (i.e. è una `directory`) o ad un altro `inode` (e.g. un `soft link` ad un `inode` di tipo `directory`, come avviene con `bin@`).\n\nOgni `filesystem` si presenta più o meno nello stesso modo. Prendiamone uno di tipo `ext4`.\n\n```\n+----------------+----------------+-----------------+---------------------+\n| Superblock     | Inode Table    | Data Blocks     | Journaling          |\n| (info su FS)   | (lista inode)  | (dati reali)    | (storico modifiche) |\n+----------------+----------------+-----------------+---------------------+\n```\n\nQuesta è la struttura di un ***file a blocchi***, che rappresenta un `filesystem`.\n\n- `superblock` - contiene i metadati come la `signature` (e.g. `0xEF53` identifica la formattazione `ext4`), lo stato del `filesystem` (e.g. `clean`, nessun problema, o `error`, ci sono problemi), dimensione dei vari blocchi e informazioni per gestire gli `inodes`;\n- `inode table` - contiene la logica con cui sono organizzati i dati. Ogni `filesystem` ha un `inode` di `root` da cui parte tutto, che ha sempre `numero` identificativo `1`;\n- `data blocks` - i dati veri e propri (e.g. blocchi puntati da `inodes` di tipo `file`);\n- `journaling` - lo storico modifiche dei blocchi e degli `inodes`.\n\nOttimo, quindi Linux ha un `filesystem`! ... ecco, non è così facile. Se così fosse, eseguendo `l -i` nella `root directory /` dovrei vedere tutti numeri di `inode` distinti. Ma se dico così ovviamente non succede questo: `/dev`, `/proc`, `/run` e `/sys` hanno tutte `inode 1`. Non solo! `/proc` e `/sys` risultano occupare `0` spazio su disco!\n\n... perché?!","x":3800,"y":-1208,"width":759,"height":848,"color":"4"}
	],
	"edges":[
		{"id":"428ec3c727bcfebf","fromNode":"22dfa299c258426a","fromSide":"top","toNode":"8603be4ae948e472","toSide":"bottom"},
		{"id":"0f8ae08f684e1ba4","fromNode":"22dfa299c258426a","fromSide":"left","toNode":"4282f1f0f685c1b7","toSide":"right"},
		{"id":"3b8450f5d7d06324","fromNode":"22dfa299c258426a","fromSide":"top","toNode":"eab759960ddcf808","toSide":"bottom"},
		{"id":"b97dacf49ed55fcb","fromNode":"0f2a36c9dcf84a3e","fromSide":"right","toNode":"7b351e91b16f865e","toSide":"left"},
		{"id":"1eec059325077352","fromNode":"7b351e91b16f865e","fromSide":"top","toNode":"22dfa299c258426a","toSide":"bottom","label":"How to get there?"},
		{"id":"cdbb7c68033e5b65","fromNode":"7b351e91b16f865e","fromSide":"bottom","toNode":"1cdecb81c364493b","toSide":"top","label":"Where am I?"},
		{"id":"c13c78293edc7b6d","fromNode":"7b351e91b16f865e","fromSide":"right","toNode":"ea0a31adef225299","toSide":"left"},
		{"id":"bda9d6a558058968","fromNode":"ea0a31adef225299","fromSide":"top","toNode":"d8bd274b8f96df69","toSide":"bottom"},
		{"id":"3d3d010e414423c8","fromNode":"ea0a31adef225299","fromSide":"bottom","toNode":"04825a06a9d94d59","toSide":"top"},
		{"id":"835b74485d5e93bb","fromNode":"339d53393538d01d","fromSide":"top","toNode":"28ffaf4f75ea584b","toSide":"bottom"},
		{"id":"f41489a2e2acda82","fromNode":"28ffaf4f75ea584b","fromSide":"left","toNode":"c43c09b5a27c6f80","toSide":"top"},
		{"id":"cb82c94245165cc9","fromNode":"339d53393538d01d","fromSide":"left","toNode":"c43c09b5a27c6f80","toSide":"right"},
		{"id":"6ba4b4daaae0441c","fromNode":"ea0a31adef225299","fromSide":"right","toNode":"625ede0e186681f5","toSide":"left"},
		{"id":"5359adb1693d9726","fromNode":"d8bd274b8f96df69","fromSide":"right","toNode":"4e494b0e134ff4a7","toSide":"left"},
		{"id":"f9071934d54f1998","fromNode":"625ede0e186681f5","fromSide":"top","toNode":"4e494b0e134ff4a7","toSide":"bottom"},
		{"id":"e5c67dbcd146b146","fromNode":"04825a06a9d94d59","fromSide":"bottom","toNode":"3d73dc291ec51cb6","toSide":"top"},
		{"id":"38de5c3f0b17d32d","fromNode":"3d73dc291ec51cb6","fromSide":"right","toNode":"efbeb23d6fccc658","toSide":"left"},
		{"id":"66a677d308a98e43","fromNode":"04825a06a9d94d59","fromSide":"right","toNode":"efbeb23d6fccc658","toSide":"left"},
		{"id":"c00a9d792bd09d56","fromNode":"efbeb23d6fccc658","fromSide":"bottom","toNode":"592cc115c760d58b","toSide":"top"},
		{"id":"f482e0b828e283d6","fromNode":"d8bd274b8f96df69","fromSide":"top","toNode":"f4f2a29153e51075","toSide":"bottom"},
		{"id":"4c7f78114b7c8129","fromNode":"ea0a31adef225299","fromSide":"top","toNode":"4e494b0e134ff4a7","toSide":"bottom"},
		{"id":"e3085dcdb384f960","fromNode":"4e494b0e134ff4a7","fromSide":"right","toNode":"b008c9c94e60d49d","toSide":"left"},
		{"id":"5de8114eb7808ca7","fromNode":"4e494b0e134ff4a7","fromSide":"top","toNode":"b3872fe16b478ecb","toSide":"bottom"},
		{"id":"620010ae0292ff42","fromNode":"b3872fe16b478ecb","fromSide":"top","toNode":"db8524057030a7aa","toSide":"bottom"},
		{"id":"13a626dd3da58b6a","fromNode":"b3872fe16b478ecb","fromSide":"right","toNode":"9353a581758bae87","toSide":"left"}
	]
}